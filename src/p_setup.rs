use ::libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    fn abs(_: libc::c_int) -> libc::c_int;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strcasecmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncasecmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strlcpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_ulong;
    fn free(_: *mut libc::c_void);
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;
    static mut cv_debug: int32_t;
    static mut devparm: boolean;
    fn sizeu3(num: size_t) -> *mut libc::c_char;
    fn sizeu2(num: size_t) -> *mut libc::c_char;
    fn sizeu1(num: size_t) -> *mut libc::c_char;
    fn M_TokenizerSetEndPos(newPos: uint32_t);
    fn M_TokenizerGetEndPos() -> uint32_t;
    fn M_TokenizerRead(i: uint32_t) -> *const libc::c_char;
    fn M_TokenizerClose();
    fn M_TokenizerOpen(inputString: *const libc::c_char);
    fn va(format: *const libc::c_char, _: ...) -> *mut libc::c_char;
    static mut M_Memcpy: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_void,
            size_t,
        ) -> *mut libc::c_void,
    >;
    fn CONS_Debug(debugflags: int32_t, fmt: *const libc::c_char, _: ...);
    fn CONS_Alert(level: alerttype_t, fmt: *const libc::c_char, _: ...);
    fn CONS_Printf(fmt: *const libc::c_char, _: ...);
    fn I_Error(error: *const libc::c_char, _: ...) -> !;
    static mut botskin: uint8_t;
    static mut botingame: boolean;
    static mut ultimatemode: uint8_t;
    static mut titlemapinaction: uint8_t;
    static mut gamestate: gamestate_t;
    static mut numskincolors: uint16_t;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn strupr(n: *mut libc::c_char) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn vres_GetMap(_: lumpnum_t) -> *mut virtres_t;
    fn vres_Free(_: *mut virtres_t);
    fn vres_Find(_: *const virtres_t, _: *const libc::c_char) -> *mut virtlump_t;
    static mut numwadfiles: uint16_t;
    static mut wadfiles: *mut *mut wadfile_t;
    fn W_InitFile(
        filename: *const libc::c_char,
        mainfile: boolean,
        startup: boolean,
    ) -> uint16_t;
    fn W_InitFolder(
        path: *const libc::c_char,
        mainfile: boolean,
        startup: boolean,
    ) -> uint16_t;
    fn W_CheckNumForMap(name: *const libc::c_char) -> lumpnum_t;
    fn W_CheckNumForName(name: *const libc::c_char) -> lumpnum_t;
    fn W_LumpLength(lumpnum: lumpnum_t) -> size_t;
    fn W_ReadLumpHeader(
        lump: lumpnum_t,
        dest: *mut libc::c_void,
        size: size_t,
        offest: size_t,
    ) -> size_t;
    fn W_CacheLumpNum(lump: lumpnum_t, tag: int32_t) -> *mut libc::c_void;
    static mut pandf: *const libc::c_char;
    fn D_CheckPathAllowed(
        path: *const libc::c_char,
        why: *const libc::c_char,
    ) -> boolean;
    fn W_CacheLumpName(name: *const libc::c_char, tag: int32_t) -> *mut libc::c_void;
    static mut srb2home: [libc::c_char; 256];
    static mut timeattackfolder: [libc::c_char; 64];
    static mut players: [player_t; 32];
    static mut playeringame: [boolean; 32];
    static mut timeinmap: tic_t;
    static mut pausedelay: int32_t;
    static mut cv_useranalog: [consvar_t; 2];
    static mut cv_analog: [consvar_t; 2];
    static mut cv_ghost_bestscore: consvar_t;
    static mut cv_ghost_besttime: consvar_t;
    static mut cv_ghost_bestrings: consvar_t;
    static mut cv_ghost_last: consvar_t;
    static mut cv_ghost_guest: consvar_t;
    fn G_BuildMapName(map: int32_t) -> *const libc::c_char;
    fn G_CopyTiccmd(
        dest: *mut ticcmd_t,
        src: *const ticcmd_t,
        n: size_t,
    ) -> *mut ticcmd_t;
    static mut localaiming: int32_t;
    static mut localaiming2: int32_t;
    fn G_DoReborn(playernum: int32_t);
    fn G_PlayerReborn(player: int32_t, betweenmaps: boolean);
    fn Tag_FSet(list: *mut taglist_t, tag: mtag_t);
    fn Tag_FGet(list: *const taglist_t) -> mtag_t;
    fn Tag_Find(list: *const taglist_t, tag: mtag_t) -> boolean;
    fn Tag_Add(list: *mut taglist_t, tag: mtag_t);
    static mut finesine: [fixed_t; 10240];
    static mut finecosine: *mut fixed_t;
    fn AngleFixed(af: angle_t) -> fixed_t;
    fn FixedAngle(fa: fixed_t) -> angle_t;
    static mut S_sfx: [sfxinfo_t; 0];
    static mut sfxfree: sfxenum_t;
    fn DEH_LoadDehackedLump(lumpnum: lumpnum_t);
    fn get_number(word: *const libc::c_char) -> fixed_t;
    static mut mobjinfo: [mobjinfo_t; 1163];
    fn P_InitCachedActions();
    fn P_RunCachedActions();
    fn P_GetMapThingSpawnHeight(
        mobjtype: mobjtype_t,
        mthing: *const mapthing_t,
        x: fixed_t,
        y: fixed_t,
    ) -> fixed_t;
    fn P_SpawnMapThing(mthing: *mut mapthing_t) -> *mut mobj_t;
    fn P_SpawnHoop(mthing: *mut mapthing_t);
    fn P_SetBonusTime(mobj: *mut mobj_t);
    fn P_SpawnItemPattern(mthing: *mut mapthing_t, bonustime: boolean);
    fn P_SpawnPrecipitation();
    static mut modulothing: int32_t;
    static mut huntemeralds: [*mut mapthing_t; 64];
    static mut numhuntemeralds: int32_t;
    static mut runemeraldmanager: boolean;
    static mut emeraldspawndelay: uint16_t;
    static mut gamemap: int16_t;
    static mut mapmusname: [libc::c_char; 7];
    static mut mapmusflags: uint16_t;
    static mut maptol: uint32_t;
    static mut cursaveslot: int32_t;
    static mut lastmaploaded: int16_t;
    static mut marathonmode: marathonmode_t;
    static mut modifiedgame: boolean;
    static mut usedCheats: boolean;
    static mut metalrecording: boolean;
    static mut modeattacking: uint8_t;
    static mut netgame: boolean;
    static mut addedtogame: boolean;
    static mut multiplayer: boolean;
    static mut gametype: int16_t;
    static mut gametyperules: uint32_t;
    static mut splitscreen: boolean;
    static mut circuitmap: boolean;
    static mut postimgtype: postimg_t;
    static mut postimgtype2: postimg_t;
    static mut consoleplayer: int32_t;
    static mut displayplayer: int32_t;
    static mut secondarydisplayplayer: int32_t;
    static mut countdowntimer: tic_t;
    static mut countdowntimeup: boolean;
    static mut exitfadestarted: boolean;
    static mut textprompts: [*mut textprompt_t; 291];
    static mut nextmapoverride: int16_t;
    static mut skipstats: uint8_t;
    static mut ssspheres: uint32_t;
    static mut redflag: *mut mobj_t;
    static mut blueflag: *mut mobj_t;
    static mut rflagpoint: *mut mapthing_t;
    static mut bflagpoint: *mut mapthing_t;
    static mut quake: quake;
    static mut mapheaderinfo: [*mut mapheader_t; 1035];
    static mut stagefailed: boolean;
    static mut nummaprings: int32_t;
    static mut tokenbits: int32_t;
    static mut hunt1: *mut mobj_t;
    static mut hunt2: *mut mobj_t;
    static mut hunt3: *mut mobj_t;
    static mut countdown: uint32_t;
    static mut countdown2: uint32_t;
    static mut gametic: tic_t;
    static mut precache: boolean;
    static mut wipegamestate: gamestate_t;
    static mut wipetypepre: int16_t;
    fn COM_BufAddTextEx(btext: *const libc::c_char, flags: com_flags_t);
    fn COM_BufInsertTextEx(btext: *const libc::c_char, flags: com_flags_t);
    fn COM_BufExecute();
    fn CV_Set(var: *mut consvar_t, value: *const libc::c_char);
    fn CV_SetValue(var: *mut consvar_t, value: int32_t);
    fn CV_StealthSetValue(var: *mut consvar_t, value: int32_t);
    static mut cv_playercolor: consvar_t;
    static mut cv_playercolor2: consvar_t;
    static mut cv_skin2: consvar_t;
    static mut cv_numlaps: consvar_t;
    static mut cv_basenumlaps: consvar_t;
    fn Tag_NextUnused(start: mtag_t) -> mtag_t;
    fn G_GetModeAttackRetryFlag() -> boolean;
    fn G_ClearModeAttackRetryFlag();
    fn G_CompetitionGametype() -> boolean;
    fn G_TagGametype() -> boolean;
    fn G_PlatformGametype() -> boolean;
    fn G_GametypeUsesCoopStarposts() -> boolean;
    static mut server: boolean;
    static mut dedicated: boolean;
    fn NetKeepAlive();
    static mut netcmds: [[ticcmd_t; 32]; 1024];
    static mut demoplayback: boolean;
    static mut demorecording: boolean;
    static mut metalplayback: *mut mobj_t;
    fn G_AddGhost(defdemoname: *mut libc::c_char);
    fn G_StopMetalDemo();
    static mut ntemprecords: [nightsdata_t; 32];
    static mut clientGamedata: *mut gamedata_t;
    static mut serverGamedata: *mut gamedata_t;
    fn FixedHypot(x: fixed_t, y: fixed_t) -> fixed_t;
    fn Tag_FindLineSpecial(special: int16_t, tag: mtag_t) -> int32_t;
    fn Tag_Iterate_Lines(tag: mtag_t, p: size_t) -> int32_t;
    fn Tag_Iterate_Sectors(tag: mtag_t, p: size_t) -> int32_t;
    fn Taglist_InitGlobalTables();
    fn G_SpawnPlayer(playernum: int32_t);
    fn G_StartTitleCard();
    fn G_PreLevelTitleCard();
    fn G_SaveGame(slot: uint32_t, mapnum: int16_t);
    static mut gametypedefaultrules: [uint32_t; 136];
    fn G_IsSpecialStage(mapnum: int32_t) -> boolean;
    static mut cv_runscripts: consvar_t;
    static mut cv_coopstarposts: consvar_t;
    static mut cv_startinglives: consvar_t;
    static mut cv_sleep: consvar_t;
    fn D_SendExitLevel(cheat: boolean);
    static mut skyboxmo: [*mut mobj_t; 2];
    static mut skyboxviewpnts: [*mut mobj_t; 16];
    static mut skyboxcenterpnts: [*mut mobj_t; 16];
    fn P_InitPicAnims();
    fn P_SetupLevelFlatAnims();
    fn P_InitSpecials();
    fn P_ApplyFlatAlignment(
        sector: *mut sector_t,
        flatangle: angle_t,
        xoffs: fixed_t,
        yoffs: fixed_t,
        floor: boolean,
        ceiling: boolean,
    );
    fn P_SpawnSpecials(fromnetsave: boolean);
    static mut cv_cam2_rotate: consvar_t;
    fn CV_UpdateCamDist();
    fn CV_UpdateCam2Dist();
    static mut iquehead: size_t;
    static mut iquetail: size_t;
    fn P_SpawnMobj(
        x: fixed_t,
        y: fixed_t,
        z: fixed_t,
        type_0: mobjtype_t,
    ) -> *mut mobj_t;
    fn P_RemoveMobj(th: *mut mobj_t);
    fn P_SetMobjState(mobj: *mut mobj_t, state: statenum_t) -> boolean;
    fn P_MapStart();
    fn P_MapEnd();
    fn P_Initsecnode();
    fn P_ClearStarPost(postnum: int32_t);
    static mut cv_cam_rotate: consvar_t;
    static mut camera: camera_t;
    fn P_InitThinkers();
    static mut thlist: [thinker_t; 0];
    fn P_BoxOnLineSide(tmbox: *mut fixed_t, ld: *mut line_t) -> int32_t;
    fn P_AproxDistance(dx: fixed_t, dy: fixed_t) -> fixed_t;
    fn M_ClearBox(box_0: *mut fixed_t);
    fn M_AddToBox(box_0: *mut fixed_t, x: fixed_t, y: fixed_t);
    static mut cv_timescale: consvar_t;
    fn P_SetMobjStateNF(mobj: *mut mobj_t, state: statenum_t) -> boolean;
    static mut leveltime: tic_t;
    fn P_PreTicker(frames: int32_t);
    fn P_RemoveThinkerDelayed(thinker: *mut thinker_t);
    static mut polyblocklinks: *mut *mut polymaplink_t;
    fn I_GetTime() -> tic_t;
    fn I_UpdateTime(timescale: fixed_t);
    fn I_FreeSfx(sfx: *mut sfxinfo_t);
    static mut rendermode: rendermode_t;
    fn I_FinishUpdate();
    fn I_UpdateNoVsync();
    static mut skytexture: int32_t;
    static mut skyflatnum: int32_t;
    static mut levelskynum: int32_t;
    static mut globallevelskynum: int32_t;
    fn R_SetupSkyDraw();
    static mut cv_resetmusic: consvar_t;
    static mut cv_resetmusicbyheader: consvar_t;
    fn S_StopSounds();
    fn S_ClearSfx();
    fn S_StartEx(reset: boolean);
    fn S_StartSound(origin: *const libc::c_void, sound_id: sfxenum_t);
    fn S_FadeMusicFromVolume(
        target_volume: uint8_t,
        source_volume: int16_t,
        ms: uint32_t,
    ) -> boolean;
    fn S_MusicName() -> *const libc::c_char;
    fn I_Sleep(ms: uint32_t);
    fn I_OsPolling();
    fn S_FadeOutStopMusic(ms: uint32_t) -> boolean;
    fn S_LoadMusicDefs(wadnum: uint16_t);
    fn R_CreateLightTable(extra_colormap: *mut extracolormap_t) -> *mut lighttable_t;
    fn R_CopyColormap(
        extra_colormap: *mut extracolormap_t,
        lighttable: boolean,
    ) -> *mut extracolormap_t;
    fn R_AddColormapToList(extra_colormap: *mut extracolormap_t);
    fn R_GetColormapFromList(
        extra_colormap: *mut extracolormap_t,
    ) -> *mut extracolormap_t;
    fn R_ReInitColormaps(num: uint16_t);
    fn R_PrecacheLevel();
    static mut flatmemory: size_t;
    fn R_CreateColormapFromLinedef(
        p1: *mut libc::c_char,
        p2: *mut libc::c_char,
        p3: *mut libc::c_char,
    ) -> *mut extracolormap_t;
    fn R_CreateColormap(
        rgba: int32_t,
        fadergba: int32_t,
        fadestart: uint8_t,
        fadeend: uint8_t,
        flags: uint8_t,
    ) -> *mut extracolormap_t;
    static mut textures: *mut *mut texture_t;
    static mut numtextures: int32_t;
    static mut numskins: int32_t;
    static mut skins: [skin_t; 32];
    fn R_ResetViewInterpolation(p: uint8_t);
    fn R_TextureNumForName(name: *const libc::c_char) -> int32_t;
    fn R_CheckTextureNumForName(name: *const libc::c_char) -> int32_t;
    fn R_GetFlatNumForName(name: *const libc::c_char) -> lumpnum_t;
    fn Picture_CheckIfDoomPatch(patch: *mut softwarepatch_t, size: size_t) -> boolean;
    fn Picture_IsLumpPNG(d: *const uint8_t, s: size_t) -> boolean;
    fn R_GetFlat(flatnum: lumpnum_t) -> *mut libc::c_void;
    fn R_AddSpriteDefs(wadnum: uint16_t);
    fn R_LoadTexturesPwad(wadnum: uint16_t);
    fn R_AddSkins(wadnum: uint16_t, mainfile: boolean);
    fn R_PatchSkins(wadnum: uint16_t, mainfile: boolean);
    fn R_LoadSpriteInfoLumps(wadnum: uint16_t, numlumps: uint16_t);
    fn SetPlayerSkin(playernum: int32_t, skinname: *const libc::c_char);
    fn LUA_InvalidateLevel();
    fn Patch_FreeTags(lowtag: int32_t, hightag: int32_t);
    fn R_ClearTextureNumCache(btell: boolean);
    fn R_InitMobjInterpolators();
    fn R_InitializeLevelInterpolators();
    fn R_UpdateMobjInterpolators();
    fn R_FlushTranslationColormapCache();
    fn ST_Start();
    fn ST_UnloadGraphics();
    fn ST_LoadGraphics();
    fn ST_ReloadSkinFaceGraphics();
    fn Z_Free(ptr: *mut libc::c_void);
    fn Z_MallocAlign(
        size: size_t,
        tag: int32_t,
        user: *mut libc::c_void,
        alignbits: int32_t,
    ) -> *mut libc::c_void;
    fn Z_CallocAlign(
        size: size_t,
        tag: int32_t,
        user: *mut libc::c_void,
        alignbits: int32_t,
    ) -> *mut libc::c_void;
    fn Z_ReallocAlign(
        ptr: *mut libc::c_void,
        size: size_t,
        tag: int32_t,
        user: *mut libc::c_void,
        alignbits: int32_t,
    ) -> *mut libc::c_void;
    fn Z_FreeTags(lowtag: int32_t, hightag: int32_t);
    fn Z_StrDup(in_0: *const libc::c_char) -> *mut libc::c_char;
    fn HU_LoadGraphics();
    fn HU_ClearCEcho();
    fn CON_SetupBackColormap();
    fn CON_Drawer();
    fn CON_LogMessage(msg: *const libc::c_char);
    static mut moviemode: moviemode_t;
    fn M_SaveFrame();
    fn M_MapNumber(first: libc::c_char, second: libc::c_char) -> int32_t;
    fn FIL_FileExists(name: *const libc::c_char) -> boolean;
    fn axtoi(hexStg: *const libc::c_char) -> int32_t;
    fn P_RandomKey(a: int32_t) -> int32_t;
    static mut FREE_SKINCOLORS: [*mut libc::c_char; 1024];
    static mut COLOR_ENUMS: [*const libc::c_char; 0];
    fn R_PointToAngle2(
        px2: fixed_t,
        py2: fixed_t,
        px1: fixed_t,
        py1: fixed_t,
    ) -> angle_t;
    fn R_PointToDist2(px2: fixed_t, py2: fixed_t, px1: fixed_t, py1: fixed_t) -> fixed_t;
    fn R_PointInSubsector(x: fixed_t, y: fixed_t) -> *mut subsector_t;
    static mut cv_chasecam: consvar_t;
    static mut cv_chasecam2: consvar_t;
    fn M_CheckParm(check: *const libc::c_char) -> int32_t;
    fn V_SetPaletteLump(pal: *const libc::c_char);
    fn V_DrawFill(x: int32_t, y: int32_t, w: int32_t, h: int32_t, c: int32_t);
    fn V_DrawSmallString(
        x: int32_t,
        y: int32_t,
        option: int32_t,
        string: *const libc::c_char,
    );
    fn F_EndTextPrompt(forceexec: boolean, noexec: boolean);
    static mut WipeStageTitle: boolean;
    static mut wipestyleflags: wipestyleflags_t;
    static mut lastwipetic: int32_t;
    fn F_WipeStartScreen();
    fn F_WipeEndScreen();
    fn F_RunWipe(wipetype: uint8_t, drawMenu: boolean);
    fn F_GetWipeLength(wipetype: uint8_t) -> tic_t;
    static mut wipedefs: [uint8_t; 28];
    fn F_WipeExists(wipetype: uint8_t) -> boolean;
    static mut refreshdirmenu: uint8_t;
    fn md5_buffer(
        buffer: *const libc::c_char,
        len: size_t,
        resblock: *mut libc::c_void,
    ) -> *mut libc::c_void;
    fn LUA_HookInt(integer: int32_t, hook: libc::c_int);
    fn P_InitSlopes();
    fn P_SpawnSlopes(fromsave: boolean);
    fn MakeViaEquationConstants(
        a: fixed_t,
        b: fixed_t,
        c: fixed_t,
        d: fixed_t,
    ) -> *mut pslope_t;
}
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type int8_t = __int8_t;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type int64_t = __int64_t;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type size_t = libc::c_ulong;
pub type boolean = int32_t;
pub type C2RustUnnamed = libc::c_uint;
pub const true_0: C2RustUnnamed = 1;
pub const false_0: C2RustUnnamed = 0;
pub type postimg_t = libc::c_uint;
pub const postimg_heat: postimg_t = 4;
pub const postimg_flip: postimg_t = 3;
pub const postimg_motion: postimg_t = 2;
pub const postimg_water: postimg_t = 1;
pub const postimg_none: postimg_t = 0;
pub type lumpnum_t = uint32_t;
pub type tic_t = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type ssize_t = __ssize_t;
pub type C2RustUnnamed_0 = libc::c_uint;
pub const NUMSUPERCOLORS: C2RustUnnamed_0 = 9;
pub const MAXSKINCOLORS: C2RustUnnamed_0 = 1182;
pub const SKINCOLOR_LASTFREESLOT: C2RustUnnamed_0 = 1181;
pub const SKINCOLOR_FIRSTFREESLOT: C2RustUnnamed_0 = 158;
pub const SKINCOLOR_SUPERTAN5: C2RustUnnamed_0 = 157;
pub const SKINCOLOR_SUPERTAN4: C2RustUnnamed_0 = 156;
pub const SKINCOLOR_SUPERTAN3: C2RustUnnamed_0 = 155;
pub const SKINCOLOR_SUPERTAN2: C2RustUnnamed_0 = 154;
pub const SKINCOLOR_SUPERTAN1: C2RustUnnamed_0 = 153;
pub const SKINCOLOR_SUPERRUST5: C2RustUnnamed_0 = 152;
pub const SKINCOLOR_SUPERRUST4: C2RustUnnamed_0 = 151;
pub const SKINCOLOR_SUPERRUST3: C2RustUnnamed_0 = 150;
pub const SKINCOLOR_SUPERRUST2: C2RustUnnamed_0 = 149;
pub const SKINCOLOR_SUPERRUST1: C2RustUnnamed_0 = 148;
pub const SKINCOLOR_SUPERPURPLE5: C2RustUnnamed_0 = 147;
pub const SKINCOLOR_SUPERPURPLE4: C2RustUnnamed_0 = 146;
pub const SKINCOLOR_SUPERPURPLE3: C2RustUnnamed_0 = 145;
pub const SKINCOLOR_SUPERPURPLE2: C2RustUnnamed_0 = 144;
pub const SKINCOLOR_SUPERPURPLE1: C2RustUnnamed_0 = 143;
pub const SKINCOLOR_SUPERSKY5: C2RustUnnamed_0 = 142;
pub const SKINCOLOR_SUPERSKY4: C2RustUnnamed_0 = 141;
pub const SKINCOLOR_SUPERSKY3: C2RustUnnamed_0 = 140;
pub const SKINCOLOR_SUPERSKY2: C2RustUnnamed_0 = 139;
pub const SKINCOLOR_SUPERSKY1: C2RustUnnamed_0 = 138;
pub const SKINCOLOR_SUPERPERIDOT5: C2RustUnnamed_0 = 137;
pub const SKINCOLOR_SUPERPERIDOT4: C2RustUnnamed_0 = 136;
pub const SKINCOLOR_SUPERPERIDOT3: C2RustUnnamed_0 = 135;
pub const SKINCOLOR_SUPERPERIDOT2: C2RustUnnamed_0 = 134;
pub const SKINCOLOR_SUPERPERIDOT1: C2RustUnnamed_0 = 133;
pub const SKINCOLOR_SUPERGOLD5: C2RustUnnamed_0 = 132;
pub const SKINCOLOR_SUPERGOLD4: C2RustUnnamed_0 = 131;
pub const SKINCOLOR_SUPERGOLD3: C2RustUnnamed_0 = 130;
pub const SKINCOLOR_SUPERGOLD2: C2RustUnnamed_0 = 129;
pub const SKINCOLOR_SUPERGOLD1: C2RustUnnamed_0 = 128;
pub const SKINCOLOR_SUPERORANGE5: C2RustUnnamed_0 = 127;
pub const SKINCOLOR_SUPERORANGE4: C2RustUnnamed_0 = 126;
pub const SKINCOLOR_SUPERORANGE3: C2RustUnnamed_0 = 125;
pub const SKINCOLOR_SUPERORANGE2: C2RustUnnamed_0 = 124;
pub const SKINCOLOR_SUPERORANGE1: C2RustUnnamed_0 = 123;
pub const SKINCOLOR_SUPERRED5: C2RustUnnamed_0 = 122;
pub const SKINCOLOR_SUPERRED4: C2RustUnnamed_0 = 121;
pub const SKINCOLOR_SUPERRED3: C2RustUnnamed_0 = 120;
pub const SKINCOLOR_SUPERRED2: C2RustUnnamed_0 = 119;
pub const SKINCOLOR_SUPERRED1: C2RustUnnamed_0 = 118;
pub const SKINCOLOR_SUPERSILVER5: C2RustUnnamed_0 = 117;
pub const SKINCOLOR_SUPERSILVER4: C2RustUnnamed_0 = 116;
pub const SKINCOLOR_SUPERSILVER3: C2RustUnnamed_0 = 115;
pub const SKINCOLOR_SUPERSILVER2: C2RustUnnamed_0 = 114;
pub const SKINCOLOR_SUPERSILVER1: C2RustUnnamed_0 = 113;
pub const FIRSTSUPERCOLOR: C2RustUnnamed_0 = 113;
pub const SKINCOLOR_VOLCANIC: C2RustUnnamed_0 = 112;
pub const SKINCOLOR_SANGRIA: C2RustUnnamed_0 = 111;
pub const SKINCOLOR_FANCY: C2RustUnnamed_0 = 110;
pub const SKINCOLOR_ROSY: C2RustUnnamed_0 = 109;
pub const SKINCOLOR_TAFFY: C2RustUnnamed_0 = 108;
pub const SKINCOLOR_RASPBERRY: C2RustUnnamed_0 = 107;
pub const SKINCOLOR_PLUM: C2RustUnnamed_0 = 106;
pub const SKINCOLOR_EVENTIDE: C2RustUnnamed_0 = 105;
pub const SKINCOLOR_MAUVE: C2RustUnnamed_0 = 104;
pub const SKINCOLOR_LILAC: C2RustUnnamed_0 = 103;
pub const SKINCOLOR_ROYAL: C2RustUnnamed_0 = 102;
pub const SKINCOLOR_VIOLET: C2RustUnnamed_0 = 101;
pub const SKINCOLOR_NEON: C2RustUnnamed_0 = 100;
pub const SKINCOLOR_MAGENTA: C2RustUnnamed_0 = 99;
pub const SKINCOLOR_SIBERITE: C2RustUnnamed_0 = 98;
pub const SKINCOLOR_BUBBLEGUM: C2RustUnnamed_0 = 97;
pub const SKINCOLOR_FUCHSIA: C2RustUnnamed_0 = 96;
pub const SKINCOLOR_NOBLE: C2RustUnnamed_0 = 95;
pub const SKINCOLOR_PURPLE: C2RustUnnamed_0 = 94;
pub const SKINCOLOR_PASTEL: C2RustUnnamed_0 = 93;
pub const SKINCOLOR_MAJESTY: C2RustUnnamed_0 = 92;
pub const SKINCOLOR_DUSK: C2RustUnnamed_0 = 91;
pub const SKINCOLOR_VAPOR: C2RustUnnamed_0 = 90;
pub const SKINCOLOR_GALAXY: C2RustUnnamed_0 = 89;
pub const SKINCOLOR_MIDNIGHT: C2RustUnnamed_0 = 88;
pub const SKINCOLOR_COBALT: C2RustUnnamed_0 = 87;
pub const SKINCOLOR_BLUE: C2RustUnnamed_0 = 86;
pub const SKINCOLOR_CORNFLOWER: C2RustUnnamed_0 = 85;
pub const SKINCOLOR_ARCTIC: C2RustUnnamed_0 = 84;
pub const SKINCOLOR_SAPPHIRE: C2RustUnnamed_0 = 83;
pub const SKINCOLOR_DAYBREAK: C2RustUnnamed_0 = 82;
pub const SKINCOLOR_ICY: C2RustUnnamed_0 = 81;
pub const SKINCOLOR_DREAM: C2RustUnnamed_0 = 80;
pub const SKINCOLOR_CERULEAN: C2RustUnnamed_0 = 79;
pub const SKINCOLOR_MARINE: C2RustUnnamed_0 = 78;
pub const SKINCOLOR_SKY: C2RustUnnamed_0 = 77;
pub const SKINCOLOR_AQUAMARINE: C2RustUnnamed_0 = 76;
pub const SKINCOLOR_TURQUOISE: C2RustUnnamed_0 = 75;
pub const SKINCOLOR_CYAN: C2RustUnnamed_0 = 74;
pub const SKINCOLOR_WAVE: C2RustUnnamed_0 = 73;
pub const SKINCOLOR_OCEAN: C2RustUnnamed_0 = 72;
pub const SKINCOLOR_TEAL: C2RustUnnamed_0 = 71;
pub const SKINCOLOR_AQUA: C2RustUnnamed_0 = 70;
pub const SKINCOLOR_BOTTLE: C2RustUnnamed_0 = 69;
pub const SKINCOLOR_ISLAND: C2RustUnnamed_0 = 68;
pub const SKINCOLOR_SEAFOAM: C2RustUnnamed_0 = 67;
pub const SKINCOLOR_EMERALD: C2RustUnnamed_0 = 66;
pub const SKINCOLOR_MASTER: C2RustUnnamed_0 = 65;
pub const SKINCOLOR_MINT: C2RustUnnamed_0 = 64;
pub const SKINCOLOR_JADE: C2RustUnnamed_0 = 63;
pub const SKINCOLOR_SHAMROCK: C2RustUnnamed_0 = 62;
pub const SKINCOLOR_FOREST: C2RustUnnamed_0 = 61;
pub const SKINCOLOR_GREEN: C2RustUnnamed_0 = 60;
pub const SKINCOLOR_CHARTREUSE: C2RustUnnamed_0 = 59;
pub const SKINCOLOR_HEADLIGHT: C2RustUnnamed_0 = 58;
pub const SKINCOLOR_APPLE: C2RustUnnamed_0 = 57;
pub const SKINCOLOR_PERIDOT: C2RustUnnamed_0 = 56;
pub const SKINCOLOR_LIME: C2RustUnnamed_0 = 55;
pub const SKINCOLOR_LEMON: C2RustUnnamed_0 = 54;
pub const SKINCOLOR_PEAR: C2RustUnnamed_0 = 53;
pub const SKINCOLOR_OLIVE: C2RustUnnamed_0 = 52;
pub const SKINCOLOR_YELLOW: C2RustUnnamed_0 = 51;
pub const SKINCOLOR_GOLDENROD: C2RustUnnamed_0 = 50;
pub const SKINCOLOR_SANDY: C2RustUnnamed_0 = 49;
pub const SKINCOLOR_GOLD: C2RustUnnamed_0 = 48;
pub const SKINCOLOR_TOPAZ: C2RustUnnamed_0 = 47;
pub const SKINCOLOR_TANGERINE: C2RustUnnamed_0 = 46;
pub const SKINCOLOR_RUST: C2RustUnnamed_0 = 45;
pub const SKINCOLOR_ORANGE: C2RustUnnamed_0 = 44;
pub const SKINCOLOR_APRICOT: C2RustUnnamed_0 = 43;
pub const SKINCOLOR_COPPER: C2RustUnnamed_0 = 42;
pub const SKINCOLOR_SUNSET: C2RustUnnamed_0 = 41;
pub const SKINCOLOR_FOUNDATION: C2RustUnnamed_0 = 40;
pub const SKINCOLOR_QUAIL: C2RustUnnamed_0 = 39;
pub const SKINCOLOR_PEACHY: C2RustUnnamed_0 = 38;
pub const SKINCOLOR_KETCHUP: C2RustUnnamed_0 = 37;
pub const SKINCOLOR_GARNET: C2RustUnnamed_0 = 36;
pub const SKINCOLOR_FLAME: C2RustUnnamed_0 = 35;
pub const SKINCOLOR_CRIMSON: C2RustUnnamed_0 = 34;
pub const SKINCOLOR_RED: C2RustUnnamed_0 = 33;
pub const SKINCOLOR_PEPPER: C2RustUnnamed_0 = 32;
pub const SKINCOLOR_SALMON: C2RustUnnamed_0 = 31;
pub const SKINCOLOR_CHERRY: C2RustUnnamed_0 = 30;
pub const SKINCOLOR_RUBY: C2RustUnnamed_0 = 29;
pub const SKINCOLOR_LAVENDER: C2RustUnnamed_0 = 28;
pub const SKINCOLOR_EGGPLANT: C2RustUnnamed_0 = 27;
pub const SKINCOLOR_AZURE: C2RustUnnamed_0 = 26;
pub const SKINCOLOR_MOSS: C2RustUnnamed_0 = 25;
pub const SKINCOLOR_ROSEBUSH: C2RustUnnamed_0 = 24;
pub const SKINCOLOR_BEIGE: C2RustUnnamed_0 = 23;
pub const SKINCOLOR_TAN: C2RustUnnamed_0 = 22;
pub const SKINCOLOR_ECRU: C2RustUnnamed_0 = 21;
pub const SKINCOLOR_SEPIA: C2RustUnnamed_0 = 20;
pub const SKINCOLOR_BRONZE: C2RustUnnamed_0 = 19;
pub const SKINCOLOR_BOULDER: C2RustUnnamed_0 = 18;
pub const SKINCOLOR_BROWN: C2RustUnnamed_0 = 17;
pub const SKINCOLOR_LATTE: C2RustUnnamed_0 = 16;
pub const SKINCOLOR_YOGURT: C2RustUnnamed_0 = 15;
pub const SKINCOLOR_ROSEWOOD: C2RustUnnamed_0 = 14;
pub const SKINCOLOR_PINK: C2RustUnnamed_0 = 13;
pub const SKINCOLOR_BLUEBELL: C2RustUnnamed_0 = 12;
pub const SKINCOLOR_MOONSTONE: C2RustUnnamed_0 = 11;
pub const SKINCOLOR_SLATE: C2RustUnnamed_0 = 10;
pub const SKINCOLOR_AETHER: C2RustUnnamed_0 = 9;
pub const SKINCOLOR_BLACK: C2RustUnnamed_0 = 8;
pub const SKINCOLOR_JET: C2RustUnnamed_0 = 7;
pub const SKINCOLOR_CARBON: C2RustUnnamed_0 = 6;
pub const SKINCOLOR_SILVER: C2RustUnnamed_0 = 5;
pub const SKINCOLOR_GREY: C2RustUnnamed_0 = 4;
pub const SKINCOLOR_CLOUDY: C2RustUnnamed_0 = 3;
pub const SKINCOLOR_BONE: C2RustUnnamed_0 = 2;
pub const SKINCOLOR_WHITE: C2RustUnnamed_0 = 1;
pub const SKINCOLOR_NONE: C2RustUnnamed_0 = 0;
pub type C2RustUnnamed_1 = libc::c_int;
pub const LE_PARAMWIDTH: C2RustUnnamed_1 = -100;
pub const LE_AXE: C2RustUnnamed_1 = 649;
pub const LE_KOOPA: C2RustUnnamed_1 = 650;
pub const LE_CAPSULE0: C2RustUnnamed_1 = 680;
pub const LE_CAPSULE1: C2RustUnnamed_1 = 681;
pub const LE_CAPSULE2: C2RustUnnamed_1 = 682;
pub const LE_BRAKPLATFORM: C2RustUnnamed_1 = 4200;
pub const LE_TURRET: C2RustUnnamed_1 = 32000;
pub const LE_BRAKVILEATACK: C2RustUnnamed_1 = -6;
pub const LE_BOSS4DROP: C2RustUnnamed_1 = -5;
pub const LE_BOSSDEAD: C2RustUnnamed_1 = -4;
pub const LE_ALLBOSSESDEAD: C2RustUnnamed_1 = -3;
pub const LE_PINCHPHASE: C2RustUnnamed_1 = -2;
pub type gamestate_t = libc::c_uint;
pub const GS_WAITINGPLAYERS: gamestate_t = 13;
pub const GS_DEDICATEDSERVER: gamestate_t = 12;
pub const GS_CUTSCENE: gamestate_t = 11;
pub const GS_ENDING: gamestate_t = 10;
pub const GS_INTRO: gamestate_t = 9;
pub const GS_GAMEEND: gamestate_t = 8;
pub const GS_EVALUATION: gamestate_t = 7;
pub const GS_CREDITS: gamestate_t = 6;
pub const GS_TIMEATTACK: gamestate_t = 5;
pub const GS_TITLESCREEN: gamestate_t = 4;
pub const GS_CONTINUING: gamestate_t = 3;
pub const GS_INTERMISSION: gamestate_t = 2;
pub const GS_LEVEL: gamestate_t = 1;
pub const GS_NULL: gamestate_t = 0;
pub type alerttype_t = libc::c_uint;
pub const CONS_ERROR: alerttype_t = 2;
pub const CONS_WARNING: alerttype_t = 1;
pub const CONS_NOTICE: alerttype_t = 0;
pub type compmethod = libc::c_uint;
pub const CM_UNSUPPORTED: compmethod = 3;
pub const CM_LZF: compmethod = 2;
pub const CM_DEFLATE: compmethod = 1;
pub const CM_NOCOMPRESSION: compmethod = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lumpinfo_t {
    pub position: libc::c_ulong,
    pub disksize: libc::c_ulong,
    pub name: [libc::c_char; 9],
    pub hash: uint32_t,
    pub longname: *mut libc::c_char,
    pub fullname: *mut libc::c_char,
    pub diskpath: *mut libc::c_char,
    pub size: size_t,
    pub compression: compmethod,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct virtlump_t {
    pub name: [libc::c_char; 9],
    pub data: *mut uint8_t,
    pub size: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct virtres_t {
    pub numlumps: size_t,
    pub vlumps: *mut virtlump_t,
}
pub type restype = libc::c_uint;
pub const RET_UNKNOWN: restype = 5;
pub const RET_FOLDER: restype = 4;
pub const RET_PK3: restype = 3;
pub const RET_LUA: restype = 2;
pub const RET_SOC: restype = 1;
pub const RET_WAD: restype = 0;
pub type restype_t = restype;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct wadfile_s {
    pub filename: *mut libc::c_char,
    pub path: *mut libc::c_char,
    pub type_0: restype_t,
    pub lumpinfo: *mut lumpinfo_t,
    pub lumpcache: *mut *mut libc::c_void,
    pub patchcache: *mut *mut libc::c_void,
    pub numlumps: uint16_t,
    pub foldercount: uint16_t,
    pub handle: *mut FILE,
    pub filesize: uint32_t,
    pub md5sum: [uint8_t; 16],
    pub important: boolean,
}
pub type wadfile_t = wadfile_s;
pub type mtag_t = int16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct taglist_t {
    pub tags: *mut mtag_t,
    pub count: uint16_t,
}
pub type fixed_t = int32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vector2_t {
    pub x: fixed_t,
    pub y: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vector3_t {
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct mapvertex_t {
    pub x: int16_t,
    pub y: int16_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct mapsidedef_t {
    pub textureoffset: int16_t,
    pub rowoffset: int16_t,
    pub toptexture: [libc::c_char; 8],
    pub bottomtexture: [libc::c_char; 8],
    pub midtexture: [libc::c_char; 8],
    pub sector: int16_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct maplinedef_t {
    pub v1: int16_t,
    pub v2: int16_t,
    pub flags: int16_t,
    pub special: int16_t,
    pub tag: int16_t,
    pub sidenum: [uint16_t; 2],
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct mapsector_t {
    pub floorheight: int16_t,
    pub ceilingheight: int16_t,
    pub floorpic: [libc::c_char; 8],
    pub ceilingpic: [libc::c_char; 8],
    pub lightlevel: int16_t,
    pub special: int16_t,
    pub tag: int16_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct mapsubsector_t {
    pub numsegs: uint16_t,
    pub firstseg: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct mapseg_t {
    pub v1: int16_t,
    pub v2: int16_t,
    pub angle: int16_t,
    pub linedef: int16_t,
    pub side: int16_t,
    pub offset: int16_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct mapnode_t {
    pub x: int16_t,
    pub y: int16_t,
    pub dx: int16_t,
    pub dy: int16_t,
    pub bbox: [[int16_t; 4]; 2],
    pub children: [uint16_t; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mapthing_t {
    pub x: int16_t,
    pub y: int16_t,
    pub angle: int16_t,
    pub pitch: int16_t,
    pub roll: int16_t,
    pub type_0: uint16_t,
    pub options: uint16_t,
    pub z: int16_t,
    pub extrainfo: uint8_t,
    pub tags: taglist_t,
    pub scale: fixed_t,
    pub spritexscale: fixed_t,
    pub spriteyscale: fixed_t,
    pub args: [int32_t; 10],
    pub stringargs: [*mut libc::c_char; 2],
    pub mobj: *mut mobj_s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mobj_s {
    pub thinker: thinker_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub old_x: fixed_t,
    pub old_y: fixed_t,
    pub old_z: fixed_t,
    pub old_x2: fixed_t,
    pub old_y2: fixed_t,
    pub old_z2: fixed_t,
    pub snext: *mut mobj_s,
    pub sprev: *mut *mut mobj_s,
    pub angle: angle_t,
    pub pitch: angle_t,
    pub roll: angle_t,
    pub old_angle: angle_t,
    pub old_pitch: angle_t,
    pub old_roll: angle_t,
    pub old_angle2: angle_t,
    pub old_pitch2: angle_t,
    pub old_roll2: angle_t,
    pub spriteroll: angle_t,
    pub old_spriteroll: angle_t,
    pub old_spriteroll2: angle_t,
    pub sprite: spritenum_t,
    pub frame: uint32_t,
    pub sprite2: uint8_t,
    pub anim_duration: uint16_t,
    pub renderflags: uint32_t,
    pub blendmode: int32_t,
    pub spritexscale: fixed_t,
    pub spriteyscale: fixed_t,
    pub spritexoffset: fixed_t,
    pub spriteyoffset: fixed_t,
    pub old_spritexscale: fixed_t,
    pub old_spriteyscale: fixed_t,
    pub old_spritexoffset: fixed_t,
    pub old_spriteyoffset: fixed_t,
    pub floorspriteslope: *mut pslope_s,
    pub touching_sectorlist: *mut msecnode_s,
    pub subsector: *mut subsector_s,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
    pub floorrover: *mut ffloor_s,
    pub ceilingrover: *mut ffloor_s,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub momx: fixed_t,
    pub momy: fixed_t,
    pub momz: fixed_t,
    pub pmomz: fixed_t,
    pub tics: int32_t,
    pub state: *mut state_t,
    pub flags: uint32_t,
    pub flags2: uint32_t,
    pub eflags: uint16_t,
    pub skin: *mut libc::c_void,
    pub color: uint16_t,
    pub drawonlyforplayer: *mut player_s,
    pub dontdrawforviewmobj: *mut mobj_s,
    pub bnext: *mut mobj_s,
    pub bprev: *mut *mut mobj_s,
    pub hnext: *mut mobj_s,
    pub hprev: *mut mobj_s,
    pub type_0: mobjtype_t,
    pub info: *const mobjinfo_t,
    pub health: int32_t,
    pub movedir: angle_t,
    pub movecount: int32_t,
    pub target: *mut mobj_s,
    pub reactiontime: int32_t,
    pub threshold: int32_t,
    pub player: *mut player_s,
    pub lastlook: int32_t,
    pub spawnpoint: *mut mapthing_t,
    pub tracer: *mut mobj_s,
    pub friction: fixed_t,
    pub movefactor: fixed_t,
    pub fuse: int32_t,
    pub watertop: fixed_t,
    pub waterbottom: fixed_t,
    pub mobjnum: uint32_t,
    pub scale: fixed_t,
    pub old_scale: fixed_t,
    pub old_scale2: fixed_t,
    pub destscale: fixed_t,
    pub scalespeed: fixed_t,
    pub extravalue1: int32_t,
    pub extravalue2: int32_t,
    pub cusval: int32_t,
    pub cvmem: int32_t,
    pub standingslope: *mut pslope_s,
    pub resetinterp: boolean,
    pub colorized: boolean,
    pub mirrored: boolean,
    pub shadowscale: fixed_t,
    pub dispoffset: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pslope_s {
    pub id: uint16_t,
    pub next: *mut pslope_s,
    pub o: vector3_t,
    pub normal: vector3_t,
    pub d: vector2_t,
    pub zdelta: fixed_t,
    pub zangle: angle_t,
    pub xydirection: angle_t,
    pub flags: uint8_t,
}
pub type angle_t = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct player_s {
    pub mo: *mut mobj_t,
    pub cmd: ticcmd_t,
    pub playerstate: playerstate_t,
    pub camerascale: fixed_t,
    pub shieldscale: fixed_t,
    pub viewz: fixed_t,
    pub viewheight: fixed_t,
    pub deltaviewheight: fixed_t,
    pub bob: fixed_t,
    pub viewrollangle: angle_t,
    pub angleturn: int16_t,
    pub oldrelangleturn: int16_t,
    pub aiming: angle_t,
    pub drawangle: angle_t,
    pub old_drawangle: angle_t,
    pub old_drawangle2: angle_t,
    pub rings: int16_t,
    pub spheres: int16_t,
    pub pity: int8_t,
    pub currentweapon: int32_t,
    pub ringweapons: int32_t,
    pub ammoremoval: uint16_t,
    pub ammoremovaltimer: tic_t,
    pub ammoremovalweapon: int32_t,
    pub powers: [uint16_t; 30],
    pub pflags: pflags_t,
    pub panim: panim_t,
    pub stronganim: uint8_t,
    pub flashcount: uint16_t,
    pub flashpal: uint16_t,
    pub skincolor: uint16_t,
    pub skin: int32_t,
    pub availabilities: uint32_t,
    pub score: uint32_t,
    pub recordscore: uint32_t,
    pub dashspeed: fixed_t,
    pub normalspeed: fixed_t,
    pub runspeed: fixed_t,
    pub thrustfactor: uint8_t,
    pub accelstart: uint8_t,
    pub acceleration: uint8_t,
    pub charability: uint8_t,
    pub charability2: uint8_t,
    pub charflags: uint32_t,
    pub thokitem: mobjtype_t,
    pub spinitem: mobjtype_t,
    pub revitem: mobjtype_t,
    pub followitem: mobjtype_t,
    pub followmobj: *mut mobj_t,
    pub actionspd: fixed_t,
    pub mindash: fixed_t,
    pub maxdash: fixed_t,
    pub jumpfactor: fixed_t,
    pub height: fixed_t,
    pub spinheight: fixed_t,
    pub lives: int8_t,
    pub continues: int8_t,
    pub xtralife: int8_t,
    pub gotcontinue: uint8_t,
    pub speed: fixed_t,
    pub secondjump: uint8_t,
    pub fly1: uint8_t,
    pub scoreadd: uint8_t,
    pub glidetime: tic_t,
    pub climbing: uint8_t,
    pub deadtimer: int32_t,
    pub exiting: tic_t,
    pub homing: uint8_t,
    pub dashmode: tic_t,
    pub skidtime: tic_t,
    pub cmomx: fixed_t,
    pub cmomy: fixed_t,
    pub rmomx: fixed_t,
    pub rmomy: fixed_t,
    pub numboxes: int16_t,
    pub totalring: int16_t,
    pub realtime: tic_t,
    pub laps: uint8_t,
    pub ctfteam: int32_t,
    pub gotflag: uint16_t,
    pub weapondelay: int32_t,
    pub tossdelay: int32_t,
    pub starpostx: int16_t,
    pub starposty: int16_t,
    pub starpostz: int16_t,
    pub starpostnum: int32_t,
    pub starposttime: tic_t,
    pub starpostangle: angle_t,
    pub starpostscale: fixed_t,
    pub angle_pos: angle_t,
    pub old_angle_pos: angle_t,
    pub axis1: *mut mobj_t,
    pub axis2: *mut mobj_t,
    pub bumpertime: tic_t,
    pub flyangle: int32_t,
    pub drilltimer: tic_t,
    pub linkcount: int32_t,
    pub linktimer: tic_t,
    pub anotherflyangle: int32_t,
    pub nightstime: tic_t,
    pub drillmeter: int32_t,
    pub drilldelay: uint8_t,
    pub bonustime: boolean,
    pub capsule: *mut mobj_t,
    pub drone: *mut mobj_t,
    pub oldscale: fixed_t,
    pub mare: uint8_t,
    pub marelap: uint8_t,
    pub marebonuslap: uint8_t,
    pub marebegunat: tic_t,
    pub startedtime: tic_t,
    pub finishedtime: tic_t,
    pub lapbegunat: tic_t,
    pub lapstartedtime: tic_t,
    pub finishedspheres: int16_t,
    pub finishedrings: int16_t,
    pub marescore: uint32_t,
    pub lastmarescore: uint32_t,
    pub totalmarescore: uint32_t,
    pub lastmare: uint8_t,
    pub lastmarelap: uint8_t,
    pub lastmarebonuslap: uint8_t,
    pub totalmarelap: uint8_t,
    pub totalmarebonuslap: uint8_t,
    pub maxlink: int32_t,
    pub texttimer: uint8_t,
    pub textvar: uint8_t,
    pub lastsidehit: int16_t,
    pub lastlinehit: int16_t,
    pub losstime: tic_t,
    pub timeshit: uint8_t,
    pub onconveyor: int32_t,
    pub awayviewmobj: *mut mobj_t,
    pub awayviewtics: int32_t,
    pub awayviewaiming: angle_t,
    pub spectator: boolean,
    pub outofcoop: boolean,
    pub removing: boolean,
    pub bot: uint8_t,
    pub botleader: *mut player_s,
    pub lastbuttons: uint16_t,
    pub botmem: botmem_t,
    pub blocked: boolean,
    pub jointime: tic_t,
    pub quittime: tic_t,
}
pub type botmem_t = botmem_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct botmem_s {
    pub lastForward: boolean,
    pub lastBlocked: boolean,
    pub blocked: boolean,
    pub catchup_tics: uint8_t,
    pub thinkstate: uint8_t,
}
pub type mobj_t = mobj_s;
pub type mobjtype_t = mobj_type;
pub type mobj_type = libc::c_uint;
pub const NUMMOBJTYPES: mobj_type = 1163;
pub const MT_LASTFREESLOT: mobj_type = 1162;
pub const MT_FIRSTFREESLOT: mobj_type = 651;
pub const MT_RAY: mobj_type = 650;
pub const MT_NAMECHECK: mobj_type = 649;
pub const MT_YELLOWBRICKDEBRIS: mobj_type = 648;
pub const MT_BLUEBRICKDEBRIS: mobj_type = 647;
pub const MT_REDBRICKDEBRIS: mobj_type = 646;
pub const MT_WOODDEBRIS: mobj_type = 645;
pub const MT_BRICKDEBRIS: mobj_type = 644;
pub const MT_GFZDEBRIS: mobj_type = 643;
pub const MT_ROCKCRUMBLE16: mobj_type = 642;
pub const MT_ROCKCRUMBLE15: mobj_type = 641;
pub const MT_ROCKCRUMBLE14: mobj_type = 640;
pub const MT_ROCKCRUMBLE13: mobj_type = 639;
pub const MT_ROCKCRUMBLE12: mobj_type = 638;
pub const MT_ROCKCRUMBLE11: mobj_type = 637;
pub const MT_ROCKCRUMBLE10: mobj_type = 636;
pub const MT_ROCKCRUMBLE9: mobj_type = 635;
pub const MT_ROCKCRUMBLE8: mobj_type = 634;
pub const MT_ROCKCRUMBLE7: mobj_type = 633;
pub const MT_ROCKCRUMBLE6: mobj_type = 632;
pub const MT_ROCKCRUMBLE5: mobj_type = 631;
pub const MT_ROCKCRUMBLE4: mobj_type = 630;
pub const MT_ROCKCRUMBLE3: mobj_type = 629;
pub const MT_ROCKCRUMBLE2: mobj_type = 628;
pub const MT_ROCKCRUMBLE1: mobj_type = 627;
pub const MT_FALLINGROCK: mobj_type = 626;
pub const MT_ROCKSPAWNER: mobj_type = 625;
pub const MT_DUST: mobj_type = 624;
pub const MT_UWEXPLODE: mobj_type = 623;
pub const MT_EXPLODE: mobj_type = 622;
pub const MT_SPARK: mobj_type = 621;
pub const MT_SKYBOX: mobj_type = 620;
pub const MT_POLYSPAWN: mobj_type = 619;
pub const MT_POLYANCHOR: mobj_type = 618;
pub const MT_ANGLEMAN: mobj_type = 617;
pub const MT_OVERLAY: mobj_type = 616;
pub const MT_GHOST: mobj_type = 615;
pub const MT_PUSH: mobj_type = 614;
pub const MT_TUBEWAYPOINT: mobj_type = 613;
pub const MT_CRUMBLEOBJ: mobj_type = 612;
pub const MT_ALTVIEWMAN: mobj_type = 611;
pub const MT_TELEPORTMAN: mobj_type = 610;
pub const MT_HANGSTER: mobj_type = 609;
pub const MT_SPINBOBERT_FIRE2: mobj_type = 608;
pub const MT_SPINBOBERT_FIRE1: mobj_type = 607;
pub const MT_SPINBOBERT: mobj_type = 606;
pub const MT_CACOFIRE: mobj_type = 605;
pub const MT_CACOSHARD: mobj_type = 604;
pub const MT_CACOLANTERN: mobj_type = 603;
pub const MT_SMASHINGSPIKEBALL: mobj_type = 602;
pub const MT_BUGGLE: mobj_type = 601;
pub const MT_BUMBLEBORE: mobj_type = 600;
pub const MT_HIVEELEMENTAL: mobj_type = 599;
pub const MT_POPSHOT_TRAIL: mobj_type = 598;
pub const MT_POPSHOT: mobj_type = 597;
pub const MT_POPHAT: mobj_type = 596;
pub const MT_PENGUINATOR: mobj_type = 595;
pub const MT_SHLEEP: mobj_type = 594;
pub const MT_PIAN: mobj_type = 593;
pub const MT_NIGHTOPIANHELPER: mobj_type = 592;
pub const MT_IDEYAANCHOR: mobj_type = 591;
pub const MT_EGGCAPSULE: mobj_type = 590;
pub const MT_NIGHTSLINKFREEZE: mobj_type = 589;
pub const MT_NIGHTSEXTRATIME: mobj_type = 588;
pub const MT_NIGHTSHELPER: mobj_type = 587;
pub const MT_NIGHTSDRILLREFILL: mobj_type = 586;
pub const MT_NIGHTSSUPERLOOP: mobj_type = 585;
pub const MT_FLINGNIGHTSSTAR: mobj_type = 584;
pub const MT_NIGHTSSTAR: mobj_type = 583;
pub const MT_FLINGNIGHTSCHIP: mobj_type = 582;
pub const MT_NIGHTSCHIP: mobj_type = 581;
pub const MT_NIGHTSCORE: mobj_type = 580;
pub const MT_HOOPCENTER: mobj_type = 579;
pub const MT_HOOPCOLLIDE: mobj_type = 578;
pub const MT_HOOP: mobj_type = 577;
pub const MT_NIGHTSBUMPER: mobj_type = 576;
pub const MT_NIGHTSLOOPHELPER: mobj_type = 575;
pub const MT_NIGHTSPARKLE: mobj_type = 574;
pub const MT_NIGHTSDRONE_GOAL: mobj_type = 573;
pub const MT_NIGHTSDRONE_SPARKLING: mobj_type = 572;
pub const MT_NIGHTSDRONE_MAN: mobj_type = 571;
pub const MT_NIGHTSDRONE: mobj_type = 570;
pub const MT_AXISTRANSFERLINE: mobj_type = 569;
pub const MT_AXISTRANSFER: mobj_type = 568;
pub const MT_AXIS: mobj_type = 567;
pub const MT_TOAD: mobj_type = 566;
pub const MT_MARIOBUSH2: mobj_type = 565;
pub const MT_MARIOBUSH1: mobj_type = 564;
pub const MT_AXE: mobj_type = 563;
pub const MT_KOOPAFLAME: mobj_type = 562;
pub const MT_KOOPA: mobj_type = 561;
pub const MT_HAMMER: mobj_type = 560;
pub const MT_PUMATRAIL: mobj_type = 559;
pub const MT_PUMA: mobj_type = 558;
pub const MT_SHELL: mobj_type = 557;
pub const MT_FIREBALLTRAIL: mobj_type = 556;
pub const MT_FIREBALL: mobj_type = 555;
pub const MT_FIREFLOWER: mobj_type = 554;
pub const MT_BLUEGOOMBA: mobj_type = 553;
pub const MT_GOOMBA: mobj_type = 552;
pub const MT_FLINGCOIN: mobj_type = 551;
pub const MT_COIN: mobj_type = 550;
pub const MT_THROWNGRENADE: mobj_type = 549;
pub const MT_THROWNEXPLOSION: mobj_type = 548;
pub const MT_THROWNSCATTER: mobj_type = 547;
pub const MT_THROWNAUTOMATIC: mobj_type = 546;
pub const MT_THROWNINFINITY: mobj_type = 545;
pub const MT_THROWNBOUNCE: mobj_type = 544;
pub const MT_GRENADEPICKUP: mobj_type = 543;
pub const MT_SCATTERPICKUP: mobj_type = 542;
pub const MT_EXPLODEPICKUP: mobj_type = 541;
pub const MT_AUTOPICKUP: mobj_type = 540;
pub const MT_RAILPICKUP: mobj_type = 539;
pub const MT_BOUNCEPICKUP: mobj_type = 538;
pub const MT_GRENADERING: mobj_type = 537;
pub const MT_SCATTERRING: mobj_type = 536;
pub const MT_EXPLOSIONRING: mobj_type = 535;
pub const MT_AUTOMATICRING: mobj_type = 534;
pub const MT_INFINITYRING: mobj_type = 533;
pub const MT_RAILRING: mobj_type = 532;
pub const MT_BOUNCERING: mobj_type = 531;
pub const MT_REDRING: mobj_type = 530;
pub const MT_LHRT: mobj_type = 529;
pub const MT_CORK: mobj_type = 528;
pub const MT_AMBIENT: mobj_type = 527;
pub const MT_FINISHFLAG: mobj_type = 526;
pub const MT_GOTFLAG: mobj_type = 525;
pub const MT_TAG: mobj_type = 524;
pub const MT_LOCKONINF: mobj_type = 523;
pub const MT_LOCKON: mobj_type = 522;
pub const MT_GOTEMERALD: mobj_type = 521;
pub const MT_DROWNNUMBERS: mobj_type = 520;
pub const MT_SCORE: mobj_type = 519;
pub const MT_PARTICLEGEN: mobj_type = 518;
pub const MT_PARTICLE: mobj_type = 517;
pub const MT_TFOG: mobj_type = 516;
pub const MT_SPINDUST: mobj_type = 515;
pub const MT_WATERZAP: mobj_type = 514;
pub const MT_EXTRALARGEBUBBLE: mobj_type = 513;
pub const MT_MEDIUMBUBBLE: mobj_type = 512;
pub const MT_SMALLBUBBLE: mobj_type = 511;
pub const MT_SMOKE: mobj_type = 510;
pub const MT_LAVASPLISH: mobj_type = 509;
pub const MT_SPLISH: mobj_type = 508;
pub const MT_SNOWFLAKE: mobj_type = 507;
pub const MT_RAIN: mobj_type = 506;
pub const MT_SEED: mobj_type = 505;
pub const MT_SECRETFLICKY_02_CENTER: mobj_type = 504;
pub const MT_SECRETFLICKY_02: mobj_type = 503;
pub const MT_SECRETFLICKY_01_CENTER: mobj_type = 502;
pub const MT_SECRETFLICKY_01: mobj_type = 501;
pub const MT_FLICKY_16_CENTER: mobj_type = 500;
pub const MT_FLICKY_16: mobj_type = 499;
pub const MT_FLICKY_15_CENTER: mobj_type = 498;
pub const MT_FLICKY_15: mobj_type = 497;
pub const MT_FLICKY_14_CENTER: mobj_type = 496;
pub const MT_FLICKY_14: mobj_type = 495;
pub const MT_FLICKY_13_CENTER: mobj_type = 494;
pub const MT_FLICKY_13: mobj_type = 493;
pub const MT_FLICKY_12_CENTER: mobj_type = 492;
pub const MT_FLICKY_12: mobj_type = 491;
pub const MT_FLICKY_11_CENTER: mobj_type = 490;
pub const MT_FLICKY_11: mobj_type = 489;
pub const MT_FLICKY_10_CENTER: mobj_type = 488;
pub const MT_FLICKY_10: mobj_type = 487;
pub const MT_FLICKY_09_CENTER: mobj_type = 486;
pub const MT_FLICKY_09: mobj_type = 485;
pub const MT_FLICKY_08_CENTER: mobj_type = 484;
pub const MT_FLICKY_08: mobj_type = 483;
pub const MT_FLICKY_07_CENTER: mobj_type = 482;
pub const MT_FLICKY_07: mobj_type = 481;
pub const MT_FLICKY_06_CENTER: mobj_type = 480;
pub const MT_FLICKY_06: mobj_type = 479;
pub const MT_FLICKY_05_CENTER: mobj_type = 478;
pub const MT_FLICKY_05: mobj_type = 477;
pub const MT_FLICKY_04_CENTER: mobj_type = 476;
pub const MT_FLICKY_04: mobj_type = 475;
pub const MT_FLICKY_03_CENTER: mobj_type = 474;
pub const MT_FLICKY_03: mobj_type = 473;
pub const MT_FLICKY_02_CENTER: mobj_type = 472;
pub const MT_FLICKY_02: mobj_type = 471;
pub const MT_FLICKY_01_CENTER: mobj_type = 470;
pub const MT_FLICKY_01: mobj_type = 469;
pub const MT_SUPERSPARK: mobj_type = 468;
pub const MT_IVSP: mobj_type = 467;
pub const MT_THUNDERCOIN_SPARK: mobj_type = 466;
pub const MT_THUNDERCOIN_ORB: mobj_type = 465;
pub const MT_BUBBLEWRAP_ORB: mobj_type = 464;
pub const MT_FLAMEAURA_ORB: mobj_type = 463;
pub const MT_PITY_ORB: mobj_type = 462;
pub const MT_WHIRLWIND_ORB: mobj_type = 461;
pub const MT_ARMAGEDDON_ORB: mobj_type = 460;
pub const MT_FORCE_ORB: mobj_type = 459;
pub const MT_ATTRACT_ORB: mobj_type = 458;
pub const MT_ELEMENTAL_ORB: mobj_type = 457;
pub const MT_EGGSTATUE2: mobj_type = 456;
pub const MT_DBALL: mobj_type = 455;
pub const MT_PALMTREE_TOP: mobj_type = 454;
pub const MT_PALMTREE_TRUNK: mobj_type = 453;
pub const MT_BIG_PALMTREE_TOP: mobj_type = 452;
pub const MT_BIG_PALMTREE_TRUNK: mobj_type = 451;
pub const MT_BSZCLOVER: mobj_type = 450;
pub const MT_BSZSHRUB: mobj_type = 449;
pub const MT_BSZVINE_ORANGE: mobj_type = 448;
pub const MT_BSZVINE_YELLOW: mobj_type = 447;
pub const MT_BSZVINE_CYAN: mobj_type = 446;
pub const MT_BSZVINE_BLUE: mobj_type = 445;
pub const MT_BSZVINE_PURPLE: mobj_type = 444;
pub const MT_BSZVINE_RED: mobj_type = 443;
pub const MT_BSZBUSH_ORANGE: mobj_type = 442;
pub const MT_BSZBUSH_YELLOW: mobj_type = 441;
pub const MT_BSZBUSH_CYAN: mobj_type = 440;
pub const MT_BSZBUSH_BLUE: mobj_type = 439;
pub const MT_BSZBUSH_PURPLE: mobj_type = 438;
pub const MT_BSZBUSH_RED: mobj_type = 437;
pub const MT_BSZCLUSTER_ORANGE: mobj_type = 436;
pub const MT_BSZCLUSTER_YELLOW: mobj_type = 435;
pub const MT_BSZCLUSTER_CYAN: mobj_type = 434;
pub const MT_BSZCLUSTER_BLUE: mobj_type = 433;
pub const MT_BSZCLUSTER_PURPLE: mobj_type = 432;
pub const MT_BSZCLUSTER_RED: mobj_type = 431;
pub const MT_BSZTULIP_ORANGE: mobj_type = 430;
pub const MT_BSZTULIP_YELLOW: mobj_type = 429;
pub const MT_BSZTULIP_CYAN: mobj_type = 428;
pub const MT_BSZTULIP_BLUE: mobj_type = 427;
pub const MT_BSZTULIP_PURPLE: mobj_type = 426;
pub const MT_BSZTULIP_RED: mobj_type = 425;
pub const MT_BSZSHORTFLOWER_ORANGE: mobj_type = 424;
pub const MT_BSZSHORTFLOWER_YELLOW: mobj_type = 423;
pub const MT_BSZSHORTFLOWER_CYAN: mobj_type = 422;
pub const MT_BSZSHORTFLOWER_BLUE: mobj_type = 421;
pub const MT_BSZSHORTFLOWER_PURPLE: mobj_type = 420;
pub const MT_BSZSHORTFLOWER_RED: mobj_type = 419;
pub const MT_BSZFLOWER_ORANGE: mobj_type = 418;
pub const MT_BSZFLOWER_YELLOW: mobj_type = 417;
pub const MT_BSZFLOWER_CYAN: mobj_type = 416;
pub const MT_BSZFLOWER_BLUE: mobj_type = 415;
pub const MT_BSZFLOWER_PURPLE: mobj_type = 414;
pub const MT_BSZFLOWER_RED: mobj_type = 413;
pub const MT_BSZTALLFLOWER_ORANGE: mobj_type = 412;
pub const MT_BSZTALLFLOWER_YELLOW: mobj_type = 411;
pub const MT_BSZTALLFLOWER_CYAN: mobj_type = 410;
pub const MT_BSZTALLFLOWER_BLUE: mobj_type = 409;
pub const MT_BSZTALLFLOWER_PURPLE: mobj_type = 408;
pub const MT_BSZTALLFLOWER_RED: mobj_type = 407;
pub const MT_HHZSTALAGMITE_SHORT: mobj_type = 406;
pub const MT_HHZSTALAGMITE_TALL: mobj_type = 405;
pub const MT_HHZTENTACLE2: mobj_type = 404;
pub const MT_HHZTENTACLE1: mobj_type = 403;
pub const MT_HHZGRASS: mobj_type = 402;
pub const MT_HHZSHROOM: mobj_type = 401;
pub const MT_HHZTREE_PART: mobj_type = 400;
pub const MT_HHZTREE_TOP: mobj_type = 399;
pub const MT_JACKO3: mobj_type = 398;
pub const MT_JACKO2: mobj_type = 397;
pub const MT_JACKO1: mobj_type = 396;
pub const MT_CDLHRT: mobj_type = 395;
pub const MT_ROSY: mobj_type = 394;
pub const MT_FHZICE2: mobj_type = 393;
pub const MT_FHZICE1: mobj_type = 392;
pub const MT_XMASBUSH: mobj_type = 391;
pub const MT_XMASBERRYBUSH: mobj_type = 390;
pub const MT_XMASBLUEBERRYBUSH: mobj_type = 389;
pub const MT_MISTLETOE: mobj_type = 388;
pub const MT_HANGSTAR: mobj_type = 387;
pub const MT_LAMPPOST2: mobj_type = 386;
pub const MT_LAMPPOST1: mobj_type = 385;
pub const MT_SNOWMANHAT: mobj_type = 384;
pub const MT_SNOWMAN: mobj_type = 383;
pub const MT_CANDYCANE: mobj_type = 382;
pub const MT_XMASPOLE: mobj_type = 381;
pub const MT_STALAGMITE9: mobj_type = 380;
pub const MT_STALAGMITE8: mobj_type = 379;
pub const MT_STALAGMITE7: mobj_type = 378;
pub const MT_STALAGMITE6: mobj_type = 377;
pub const MT_STALAGMITE5: mobj_type = 376;
pub const MT_STALAGMITE4: mobj_type = 375;
pub const MT_STALAGMITE3: mobj_type = 374;
pub const MT_STALAGMITE2: mobj_type = 373;
pub const MT_STALAGMITE1: mobj_type = 372;
pub const MT_STALAGMITE0: mobj_type = 371;
pub const MT_BLUEGARGOYLE: mobj_type = 370;
pub const MT_GREENFLAME: mobj_type = 369;
pub const MT_TARGET: mobj_type = 368;
pub const MT_GLAREGOYLELONG: mobj_type = 367;
pub const MT_GLAREGOYLEDOWN: mobj_type = 366;
pub const MT_GLAREGOYLEUP: mobj_type = 365;
pub const MT_GLAREGOYLE: mobj_type = 364;
pub const MT_WALLVINE_SHORT: mobj_type = 363;
pub const MT_WALLVINE_LONG: mobj_type = 362;
pub const MT_TORCHFLOWER: mobj_type = 361;
pub const MT_JUNGLEPALM: mobj_type = 360;
pub const MT_BIGFERN: mobj_type = 359;
pub const MT_BIGFERNLEAF: mobj_type = 358;
pub const MT_ROLLOUTROCK: mobj_type = 357;
pub const MT_ROLLOUTSPAWN: mobj_type = 356;
pub const MT_LAVAFALLROCK: mobj_type = 355;
pub const MT_LAVAFALL_LAVA: mobj_type = 354;
pub const MT_LAVAFALL: mobj_type = 353;
pub const MT_FLAMEJETFLAMEB: mobj_type = 352;
pub const MT_FJSPINAXISB: mobj_type = 351;
pub const MT_FJSPINAXISA: mobj_type = 350;
pub const MT_FLAMEJETFLAME: mobj_type = 349;
pub const MT_VERTICALFLAMEJET: mobj_type = 348;
pub const MT_FLAMEJET: mobj_type = 347;
pub const MT_MINECARTSWITCHPOINT: mobj_type = 346;
pub const MT_TRAINSTEAMSPAWNER: mobj_type = 345;
pub const MT_TRAINDUSTSPAWNER: mobj_type = 344;
pub const MT_TRAINSEG: mobj_type = 343;
pub const MT_TRAINCAMEOSPAWNER: mobj_type = 342;
pub const MT_SALOONDOORCENTER: mobj_type = 341;
pub const MT_SALOONDOOR: mobj_type = 340;
pub const MT_MINECARTSPARK: mobj_type = 339;
pub const MT_MINECARTSIDEMARK: mobj_type = 338;
pub const MT_MINECARTENDSOLID: mobj_type = 337;
pub const MT_MINECARTEND: mobj_type = 336;
pub const MT_MINECARTSPAWNER: mobj_type = 335;
pub const MT_MINECARTSEG: mobj_type = 334;
pub const MT_MINECART: mobj_type = 333;
pub const MT_ARIDDUST: mobj_type = 332;
pub const MT_DUSTLAYER: mobj_type = 331;
pub const MT_DUSTDEVIL: mobj_type = 330;
pub const MT_PROXIMITYTNT: mobj_type = 329;
pub const MT_TNTBARREL: mobj_type = 328;
pub const MT_OILLAMP: mobj_type = 327;
pub const MT_ARIDSIGN_SHARPTURN: mobj_type = 326;
pub const MT_ARIDSIGN_CACTI: mobj_type = 325;
pub const MT_ARIDSIGN_CAUTION: mobj_type = 324;
pub const MT_CACTISMALLSEG: mobj_type = 323;
pub const MT_CACTITINYSEG: mobj_type = 322;
pub const MT_CACTI11: mobj_type = 321;
pub const MT_CACTI10: mobj_type = 320;
pub const MT_CACTI9: mobj_type = 319;
pub const MT_CACTI8: mobj_type = 318;
pub const MT_CACTI7: mobj_type = 317;
pub const MT_CACTI6: mobj_type = 316;
pub const MT_CACTI5: mobj_type = 315;
pub const MT_CACTI4: mobj_type = 314;
pub const MT_CACTI3: mobj_type = 313;
pub const MT_CACTI2: mobj_type = 312;
pub const MT_CACTI1: mobj_type = 311;
pub const MT_LITTLETUMBLEWEED: mobj_type = 310;
pub const MT_BIGTUMBLEWEED: mobj_type = 309;
pub const MT_BRAMBLES: mobj_type = 308;
pub const MT_SUSPICIOUSFACESTABBERSTATUE: mobj_type = 307;
pub const MT_FACESTABBERSTATUE: mobj_type = 306;
pub const MT_CRAWLASTATUE: mobj_type = 305;
pub const MT_WAVINGFLAGSEG2: mobj_type = 304;
pub const MT_WAVINGFLAGSEG1: mobj_type = 303;
pub const MT_WAVINGFLAG2: mobj_type = 302;
pub const MT_WAVINGFLAG1: mobj_type = 301;
pub const MT_FIRETORCH: mobj_type = 300;
pub const MT_FLAMEHOLDER: mobj_type = 299;
pub const MT_CANDLEPRICKET: mobj_type = 298;
pub const MT_CANDLE: mobj_type = 297;
pub const MT_CEZBUSH2: mobj_type = 296;
pub const MT_CEZBUSH1: mobj_type = 295;
pub const MT_PINETREE: mobj_type = 294;
pub const MT_CEZBANNER2: mobj_type = 293;
pub const MT_CEZBANNER1: mobj_type = 292;
pub const MT_CEZPOLE2: mobj_type = 291;
pub const MT_CEZPOLE1: mobj_type = 290;
pub const MT_CEZFLOWER: mobj_type = 289;
pub const MT_BIGFIREBAR: mobj_type = 288;
pub const MT_SMALLFIREBAR: mobj_type = 287;
pub const MT_REDSPRINGBALL: mobj_type = 286;
pub const MT_YELLOWSPRINGBALL: mobj_type = 285;
pub const MT_BIGGRABCHAIN: mobj_type = 284;
pub const MT_SMALLGRABCHAIN: mobj_type = 283;
pub const MT_BIGMACE: mobj_type = 282;
pub const MT_SMALLMACE: mobj_type = 281;
pub const MT_BIGMACECHAIN: mobj_type = 280;
pub const MT_SMALLMACECHAIN: mobj_type = 279;
pub const MT_CUSTOMMACEPOINT: mobj_type = 278;
pub const MT_FIREBARPOINT: mobj_type = 277;
pub const MT_HIDDEN_SLING: mobj_type = 276;
pub const MT_CHAINPOINT: mobj_type = 275;
pub const MT_SPRINGBALLPOINT: mobj_type = 274;
pub const MT_CHAINMACEPOINT: mobj_type = 273;
pub const MT_MACEPOINT: mobj_type = 272;
pub const MT_EGGSTATUE: mobj_type = 271;
pub const MT_FLAMEPARTICLE: mobj_type = 270;
pub const MT_FLAME: mobj_type = 269;
pub const MT_CHAIN: mobj_type = 268;
pub const MT_LIGHTBEAM: mobj_type = 267;
pub const MT_DSZ2STALAGMITE: mobj_type = 266;
pub const MT_DSZSTALAGMITE: mobj_type = 265;
pub const MT_ANIMALGAESEG: mobj_type = 264;
pub const MT_ANIMALGAETOP: mobj_type = 263;
pub const MT_KELP: mobj_type = 262;
pub const MT_BLUECRYSTAL: mobj_type = 261;
pub const MT_CORAL5: mobj_type = 260;
pub const MT_CORAL4: mobj_type = 259;
pub const MT_CORAL3: mobj_type = 258;
pub const MT_CORAL2: mobj_type = 257;
pub const MT_CORAL1: mobj_type = 256;
pub const MT_WATERDROP: mobj_type = 255;
pub const MT_WATERDRIP: mobj_type = 254;
pub const MT_SEAWEED: mobj_type = 253;
pub const MT_BIGGARGOYLE: mobj_type = 252;
pub const MT_GARGOYLE: mobj_type = 251;
pub const MT_ALARM: mobj_type = 250;
pub const MT_THZTREEBRANCH: mobj_type = 249;
pub const MT_THZTREE: mobj_type = 248;
pub const MT_THZFLOWER3: mobj_type = 247;
pub const MT_THZFLOWER2: mobj_type = 246;
pub const MT_THZFLOWER1: mobj_type = 245;
pub const MT_SPRINGTREE: mobj_type = 244;
pub const MT_BUSHREDTREE: mobj_type = 243;
pub const MT_BUSHTREE: mobj_type = 242;
pub const MT_POLYGONTREE: mobj_type = 241;
pub const MT_FHZPINKTREE: mobj_type = 240;
pub const MT_FHZTREE: mobj_type = 239;
pub const MT_CHECKERSUNSETTREE: mobj_type = 238;
pub const MT_CHECKERTREE: mobj_type = 237;
pub const MT_GFZCHERRYTREE: mobj_type = 236;
pub const MT_GFZBERRYTREE: mobj_type = 235;
pub const MT_GFZTREE: mobj_type = 234;
pub const MT_BUSH: mobj_type = 233;
pub const MT_BERRYBUSH: mobj_type = 232;
pub const MT_BLUEBERRYBUSH: mobj_type = 231;
pub const MT_GFZFLOWER3: mobj_type = 230;
pub const MT_GFZFLOWER2: mobj_type = 229;
pub const MT_GFZFLOWER1: mobj_type = 228;
pub const MT_TUTORIALFLOWERF: mobj_type = 227;
pub const MT_TUTORIALFLOWER: mobj_type = 226;
pub const MT_TUTORIALLEAF: mobj_type = 225;
pub const MT_TUTORIALPLANT: mobj_type = 224;
pub const MT_LETTER: mobj_type = 223;
pub const MT_DEMONFIRE: mobj_type = 222;
pub const MT_ARROW: mobj_type = 221;
pub const MT_CANNONBALLDECOR: mobj_type = 220;
pub const MT_CANNONBALL: mobj_type = 219;
pub const MT_TURRETLASER: mobj_type = 218;
pub const MT_JETTBULLET: mobj_type = 217;
pub const MT_MINE: mobj_type = 216;
pub const MT_ENERGYBALL: mobj_type = 215;
pub const MT_TORPEDO2: mobj_type = 214;
pub const MT_TORPEDO: mobj_type = 213;
pub const MT_LASER: mobj_type = 212;
pub const MT_ROCKET: mobj_type = 211;
pub const MT_THUNDERCOIN_ICON: mobj_type = 210;
pub const MT_BUBBLEWRAP_ICON: mobj_type = 209;
pub const MT_FLAMEAURA_ICON: mobj_type = 208;
pub const MT_SCORE10K_ICON: mobj_type = 207;
pub const MT_SCORE1K_ICON: mobj_type = 206;
pub const MT_RECYCLER_ICON: mobj_type = 205;
pub const MT_GRAVITY_ICON: mobj_type = 204;
pub const MT_MIXUP_ICON: mobj_type = 203;
pub const MT_EGGMAN_ICON: mobj_type = 202;
pub const MT_1UP_ICON: mobj_type = 201;
pub const MT_INVULN_ICON: mobj_type = 200;
pub const MT_SNEAKERS_ICON: mobj_type = 199;
pub const MT_ELEMENTAL_ICON: mobj_type = 198;
pub const MT_WHIRLWIND_ICON: mobj_type = 197;
pub const MT_ARMAGEDDON_ICON: mobj_type = 196;
pub const MT_FORCE_ICON: mobj_type = 195;
pub const MT_ATTRACT_ICON: mobj_type = 194;
pub const MT_PITY_ICON: mobj_type = 193;
pub const MT_RING_ICON: mobj_type = 192;
pub const MT_RING_BLUEBOX: mobj_type = 191;
pub const MT_RING_REDBOX: mobj_type = 190;
pub const MT_THUNDERCOIN_GOLDBOX: mobj_type = 189;
pub const MT_BUBBLEWRAP_GOLDBOX: mobj_type = 188;
pub const MT_FLAMEAURA_GOLDBOX: mobj_type = 187;
pub const MT_GRAVITY_GOLDBOX: mobj_type = 186;
pub const MT_EGGMAN_GOLDBOX: mobj_type = 185;
pub const MT_INVULN_GOLDBOX: mobj_type = 184;
pub const MT_SNEAKERS_GOLDBOX: mobj_type = 183;
pub const MT_ELEMENTAL_GOLDBOX: mobj_type = 182;
pub const MT_WHIRLWIND_GOLDBOX: mobj_type = 181;
pub const MT_ARMAGEDDON_GOLDBOX: mobj_type = 180;
pub const MT_FORCE_GOLDBOX: mobj_type = 179;
pub const MT_ATTRACT_GOLDBOX: mobj_type = 178;
pub const MT_PITY_GOLDBOX: mobj_type = 177;
pub const MT_THUNDERCOIN_BOX: mobj_type = 176;
pub const MT_BUBBLEWRAP_BOX: mobj_type = 175;
pub const MT_FLAMEAURA_BOX: mobj_type = 174;
pub const MT_SCORE10K_BOX: mobj_type = 173;
pub const MT_SCORE1K_BOX: mobj_type = 172;
pub const MT_RECYCLER_BOX: mobj_type = 171;
pub const MT_GRAVITY_BOX: mobj_type = 170;
pub const MT_MYSTERY_BOX: mobj_type = 169;
pub const MT_MIXUP_BOX: mobj_type = 168;
pub const MT_EGGMAN_BOX: mobj_type = 167;
pub const MT_1UP_BOX: mobj_type = 166;
pub const MT_INVULN_BOX: mobj_type = 165;
pub const MT_SNEAKERS_BOX: mobj_type = 164;
pub const MT_ELEMENTAL_BOX: mobj_type = 163;
pub const MT_WHIRLWIND_BOX: mobj_type = 162;
pub const MT_ARMAGEDDON_BOX: mobj_type = 161;
pub const MT_FORCE_BOX: mobj_type = 160;
pub const MT_ATTRACT_BOX: mobj_type = 159;
pub const MT_PITY_BOX: mobj_type = 158;
pub const MT_RING_BOX: mobj_type = 157;
pub const MT_BOXSPARKLE: mobj_type = 156;
pub const MT_CANNONLAUNCHER: mobj_type = 155;
pub const MT_BLASTEXECUTOR: mobj_type = 154;
pub const MT_BIGMINE: mobj_type = 153;
pub const MT_STARPOST: mobj_type = 152;
pub const MT_WALLSPIKEBASE: mobj_type = 151;
pub const MT_WALLSPIKE: mobj_type = 150;
pub const MT_SPIKE: mobj_type = 149;
pub const MT_SPINFIRE: mobj_type = 148;
pub const MT_SPIKEBALL: mobj_type = 147;
pub const MT_SIGN: mobj_type = 146;
pub const MT_BUBBLES: mobj_type = 145;
pub const MT_REDBOOSTER: mobj_type = 144;
pub const MT_YELLOWBOOSTER: mobj_type = 143;
pub const MT_BOOSTERROLLER: mobj_type = 142;
pub const MT_BOOSTERSEG: mobj_type = 141;
pub const MT_BLUEHORIZ: mobj_type = 140;
pub const MT_REDHORIZ: mobj_type = 139;
pub const MT_YELLOWHORIZ: mobj_type = 138;
pub const MT_BLUEDIAG: mobj_type = 137;
pub const MT_REDDIAG: mobj_type = 136;
pub const MT_YELLOWDIAG: mobj_type = 135;
pub const MT_BLUESPRING: mobj_type = 134;
pub const MT_REDSPRING: mobj_type = 133;
pub const MT_YELLOWSPRING: mobj_type = 132;
pub const MT_BALLOON: mobj_type = 131;
pub const MT_BUMPER: mobj_type = 130;
pub const MT_STEAM: mobj_type = 129;
pub const MT_FAN: mobj_type = 128;
pub const MT_FLINGEMERALD: mobj_type = 127;
pub const MT_EMERALDSPAWN: mobj_type = 126;
pub const MT_EMERHUNT: mobj_type = 125;
pub const MT_EMERALD7: mobj_type = 124;
pub const MT_EMERALD6: mobj_type = 123;
pub const MT_EMERALD5: mobj_type = 122;
pub const MT_EMERALD4: mobj_type = 121;
pub const MT_EMERALD3: mobj_type = 120;
pub const MT_EMERALD2: mobj_type = 119;
pub const MT_EMERALD1: mobj_type = 118;
pub const MT_EMBLEM: mobj_type = 117;
pub const MT_BLUEFLAG: mobj_type = 116;
pub const MT_REDFLAG: mobj_type = 115;
pub const MT_TOKEN: mobj_type = 114;
pub const MT_BLUETEAMRING: mobj_type = 113;
pub const MT_REDTEAMRING: mobj_type = 112;
pub const MT_BOMBSPHERE: mobj_type = 111;
pub const MT_FLINGBLUESPHERE: mobj_type = 110;
pub const MT_BLUESPHERE: mobj_type = 109;
pub const MT_FLINGRING: mobj_type = 108;
pub const MT_RING: mobj_type = 107;
pub const MT_MSGATHER: mobj_type = 106;
pub const MT_MSSHIELD_FRONT: mobj_type = 105;
pub const MT_METALSONIC_BATTLE: mobj_type = 104;
pub const MT_METALSONIC_RACE: mobj_type = 103;
pub const MT_CYBRAKDEMON_VILE_EXPLOSION: mobj_type = 102;
pub const MT_CYBRAKDEMON_NAPALM_FLAMES: mobj_type = 101;
pub const MT_CYBRAKDEMON_NAPALM_BOMB_SMALL: mobj_type = 100;
pub const MT_CYBRAKDEMON_NAPALM_BOMB_LARGE: mobj_type = 99;
pub const MT_CYBRAKDEMON_TARGET_DOT: mobj_type = 98;
pub const MT_CYBRAKDEMON_TARGET_RETICULE: mobj_type = 97;
pub const MT_CYBRAKDEMON_FLAMEREST: mobj_type = 96;
pub const MT_CYBRAKDEMON_FLAMESHOT: mobj_type = 95;
pub const MT_CYBRAKDEMON_MISSILE: mobj_type = 94;
pub const MT_CYBRAKDEMON_ELECTRIC_BARRIER: mobj_type = 93;
pub const MT_CYBRAKDEMON: mobj_type = 92;
pub const MT_BLACKEGGMAN_MISSILE: mobj_type = 91;
pub const MT_BLACKEGGMAN_GOOPFIRE: mobj_type = 90;
pub const MT_BLACKEGGMAN_HELPER: mobj_type = 89;
pub const MT_BLACKEGGMAN: mobj_type = 88;
pub const MT_FANGWAYPOINT: mobj_type = 87;
pub const MT_FSGNB: mobj_type = 86;
pub const MT_FSGNA: mobj_type = 85;
pub const MT_TNTDUST: mobj_type = 84;
pub const MT_FBOMB: mobj_type = 83;
pub const MT_PROJECTORLIGHT: mobj_type = 82;
pub const MT_VWREB: mobj_type = 81;
pub const MT_VWREF: mobj_type = 80;
pub const MT_BROKENROBOT: mobj_type = 79;
pub const MT_FANG: mobj_type = 78;
pub const MT_EGGROBO1JET: mobj_type = 77;
pub const MT_EGGROBO1: mobj_type = 76;
pub const MT_JETFLAME: mobj_type = 75;
pub const MT_EGGMOBILE4_MACE: mobj_type = 74;
pub const MT_EGGMOBILE4: mobj_type = 73;
pub const MT_SHOCKWAVE: mobj_type = 72;
pub const MT_FAKEMOBILE: mobj_type = 71;
pub const MT_EGGMOBILE3: mobj_type = 70;
pub const MT_GOOPTRAIL: mobj_type = 69;
pub const MT_GOOP: mobj_type = 68;
pub const MT_EGGMOBILE2_POGO: mobj_type = 67;
pub const MT_EGGMOBILE2: mobj_type = 66;
pub const MT_EGGMOBILE_FIRE: mobj_type = 65;
pub const MT_EGGMOBILE_TARGET: mobj_type = 64;
pub const MT_EGGMOBILE_BALL: mobj_type = 63;
pub const MT_JETFUME1: mobj_type = 62;
pub const MT_EGGMOBILE: mobj_type = 61;
pub const MT_BOSSJUNK: mobj_type = 60;
pub const MT_BOSS9GATHERPOINT: mobj_type = 59;
pub const MT_BOSS3WAYPOINT: mobj_type = 58;
pub const MT_EGGTRAP: mobj_type = 57;
pub const MT_BOSSFLYPOINT: mobj_type = 56;
pub const MT_SONIC3KBOSSEXPLODE: mobj_type = 55;
pub const MT_BOSSEXPLODE: mobj_type = 54;
pub const MT_DRAGONMINE: mobj_type = 53;
pub const MT_DRAGONTAIL: mobj_type = 52;
pub const MT_DRAGONWING: mobj_type = 51;
pub const MT_DRAGONBOMBER: mobj_type = 50;
pub const MT_PTERABYTE: mobj_type = 49;
pub const MT_PTERABYTEWAYPOINT: mobj_type = 48;
pub const MT_PTERABYTESPAWNER: mobj_type = 47;
pub const MT_PYREFLY_FIRE: mobj_type = 46;
pub const MT_PYREFLY: mobj_type = 45;
pub const MT_CANARIVORE_GAS: mobj_type = 44;
pub const MT_CANARIVORE: mobj_type = 43;
pub const MT_UNIBALL: mobj_type = 42;
pub const MT_UNIDUS: mobj_type = 41;
pub const MT_YELLOWSHELL: mobj_type = 40;
pub const MT_SPRINGSHELL: mobj_type = 39;
pub const MT_MINUSDIRT: mobj_type = 38;
pub const MT_MINUS: mobj_type = 37;
pub const MT_SNAPPER_HEAD: mobj_type = 36;
pub const MT_SNAPPER_LEG: mobj_type = 35;
pub const MT_GSNAPPER: mobj_type = 34;
pub const MT_EGGSHIELD: mobj_type = 33;
pub const MT_EGGGUARD: mobj_type = 32;
pub const MT_FACESTABBERSPEAR: mobj_type = 31;
pub const MT_FACESTABBER: mobj_type = 30;
pub const MT_ROBOHOOD: mobj_type = 29;
pub const MT_POINTYBALL: mobj_type = 28;
pub const MT_POINTY: mobj_type = 27;
pub const MT_VULTURE: mobj_type = 26;
pub const MT_SNAILER: mobj_type = 25;
pub const MT_JETJAW: mobj_type = 24;
pub const MT_BANPSPRING: mobj_type = 23;
pub const MT_BANPYURA: mobj_type = 22;
pub const MT_CRUSHCHAIN: mobj_type = 21;
pub const MT_CRUSHCLAW: mobj_type = 20;
pub const MT_CRUSHSTACEAN: mobj_type = 19;
pub const MT_SPINCUSHION: mobj_type = 18;
pub const MT_POPUPTURRET: mobj_type = 17;
pub const MT_TURRET: mobj_type = 16;
pub const MT_SKIM: mobj_type = 15;
pub const MT_DETON: mobj_type = 14;
pub const MT_CRAWLACOMMANDER: mobj_type = 13;
pub const MT_JETTGUNNER: mobj_type = 12;
pub const MT_JETTBOMBER: mobj_type = 11;
pub const MT_REDBUZZ: mobj_type = 10;
pub const MT_GOLDBUZZ: mobj_type = 9;
pub const MT_GFZFISH: mobj_type = 8;
pub const MT_REDCRAWLA: mobj_type = 7;
pub const MT_BLUECRAWLA: mobj_type = 6;
pub const MT_METALJETFUME: mobj_type = 5;
pub const MT_TAILSOVERLAY: mobj_type = 4;
pub const MT_PLAYER: mobj_type = 3;
pub const MT_THOK: mobj_type = 2;
pub const MT_UNKNOWN: mobj_type = 1;
pub const MT_NULL: mobj_type = 0;
pub type panim_t = libc::c_uint;
pub const PA_RIDE: panim_t = 13;
pub const PA_ABILITY2: panim_t = 12;
pub const PA_ABILITY: panim_t = 11;
pub const PA_FALL: panim_t = 10;
pub const PA_SPRING: panim_t = 9;
pub const PA_JUMP: panim_t = 8;
pub const PA_ROLL: panim_t = 7;
pub const PA_PAIN: panim_t = 6;
pub const PA_DASH: panim_t = 5;
pub const PA_RUN: panim_t = 4;
pub const PA_WALK: panim_t = 3;
pub const PA_EDGE: panim_t = 2;
pub const PA_IDLE: panim_t = 1;
pub const PA_ETC: panim_t = 0;
pub type pflags_t = libc::c_uint;
pub const PF_FINISHED: pflags_t = 1073741824;
pub const PF_CANCARRY: pflags_t = 536870912;
pub const PF_FORCESTRAFE: pflags_t = 268435456;
pub const PF_TAGIT: pflags_t = 134217728;
pub const PF_GAMETYPEOVER: pflags_t = 67108864;
pub const PF_DRILLING: pflags_t = 33554432;
pub const PF_TRANSFERTOCLOSEST: pflags_t = 16777216;
pub const PF_SLIDING: pflags_t = 8388608;
pub const PF_BOUNCING: pflags_t = 4194304;
pub const PF_GLIDING: pflags_t = 2097152;
pub const PF_SHIELDABILITY: pflags_t = 1048576;
pub const PF_THOKKED: pflags_t = 524288;
pub const PF_STARTDASH: pflags_t = 262144;
pub const PF_SPINNING: pflags_t = 131072;
pub const PF_NOJUMPDAMAGE: pflags_t = 65536;
pub const PF_JUMPED: pflags_t = 32768;
pub const PF_STARTJUMP: pflags_t = 16384;
pub const PF_APPLYAUTOBRAKE: pflags_t = 8192;
pub const PF_FULLSTASIS: pflags_t = 6144;
pub const PF_JUMPSTASIS: pflags_t = 4096;
pub const PF_STASIS: pflags_t = 2048;
pub const PF_WPNDOWN: pflags_t = 1024;
pub const PF_JUMPDOWN: pflags_t = 512;
pub const PF_SPINDOWN: pflags_t = 256;
pub const PF_ATTACKDOWN: pflags_t = 128;
pub const PF_INVIS: pflags_t = 64;
pub const PF_NOCLIP: pflags_t = 32;
pub const PF_GODMODE: pflags_t = 16;
pub const PF_AUTOBRAKE: pflags_t = 8;
pub const PF_DIRECTIONCHAR: pflags_t = 4;
pub const PF_ANALOGMODE: pflags_t = 2;
pub const PF_FLIPCAM: pflags_t = 1;
pub type playerstate_t = libc::c_uint;
pub const PST_REBORN: playerstate_t = 2;
pub const PST_DEAD: playerstate_t = 1;
pub const PST_LIVE: playerstate_t = 0;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct ticcmd_t {
    pub forwardmove: int8_t,
    pub sidemove: int8_t,
    pub angleturn: int16_t,
    pub aiming: int16_t,
    pub buttons: uint16_t,
    pub latency: uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mobjinfo_t {
    pub doomednum: int32_t,
    pub spawnstate: statenum_t,
    pub spawnhealth: int32_t,
    pub seestate: statenum_t,
    pub seesound: sfxenum_t,
    pub reactiontime: int32_t,
    pub attacksound: sfxenum_t,
    pub painstate: statenum_t,
    pub painchance: int32_t,
    pub painsound: sfxenum_t,
    pub meleestate: statenum_t,
    pub missilestate: statenum_t,
    pub deathstate: statenum_t,
    pub xdeathstate: statenum_t,
    pub deathsound: sfxenum_t,
    pub speed: fixed_t,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub dispoffset: int32_t,
    pub mass: int32_t,
    pub damage: int32_t,
    pub activesound: sfxenum_t,
    pub flags: uint32_t,
    pub raisestate: statenum_t,
}
pub type statenum_t = state;
pub type state = libc::c_uint;
pub const NUMSTATES: state = 6735;
pub const S_LASTFREESLOT: state = 6734;
pub const S_FIRSTFREESLOT: state = 2639;
pub const S_NAMECHECK: state = 2638;
pub const S_YELLOWBRICKDEBRIS: state = 2637;
pub const S_BLUEBRICKDEBRIS: state = 2636;
pub const S_REDBRICKDEBRIS: state = 2635;
pub const S_WOODDEBRIS: state = 2634;
pub const S_BRICKDEBRIS: state = 2633;
pub const S_GFZDEBRIS: state = 2632;
pub const S_ROCKCRUMBLEP: state = 2631;
pub const S_ROCKCRUMBLEO: state = 2630;
pub const S_ROCKCRUMBLEN: state = 2629;
pub const S_ROCKCRUMBLEM: state = 2628;
pub const S_ROCKCRUMBLEL: state = 2627;
pub const S_ROCKCRUMBLEK: state = 2626;
pub const S_ROCKCRUMBLEJ: state = 2625;
pub const S_ROCKCRUMBLEI: state = 2624;
pub const S_ROCKCRUMBLEH: state = 2623;
pub const S_ROCKCRUMBLEG: state = 2622;
pub const S_ROCKCRUMBLEF: state = 2621;
pub const S_ROCKCRUMBLEE: state = 2620;
pub const S_ROCKCRUMBLED: state = 2619;
pub const S_ROCKCRUMBLEC: state = 2618;
pub const S_ROCKCRUMBLEB: state = 2617;
pub const S_ROCKCRUMBLEA: state = 2616;
pub const S_ROCKSPAWN: state = 2615;
pub const S_DUST4: state = 2614;
pub const S_DUST3: state = 2613;
pub const S_DUST2: state = 2612;
pub const S_DUST1: state = 2611;
pub const S_WPLD6: state = 2610;
pub const S_WPLD5: state = 2609;
pub const S_WPLD4: state = 2608;
pub const S_WPLD3: state = 2607;
pub const S_WPLD2: state = 2606;
pub const S_WPLD1: state = 2605;
pub const S_XPLD_EGGTRAP: state = 2604;
pub const S_XPLD6: state = 2603;
pub const S_XPLD5: state = 2602;
pub const S_XPLD4: state = 2601;
pub const S_XPLD3: state = 2600;
pub const S_XPLD2: state = 2599;
pub const S_XPLD1: state = 2598;
pub const S_XPLD_FLICKY: state = 2597;
pub const S_SPRK3: state = 2596;
pub const S_SPRK2: state = 2595;
pub const S_SPRK1: state = 2594;
pub const S_CRUMBLE2: state = 2593;
pub const S_CRUMBLE1: state = 2592;
pub const S_HANGSTER_RETURN3: state = 2591;
pub const S_HANGSTER_RETURN2: state = 2590;
pub const S_HANGSTER_RETURN1: state = 2589;
pub const S_HANGSTER_ARCUP3: state = 2588;
pub const S_HANGSTER_ARCUP2: state = 2587;
pub const S_HANGSTER_ARCUP1: state = 2586;
pub const S_HANGSTER_FLYREPEAT: state = 2585;
pub const S_HANGSTER_FLY4: state = 2584;
pub const S_HANGSTER_FLY3: state = 2583;
pub const S_HANGSTER_FLY2: state = 2582;
pub const S_HANGSTER_FLY1: state = 2581;
pub const S_HANGSTER_ARC3: state = 2580;
pub const S_HANGSTER_ARC2: state = 2579;
pub const S_HANGSTER_ARC1: state = 2578;
pub const S_HANGSTER_SWOOP2: state = 2577;
pub const S_HANGSTER_SWOOP1: state = 2576;
pub const S_HANGSTER_LOOK: state = 2575;
pub const S_SPINBOBERT_FIRE_TRAIL3: state = 2574;
pub const S_SPINBOBERT_FIRE_TRAIL2: state = 2573;
pub const S_SPINBOBERT_FIRE_TRAIL1: state = 2572;
pub const S_SPINBOBERT_FIRE_GHOST: state = 2571;
pub const S_SPINBOBERT_FIRE_MOVE: state = 2570;
pub const S_SPINBOBERT_MOVE_DOWN: state = 2569;
pub const S_SPINBOBERT_MOVE_FLIPDOWN: state = 2568;
pub const S_SPINBOBERT_MOVE_UP: state = 2567;
pub const S_SPINBOBERT_MOVE_FLIPUP: state = 2566;
pub const S_CACOFIRE_EXPLODE4: state = 2565;
pub const S_CACOFIRE_EXPLODE3: state = 2564;
pub const S_CACOFIRE_EXPLODE2: state = 2563;
pub const S_CACOFIRE_EXPLODE1: state = 2562;
pub const S_CACOFIRE3: state = 2561;
pub const S_CACOFIRE2: state = 2560;
pub const S_CACOFIRE1: state = 2559;
pub const S_CACOSHARD2_2: state = 2558;
pub const S_CACOSHARD2_1: state = 2557;
pub const S_CACOSHARD1_2: state = 2556;
pub const S_CACOSHARD1_1: state = 2555;
pub const S_CACOSHARD_RANDOMIZE: state = 2554;
pub const S_CACO_DIE_FALL: state = 2553;
pub const S_CACO_DIE_SHATTER: state = 2552;
pub const S_CACO_DIE_SCREAM: state = 2551;
pub const S_CACO_DIE_GIB2: state = 2550;
pub const S_CACO_DIE_GIB1: state = 2549;
pub const S_CACO_DIE_FLAGS: state = 2548;
pub const S_CACO_CLOSE: state = 2547;
pub const S_CACO_SHOOT2: state = 2546;
pub const S_CACO_SHOOT1: state = 2545;
pub const S_CACO_SHOOT_SOUND: state = 2544;
pub const S_CACO_PREPARE3: state = 2543;
pub const S_CACO_PREPARE2: state = 2542;
pub const S_CACO_PREPARE1: state = 2541;
pub const S_CACO_PREPARE_SOUND: state = 2540;
pub const S_CACO_RANDOM: state = 2539;
pub const S_CACO_CHASE_REPEAT: state = 2538;
pub const S_CACO_CHASE: state = 2537;
pub const S_CACO_ROAR: state = 2536;
pub const S_CACO_WAKE4: state = 2535;
pub const S_CACO_WAKE3: state = 2534;
pub const S_CACO_WAKE2: state = 2533;
pub const S_CACO_WAKE1: state = 2532;
pub const S_CACO_LOOK: state = 2531;
pub const S_SMASHSPIKE_RISE2: state = 2530;
pub const S_SMASHSPIKE_RISE1: state = 2529;
pub const S_SMASHSPIKE_STOMP2: state = 2528;
pub const S_SMASHSPIKE_STOMP1: state = 2527;
pub const S_SMASHSPIKE_FALL: state = 2526;
pub const S_SMASHSPIKE_EASE2: state = 2525;
pub const S_SMASHSPIKE_EASE1: state = 2524;
pub const S_SMASHSPIKE_FLOAT: state = 2523;
pub const S_BUGGLEFLY: state = 2522;
pub const S_BUGGLEIDLE: state = 2521;
pub const S_BUMBLEBORE_DIE: state = 2520;
pub const S_BUMBLEBORE_STUCK2: state = 2519;
pub const S_BUMBLEBORE_STUCK1: state = 2518;
pub const S_BUMBLEBORE_FALL2: state = 2517;
pub const S_BUMBLEBORE_FALL1: state = 2516;
pub const S_BUMBLEBORE_RAISE: state = 2515;
pub const S_BUMBLEBORE_FLY2: state = 2514;
pub const S_BUMBLEBORE_FLY1: state = 2513;
pub const S_BUMBLEBORE_LOOK2: state = 2512;
pub const S_BUMBLEBORE_LOOK1: state = 2511;
pub const S_BUMBLEBORE_SPAWN: state = 2510;
pub const S_HIVEELEMENTAL_DIE3: state = 2509;
pub const S_HIVEELEMENTAL_DIE2: state = 2508;
pub const S_HIVEELEMENTAL_DIE1: state = 2507;
pub const S_HIVEELEMENTAL_PAIN: state = 2506;
pub const S_HIVEELEMENTAL_DORMANT: state = 2505;
pub const S_HIVEELEMENTAL_SHOOT2: state = 2504;
pub const S_HIVEELEMENTAL_SHOOT1: state = 2503;
pub const S_HIVEELEMENTAL_PREPARE2: state = 2502;
pub const S_HIVEELEMENTAL_PREPARE1: state = 2501;
pub const S_HIVEELEMENTAL_LOOK: state = 2500;
pub const S_POPSHOT_TRAIL: state = 2499;
pub const S_POPSHOT: state = 2498;
pub const S_POPHAT_SHOOT4: state = 2497;
pub const S_POPHAT_SHOOT3: state = 2496;
pub const S_POPHAT_SHOOT2: state = 2495;
pub const S_POPHAT_SHOOT1: state = 2494;
pub const S_POPHAT_LOOK: state = 2493;
pub const S_PENGUINATOR_SLIDE5: state = 2492;
pub const S_PENGUINATOR_SLIDE4: state = 2491;
pub const S_PENGUINATOR_SLIDE3: state = 2490;
pub const S_PENGUINATOR_SLIDE2: state = 2489;
pub const S_PENGUINATOR_SLIDE1: state = 2488;
pub const S_PENGUINATOR_WADDLE4: state = 2487;
pub const S_PENGUINATOR_WADDLE3: state = 2486;
pub const S_PENGUINATOR_WADDLE2: state = 2485;
pub const S_PENGUINATOR_WADDLE1: state = 2484;
pub const S_PENGUINATOR_LOOK: state = 2483;
pub const S_SHLEEPBOUNCE3: state = 2482;
pub const S_SHLEEPBOUNCE2: state = 2481;
pub const S_SHLEEPBOUNCE1: state = 2480;
pub const S_SHLEEP4: state = 2479;
pub const S_SHLEEP3: state = 2478;
pub const S_SHLEEP2: state = 2477;
pub const S_SHLEEP1: state = 2476;
pub const S_PIAN_SING: state = 2475;
pub const S_PIAN_FLY3: state = 2474;
pub const S_PIAN_FLY2: state = 2473;
pub const S_PIAN_FLY1: state = 2472;
pub const S_PIAN_LOOK3: state = 2471;
pub const S_PIAN_LOOK2: state = 2470;
pub const S_PIAN_LOOK1: state = 2469;
pub const S_NIGHTOPIANHELPER9: state = 2468;
pub const S_NIGHTOPIANHELPER8: state = 2467;
pub const S_NIGHTOPIANHELPER7: state = 2466;
pub const S_NIGHTOPIANHELPER6: state = 2465;
pub const S_NIGHTOPIANHELPER5: state = 2464;
pub const S_NIGHTOPIANHELPER4: state = 2463;
pub const S_NIGHTOPIANHELPER3: state = 2462;
pub const S_NIGHTOPIANHELPER2: state = 2461;
pub const S_NIGHTOPIANHELPER1: state = 2460;
pub const S_ORBIDYA5: state = 2459;
pub const S_ORBIDYA4: state = 2458;
pub const S_ORBIDYA3: state = 2457;
pub const S_ORBIDYA2: state = 2456;
pub const S_ORBIDYA1: state = 2455;
pub const S_ORBITEM8: state = 2454;
pub const S_ORBITEM7: state = 2453;
pub const S_ORBITEM6: state = 2452;
pub const S_ORBITEM5: state = 2451;
pub const S_ORBITEM4: state = 2450;
pub const S_ORBITEM3: state = 2449;
pub const S_ORBITEM2: state = 2448;
pub const S_ORBITEM1: state = 2447;
pub const S_EGGCAPSULE: state = 2446;
pub const S_NIGHTSLINKFREEZE: state = 2445;
pub const S_NIGHTSEXTRATIME: state = 2444;
pub const S_NIGHTSHELPER: state = 2443;
pub const S_NIGHTSDRILLREFILL: state = 2442;
pub const S_NIGHTSSUPERLOOP: state = 2441;
pub const S_NIGHTSCORE100_2: state = 2440;
pub const S_NIGHTSCORE90_2: state = 2439;
pub const S_NIGHTSCORE80_2: state = 2438;
pub const S_NIGHTSCORE70_2: state = 2437;
pub const S_NIGHTSCORE60_2: state = 2436;
pub const S_NIGHTSCORE50_2: state = 2435;
pub const S_NIGHTSCORE40_2: state = 2434;
pub const S_NIGHTSCORE30_2: state = 2433;
pub const S_NIGHTSCORE20_2: state = 2432;
pub const S_NIGHTSCORE10_2: state = 2431;
pub const S_NIGHTSCORE100: state = 2430;
pub const S_NIGHTSCORE90: state = 2429;
pub const S_NIGHTSCORE80: state = 2428;
pub const S_NIGHTSCORE70: state = 2427;
pub const S_NIGHTSCORE60: state = 2426;
pub const S_NIGHTSCORE50: state = 2425;
pub const S_NIGHTSCORE40: state = 2424;
pub const S_NIGHTSCORE30: state = 2423;
pub const S_NIGHTSCORE20: state = 2422;
pub const S_NIGHTSCORE10: state = 2421;
pub const S_HOOP_XMASB: state = 2420;
pub const S_HOOP_XMASA: state = 2419;
pub const S_HOOP: state = 2418;
pub const S_NIGHTSBUMPER12: state = 2417;
pub const S_NIGHTSBUMPER11: state = 2416;
pub const S_NIGHTSBUMPER10: state = 2415;
pub const S_NIGHTSBUMPER9: state = 2414;
pub const S_NIGHTSBUMPER8: state = 2413;
pub const S_NIGHTSBUMPER7: state = 2412;
pub const S_NIGHTSBUMPER6: state = 2411;
pub const S_NIGHTSBUMPER5: state = 2410;
pub const S_NIGHTSBUMPER4: state = 2409;
pub const S_NIGHTSBUMPER3: state = 2408;
pub const S_NIGHTSBUMPER2: state = 2407;
pub const S_NIGHTSBUMPER1: state = 2406;
pub const S_NIGHTSLOOPHELPER: state = 2405;
pub const S_NIGHTSPARKLESUPER4: state = 2404;
pub const S_NIGHTSPARKLESUPER3: state = 2403;
pub const S_NIGHTSPARKLESUPER2: state = 2402;
pub const S_NIGHTSPARKLESUPER1: state = 2401;
pub const S_NIGHTSPARKLE4: state = 2400;
pub const S_NIGHTSPARKLE3: state = 2399;
pub const S_NIGHTSPARKLE2: state = 2398;
pub const S_NIGHTSPARKLE1: state = 2397;
pub const S_NIGHTSDRONE_GOAL4: state = 2396;
pub const S_NIGHTSDRONE_GOAL3: state = 2395;
pub const S_NIGHTSDRONE_GOAL2: state = 2394;
pub const S_NIGHTSDRONE_GOAL1: state = 2393;
pub const S_NIGHTSDRONE_SPARKLING16: state = 2392;
pub const S_NIGHTSDRONE_SPARKLING15: state = 2391;
pub const S_NIGHTSDRONE_SPARKLING14: state = 2390;
pub const S_NIGHTSDRONE_SPARKLING13: state = 2389;
pub const S_NIGHTSDRONE_SPARKLING12: state = 2388;
pub const S_NIGHTSDRONE_SPARKLING11: state = 2387;
pub const S_NIGHTSDRONE_SPARKLING10: state = 2386;
pub const S_NIGHTSDRONE_SPARKLING9: state = 2385;
pub const S_NIGHTSDRONE_SPARKLING8: state = 2384;
pub const S_NIGHTSDRONE_SPARKLING7: state = 2383;
pub const S_NIGHTSDRONE_SPARKLING6: state = 2382;
pub const S_NIGHTSDRONE_SPARKLING5: state = 2381;
pub const S_NIGHTSDRONE_SPARKLING4: state = 2380;
pub const S_NIGHTSDRONE_SPARKLING3: state = 2379;
pub const S_NIGHTSDRONE_SPARKLING2: state = 2378;
pub const S_NIGHTSDRONE_SPARKLING1: state = 2377;
pub const S_NIGHTSDRONE_MAN2: state = 2376;
pub const S_NIGHTSDRONE_MAN1: state = 2375;
pub const S_TOAD: state = 2374;
pub const S_MARIOBUSH2: state = 2373;
pub const S_MARIOBUSH1: state = 2372;
pub const S_AXE3: state = 2371;
pub const S_AXE2: state = 2370;
pub const S_AXE1: state = 2369;
pub const S_KOOPAFLAME3: state = 2368;
pub const S_KOOPAFLAME2: state = 2367;
pub const S_KOOPAFLAME1: state = 2366;
pub const S_KOOPA2: state = 2365;
pub const S_KOOPA1: state = 2364;
pub const S_HAMMER: state = 2363;
pub const S_PUMATRAIL4: state = 2362;
pub const S_PUMATRAIL3: state = 2361;
pub const S_PUMATRAIL2: state = 2360;
pub const S_PUMATRAIL1: state = 2359;
pub const S_PUMA_DOWN3: state = 2358;
pub const S_PUMA_DOWN2: state = 2357;
pub const S_PUMA_DOWN1: state = 2356;
pub const S_PUMA_UP3: state = 2355;
pub const S_PUMA_UP2: state = 2354;
pub const S_PUMA_UP1: state = 2353;
pub const S_PUMA_START2: state = 2352;
pub const S_PUMA_START1: state = 2351;
pub const S_SHELL: state = 2350;
pub const S_FIREBALLTRAIL2: state = 2349;
pub const S_FIREBALLTRAIL1: state = 2348;
pub const S_FIREBALL: state = 2347;
pub const S_FIREFLOWER4: state = 2346;
pub const S_FIREFLOWER3: state = 2345;
pub const S_FIREFLOWER2: state = 2344;
pub const S_FIREFLOWER1: state = 2343;
pub const S_BLUEGOOMBA_DEAD: state = 2342;
pub const S_BLUEGOOMBA9: state = 2341;
pub const S_BLUEGOOMBA8: state = 2340;
pub const S_BLUEGOOMBA7: state = 2339;
pub const S_BLUEGOOMBA6: state = 2338;
pub const S_BLUEGOOMBA5: state = 2337;
pub const S_BLUEGOOMBA4: state = 2336;
pub const S_BLUEGOOMBA3: state = 2335;
pub const S_BLUEGOOMBA2: state = 2334;
pub const S_BLUEGOOMBA1B: state = 2333;
pub const S_BLUEGOOMBA1: state = 2332;
pub const S_GOOMBA_DEAD: state = 2331;
pub const S_GOOMBA9: state = 2330;
pub const S_GOOMBA8: state = 2329;
pub const S_GOOMBA7: state = 2328;
pub const S_GOOMBA6: state = 2327;
pub const S_GOOMBA5: state = 2326;
pub const S_GOOMBA4: state = 2325;
pub const S_GOOMBA3: state = 2324;
pub const S_GOOMBA2: state = 2323;
pub const S_GOOMBA1B: state = 2322;
pub const S_GOOMBA1: state = 2321;
pub const S_COINSPARKLE4: state = 2320;
pub const S_COINSPARKLE3: state = 2319;
pub const S_COINSPARKLE2: state = 2318;
pub const S_COINSPARKLE1: state = 2317;
pub const S_COIN3: state = 2316;
pub const S_COIN2: state = 2315;
pub const S_COIN1: state = 2314;
pub const S_RINGEXPLODE: state = 2313;
pub const S_THROWNSCATTER: state = 2312;
pub const S_THROWNGRENADE18: state = 2311;
pub const S_THROWNGRENADE17: state = 2310;
pub const S_THROWNGRENADE16: state = 2309;
pub const S_THROWNGRENADE15: state = 2308;
pub const S_THROWNGRENADE14: state = 2307;
pub const S_THROWNGRENADE13: state = 2306;
pub const S_THROWNGRENADE12: state = 2305;
pub const S_THROWNGRENADE11: state = 2304;
pub const S_THROWNGRENADE10: state = 2303;
pub const S_THROWNGRENADE9: state = 2302;
pub const S_THROWNGRENADE8: state = 2301;
pub const S_THROWNGRENADE7: state = 2300;
pub const S_THROWNGRENADE6: state = 2299;
pub const S_THROWNGRENADE5: state = 2298;
pub const S_THROWNGRENADE4: state = 2297;
pub const S_THROWNGRENADE3: state = 2296;
pub const S_THROWNGRENADE2: state = 2295;
pub const S_THROWNGRENADE1: state = 2294;
pub const S_THROWNEXPLOSION7: state = 2293;
pub const S_THROWNEXPLOSION6: state = 2292;
pub const S_THROWNEXPLOSION5: state = 2291;
pub const S_THROWNEXPLOSION4: state = 2290;
pub const S_THROWNEXPLOSION3: state = 2289;
pub const S_THROWNEXPLOSION2: state = 2288;
pub const S_THROWNEXPLOSION1: state = 2287;
pub const S_THROWNAUTOMATIC7: state = 2286;
pub const S_THROWNAUTOMATIC6: state = 2285;
pub const S_THROWNAUTOMATIC5: state = 2284;
pub const S_THROWNAUTOMATIC4: state = 2283;
pub const S_THROWNAUTOMATIC3: state = 2282;
pub const S_THROWNAUTOMATIC2: state = 2281;
pub const S_THROWNAUTOMATIC1: state = 2280;
pub const S_THROWNINFINITY7: state = 2279;
pub const S_THROWNINFINITY6: state = 2278;
pub const S_THROWNINFINITY5: state = 2277;
pub const S_THROWNINFINITY4: state = 2276;
pub const S_THROWNINFINITY3: state = 2275;
pub const S_THROWNINFINITY2: state = 2274;
pub const S_THROWNINFINITY1: state = 2273;
pub const S_THROWNBOUNCE7: state = 2272;
pub const S_THROWNBOUNCE6: state = 2271;
pub const S_THROWNBOUNCE5: state = 2270;
pub const S_THROWNBOUNCE4: state = 2269;
pub const S_THROWNBOUNCE3: state = 2268;
pub const S_THROWNBOUNCE2: state = 2267;
pub const S_THROWNBOUNCE1: state = 2266;
pub const S_GRENADEPICKUPFADE8: state = 2265;
pub const S_GRENADEPICKUPFADE7: state = 2264;
pub const S_GRENADEPICKUPFADE6: state = 2263;
pub const S_GRENADEPICKUPFADE5: state = 2262;
pub const S_GRENADEPICKUPFADE4: state = 2261;
pub const S_GRENADEPICKUPFADE3: state = 2260;
pub const S_GRENADEPICKUPFADE2: state = 2259;
pub const S_GRENADEPICKUPFADE1: state = 2258;
pub const S_GRENADEPICKUP: state = 2257;
pub const S_SCATTERPICKUPFADE8: state = 2256;
pub const S_SCATTERPICKUPFADE7: state = 2255;
pub const S_SCATTERPICKUPFADE6: state = 2254;
pub const S_SCATTERPICKUPFADE5: state = 2253;
pub const S_SCATTERPICKUPFADE4: state = 2252;
pub const S_SCATTERPICKUPFADE3: state = 2251;
pub const S_SCATTERPICKUPFADE2: state = 2250;
pub const S_SCATTERPICKUPFADE1: state = 2249;
pub const S_SCATTERPICKUP: state = 2248;
pub const S_EXPLODEPICKUPFADE8: state = 2247;
pub const S_EXPLODEPICKUPFADE7: state = 2246;
pub const S_EXPLODEPICKUPFADE6: state = 2245;
pub const S_EXPLODEPICKUPFADE5: state = 2244;
pub const S_EXPLODEPICKUPFADE4: state = 2243;
pub const S_EXPLODEPICKUPFADE3: state = 2242;
pub const S_EXPLODEPICKUPFADE2: state = 2241;
pub const S_EXPLODEPICKUPFADE1: state = 2240;
pub const S_EXPLODEPICKUP: state = 2239;
pub const S_AUTOPICKUPFADE8: state = 2238;
pub const S_AUTOPICKUPFADE7: state = 2237;
pub const S_AUTOPICKUPFADE6: state = 2236;
pub const S_AUTOPICKUPFADE5: state = 2235;
pub const S_AUTOPICKUPFADE4: state = 2234;
pub const S_AUTOPICKUPFADE3: state = 2233;
pub const S_AUTOPICKUPFADE2: state = 2232;
pub const S_AUTOPICKUPFADE1: state = 2231;
pub const S_AUTOPICKUP: state = 2230;
pub const S_RAILPICKUPFADE8: state = 2229;
pub const S_RAILPICKUPFADE7: state = 2228;
pub const S_RAILPICKUPFADE6: state = 2227;
pub const S_RAILPICKUPFADE5: state = 2226;
pub const S_RAILPICKUPFADE4: state = 2225;
pub const S_RAILPICKUPFADE3: state = 2224;
pub const S_RAILPICKUPFADE2: state = 2223;
pub const S_RAILPICKUPFADE1: state = 2222;
pub const S_RAILPICKUP: state = 2221;
pub const S_BOUNCEPICKUPFADE8: state = 2220;
pub const S_BOUNCEPICKUPFADE7: state = 2219;
pub const S_BOUNCEPICKUPFADE6: state = 2218;
pub const S_BOUNCEPICKUPFADE5: state = 2217;
pub const S_BOUNCEPICKUPFADE4: state = 2216;
pub const S_BOUNCEPICKUPFADE3: state = 2215;
pub const S_BOUNCEPICKUPFADE2: state = 2214;
pub const S_BOUNCEPICKUPFADE1: state = 2213;
pub const S_BOUNCEPICKUP: state = 2212;
pub const S_GRENADERINGAMMO: state = 2211;
pub const S_SCATTERRINGAMMO: state = 2210;
pub const S_EXPLOSIONRINGAMMO: state = 2209;
pub const S_AUTOMATICRINGAMMO: state = 2208;
pub const S_INFINITYRINGAMMO: state = 2207;
pub const S_RAILRINGAMMO: state = 2206;
pub const S_BOUNCERINGAMMO: state = 2205;
pub const S_RRNG7: state = 2204;
pub const S_RRNG6: state = 2203;
pub const S_RRNG5: state = 2202;
pub const S_RRNG4: state = 2201;
pub const S_RRNG3: state = 2200;
pub const S_RRNG2: state = 2199;
pub const S_RRNG1: state = 2198;
pub const S_LHRT: state = 2197;
pub const S_CORK: state = 2196;
pub const S_FINISHFLAG: state = 2195;
pub const S_GOTFLAG: state = 2194;
pub const S_TTAG: state = 2193;
pub const S_LOCKONINF4: state = 2192;
pub const S_LOCKONINF3: state = 2191;
pub const S_LOCKONINF2: state = 2190;
pub const S_LOCKONINF1: state = 2189;
pub const S_LOCKON4: state = 2188;
pub const S_LOCKON3: state = 2187;
pub const S_LOCKON2: state = 2186;
pub const S_LOCKON1: state = 2185;
pub const S_FLIGHTINDICATOR: state = 2184;
pub const S_FIVE2: state = 2183;
pub const S_FOUR2: state = 2182;
pub const S_THREE2: state = 2181;
pub const S_TWO2: state = 2180;
pub const S_ONE2: state = 2179;
pub const S_ZERO2: state = 2178;
pub const S_FIVE1: state = 2177;
pub const S_FOUR1: state = 2176;
pub const S_THREE1: state = 2175;
pub const S_TWO1: state = 2174;
pub const S_ONE1: state = 2173;
pub const S_ZERO1: state = 2172;
pub const S_SCRL: state = 2171;
pub const S_SCRK: state = 2170;
pub const S_SCRJ: state = 2169;
pub const S_SCRI: state = 2168;
pub const S_SCRH: state = 2167;
pub const S_SCRG: state = 2166;
pub const S_SCRF: state = 2165;
pub const S_SCRE: state = 2164;
pub const S_SCRD: state = 2163;
pub const S_SCRC: state = 2162;
pub const S_SCRB: state = 2161;
pub const S_SCRA: state = 2160;
pub const S_PARTICLE: state = 2159;
pub const S_SEED: state = 2158;
pub const S_FOG14: state = 2157;
pub const S_FOG13: state = 2156;
pub const S_FOG12: state = 2155;
pub const S_FOG11: state = 2154;
pub const S_FOG10: state = 2153;
pub const S_FOG9: state = 2152;
pub const S_FOG8: state = 2151;
pub const S_FOG7: state = 2150;
pub const S_FOG6: state = 2149;
pub const S_FOG5: state = 2148;
pub const S_FOG4: state = 2147;
pub const S_FOG3: state = 2146;
pub const S_FOG2: state = 2145;
pub const S_FOG1: state = 2144;
pub const S_SPINDUST_FIRE4: state = 2143;
pub const S_SPINDUST_FIRE3: state = 2142;
pub const S_SPINDUST_FIRE2: state = 2141;
pub const S_SPINDUST_FIRE1: state = 2140;
pub const S_SPINDUST_BUBBLE4: state = 2139;
pub const S_SPINDUST_BUBBLE3: state = 2138;
pub const S_SPINDUST_BUBBLE2: state = 2137;
pub const S_SPINDUST_BUBBLE1: state = 2136;
pub const S_SPINDUST4: state = 2135;
pub const S_SPINDUST3: state = 2134;
pub const S_SPINDUST2: state = 2133;
pub const S_SPINDUST1: state = 2132;
pub const S_WATERZAP: state = 2131;
pub const S_POP1: state = 2130;
pub const S_EXTRALARGEBUBBLE: state = 2129;
pub const S_LARGEBUBBLE2: state = 2128;
pub const S_LARGEBUBBLE1: state = 2127;
pub const S_MEDIUMBUBBLE: state = 2126;
pub const S_SMALLBUBBLE: state = 2125;
pub const S_SMOKE5: state = 2124;
pub const S_SMOKE4: state = 2123;
pub const S_SMOKE3: state = 2122;
pub const S_SMOKE2: state = 2121;
pub const S_SMOKE1: state = 2120;
pub const S_SPLASH3: state = 2119;
pub const S_SPLASH2: state = 2118;
pub const S_SPLASH1: state = 2117;
pub const S_LAVASPLISH: state = 2116;
pub const S_SPLISH9: state = 2115;
pub const S_SPLISH8: state = 2114;
pub const S_SPLISH7: state = 2113;
pub const S_SPLISH6: state = 2112;
pub const S_SPLISH5: state = 2111;
pub const S_SPLISH4: state = 2110;
pub const S_SPLISH3: state = 2109;
pub const S_SPLISH2: state = 2108;
pub const S_SPLISH1: state = 2107;
pub const S_SNOW3: state = 2106;
pub const S_SNOW2: state = 2105;
pub const S_SNOW1: state = 2104;
pub const S_RAINRETURN: state = 2103;
pub const S_RAIN1: state = 2102;
pub const S_REDBOOSTERSEG_FACE: state = 2101;
pub const S_REDBOOSTERSEG_RIGHT: state = 2100;
pub const S_REDBOOSTERSEG_LEFT: state = 2099;
pub const S_REDBOOSTERROLLER: state = 2098;
pub const S_YELLOWBOOSTERSEG_FACE: state = 2097;
pub const S_YELLOWBOOSTERSEG_RIGHT: state = 2096;
pub const S_YELLOWBOOSTERSEG_LEFT: state = 2095;
pub const S_YELLOWBOOSTERROLLER: state = 2094;
pub const S_BOOSTERSOUND: state = 2093;
pub const S_BHORIZ8: state = 2092;
pub const S_BHORIZ7: state = 2091;
pub const S_BHORIZ6: state = 2090;
pub const S_BHORIZ5: state = 2089;
pub const S_BHORIZ4: state = 2088;
pub const S_BHORIZ3: state = 2087;
pub const S_BHORIZ2: state = 2086;
pub const S_BHORIZ1: state = 2085;
pub const S_RHORIZ8: state = 2084;
pub const S_RHORIZ7: state = 2083;
pub const S_RHORIZ6: state = 2082;
pub const S_RHORIZ5: state = 2081;
pub const S_RHORIZ4: state = 2080;
pub const S_RHORIZ3: state = 2079;
pub const S_RHORIZ2: state = 2078;
pub const S_RHORIZ1: state = 2077;
pub const S_YHORIZ8: state = 2076;
pub const S_YHORIZ7: state = 2075;
pub const S_YHORIZ6: state = 2074;
pub const S_YHORIZ5: state = 2073;
pub const S_YHORIZ4: state = 2072;
pub const S_YHORIZ3: state = 2071;
pub const S_YHORIZ2: state = 2070;
pub const S_YHORIZ1: state = 2069;
pub const S_BDIAG8: state = 2068;
pub const S_BDIAG7: state = 2067;
pub const S_BDIAG6: state = 2066;
pub const S_BDIAG5: state = 2065;
pub const S_BDIAG4: state = 2064;
pub const S_BDIAG3: state = 2063;
pub const S_BDIAG2: state = 2062;
pub const S_BDIAG1: state = 2061;
pub const S_RDIAG8: state = 2060;
pub const S_RDIAG7: state = 2059;
pub const S_RDIAG6: state = 2058;
pub const S_RDIAG5: state = 2057;
pub const S_RDIAG4: state = 2056;
pub const S_RDIAG3: state = 2055;
pub const S_RDIAG2: state = 2054;
pub const S_RDIAG1: state = 2053;
pub const S_YDIAG8: state = 2052;
pub const S_YDIAG7: state = 2051;
pub const S_YDIAG6: state = 2050;
pub const S_YDIAG5: state = 2049;
pub const S_YDIAG4: state = 2048;
pub const S_YDIAG3: state = 2047;
pub const S_YDIAG2: state = 2046;
pub const S_YDIAG1: state = 2045;
pub const S_BLUESPRING5: state = 2044;
pub const S_BLUESPRING4: state = 2043;
pub const S_BLUESPRING3: state = 2042;
pub const S_BLUESPRING2: state = 2041;
pub const S_BLUESPRING: state = 2040;
pub const S_REDSPRING5: state = 2039;
pub const S_REDSPRING4: state = 2038;
pub const S_REDSPRING3: state = 2037;
pub const S_REDSPRING2: state = 2036;
pub const S_REDSPRING: state = 2035;
pub const S_YELLOWSPRING5: state = 2034;
pub const S_YELLOWSPRING4: state = 2033;
pub const S_YELLOWSPRING3: state = 2032;
pub const S_YELLOWSPRING2: state = 2031;
pub const S_YELLOWSPRING: state = 2030;
pub const S_BALLOONPOP6: state = 2029;
pub const S_BALLOONPOP5: state = 2028;
pub const S_BALLOONPOP4: state = 2027;
pub const S_BALLOONPOP3: state = 2026;
pub const S_BALLOONPOP2: state = 2025;
pub const S_BALLOONPOP1: state = 2024;
pub const S_BALLOON: state = 2023;
pub const S_BUMPERHIT: state = 2022;
pub const S_BUMPER: state = 2021;
pub const S_STEAM8: state = 2020;
pub const S_STEAM7: state = 2019;
pub const S_STEAM6: state = 2018;
pub const S_STEAM5: state = 2017;
pub const S_STEAM4: state = 2016;
pub const S_STEAM3: state = 2015;
pub const S_STEAM2: state = 2014;
pub const S_STEAM1: state = 2013;
pub const S_FAN5: state = 2012;
pub const S_FAN4: state = 2011;
pub const S_FAN3: state = 2010;
pub const S_FAN2: state = 2009;
pub const S_FAN: state = 2008;
pub const S_SECRETFLICKY_02_CENTER: state = 2007;
pub const S_SECRETFLICKY_02_STAND: state = 2006;
pub const S_SECRETFLICKY_02_FLAP3: state = 2005;
pub const S_SECRETFLICKY_02_FLAP2: state = 2004;
pub const S_SECRETFLICKY_02_FLAP1: state = 2003;
pub const S_SECRETFLICKY_02_OUT: state = 2002;
pub const S_SECRETFLICKY_01_CENTER: state = 2001;
pub const S_SECRETFLICKY_01_STAND: state = 2000;
pub const S_SECRETFLICKY_01_DOWN: state = 1999;
pub const S_SECRETFLICKY_01_UP: state = 1998;
pub const S_SECRETFLICKY_01_HOP: state = 1997;
pub const S_SECRETFLICKY_01_AIM: state = 1996;
pub const S_SECRETFLICKY_01_OUT: state = 1995;
pub const S_FLICKY_16_CENTER: state = 1994;
pub const S_FLICKY_16_STAND: state = 1993;
pub const S_FLICKY_16_FLAP3: state = 1992;
pub const S_FLICKY_16_FLAP2: state = 1991;
pub const S_FLICKY_16_FLAP1: state = 1990;
pub const S_FLICKY_16_OUT: state = 1989;
pub const S_FLICKY_15_CENTER: state = 1988;
pub const S_FLICKY_15_STAND: state = 1987;
pub const S_FLICKY_15_DOWN: state = 1986;
pub const S_FLICKY_15_UP: state = 1985;
pub const S_FLICKY_15_HOP: state = 1984;
pub const S_FLICKY_15_AIM: state = 1983;
pub const S_FLICKY_15_OUT: state = 1982;
pub const S_FLICKY_14_CENTER: state = 1981;
pub const S_FLICKY_14_STAND: state = 1980;
pub const S_FLICKY_14_FLAP3: state = 1979;
pub const S_FLICKY_14_FLAP2: state = 1978;
pub const S_FLICKY_14_FLAP1: state = 1977;
pub const S_FLICKY_14_OUT: state = 1976;
pub const S_FLICKY_13_CENTER: state = 1975;
pub const S_FLICKY_13_STAND: state = 1974;
pub const S_FLICKY_13_DOWN: state = 1973;
pub const S_FLICKY_13_UP: state = 1972;
pub const S_FLICKY_13_HOP: state = 1971;
pub const S_FLICKY_13_AIM: state = 1970;
pub const S_FLICKY_13_OUT: state = 1969;
pub const S_FLICKY_12_CENTER: state = 1968;
pub const S_FLICKY_12_STAND: state = 1967;
pub const S_FLICKY_12_RUN3: state = 1966;
pub const S_FLICKY_12_RUN2: state = 1965;
pub const S_FLICKY_12_RUN1: state = 1964;
pub const S_FLICKY_12_AIM: state = 1963;
pub const S_FLICKY_12_OUT: state = 1962;
pub const S_FLICKY_11_CENTER: state = 1961;
pub const S_FLICKY_11_STAND: state = 1960;
pub const S_FLICKY_11_RUN3: state = 1959;
pub const S_FLICKY_11_RUN2: state = 1958;
pub const S_FLICKY_11_RUN1: state = 1957;
pub const S_FLICKY_11_AIM: state = 1956;
pub const S_FLICKY_11_OUT: state = 1955;
pub const S_FLICKY_10_CENTER: state = 1954;
pub const S_FLICKY_10_STAND: state = 1953;
pub const S_FLICKY_10_FLAP2: state = 1952;
pub const S_FLICKY_10_FLAP1: state = 1951;
pub const S_FLICKY_10_OUT: state = 1950;
pub const S_FLICKY_09_CENTER: state = 1949;
pub const S_FLICKY_09_STAND: state = 1948;
pub const S_FLICKY_09_DOWN: state = 1947;
pub const S_FLICKY_09_UP: state = 1946;
pub const S_FLICKY_09_HOP: state = 1945;
pub const S_FLICKY_09_AIM: state = 1944;
pub const S_FLICKY_09_OUT: state = 1943;
pub const S_FLICKY_08_CENTER: state = 1942;
pub const S_FLICKY_08_STAND: state = 1941;
pub const S_FLICKY_08_SWIM4: state = 1940;
pub const S_FLICKY_08_SWIM3: state = 1939;
pub const S_FLICKY_08_SWIM2: state = 1938;
pub const S_FLICKY_08_SWIM1: state = 1937;
pub const S_FLICKY_08_FLAP4: state = 1936;
pub const S_FLICKY_08_FLAP3: state = 1935;
pub const S_FLICKY_08_FLAP2: state = 1934;
pub const S_FLICKY_08_FLAP1: state = 1933;
pub const S_FLICKY_08_HOP: state = 1932;
pub const S_FLICKY_08_AIM: state = 1931;
pub const S_FLICKY_08_OUT: state = 1930;
pub const S_FLICKY_07_CENTER: state = 1929;
pub const S_FLICKY_07_STAND: state = 1928;
pub const S_FLICKY_07_SWIM3: state = 1927;
pub const S_FLICKY_07_SWIM2: state = 1926;
pub const S_FLICKY_07_SWIM1: state = 1925;
pub const S_FLICKY_07_DOWNR: state = 1924;
pub const S_FLICKY_07_UPR: state = 1923;
pub const S_FLICKY_07_HOPR: state = 1922;
pub const S_FLICKY_07_AIMR: state = 1921;
pub const S_FLICKY_07_DOWNL: state = 1920;
pub const S_FLICKY_07_UPL: state = 1919;
pub const S_FLICKY_07_HOPL: state = 1918;
pub const S_FLICKY_07_AIML: state = 1917;
pub const S_FLICKY_07_OUT: state = 1916;
pub const S_FLICKY_06_CENTER: state = 1915;
pub const S_FLICKY_06_STAND: state = 1914;
pub const S_FLICKY_06_DOWN: state = 1913;
pub const S_FLICKY_06_UP: state = 1912;
pub const S_FLICKY_06_HOP: state = 1911;
pub const S_FLICKY_06_AIM: state = 1910;
pub const S_FLICKY_06_OUT: state = 1909;
pub const S_FLICKY_05_CENTER: state = 1908;
pub const S_FLICKY_05_STAND: state = 1907;
pub const S_FLICKY_05_DOWN: state = 1906;
pub const S_FLICKY_05_UP: state = 1905;
pub const S_FLICKY_05_HOP: state = 1904;
pub const S_FLICKY_05_AIM: state = 1903;
pub const S_FLICKY_05_OUT: state = 1902;
pub const S_FLICKY_04_CENTER: state = 1901;
pub const S_FLICKY_04_STAND: state = 1900;
pub const S_FLICKY_04_SWIM4: state = 1899;
pub const S_FLICKY_04_SWIM3: state = 1898;
pub const S_FLICKY_04_SWIM2: state = 1897;
pub const S_FLICKY_04_SWIM1: state = 1896;
pub const S_FLICKY_04_DOWN: state = 1895;
pub const S_FLICKY_04_UP: state = 1894;
pub const S_FLICKY_04_HOP: state = 1893;
pub const S_FLICKY_04_AIM: state = 1892;
pub const S_FLICKY_04_OUT: state = 1891;
pub const S_FLICKY_03_CENTER: state = 1890;
pub const S_FLICKY_03_STAND: state = 1889;
pub const S_FLICKY_03_FLAP2: state = 1888;
pub const S_FLICKY_03_FLAP1: state = 1887;
pub const S_FLICKY_03_UP: state = 1886;
pub const S_FLICKY_03_HOP: state = 1885;
pub const S_FLICKY_03_AIM: state = 1884;
pub const S_FLICKY_03_OUT: state = 1883;
pub const S_FLICKY_02_CENTER: state = 1882;
pub const S_FLICKY_02_STAND: state = 1881;
pub const S_FLICKY_02_DOWN: state = 1880;
pub const S_FLICKY_02_UP: state = 1879;
pub const S_FLICKY_02_HOP: state = 1878;
pub const S_FLICKY_02_AIM: state = 1877;
pub const S_FLICKY_02_OUT: state = 1876;
pub const S_FLICKY_01_CENTER: state = 1875;
pub const S_FLICKY_01_STAND: state = 1874;
pub const S_FLICKY_01_FLAP3: state = 1873;
pub const S_FLICKY_01_FLAP2: state = 1872;
pub const S_FLICKY_01_FLAP1: state = 1871;
pub const S_FLICKY_01_OUT: state = 1870;
pub const S_FLICKY_BUBBLE: state = 1869;
pub const S_SSPK5: state = 1868;
pub const S_SSPK4: state = 1867;
pub const S_SSPK3: state = 1866;
pub const S_SSPK2: state = 1865;
pub const S_SSPK1: state = 1864;
pub const S_IVSP: state = 1863;
pub const S_THUNDERCOIN_SPARK: state = 1862;
pub const S_ZAPSB11: state = 1861;
pub const S_ZAPSB10: state = 1860;
pub const S_ZAPSB9: state = 1859;
pub const S_ZAPSB8: state = 1858;
pub const S_ZAPSB7: state = 1857;
pub const S_ZAPSB6: state = 1856;
pub const S_ZAPSB5: state = 1855;
pub const S_ZAPSB4: state = 1854;
pub const S_ZAPSB3: state = 1853;
pub const S_ZAPSB2: state = 1852;
pub const S_ZAPSB1: state = 1851;
pub const S_ZAPS16: state = 1850;
pub const S_ZAPS15: state = 1849;
pub const S_ZAPS14: state = 1848;
pub const S_ZAPS13: state = 1847;
pub const S_ZAPS12: state = 1846;
pub const S_ZAPS11: state = 1845;
pub const S_ZAPS10: state = 1844;
pub const S_ZAPS9: state = 1843;
pub const S_ZAPS8: state = 1842;
pub const S_ZAPS7: state = 1841;
pub const S_ZAPS6: state = 1840;
pub const S_ZAPS5: state = 1839;
pub const S_ZAPS4: state = 1838;
pub const S_ZAPS3: state = 1837;
pub const S_ZAPS2: state = 1836;
pub const S_ZAPS1: state = 1835;
pub const S_BUBSB6: state = 1834;
pub const S_BUBSB5: state = 1833;
pub const S_BUBSB4: state = 1832;
pub const S_BUBSB3: state = 1831;
pub const S_BUBSB2: state = 1830;
pub const S_BUBSB1: state = 1829;
pub const S_BUBS11: state = 1828;
pub const S_BUBS10: state = 1827;
pub const S_BUBS9: state = 1826;
pub const S_BUBS8: state = 1825;
pub const S_BUBS7: state = 1824;
pub const S_BUBS6: state = 1823;
pub const S_BUBS5: state = 1822;
pub const S_BUBS4: state = 1821;
pub const S_BUBS3: state = 1820;
pub const S_BUBS2: state = 1819;
pub const S_BUBS1: state = 1818;
pub const S_FIRSB10: state = 1817;
pub const S_FIRSB9: state = 1816;
pub const S_FIRSB8: state = 1815;
pub const S_FIRSB7: state = 1814;
pub const S_FIRSB6: state = 1813;
pub const S_FIRSB5: state = 1812;
pub const S_FIRSB4: state = 1811;
pub const S_FIRSB3: state = 1810;
pub const S_FIRSB2: state = 1809;
pub const S_FIRSB1: state = 1808;
pub const S_FIRS11: state = 1807;
pub const S_FIRS10: state = 1806;
pub const S_FIRS9: state = 1805;
pub const S_FIRS8: state = 1804;
pub const S_FIRS7: state = 1803;
pub const S_FIRS6: state = 1802;
pub const S_FIRS5: state = 1801;
pub const S_FIRS4: state = 1800;
pub const S_FIRS3: state = 1799;
pub const S_FIRS2: state = 1798;
pub const S_FIRS1: state = 1797;
pub const S_PITY12: state = 1796;
pub const S_PITY11: state = 1795;
pub const S_PITY10: state = 1794;
pub const S_PITY9: state = 1793;
pub const S_PITY8: state = 1792;
pub const S_PITY7: state = 1791;
pub const S_PITY6: state = 1790;
pub const S_PITY5: state = 1789;
pub const S_PITY4: state = 1788;
pub const S_PITY3: state = 1787;
pub const S_PITY2: state = 1786;
pub const S_PITY1: state = 1785;
pub const S_ELEMF10: state = 1784;
pub const S_ELEMF9: state = 1783;
pub const S_ELEMF8: state = 1782;
pub const S_ELEMF7: state = 1781;
pub const S_ELEMF6: state = 1780;
pub const S_ELEMF5: state = 1779;
pub const S_ELEMF4: state = 1778;
pub const S_ELEMF3: state = 1777;
pub const S_ELEMF2: state = 1776;
pub const S_ELEMF1: state = 1775;
pub const S_ELEM14: state = 1774;
pub const S_ELEM13: state = 1773;
pub const S_ELEM12: state = 1772;
pub const S_ELEM11: state = 1771;
pub const S_ELEM10: state = 1770;
pub const S_ELEM9: state = 1769;
pub const S_ELEM8: state = 1768;
pub const S_ELEM7: state = 1767;
pub const S_ELEM6: state = 1766;
pub const S_ELEM5: state = 1765;
pub const S_ELEM4: state = 1764;
pub const S_ELEM3: state = 1763;
pub const S_ELEM2: state = 1762;
pub const S_ELEM1: state = 1761;
pub const S_FORC21: state = 1760;
pub const S_FORC20: state = 1759;
pub const S_FORC19: state = 1758;
pub const S_FORC18: state = 1757;
pub const S_FORC17: state = 1756;
pub const S_FORC16: state = 1755;
pub const S_FORC15: state = 1754;
pub const S_FORC14: state = 1753;
pub const S_FORC13: state = 1752;
pub const S_FORC12: state = 1751;
pub const S_FORC11: state = 1750;
pub const S_FORC10: state = 1749;
pub const S_FORC9: state = 1748;
pub const S_FORC8: state = 1747;
pub const S_FORC7: state = 1746;
pub const S_FORC6: state = 1745;
pub const S_FORC5: state = 1744;
pub const S_FORC4: state = 1743;
pub const S_FORC3: state = 1742;
pub const S_FORC2: state = 1741;
pub const S_FORC1: state = 1740;
pub const S_MAGN13: state = 1739;
pub const S_MAGN12: state = 1738;
pub const S_MAGN11: state = 1737;
pub const S_MAGN10: state = 1736;
pub const S_MAGN9: state = 1735;
pub const S_MAGN8: state = 1734;
pub const S_MAGN7: state = 1733;
pub const S_MAGN6: state = 1732;
pub const S_MAGN5: state = 1731;
pub const S_MAGN4: state = 1730;
pub const S_MAGN3: state = 1729;
pub const S_MAGN2: state = 1728;
pub const S_MAGN1: state = 1727;
pub const S_WIND8: state = 1726;
pub const S_WIND7: state = 1725;
pub const S_WIND6: state = 1724;
pub const S_WIND5: state = 1723;
pub const S_WIND4: state = 1722;
pub const S_WIND3: state = 1721;
pub const S_WIND2: state = 1720;
pub const S_WIND1: state = 1719;
pub const S_ARMB32: state = 1718;
pub const S_ARMB31: state = 1717;
pub const S_ARMB30: state = 1716;
pub const S_ARMB29: state = 1715;
pub const S_ARMB28: state = 1714;
pub const S_ARMB27: state = 1713;
pub const S_ARMB26: state = 1712;
pub const S_ARMB25: state = 1711;
pub const S_ARMB24: state = 1710;
pub const S_ARMB23: state = 1709;
pub const S_ARMB22: state = 1708;
pub const S_ARMB21: state = 1707;
pub const S_ARMB20: state = 1706;
pub const S_ARMB19: state = 1705;
pub const S_ARMB18: state = 1704;
pub const S_ARMB17: state = 1703;
pub const S_ARMB16: state = 1702;
pub const S_ARMB15: state = 1701;
pub const S_ARMB14: state = 1700;
pub const S_ARMB13: state = 1699;
pub const S_ARMB12: state = 1698;
pub const S_ARMB11: state = 1697;
pub const S_ARMB10: state = 1696;
pub const S_ARMB9: state = 1695;
pub const S_ARMB8: state = 1694;
pub const S_ARMB7: state = 1693;
pub const S_ARMB6: state = 1692;
pub const S_ARMB5: state = 1691;
pub const S_ARMB4: state = 1690;
pub const S_ARMB3: state = 1689;
pub const S_ARMB2: state = 1688;
pub const S_ARMB1: state = 1687;
pub const S_ARMF32: state = 1686;
pub const S_ARMF31: state = 1685;
pub const S_ARMF30: state = 1684;
pub const S_ARMF29: state = 1683;
pub const S_ARMF28: state = 1682;
pub const S_ARMF27: state = 1681;
pub const S_ARMF26: state = 1680;
pub const S_ARMF25: state = 1679;
pub const S_ARMF24: state = 1678;
pub const S_ARMF23: state = 1677;
pub const S_ARMF22: state = 1676;
pub const S_ARMF21: state = 1675;
pub const S_ARMF20: state = 1674;
pub const S_ARMF19: state = 1673;
pub const S_ARMF18: state = 1672;
pub const S_ARMF17: state = 1671;
pub const S_ARMF16: state = 1670;
pub const S_ARMF15: state = 1669;
pub const S_ARMF14: state = 1668;
pub const S_ARMF13: state = 1667;
pub const S_ARMF12: state = 1666;
pub const S_ARMF11: state = 1665;
pub const S_ARMF10: state = 1664;
pub const S_ARMF9: state = 1663;
pub const S_ARMF8: state = 1662;
pub const S_ARMF7: state = 1661;
pub const S_ARMF6: state = 1660;
pub const S_ARMF5: state = 1659;
pub const S_ARMF4: state = 1658;
pub const S_ARMF3: state = 1657;
pub const S_ARMF2: state = 1656;
pub const S_ARMF1: state = 1655;
pub const S_ARMA16: state = 1654;
pub const S_ARMA15: state = 1653;
pub const S_ARMA14: state = 1652;
pub const S_ARMA13: state = 1651;
pub const S_ARMA12: state = 1650;
pub const S_ARMA11: state = 1649;
pub const S_ARMA10: state = 1648;
pub const S_ARMA9: state = 1647;
pub const S_ARMA8: state = 1646;
pub const S_ARMA7: state = 1645;
pub const S_ARMA6: state = 1644;
pub const S_ARMA5: state = 1643;
pub const S_ARMA4: state = 1642;
pub const S_ARMA3: state = 1641;
pub const S_ARMA2: state = 1640;
pub const S_ARMA1: state = 1639;
pub const S_EGGSTATUE2: state = 1638;
pub const S_DBALL6: state = 1637;
pub const S_DBALL5: state = 1636;
pub const S_DBALL4: state = 1635;
pub const S_DBALL3: state = 1634;
pub const S_DBALL2: state = 1633;
pub const S_DBALL1: state = 1632;
pub const S_PALMTREE_TOP: state = 1631;
pub const S_PALMTREE_TRUNK: state = 1630;
pub const S_BIG_PALMTREE_TOP: state = 1629;
pub const S_BIG_PALMTREE_TRUNK: state = 1628;
pub const S_BSZCLOVER: state = 1627;
pub const S_BSZSHRUB: state = 1626;
pub const S_BSZVINE_ORANGE: state = 1625;
pub const S_BSZVINE_YELLOW: state = 1624;
pub const S_BSZVINE_CYAN: state = 1623;
pub const S_BSZVINE_BLUE: state = 1622;
pub const S_BSZVINE_PURPLE: state = 1621;
pub const S_BSZVINE_RED: state = 1620;
pub const S_BSZBUSH_ORANGE: state = 1619;
pub const S_BSZBUSH_YELLOW: state = 1618;
pub const S_BSZBUSH_CYAN: state = 1617;
pub const S_BSZBUSH_BLUE: state = 1616;
pub const S_BSZBUSH_PURPLE: state = 1615;
pub const S_BSZBUSH_RED: state = 1614;
pub const S_BSZCLUSTER_ORANGE: state = 1613;
pub const S_BSZCLUSTER_YELLOW: state = 1612;
pub const S_BSZCLUSTER_CYAN: state = 1611;
pub const S_BSZCLUSTER_BLUE: state = 1610;
pub const S_BSZCLUSTER_PURPLE: state = 1609;
pub const S_BSZCLUSTER_RED: state = 1608;
pub const S_BSZTULIP_ORANGE: state = 1607;
pub const S_BSZTULIP_YELLOW: state = 1606;
pub const S_BSZTULIP_CYAN: state = 1605;
pub const S_BSZTULIP_BLUE: state = 1604;
pub const S_BSZTULIP_PURPLE: state = 1603;
pub const S_BSZTULIP_RED: state = 1602;
pub const S_BSZSHORTFLOWER_ORANGE: state = 1601;
pub const S_BSZSHORTFLOWER_YELLOW: state = 1600;
pub const S_BSZSHORTFLOWER_CYAN: state = 1599;
pub const S_BSZSHORTFLOWER_BLUE: state = 1598;
pub const S_BSZSHORTFLOWER_PURPLE: state = 1597;
pub const S_BSZSHORTFLOWER_RED: state = 1596;
pub const S_BSZFLOWER_ORANGE: state = 1595;
pub const S_BSZFLOWER_YELLOW: state = 1594;
pub const S_BSZFLOWER_CYAN: state = 1593;
pub const S_BSZFLOWER_BLUE: state = 1592;
pub const S_BSZFLOWER_PURPLE: state = 1591;
pub const S_BSZFLOWER_RED: state = 1590;
pub const S_BSZTALLFLOWER_ORANGE: state = 1589;
pub const S_BSZTALLFLOWER_YELLOW: state = 1588;
pub const S_BSZTALLFLOWER_CYAN: state = 1587;
pub const S_BSZTALLFLOWER_BLUE: state = 1586;
pub const S_BSZTALLFLOWER_PURPLE: state = 1585;
pub const S_BSZTALLFLOWER_RED: state = 1584;
pub const S_HHZSTALAGMITE_SHORT: state = 1583;
pub const S_HHZSTALAGMITE_TALL: state = 1582;
pub const S_HHZTENT2: state = 1581;
pub const S_HHZTENT1: state = 1580;
pub const S_HHZGRASS: state = 1579;
pub const S_HHZSHROOM_16: state = 1578;
pub const S_HHZSHROOM_15: state = 1577;
pub const S_HHZSHROOM_14: state = 1576;
pub const S_HHZSHROOM_13: state = 1575;
pub const S_HHZSHROOM_12: state = 1574;
pub const S_HHZSHROOM_11: state = 1573;
pub const S_HHZSHROOM_10: state = 1572;
pub const S_HHZSHROOM_9: state = 1571;
pub const S_HHZSHROOM_8: state = 1570;
pub const S_HHZSHROOM_7: state = 1569;
pub const S_HHZSHROOM_6: state = 1568;
pub const S_HHZSHROOM_5: state = 1567;
pub const S_HHZSHROOM_4: state = 1566;
pub const S_HHZSHROOM_3: state = 1565;
pub const S_HHZSHROOM_2: state = 1564;
pub const S_HHZSHROOM_1: state = 1563;
pub const S_HHZTREE_LEAF: state = 1562;
pub const S_HHZTREE_TRUNK: state = 1561;
pub const S_HHZTREE_TOP: state = 1560;
pub const S_JACKO3OVERLAY_4: state = 1559;
pub const S_JACKO3OVERLAY_3: state = 1558;
pub const S_JACKO3OVERLAY_2: state = 1557;
pub const S_JACKO3OVERLAY_1: state = 1556;
pub const S_JACKO3: state = 1555;
pub const S_JACKO2OVERLAY_4: state = 1554;
pub const S_JACKO2OVERLAY_3: state = 1553;
pub const S_JACKO2OVERLAY_2: state = 1552;
pub const S_JACKO2OVERLAY_1: state = 1551;
pub const S_JACKO2: state = 1550;
pub const S_JACKO1OVERLAY_4: state = 1549;
pub const S_JACKO1OVERLAY_3: state = 1548;
pub const S_JACKO1OVERLAY_2: state = 1547;
pub const S_JACKO1OVERLAY_1: state = 1546;
pub const S_JACKO1: state = 1545;
pub const S_ROSY_UNHAPPY: state = 1544;
pub const S_ROSY_STND: state = 1543;
pub const S_ROSY_PAIN: state = 1542;
pub const S_ROSY_HUG: state = 1541;
pub const S_ROSY_WALK: state = 1540;
pub const S_ROSY_JUMP: state = 1539;
pub const S_ROSY_IDLE4: state = 1538;
pub const S_ROSY_IDLE3: state = 1537;
pub const S_ROSY_IDLE2: state = 1536;
pub const S_ROSY_IDLE1: state = 1535;
pub const S_FHZICE2: state = 1534;
pub const S_FHZICE1: state = 1533;
pub const S_XMASBUSH: state = 1532;
pub const S_XMASBERRYBUSH: state = 1531;
pub const S_XMASBLUEBERRYBUSH: state = 1530;
pub const S_MISTLETOE: state = 1529;
pub const S_HANGSTAR: state = 1528;
pub const S_LAMPPOST2: state = 1527;
pub const S_LAMPPOST1: state = 1526;
pub const S_SNOWMANHAT: state = 1525;
pub const S_SNOWMAN: state = 1524;
pub const S_CANDYCANE: state = 1523;
pub const S_XMASPOLE: state = 1522;
pub const S_STG9: state = 1521;
pub const S_STG8: state = 1520;
pub const S_STG7: state = 1519;
pub const S_STG6: state = 1518;
pub const S_STG5: state = 1517;
pub const S_STG4: state = 1516;
pub const S_STG3: state = 1515;
pub const S_STG2: state = 1514;
pub const S_STG1: state = 1513;
pub const S_STG0: state = 1512;
pub const S_BLUEGARGOYLE: state = 1511;
pub const S_GREENFLAME: state = 1510;
pub const S_TARGET_ALLDONE: state = 1509;
pub const S_TARGET_RESPAWN: state = 1508;
pub const S_TARGET_HIT2: state = 1507;
pub const S_TARGET_HIT1: state = 1506;
pub const S_TARGET_IDLE: state = 1505;
pub const S_GLAREGOYLELONG_COOLDOWN: state = 1504;
pub const S_GLAREGOYLELONG_LOOP: state = 1503;
pub const S_GLAREGOYLELONG_FIRE: state = 1502;
pub const S_GLAREGOYLELONG_HOLD: state = 1501;
pub const S_GLAREGOYLELONG_BLINK: state = 1500;
pub const S_GLAREGOYLELONG_CHARGE: state = 1499;
pub const S_GLAREGOYLELONG: state = 1498;
pub const S_GLAREGOYLEDOWN_COOLDOWN: state = 1497;
pub const S_GLAREGOYLEDOWN_LOOP: state = 1496;
pub const S_GLAREGOYLEDOWN_FIRE: state = 1495;
pub const S_GLAREGOYLEDOWN_HOLD: state = 1494;
pub const S_GLAREGOYLEDOWN_BLINK: state = 1493;
pub const S_GLAREGOYLEDOWN_CHARGE: state = 1492;
pub const S_GLAREGOYLEDOWN: state = 1491;
pub const S_GLAREGOYLEUP_COOLDOWN: state = 1490;
pub const S_GLAREGOYLEUP_LOOP: state = 1489;
pub const S_GLAREGOYLEUP_FIRE: state = 1488;
pub const S_GLAREGOYLEUP_HOLD: state = 1487;
pub const S_GLAREGOYLEUP_BLINK: state = 1486;
pub const S_GLAREGOYLEUP_CHARGE: state = 1485;
pub const S_GLAREGOYLEUP: state = 1484;
pub const S_GLAREGOYLE_COOLDOWN: state = 1483;
pub const S_GLAREGOYLE_LOOP: state = 1482;
pub const S_GLAREGOYLE_FIRE: state = 1481;
pub const S_GLAREGOYLE_HOLD: state = 1480;
pub const S_GLAREGOYLE_BLINK: state = 1479;
pub const S_GLAREGOYLE_CHARGE: state = 1478;
pub const S_GLAREGOYLE: state = 1477;
pub const S_WALLVINE_SHORT: state = 1476;
pub const S_WALLVINE_LONG: state = 1475;
pub const S_TORCHFLOWER: state = 1474;
pub const S_JUNGLEPALM: state = 1473;
pub const S_BIGFERN2: state = 1472;
pub const S_BIGFERN1: state = 1471;
pub const S_BIGFERNLEAF: state = 1470;
pub const S_ROLLOUTROCK: state = 1469;
pub const S_ROLLOUTSPAWN: state = 1468;
pub const S_LAVAFALLROCK: state = 1467;
pub const S_LAVAFALL_LAVA3: state = 1466;
pub const S_LAVAFALL_LAVA2: state = 1465;
pub const S_LAVAFALL_LAVA1: state = 1464;
pub const S_LAVAFALL_SHOOT: state = 1463;
pub const S_LAVAFALL_TELL: state = 1462;
pub const S_LAVAFALL_DORMANT: state = 1461;
pub const S_FLAMEJETFLAMEB3: state = 1460;
pub const S_FLAMEJETFLAMEB2: state = 1459;
pub const S_FLAMEJETFLAMEB1: state = 1458;
pub const S_FJSPINAXISB2: state = 1457;
pub const S_FJSPINAXISB1: state = 1456;
pub const S_FJSPINAXISA2: state = 1455;
pub const S_FJSPINAXISA1: state = 1454;
pub const S_FLAMEJETFLAME9: state = 1453;
pub const S_FLAMEJETFLAME8: state = 1452;
pub const S_FLAMEJETFLAME7: state = 1451;
pub const S_FLAMEJETFLAME6: state = 1450;
pub const S_FLAMEJETFLAME5: state = 1449;
pub const S_FLAMEJETFLAME4: state = 1448;
pub const S_FLAMEJETFLAME3: state = 1447;
pub const S_FLAMEJETFLAME2: state = 1446;
pub const S_FLAMEJETFLAME1: state = 1445;
pub const S_FLAMEJETSTOP: state = 1444;
pub const S_FLAMEJETSTART: state = 1443;
pub const S_FLAMEJETSTND: state = 1442;
pub const S_TRAINSTEAM: state = 1441;
pub const S_TRAINDUST: state = 1440;
pub const S_TRAINPUFFMAKER: state = 1439;
pub const S_TRAINCAMEOSPAWNER_5: state = 1438;
pub const S_TRAINCAMEOSPAWNER_4: state = 1437;
pub const S_TRAINCAMEOSPAWNER_3: state = 1436;
pub const S_TRAINCAMEOSPAWNER_2: state = 1435;
pub const S_TRAINCAMEOSPAWNER_1: state = 1434;
pub const S_SALOONDOORCENTER: state = 1433;
pub const S_SALOONDOOR: state = 1432;
pub const S_MINECARTSPARK: state = 1431;
pub const S_MINECARTSIDEMARK2: state = 1430;
pub const S_MINECARTSIDEMARK1: state = 1429;
pub const S_MINECARTSEG_RIGHT: state = 1428;
pub const S_MINECARTSEG_LEFT: state = 1427;
pub const S_MINECARTSEG_BACK: state = 1426;
pub const S_MINECARTSEG_FRONT: state = 1425;
pub const S_MINECARTEND: state = 1424;
pub const S_MINECART_DTH1: state = 1423;
pub const S_MINECART_IDLE: state = 1422;
pub const S_ARIDDUST3: state = 1421;
pub const S_ARIDDUST2: state = 1420;
pub const S_ARIDDUST1: state = 1419;
pub const S_DUSTLAYER5: state = 1418;
pub const S_DUSTLAYER4: state = 1417;
pub const S_DUSTLAYER3: state = 1416;
pub const S_DUSTLAYER2: state = 1415;
pub const S_DUSTLAYER1: state = 1414;
pub const S_DUSTDEVIL: state = 1413;
pub const S_PROXIMITY_TNT_TRIGGER23: state = 1412;
pub const S_PROXIMITY_TNT_TRIGGER22: state = 1411;
pub const S_PROXIMITY_TNT_TRIGGER21: state = 1410;
pub const S_PROXIMITY_TNT_TRIGGER20: state = 1409;
pub const S_PROXIMITY_TNT_TRIGGER19: state = 1408;
pub const S_PROXIMITY_TNT_TRIGGER18: state = 1407;
pub const S_PROXIMITY_TNT_TRIGGER17: state = 1406;
pub const S_PROXIMITY_TNT_TRIGGER16: state = 1405;
pub const S_PROXIMITY_TNT_TRIGGER15: state = 1404;
pub const S_PROXIMITY_TNT_TRIGGER14: state = 1403;
pub const S_PROXIMITY_TNT_TRIGGER13: state = 1402;
pub const S_PROXIMITY_TNT_TRIGGER12: state = 1401;
pub const S_PROXIMITY_TNT_TRIGGER11: state = 1400;
pub const S_PROXIMITY_TNT_TRIGGER10: state = 1399;
pub const S_PROXIMITY_TNT_TRIGGER9: state = 1398;
pub const S_PROXIMITY_TNT_TRIGGER8: state = 1397;
pub const S_PROXIMITY_TNT_TRIGGER7: state = 1396;
pub const S_PROXIMITY_TNT_TRIGGER6: state = 1395;
pub const S_PROXIMITY_TNT_TRIGGER5: state = 1394;
pub const S_PROXIMITY_TNT_TRIGGER4: state = 1393;
pub const S_PROXIMITY_TNT_TRIGGER3: state = 1392;
pub const S_PROXIMITY_TNT_TRIGGER2: state = 1391;
pub const S_PROXIMITY_TNT_TRIGGER1: state = 1390;
pub const S_PROXIMITY_TNT: state = 1389;
pub const S_TNTBARREL_FLYING: state = 1388;
pub const S_TNTBARREL_EXPL7: state = 1387;
pub const S_TNTBARREL_EXPL6: state = 1386;
pub const S_TNTBARREL_EXPL5: state = 1385;
pub const S_TNTBARREL_EXPL4: state = 1384;
pub const S_TNTBARREL_EXPL3: state = 1383;
pub const S_TNTBARREL_EXPL2: state = 1382;
pub const S_TNTBARREL_EXPL1: state = 1381;
pub const S_TNTBARREL_STND1: state = 1380;
pub const S_OILLAMPFLARE: state = 1379;
pub const S_OILLAMP: state = 1378;
pub const S_ARIDSIGN_SHARPTURN: state = 1377;
pub const S_ARIDSIGN_CACTI: state = 1376;
pub const S_ARIDSIGN_CAUTION: state = 1375;
pub const S_CACTISMALLSEG: state = 1374;
pub const S_CACTITINYSEG: state = 1373;
pub const S_CACTI11: state = 1372;
pub const S_CACTI10: state = 1371;
pub const S_CACTI9: state = 1370;
pub const S_CACTI8: state = 1369;
pub const S_CACTI7: state = 1368;
pub const S_CACTI6: state = 1367;
pub const S_CACTI5: state = 1366;
pub const S_CACTI4: state = 1365;
pub const S_CACTI3: state = 1364;
pub const S_CACTI2: state = 1363;
pub const S_CACTI1: state = 1362;
pub const S_LITTLETUMBLEWEED_ROLL8: state = 1361;
pub const S_LITTLETUMBLEWEED_ROLL7: state = 1360;
pub const S_LITTLETUMBLEWEED_ROLL6: state = 1359;
pub const S_LITTLETUMBLEWEED_ROLL5: state = 1358;
pub const S_LITTLETUMBLEWEED_ROLL4: state = 1357;
pub const S_LITTLETUMBLEWEED_ROLL3: state = 1356;
pub const S_LITTLETUMBLEWEED_ROLL2: state = 1355;
pub const S_LITTLETUMBLEWEED_ROLL1: state = 1354;
pub const S_LITTLETUMBLEWEED: state = 1353;
pub const S_BIGTUMBLEWEED_ROLL8: state = 1352;
pub const S_BIGTUMBLEWEED_ROLL7: state = 1351;
pub const S_BIGTUMBLEWEED_ROLL6: state = 1350;
pub const S_BIGTUMBLEWEED_ROLL5: state = 1349;
pub const S_BIGTUMBLEWEED_ROLL4: state = 1348;
pub const S_BIGTUMBLEWEED_ROLL3: state = 1347;
pub const S_BIGTUMBLEWEED_ROLL2: state = 1346;
pub const S_BIGTUMBLEWEED_ROLL1: state = 1345;
pub const S_BIGTUMBLEWEED: state = 1344;
pub const S_BRAMBLES: state = 1343;
pub const S_SUSPICIOUSFACESTABBERSTATUE_BURST2: state = 1342;
pub const S_SUSPICIOUSFACESTABBERSTATUE_BURST1: state = 1341;
pub const S_SUSPICIOUSFACESTABBERSTATUE_WAIT: state = 1340;
pub const S_FACESTABBERSTATUE: state = 1339;
pub const S_CRAWLASTATUE: state = 1338;
pub const S_WAVINGFLAGSEG2: state = 1337;
pub const S_WAVINGFLAGSEG1: state = 1336;
pub const S_WAVINGFLAG: state = 1335;
pub const S_FIRETORCH: state = 1334;
pub const S_FLAMEHOLDER: state = 1333;
pub const S_CANDLEPRICKET: state = 1332;
pub const S_CANDLE: state = 1331;
pub const S_CEZBUSH2: state = 1330;
pub const S_CEZBUSH1: state = 1329;
pub const S_PINETREE: state = 1328;
pub const S_CEZBANNER2: state = 1327;
pub const S_CEZBANNER1: state = 1326;
pub const S_CEZPOLE: state = 1325;
pub const S_CEZFLOWER: state = 1324;
pub const S_BIGFIREBAR16: state = 1323;
pub const S_BIGFIREBAR15: state = 1322;
pub const S_BIGFIREBAR14: state = 1321;
pub const S_BIGFIREBAR13: state = 1320;
pub const S_BIGFIREBAR12: state = 1319;
pub const S_BIGFIREBAR11: state = 1318;
pub const S_BIGFIREBAR10: state = 1317;
pub const S_BIGFIREBAR9: state = 1316;
pub const S_BIGFIREBAR8: state = 1315;
pub const S_BIGFIREBAR7: state = 1314;
pub const S_BIGFIREBAR6: state = 1313;
pub const S_BIGFIREBAR5: state = 1312;
pub const S_BIGFIREBAR4: state = 1311;
pub const S_BIGFIREBAR3: state = 1310;
pub const S_BIGFIREBAR2: state = 1309;
pub const S_BIGFIREBAR1: state = 1308;
pub const S_SMALLFIREBAR16: state = 1307;
pub const S_SMALLFIREBAR15: state = 1306;
pub const S_SMALLFIREBAR14: state = 1305;
pub const S_SMALLFIREBAR13: state = 1304;
pub const S_SMALLFIREBAR12: state = 1303;
pub const S_SMALLFIREBAR11: state = 1302;
pub const S_SMALLFIREBAR10: state = 1301;
pub const S_SMALLFIREBAR9: state = 1300;
pub const S_SMALLFIREBAR8: state = 1299;
pub const S_SMALLFIREBAR7: state = 1298;
pub const S_SMALLFIREBAR6: state = 1297;
pub const S_SMALLFIREBAR5: state = 1296;
pub const S_SMALLFIREBAR4: state = 1295;
pub const S_SMALLFIREBAR3: state = 1294;
pub const S_SMALLFIREBAR2: state = 1293;
pub const S_SMALLFIREBAR1: state = 1292;
pub const S_REDSPRINGBALL5: state = 1291;
pub const S_REDSPRINGBALL4: state = 1290;
pub const S_REDSPRINGBALL3: state = 1289;
pub const S_REDSPRINGBALL2: state = 1288;
pub const S_REDSPRINGBALL: state = 1287;
pub const S_YELLOWSPRINGBALL5: state = 1286;
pub const S_YELLOWSPRINGBALL4: state = 1285;
pub const S_YELLOWSPRINGBALL3: state = 1284;
pub const S_YELLOWSPRINGBALL2: state = 1283;
pub const S_YELLOWSPRINGBALL: state = 1282;
pub const S_BIGGRABCHAIN: state = 1281;
pub const S_SMALLGRABCHAIN: state = 1280;
pub const S_BIGMACE: state = 1279;
pub const S_SMALLMACE: state = 1278;
pub const S_BIGMACECHAIN: state = 1277;
pub const S_SMALLMACECHAIN: state = 1276;
pub const S_SLING2: state = 1275;
pub const S_SLING1: state = 1274;
pub const S_EGGSTATUE1: state = 1273;
pub const S_FLAMEREST: state = 1272;
pub const S_FLAMEPARTICLE: state = 1271;
pub const S_FLAME: state = 1270;
pub const S_CEZCHAIN: state = 1269;
pub const S_LIGHTBEAM12: state = 1268;
pub const S_LIGHTBEAM11: state = 1267;
pub const S_LIGHTBEAM10: state = 1266;
pub const S_LIGHTBEAM9: state = 1265;
pub const S_LIGHTBEAM8: state = 1264;
pub const S_LIGHTBEAM7: state = 1263;
pub const S_LIGHTBEAM6: state = 1262;
pub const S_LIGHTBEAM5: state = 1261;
pub const S_LIGHTBEAM4: state = 1260;
pub const S_LIGHTBEAM3: state = 1259;
pub const S_LIGHTBEAM2: state = 1258;
pub const S_LIGHTBEAM1: state = 1257;
pub const S_DSZ2STALAGMITE: state = 1256;
pub const S_DSZSTALAGMITE: state = 1255;
pub const S_ANIMALGAESEG: state = 1254;
pub const S_ANIMALGAETOP2: state = 1253;
pub const S_ANIMALGAETOP1: state = 1252;
pub const S_KELP: state = 1251;
pub const S_BLUECRYSTAL1: state = 1250;
pub const S_CORAL5: state = 1249;
pub const S_CORAL4: state = 1248;
pub const S_CORAL3: state = 1247;
pub const S_CORAL2: state = 1246;
pub const S_CORAL1: state = 1245;
pub const S_DRIPC2: state = 1244;
pub const S_DRIPC1: state = 1243;
pub const S_DRIPB1: state = 1242;
pub const S_DRIPA4: state = 1241;
pub const S_DRIPA3: state = 1240;
pub const S_DRIPA2: state = 1239;
pub const S_DRIPA1: state = 1238;
pub const S_SEAWEED6: state = 1237;
pub const S_SEAWEED5: state = 1236;
pub const S_SEAWEED4: state = 1235;
pub const S_SEAWEED3: state = 1234;
pub const S_SEAWEED2: state = 1233;
pub const S_SEAWEED1: state = 1232;
pub const S_BIGGARGOYLE: state = 1231;
pub const S_GARGOYLE: state = 1230;
pub const S_ALARM1: state = 1229;
pub const S_THZTREEBRANCH13: state = 1228;
pub const S_THZTREEBRANCH12: state = 1227;
pub const S_THZTREEBRANCH11: state = 1226;
pub const S_THZTREEBRANCH10: state = 1225;
pub const S_THZTREEBRANCH9: state = 1224;
pub const S_THZTREEBRANCH8: state = 1223;
pub const S_THZTREEBRANCH7: state = 1222;
pub const S_THZTREEBRANCH6: state = 1221;
pub const S_THZTREEBRANCH5: state = 1220;
pub const S_THZTREEBRANCH4: state = 1219;
pub const S_THZTREEBRANCH3: state = 1218;
pub const S_THZTREEBRANCH2: state = 1217;
pub const S_THZTREEBRANCH1: state = 1216;
pub const S_THZTREE: state = 1215;
pub const S_THZFLOWERC: state = 1214;
pub const S_THZFLOWERB: state = 1213;
pub const S_THZFLOWERA: state = 1212;
pub const S_SPRINGTREE: state = 1211;
pub const S_BUSHREDTREE: state = 1210;
pub const S_BUSHTREE: state = 1209;
pub const S_POLYGONTREE: state = 1208;
pub const S_FHZPINKTREE: state = 1207;
pub const S_FHZTREE: state = 1206;
pub const S_CHECKERSUNSETTREE: state = 1205;
pub const S_CHECKERTREE: state = 1204;
pub const S_GFZCHERRYTREE: state = 1203;
pub const S_GFZBERRYTREE: state = 1202;
pub const S_GFZTREE: state = 1201;
pub const S_BUSH: state = 1200;
pub const S_BERRYBUSH: state = 1199;
pub const S_BLUEBERRYBUSH: state = 1198;
pub const S_GFZFLOWERC: state = 1197;
pub const S_GFZFLOWERB: state = 1196;
pub const S_GFZFLOWERA: state = 1195;
pub const S_TUTORIALFLOWERF16: state = 1194;
pub const S_TUTORIALFLOWERF15: state = 1193;
pub const S_TUTORIALFLOWERF14: state = 1192;
pub const S_TUTORIALFLOWERF13: state = 1191;
pub const S_TUTORIALFLOWERF12: state = 1190;
pub const S_TUTORIALFLOWERF11: state = 1189;
pub const S_TUTORIALFLOWERF10: state = 1188;
pub const S_TUTORIALFLOWERF9: state = 1187;
pub const S_TUTORIALFLOWERF8: state = 1186;
pub const S_TUTORIALFLOWERF7: state = 1185;
pub const S_TUTORIALFLOWERF6: state = 1184;
pub const S_TUTORIALFLOWERF5: state = 1183;
pub const S_TUTORIALFLOWERF4: state = 1182;
pub const S_TUTORIALFLOWERF3: state = 1181;
pub const S_TUTORIALFLOWERF2: state = 1180;
pub const S_TUTORIALFLOWERF1: state = 1179;
pub const S_TUTORIALFLOWER16: state = 1178;
pub const S_TUTORIALFLOWER15: state = 1177;
pub const S_TUTORIALFLOWER14: state = 1176;
pub const S_TUTORIALFLOWER13: state = 1175;
pub const S_TUTORIALFLOWER12: state = 1174;
pub const S_TUTORIALFLOWER11: state = 1173;
pub const S_TUTORIALFLOWER10: state = 1172;
pub const S_TUTORIALFLOWER9: state = 1171;
pub const S_TUTORIALFLOWER8: state = 1170;
pub const S_TUTORIALFLOWER7: state = 1169;
pub const S_TUTORIALFLOWER6: state = 1168;
pub const S_TUTORIALFLOWER5: state = 1167;
pub const S_TUTORIALFLOWER4: state = 1166;
pub const S_TUTORIALFLOWER3: state = 1165;
pub const S_TUTORIALFLOWER2: state = 1164;
pub const S_TUTORIALFLOWER1: state = 1163;
pub const S_TUTORIALLEAF16: state = 1162;
pub const S_TUTORIALLEAF15: state = 1161;
pub const S_TUTORIALLEAF14: state = 1160;
pub const S_TUTORIALLEAF13: state = 1159;
pub const S_TUTORIALLEAF12: state = 1158;
pub const S_TUTORIALLEAF11: state = 1157;
pub const S_TUTORIALLEAF10: state = 1156;
pub const S_TUTORIALLEAF9: state = 1155;
pub const S_TUTORIALLEAF8: state = 1154;
pub const S_TUTORIALLEAF7: state = 1153;
pub const S_TUTORIALLEAF6: state = 1152;
pub const S_TUTORIALLEAF5: state = 1151;
pub const S_TUTORIALLEAF4: state = 1150;
pub const S_TUTORIALLEAF3: state = 1149;
pub const S_TUTORIALLEAF2: state = 1148;
pub const S_TUTORIALLEAF1: state = 1147;
pub const S_LETTER: state = 1146;
pub const S_DEMONFIRE: state = 1145;
pub const S_ARROWBONK: state = 1144;
pub const S_ARROW: state = 1143;
pub const S_CANNONBALL1: state = 1142;
pub const S_TURRETLASEREXPLODE2: state = 1141;
pub const S_TURRETLASEREXPLODE1: state = 1140;
pub const S_TURRETLASER: state = 1139;
pub const S_JETBULLET2: state = 1138;
pub const S_JETBULLET1: state = 1137;
pub const S_MINE_BOOM4: state = 1136;
pub const S_MINE_BOOM3: state = 1135;
pub const S_MINE_BOOM2: state = 1134;
pub const S_MINE_BOOM1: state = 1133;
pub const S_MINE1: state = 1132;
pub const S_ENERGYBALL2: state = 1131;
pub const S_ENERGYBALL1: state = 1130;
pub const S_TORPEDO: state = 1129;
pub const S_LASERFLAME5: state = 1128;
pub const S_LASERFLAME4: state = 1127;
pub const S_LASERFLAME3: state = 1126;
pub const S_LASERFLAME2: state = 1125;
pub const S_LASERFLAME1: state = 1124;
pub const S_LASERFLASH: state = 1123;
pub const S_LASER2: state = 1122;
pub const S_LASER: state = 1121;
pub const S_ROCKET: state = 1120;
pub const S_THUNDERCOIN_ICON2: state = 1119;
pub const S_THUNDERCOIN_ICON1: state = 1118;
pub const S_BUBBLEWRAP_ICON2: state = 1117;
pub const S_BUBBLEWRAP_ICON1: state = 1116;
pub const S_FLAMEAURA_ICON2: state = 1115;
pub const S_FLAMEAURA_ICON1: state = 1114;
pub const S_SCORE10K_ICON2: state = 1113;
pub const S_SCORE10K_ICON1: state = 1112;
pub const S_SCORE1K_ICON2: state = 1111;
pub const S_SCORE1K_ICON1: state = 1110;
pub const S_RECYCLER_ICON2: state = 1109;
pub const S_RECYCLER_ICON1: state = 1108;
pub const S_GRAVITY_ICON2: state = 1107;
pub const S_GRAVITY_ICON1: state = 1106;
pub const S_MIXUP_ICON2: state = 1105;
pub const S_MIXUP_ICON1: state = 1104;
pub const S_EGGMAN_ICON2: state = 1103;
pub const S_EGGMAN_ICON1: state = 1102;
pub const S_1UP_ICON2: state = 1101;
pub const S_1UP_ICON1: state = 1100;
pub const S_INVULN_ICON2: state = 1099;
pub const S_INVULN_ICON1: state = 1098;
pub const S_SNEAKERS_ICON2: state = 1097;
pub const S_SNEAKERS_ICON1: state = 1096;
pub const S_ELEMENTAL_ICON2: state = 1095;
pub const S_ELEMENTAL_ICON1: state = 1094;
pub const S_WHIRLWIND_ICON2: state = 1093;
pub const S_WHIRLWIND_ICON1: state = 1092;
pub const S_ARMAGEDDON_ICON2: state = 1091;
pub const S_ARMAGEDDON_ICON1: state = 1090;
pub const S_FORCE_ICON2: state = 1089;
pub const S_FORCE_ICON1: state = 1088;
pub const S_ATTRACT_ICON2: state = 1087;
pub const S_ATTRACT_ICON1: state = 1086;
pub const S_PITY_ICON2: state = 1085;
pub const S_PITY_ICON1: state = 1084;
pub const S_RING_ICON2: state = 1083;
pub const S_RING_ICON1: state = 1082;
pub const S_BLUEBOX_POP2: state = 1081;
pub const S_BLUEBOX_POP1: state = 1080;
pub const S_RING_BLUEBOX2: state = 1079;
pub const S_RING_BLUEBOX1: state = 1078;
pub const S_REDBOX_POP2: state = 1077;
pub const S_REDBOX_POP1: state = 1076;
pub const S_RING_REDBOX2: state = 1075;
pub const S_RING_REDBOX1: state = 1074;
pub const S_THUNDERCOIN_GOLDBOX: state = 1073;
pub const S_BUBBLEWRAP_GOLDBOX: state = 1072;
pub const S_FLAMEAURA_GOLDBOX: state = 1071;
pub const S_GRAVITY_GOLDBOX: state = 1070;
pub const S_EGGMAN_GOLDBOX: state = 1069;
pub const S_INVULN_GOLDBOX: state = 1068;
pub const S_SNEAKERS_GOLDBOX: state = 1067;
pub const S_ELEMENTAL_GOLDBOX: state = 1066;
pub const S_WHIRLWIND_GOLDBOX: state = 1065;
pub const S_ARMAGEDDON_GOLDBOX: state = 1064;
pub const S_FORCE_GOLDBOX: state = 1063;
pub const S_ATTRACT_GOLDBOX: state = 1062;
pub const S_PITY_GOLDBOX: state = 1061;
pub const S_THUNDERCOIN_BOX: state = 1060;
pub const S_BUBBLEWRAP_BOX: state = 1059;
pub const S_FLAMEAURA_BOX: state = 1058;
pub const S_SCORE10K_BOX: state = 1057;
pub const S_SCORE1K_BOX: state = 1056;
pub const S_RECYCLER_BOX: state = 1055;
pub const S_GRAVITY_BOX: state = 1054;
pub const S_MIXUP_BOX: state = 1053;
pub const S_EGGMAN_BOX: state = 1052;
pub const S_1UP_BOX: state = 1051;
pub const S_INVULN_BOX: state = 1050;
pub const S_SNEAKERS_BOX: state = 1049;
pub const S_ELEMENTAL_BOX: state = 1048;
pub const S_WHIRLWIND_BOX: state = 1047;
pub const S_ARMAGEDDON_BOX: state = 1046;
pub const S_FORCE_BOX: state = 1045;
pub const S_ATTRACT_BOX: state = 1044;
pub const S_PITY_BOX: state = 1043;
pub const S_RING_BOX: state = 1042;
pub const S_MYSTERY_BOX: state = 1041;
pub const S_GOLDBOX_OFF7: state = 1040;
pub const S_GOLDBOX_OFF6: state = 1039;
pub const S_GOLDBOX_OFF5: state = 1038;
pub const S_GOLDBOX_OFF4: state = 1037;
pub const S_GOLDBOX_OFF3: state = 1036;
pub const S_GOLDBOX_OFF2: state = 1035;
pub const S_GOLDBOX_OFF1: state = 1034;
pub const S_GOLDBOX_FLICKER: state = 1033;
pub const S_BOX_POP2: state = 1032;
pub const S_BOX_POP1: state = 1031;
pub const S_BOX_FLICKER: state = 1030;
pub const S_BOXSPARKLE4: state = 1029;
pub const S_BOXSPARKLE3: state = 1028;
pub const S_BOXSPARKLE2: state = 1027;
pub const S_BOXSPARKLE1: state = 1026;
pub const S_CANNONLAUNCHER3: state = 1025;
pub const S_CANNONLAUNCHER2: state = 1024;
pub const S_CANNONLAUNCHER1: state = 1023;
pub const S_BIGMINE_BLAST5: state = 1022;
pub const S_BIGMINE_BLAST4: state = 1021;
pub const S_BIGMINE_BLAST3: state = 1020;
pub const S_BIGMINE_BLAST2: state = 1019;
pub const S_BIGMINE_BLAST1: state = 1018;
pub const S_BIGMINE_SET3: state = 1017;
pub const S_BIGMINE_SET2: state = 1016;
pub const S_BIGMINE_SET1: state = 1015;
pub const S_BIGMINE_ALERT3: state = 1014;
pub const S_BIGMINE_ALERT2: state = 1013;
pub const S_BIGMINE_ALERT1: state = 1012;
pub const S_BIGMINE_IDLE: state = 1011;
pub const S_STARPOST_ENDSPIN: state = 1010;
pub const S_STARPOST_SPIN: state = 1009;
pub const S_STARPOST_STARTSPIN: state = 1008;
pub const S_STARPOST_FLASH: state = 1007;
pub const S_STARPOST_IDLE: state = 1006;
pub const S_WALLSPIKED2: state = 1005;
pub const S_WALLSPIKED1: state = 1004;
pub const S_WALLSPIKEBASE: state = 1003;
pub const S_WALLSPIKE6: state = 1002;
pub const S_WALLSPIKE5: state = 1001;
pub const S_WALLSPIKE4: state = 1000;
pub const S_WALLSPIKE3: state = 999;
pub const S_WALLSPIKE2: state = 998;
pub const S_WALLSPIKE1: state = 997;
pub const S_SPIKED2: state = 996;
pub const S_SPIKED1: state = 995;
pub const S_SPIKE6: state = 994;
pub const S_SPIKE5: state = 993;
pub const S_SPIKE4: state = 992;
pub const S_SPIKE3: state = 991;
pub const S_SPIKE2: state = 990;
pub const S_SPIKE1: state = 989;
pub const S_TEAM_SPINFIRE6: state = 988;
pub const S_TEAM_SPINFIRE5: state = 987;
pub const S_TEAM_SPINFIRE4: state = 986;
pub const S_TEAM_SPINFIRE3: state = 985;
pub const S_TEAM_SPINFIRE2: state = 984;
pub const S_TEAM_SPINFIRE1: state = 983;
pub const S_SPINFIRE6: state = 982;
pub const S_SPINFIRE5: state = 981;
pub const S_SPINFIRE4: state = 980;
pub const S_SPINFIRE3: state = 979;
pub const S_SPINFIRE2: state = 978;
pub const S_SPINFIRE1: state = 977;
pub const S_SPIKEBALL8: state = 976;
pub const S_SPIKEBALL7: state = 975;
pub const S_SPIKEBALL6: state = 974;
pub const S_SPIKEBALL5: state = 973;
pub const S_SPIKEBALL4: state = 972;
pub const S_SPIKEBALL3: state = 971;
pub const S_SPIKEBALL2: state = 970;
pub const S_SPIKEBALL1: state = 969;
pub const S_CLEARSIGN: state = 968;
pub const S_EGGMANSIGN: state = 967;
pub const S_SIGNBOARD: state = 966;
pub const S_SIGNSTOP: state = 965;
pub const S_SIGNSLOW: state = 964;
pub const S_SIGNPLAYER: state = 963;
pub const S_SIGNSPIN6: state = 962;
pub const S_SIGNSPIN5: state = 961;
pub const S_SIGNSPIN4: state = 960;
pub const S_SIGNSPIN3: state = 959;
pub const S_SIGNSPIN2: state = 958;
pub const S_SIGNSPIN1: state = 957;
pub const S_SIGN: state = 956;
pub const S_BUBBLES4: state = 955;
pub const S_BUBBLES3: state = 954;
pub const S_BUBBLES2: state = 953;
pub const S_BUBBLES1: state = 952;
pub const S_SHRD3: state = 951;
pub const S_SHRD2: state = 950;
pub const S_SHRD1: state = 949;
pub const S_CEMG7: state = 948;
pub const S_CEMG6: state = 947;
pub const S_CEMG5: state = 946;
pub const S_CEMG4: state = 945;
pub const S_CEMG3: state = 944;
pub const S_CEMG2: state = 943;
pub const S_CEMG1: state = 942;
pub const S_EMBLEM26: state = 941;
pub const S_EMBLEM25: state = 940;
pub const S_EMBLEM24: state = 939;
pub const S_EMBLEM23: state = 938;
pub const S_EMBLEM22: state = 937;
pub const S_EMBLEM21: state = 936;
pub const S_EMBLEM20: state = 935;
pub const S_EMBLEM19: state = 934;
pub const S_EMBLEM18: state = 933;
pub const S_EMBLEM17: state = 932;
pub const S_EMBLEM16: state = 931;
pub const S_EMBLEM15: state = 930;
pub const S_EMBLEM14: state = 929;
pub const S_EMBLEM13: state = 928;
pub const S_EMBLEM12: state = 927;
pub const S_EMBLEM11: state = 926;
pub const S_EMBLEM10: state = 925;
pub const S_EMBLEM9: state = 924;
pub const S_EMBLEM8: state = 923;
pub const S_EMBLEM7: state = 922;
pub const S_EMBLEM6: state = 921;
pub const S_EMBLEM5: state = 920;
pub const S_EMBLEM4: state = 919;
pub const S_EMBLEM3: state = 918;
pub const S_EMBLEM2: state = 917;
pub const S_EMBLEM1: state = 916;
pub const S_BLUEFLAG: state = 915;
pub const S_REDFLAG: state = 914;
pub const S_TOKEN: state = 913;
pub const S_TEAMRING: state = 912;
pub const S_GRAVWELLRED: state = 911;
pub const S_GRAVWELLGREEN: state = 910;
pub const S_NIGHTSSTARXMAS: state = 909;
pub const S_NIGHTSSTAR: state = 908;
pub const S_NIGHTSCHIPBONUS: state = 907;
pub const S_NIGHTSCHIP: state = 906;
pub const S_BOMBSPHERE4: state = 905;
pub const S_BOMBSPHERE3: state = 904;
pub const S_BOMBSPHERE2: state = 903;
pub const S_BOMBSPHERE1: state = 902;
pub const S_BLUESPHERESPARK: state = 901;
pub const S_BLUESPHEREBONUS: state = 900;
pub const S_BLUESPHERE: state = 899;
pub const S_RING: state = 898;
pub const S_MSSHIELD_F2: state = 897;
pub const S_MSSHIELD_F1: state = 896;
pub const S_METALSONIC_FLEE2: state = 895;
pub const S_METALSONIC_FLEE1: state = 894;
pub const S_METALSONIC_DEATH4: state = 893;
pub const S_METALSONIC_DEATH3: state = 892;
pub const S_METALSONIC_DEATH2: state = 891;
pub const S_METALSONIC_DEATH1: state = 890;
pub const S_METALSONIC_PAIN: state = 889;
pub const S_METALSONIC_SHOOT: state = 888;
pub const S_METALSONIC_BADBOUNCE: state = 887;
pub const S_METALSONIC_BOUNCE: state = 886;
pub const S_METALSONIC_DASH: state = 885;
pub const S_METALSONIC_GATHER: state = 884;
pub const S_METALSONIC_RAISE: state = 883;
pub const S_METALSONIC_STUN: state = 882;
pub const S_METALSONIC_VECTOR: state = 881;
pub const S_METALSONIC_FLOAT: state = 880;
pub const S_METALSONIC_RACE: state = 879;
pub const S_CYBRAKDEMONVILEEXPLOSION3: state = 878;
pub const S_CYBRAKDEMONVILEEXPLOSION2: state = 877;
pub const S_CYBRAKDEMONVILEEXPLOSION1: state = 876;
pub const S_CYBRAKDEMONNAPALMFLAME_DIE: state = 875;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY6: state = 874;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY5: state = 873;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY4: state = 872;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY3: state = 871;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY2: state = 870;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY1: state = 869;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE5: state = 868;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE4: state = 867;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE3: state = 866;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE2: state = 865;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE1: state = 864;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL: state = 863;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE4: state = 862;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE3: state = 861;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE2: state = 860;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE1: state = 859;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY4: state = 858;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY3: state = 857;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY2: state = 856;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY1: state = 855;
pub const S_CYBRAKDEMONTARGETDOT: state = 854;
pub const S_CYBRAKDEMONTARGETRETICULE14: state = 853;
pub const S_CYBRAKDEMONTARGETRETICULE13: state = 852;
pub const S_CYBRAKDEMONTARGETRETICULE12: state = 851;
pub const S_CYBRAKDEMONTARGETRETICULE11: state = 850;
pub const S_CYBRAKDEMONTARGETRETICULE10: state = 849;
pub const S_CYBRAKDEMONTARGETRETICULE9: state = 848;
pub const S_CYBRAKDEMONTARGETRETICULE8: state = 847;
pub const S_CYBRAKDEMONTARGETRETICULE7: state = 846;
pub const S_CYBRAKDEMONTARGETRETICULE6: state = 845;
pub const S_CYBRAKDEMONTARGETRETICULE5: state = 844;
pub const S_CYBRAKDEMONTARGETRETICULE4: state = 843;
pub const S_CYBRAKDEMONTARGETRETICULE3: state = 842;
pub const S_CYBRAKDEMONTARGETRETICULE2: state = 841;
pub const S_CYBRAKDEMONTARGETRETICULE1: state = 840;
pub const S_CYBRAKDEMONELECTRICBARRIER_REVIVE3: state = 839;
pub const S_CYBRAKDEMONELECTRICBARRIER_REVIVE2: state = 838;
pub const S_CYBRAKDEMONELECTRICBARRIER_REVIVE1: state = 837;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMLOOP: state = 836;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMFAIL: state = 835;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM12: state = 834;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM11: state = 833;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM10: state = 832;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM9: state = 831;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM8: state = 830;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM7: state = 829;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM6: state = 828;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM5: state = 827;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM4: state = 826;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM3: state = 825;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM2: state = 824;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM1: state = 823;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMCHOOSE: state = 822;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMSUCCESS: state = 821;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMCHECK: state = 820;
pub const S_CYBRAKDEMONELECTRICBARRIER_DIE3: state = 819;
pub const S_CYBRAKDEMONELECTRICBARRIER_DIE2: state = 818;
pub const S_CYBRAKDEMONELECTRICBARRIER_DIE1: state = 817;
pub const S_CYBRAKDEMONELECTRICBARRIER24: state = 816;
pub const S_CYBRAKDEMONELECTRICBARRIER23: state = 815;
pub const S_CYBRAKDEMONELECTRICBARRIER22: state = 814;
pub const S_CYBRAKDEMONELECTRICBARRIER21: state = 813;
pub const S_CYBRAKDEMONELECTRICBARRIER20: state = 812;
pub const S_CYBRAKDEMONELECTRICBARRIER19: state = 811;
pub const S_CYBRAKDEMONELECTRICBARRIER18: state = 810;
pub const S_CYBRAKDEMONELECTRICBARRIER17: state = 809;
pub const S_CYBRAKDEMONELECTRICBARRIER16: state = 808;
pub const S_CYBRAKDEMONELECTRICBARRIER15: state = 807;
pub const S_CYBRAKDEMONELECTRICBARRIER14: state = 806;
pub const S_CYBRAKDEMONELECTRICBARRIER13: state = 805;
pub const S_CYBRAKDEMONELECTRICBARRIER12: state = 804;
pub const S_CYBRAKDEMONELECTRICBARRIER11: state = 803;
pub const S_CYBRAKDEMONELECTRICBARRIER10: state = 802;
pub const S_CYBRAKDEMONELECTRICBARRIER9: state = 801;
pub const S_CYBRAKDEMONELECTRICBARRIER8: state = 800;
pub const S_CYBRAKDEMONELECTRICBARRIER7: state = 799;
pub const S_CYBRAKDEMONELECTRICBARRIER6: state = 798;
pub const S_CYBRAKDEMONELECTRICBARRIER5: state = 797;
pub const S_CYBRAKDEMONELECTRICBARRIER4: state = 796;
pub const S_CYBRAKDEMONELECTRICBARRIER3: state = 795;
pub const S_CYBRAKDEMONELECTRICBARRIER2: state = 794;
pub const S_CYBRAKDEMONELECTRICBARRIER1: state = 793;
pub const S_CYBRAKDEMONELECTRICBARRIER_PLAYSOUND: state = 792;
pub const S_CYBRAKDEMONELECTRICBARRIER_INIT2: state = 791;
pub const S_CYBRAKDEMONELECTRICBARRIER_INIT1: state = 790;
pub const S_CYBRAKDEMONFLAMEREST: state = 789;
pub const S_CYBRAKDEMONFLAMESHOT_DIE: state = 788;
pub const S_CYBRAKDEMONFLAMESHOT_FLY3: state = 787;
pub const S_CYBRAKDEMONFLAMESHOT_FLY2: state = 786;
pub const S_CYBRAKDEMONFLAMESHOT_FLY1: state = 785;
pub const S_CYBRAKDEMONMISSILE_EXPLODE3: state = 784;
pub const S_CYBRAKDEMONMISSILE_EXPLODE2: state = 783;
pub const S_CYBRAKDEMONMISSILE_EXPLODE1: state = 782;
pub const S_CYBRAKDEMONMISSILE: state = 781;
pub const S_CYBRAKDEMON_INVINCIBLERIZE: state = 780;
pub const S_CYBRAKDEMON_DEINVINCIBLERIZE: state = 779;
pub const S_CYBRAKDEMON_DIE8: state = 778;
pub const S_CYBRAKDEMON_DIE7: state = 777;
pub const S_CYBRAKDEMON_DIE6: state = 776;
pub const S_CYBRAKDEMON_DIE5: state = 775;
pub const S_CYBRAKDEMON_DIE4: state = 774;
pub const S_CYBRAKDEMON_DIE3: state = 773;
pub const S_CYBRAKDEMON_DIE2: state = 772;
pub const S_CYBRAKDEMON_DIE1: state = 771;
pub const S_CYBRAKDEMON_PAIN3: state = 770;
pub const S_CYBRAKDEMON_PAIN2: state = 769;
pub const S_CYBRAKDEMON_PAIN1: state = 768;
pub const S_CYBRAKDEMON_FINISH_ATTACK2: state = 767;
pub const S_CYBRAKDEMON_FINISH_ATTACK1: state = 766;
pub const S_CYBRAKDEMON_NAPALM_ATTACK3: state = 765;
pub const S_CYBRAKDEMON_NAPALM_ATTACK2: state = 764;
pub const S_CYBRAKDEMON_NAPALM_ATTACK1: state = 763;
pub const S_CYBRAKDEMON_VILE_ATTACK6: state = 762;
pub const S_CYBRAKDEMON_VILE_ATTACK5: state = 761;
pub const S_CYBRAKDEMON_VILE_ATTACK4: state = 760;
pub const S_CYBRAKDEMON_VILE_ATTACK3: state = 759;
pub const S_CYBRAKDEMON_VILE_ATTACK2: state = 758;
pub const S_CYBRAKDEMON_VILE_ATTACK1: state = 757;
pub const S_CYBRAKDEMON_CHOOSE_ATTACK2: state = 756;
pub const S_CYBRAKDEMON_FLAME_ATTACK4: state = 755;
pub const S_CYBRAKDEMON_FLAME_ATTACK3: state = 754;
pub const S_CYBRAKDEMON_FLAME_ATTACK2: state = 753;
pub const S_CYBRAKDEMON_FLAME_ATTACK1: state = 752;
pub const S_CYBRAKDEMON_MISSILE_ATTACK6: state = 751;
pub const S_CYBRAKDEMON_MISSILE_ATTACK5: state = 750;
pub const S_CYBRAKDEMON_MISSILE_ATTACK4: state = 749;
pub const S_CYBRAKDEMON_MISSILE_ATTACK3: state = 748;
pub const S_CYBRAKDEMON_MISSILE_ATTACK2: state = 747;
pub const S_CYBRAKDEMON_MISSILE_ATTACK1: state = 746;
pub const S_CYBRAKDEMON_CHOOSE_ATTACK1: state = 745;
pub const S_CYBRAKDEMON_WALK6: state = 744;
pub const S_CYBRAKDEMON_WALK5: state = 743;
pub const S_CYBRAKDEMON_WALK4: state = 742;
pub const S_CYBRAKDEMON_WALK3: state = 741;
pub const S_CYBRAKDEMON_WALK2: state = 740;
pub const S_CYBRAKDEMON_WALK1: state = 739;
pub const S_CYBRAKDEMON_IDLE: state = 738;
pub const S_BLACKEGG_MISSILE: state = 737;
pub const S_BLACKEGG_GOOP7: state = 736;
pub const S_BLACKEGG_GOOP6: state = 735;
pub const S_BLACKEGG_GOOP5: state = 734;
pub const S_BLACKEGG_GOOP4: state = 733;
pub const S_BLACKEGG_GOOP3: state = 732;
pub const S_BLACKEGG_GOOP2: state = 731;
pub const S_BLACKEGG_GOOP1: state = 730;
pub const S_BLACKEGG_HELPER: state = 729;
pub const S_BLACKEGG_DESTROYPLAT3: state = 728;
pub const S_BLACKEGG_DESTROYPLAT2: state = 727;
pub const S_BLACKEGG_DESTROYPLAT1: state = 726;
pub const S_BLACKEGG_JUMP2: state = 725;
pub const S_BLACKEGG_JUMP1: state = 724;
pub const S_BLACKEGG_GOOP: state = 723;
pub const S_BLACKEGG_MISSILE3: state = 722;
pub const S_BLACKEGG_MISSILE2: state = 721;
pub const S_BLACKEGG_MISSILE1: state = 720;
pub const S_BLACKEGG_DIE5: state = 719;
pub const S_BLACKEGG_DIE4: state = 718;
pub const S_BLACKEGG_DIE3: state = 717;
pub const S_BLACKEGG_DIE2: state = 716;
pub const S_BLACKEGG_DIE1: state = 715;
pub const S_BLACKEGG_HITFACE4: state = 714;
pub const S_BLACKEGG_HITFACE3: state = 713;
pub const S_BLACKEGG_HITFACE2: state = 712;
pub const S_BLACKEGG_HITFACE1: state = 711;
pub const S_BLACKEGG_PAIN35: state = 710;
pub const S_BLACKEGG_PAIN34: state = 709;
pub const S_BLACKEGG_PAIN33: state = 708;
pub const S_BLACKEGG_PAIN32: state = 707;
pub const S_BLACKEGG_PAIN31: state = 706;
pub const S_BLACKEGG_PAIN30: state = 705;
pub const S_BLACKEGG_PAIN29: state = 704;
pub const S_BLACKEGG_PAIN28: state = 703;
pub const S_BLACKEGG_PAIN27: state = 702;
pub const S_BLACKEGG_PAIN26: state = 701;
pub const S_BLACKEGG_PAIN25: state = 700;
pub const S_BLACKEGG_PAIN24: state = 699;
pub const S_BLACKEGG_PAIN23: state = 698;
pub const S_BLACKEGG_PAIN22: state = 697;
pub const S_BLACKEGG_PAIN21: state = 696;
pub const S_BLACKEGG_PAIN20: state = 695;
pub const S_BLACKEGG_PAIN19: state = 694;
pub const S_BLACKEGG_PAIN18: state = 693;
pub const S_BLACKEGG_PAIN17: state = 692;
pub const S_BLACKEGG_PAIN16: state = 691;
pub const S_BLACKEGG_PAIN15: state = 690;
pub const S_BLACKEGG_PAIN14: state = 689;
pub const S_BLACKEGG_PAIN13: state = 688;
pub const S_BLACKEGG_PAIN12: state = 687;
pub const S_BLACKEGG_PAIN11: state = 686;
pub const S_BLACKEGG_PAIN10: state = 685;
pub const S_BLACKEGG_PAIN9: state = 684;
pub const S_BLACKEGG_PAIN8: state = 683;
pub const S_BLACKEGG_PAIN7: state = 682;
pub const S_BLACKEGG_PAIN6: state = 681;
pub const S_BLACKEGG_PAIN5: state = 680;
pub const S_BLACKEGG_PAIN4: state = 679;
pub const S_BLACKEGG_PAIN3: state = 678;
pub const S_BLACKEGG_PAIN2: state = 677;
pub const S_BLACKEGG_PAIN1: state = 676;
pub const S_BLACKEGG_SHOOT2: state = 675;
pub const S_BLACKEGG_SHOOT1: state = 674;
pub const S_BLACKEGG_WALK6: state = 673;
pub const S_BLACKEGG_WALK5: state = 672;
pub const S_BLACKEGG_WALK4: state = 671;
pub const S_BLACKEGG_WALK3: state = 670;
pub const S_BLACKEGG_WALK2: state = 669;
pub const S_BLACKEGG_WALK1: state = 668;
pub const S_BLACKEGG_STND2: state = 667;
pub const S_BLACKEGG_STND: state = 666;
pub const S_FSGND: state = 665;
pub const S_FSGNC: state = 664;
pub const S_FSGNB: state = 663;
pub const S_FSGNA: state = 662;
pub const S_TNTDUST_8: state = 661;
pub const S_TNTDUST_7: state = 660;
pub const S_TNTDUST_6: state = 659;
pub const S_TNTDUST_5: state = 658;
pub const S_TNTDUST_4: state = 657;
pub const S_TNTDUST_3: state = 656;
pub const S_TNTDUST_2: state = 655;
pub const S_TNTDUST_1: state = 654;
pub const S_FBOMB_EXPL6: state = 653;
pub const S_FBOMB_EXPL5: state = 652;
pub const S_FBOMB_EXPL4: state = 651;
pub const S_FBOMB_EXPL3: state = 650;
pub const S_FBOMB_EXPL2: state = 649;
pub const S_FBOMB_EXPL1: state = 648;
pub const S_FBOMB2: state = 647;
pub const S_FBOMB1: state = 646;
pub const S_PROJECTORLIGHT5: state = 645;
pub const S_PROJECTORLIGHT4: state = 644;
pub const S_PROJECTORLIGHT3: state = 643;
pub const S_PROJECTORLIGHT2: state = 642;
pub const S_PROJECTORLIGHT1: state = 641;
pub const S_VWREB: state = 640;
pub const S_VWREF: state = 639;
pub const S_ALART2: state = 638;
pub const S_ALART1: state = 637;
pub const S_BROKENROBOTF: state = 636;
pub const S_BROKENROBOTE: state = 635;
pub const S_BROKENROBOTD: state = 634;
pub const S_BROKENROBOTC: state = 633;
pub const S_BROKENROBOTB: state = 632;
pub const S_BROKENROBOTA: state = 631;
pub const S_BROKENROBOTRANDOM: state = 630;
pub const S_FANG_KO: state = 629;
pub const S_FANG_FLEEBOUNCE2: state = 628;
pub const S_FANG_FLEEBOUNCE1: state = 627;
pub const S_FANG_FLEEPATHING2: state = 626;
pub const S_FANG_FLEEPATHING1: state = 625;
pub const S_FANG_DIE8: state = 624;
pub const S_FANG_DIE7: state = 623;
pub const S_FANG_DIE6: state = 622;
pub const S_FANG_DIE5: state = 621;
pub const S_FANG_DIE4: state = 620;
pub const S_FANG_DIE3: state = 619;
pub const S_FANG_DIE2: state = 618;
pub const S_FANG_DIE1: state = 617;
pub const S_FANG_PINCHLOBSHOT4: state = 616;
pub const S_FANG_PINCHLOBSHOT3: state = 615;
pub const S_FANG_PINCHLOBSHOT2: state = 614;
pub const S_FANG_PINCHLOBSHOT1: state = 613;
pub const S_FANG_PINCHLOBSHOT0: state = 612;
pub const S_FANG_PINCHSKID2: state = 611;
pub const S_FANG_PINCHSKID1: state = 610;
pub const S_FANG_PINCHFALL2: state = 609;
pub const S_FANG_PINCHFALL1: state = 608;
pub const S_FANG_PINCHFALL0: state = 607;
pub const S_FANG_PINCHBOUNCE4: state = 606;
pub const S_FANG_PINCHBOUNCE3: state = 605;
pub const S_FANG_PINCHBOUNCE2: state = 604;
pub const S_FANG_PINCHBOUNCE1: state = 603;
pub const S_FANG_PINCHBOUNCE0: state = 602;
pub const S_FANG_PINCHPATHING: state = 601;
pub const S_FANG_PINCHPATHINGSTART2: state = 600;
pub const S_FANG_PINCHPATHINGSTART1: state = 599;
pub const S_FANG_WALLHIT: state = 598;
pub const S_FANG_WAIT2: state = 597;
pub const S_FANG_WAIT1: state = 596;
pub const S_FANG_LOBSHOT2: state = 595;
pub const S_FANG_LOBSHOT1: state = 594;
pub const S_FANG_LOBSHOT0: state = 593;
pub const S_FANG_FIREREPEAT: state = 592;
pub const S_FANG_FIRE4: state = 591;
pub const S_FANG_FIRE3: state = 590;
pub const S_FANG_FIRE2: state = 589;
pub const S_FANG_FIRE1: state = 588;
pub const S_FANG_FIRESTART2: state = 587;
pub const S_FANG_FIRESTART1: state = 586;
pub const S_FANG_CHOOSEATTACK: state = 585;
pub const S_FANG_SKID3: state = 584;
pub const S_FANG_SKID2: state = 583;
pub const S_FANG_SKID1: state = 582;
pub const S_FANG_PATHINGCONT3: state = 581;
pub const S_FANG_PATHINGCONT2: state = 580;
pub const S_FANG_PATHINGCONT1: state = 579;
pub const S_FANG_CHECKPATH2: state = 578;
pub const S_FANG_CHECKPATH1: state = 577;
pub const S_FANG_FALL2: state = 576;
pub const S_FANG_FALL1: state = 575;
pub const S_FANG_BOUNCE4: state = 574;
pub const S_FANG_BOUNCE3: state = 573;
pub const S_FANG_BOUNCE2: state = 572;
pub const S_FANG_BOUNCE1: state = 571;
pub const S_FANG_PATHING: state = 570;
pub const S_FANG_PATHINGSTART2: state = 569;
pub const S_FANG_PATHINGSTART1: state = 568;
pub const S_FANG_PAIN2: state = 567;
pub const S_FANG_PAIN1: state = 566;
pub const S_FANG_IDLE8: state = 565;
pub const S_FANG_IDLE7: state = 564;
pub const S_FANG_IDLE6: state = 563;
pub const S_FANG_IDLE5: state = 562;
pub const S_FANG_IDLE4: state = 561;
pub const S_FANG_IDLE3: state = 560;
pub const S_FANG_IDLE2: state = 559;
pub const S_FANG_IDLE1: state = 558;
pub const S_FANG_IDLE0: state = 557;
pub const S_FANG_CLONE4: state = 556;
pub const S_FANG_CLONE3: state = 555;
pub const S_FANG_CLONE2: state = 554;
pub const S_FANG_CLONE1: state = 553;
pub const S_FANG_INTRO12: state = 552;
pub const S_FANG_INTRO11: state = 551;
pub const S_FANG_INTRO10: state = 550;
pub const S_FANG_INTRO9: state = 549;
pub const S_FANG_INTRO8: state = 548;
pub const S_FANG_INTRO7: state = 547;
pub const S_FANG_INTRO6: state = 546;
pub const S_FANG_INTRO5: state = 545;
pub const S_FANG_INTRO4: state = 544;
pub const S_FANG_INTRO3: state = 543;
pub const S_FANG_INTRO2: state = 542;
pub const S_FANG_INTRO1: state = 541;
pub const S_FANG_INTRO0: state = 540;
pub const S_FANG_SETUP: state = 539;
pub const S_EGGROBOJET: state = 538;
pub const S_EGGROBO1_PISSED: state = 537;
pub const S_EGGROBO1_BSLAP2: state = 536;
pub const S_EGGROBO1_BSLAP1: state = 535;
pub const S_EGGROBO1_STND: state = 534;
pub const S_JETFLAME: state = 533;
pub const S_EGGMOBILE4_MACE_DIE3: state = 532;
pub const S_EGGMOBILE4_MACE_DIE2: state = 531;
pub const S_EGGMOBILE4_MACE_DIE1: state = 530;
pub const S_EGGMOBILE4_MACE: state = 529;
pub const S_EGGMOBILE4_FLEE2: state = 528;
pub const S_EGGMOBILE4_FLEE1: state = 527;
pub const S_EGGMOBILE4_DIE4: state = 526;
pub const S_EGGMOBILE4_DIE3: state = 525;
pub const S_EGGMOBILE4_DIE2: state = 524;
pub const S_EGGMOBILE4_DIE1: state = 523;
pub const S_EGGMOBILE4_PAIN2: state = 522;
pub const S_EGGMOBILE4_PAIN1: state = 521;
pub const S_EGGMOBILE4_RAISE2: state = 520;
pub const S_EGGMOBILE4_RAISE1: state = 519;
pub const S_EGGMOBILE4_RATK6: state = 518;
pub const S_EGGMOBILE4_RATK5: state = 517;
pub const S_EGGMOBILE4_RATK4: state = 516;
pub const S_EGGMOBILE4_RATK3: state = 515;
pub const S_EGGMOBILE4_RATK2: state = 514;
pub const S_EGGMOBILE4_RATK1: state = 513;
pub const S_EGGMOBILE4_LATK6: state = 512;
pub const S_EGGMOBILE4_LATK5: state = 511;
pub const S_EGGMOBILE4_LATK4: state = 510;
pub const S_EGGMOBILE4_LATK3: state = 509;
pub const S_EGGMOBILE4_LATK2: state = 508;
pub const S_EGGMOBILE4_LATK1: state = 507;
pub const S_EGGMOBILE4_STND: state = 506;
pub const S_SHOCKWAVE2: state = 505;
pub const S_SHOCKWAVE1: state = 504;
pub const S_BOSSSEBH2: state = 503;
pub const S_BOSSSEBH1: state = 502;
pub const S_FAKEMOBILE_DIE2: state = 501;
pub const S_FAKEMOBILE_DIE1: state = 500;
pub const S_FAKEMOBILE_ATK3D: state = 499;
pub const S_FAKEMOBILE_ATK3C: state = 498;
pub const S_FAKEMOBILE_ATK3B: state = 497;
pub const S_FAKEMOBILE_ATK3A: state = 496;
pub const S_FAKEMOBILE_ATK2: state = 495;
pub const S_FAKEMOBILE_ATK1: state = 494;
pub const S_FAKEMOBILE: state = 493;
pub const S_FAKEMOBILE_INIT: state = 492;
pub const S_EGGMOBILE3_FLEE2: state = 491;
pub const S_EGGMOBILE3_FLEE1: state = 490;
pub const S_EGGMOBILE3_DIE4: state = 489;
pub const S_EGGMOBILE3_DIE3: state = 488;
pub const S_EGGMOBILE3_DIE2: state = 487;
pub const S_EGGMOBILE3_DIE1: state = 486;
pub const S_EGGMOBILE3_PAIN2: state = 485;
pub const S_EGGMOBILE3_PAIN: state = 484;
pub const S_EGGMOBILE3_ROFL: state = 483;
pub const S_EGGMOBILE3_ATK5: state = 482;
pub const S_EGGMOBILE3_ATK4: state = 481;
pub const S_EGGMOBILE3_ATK3D: state = 480;
pub const S_EGGMOBILE3_ATK3C: state = 479;
pub const S_EGGMOBILE3_ATK3B: state = 478;
pub const S_EGGMOBILE3_ATK3A: state = 477;
pub const S_EGGMOBILE3_ATK2: state = 476;
pub const S_EGGMOBILE3_ATK1: state = 475;
pub const S_EGGMOBILE3_SHOCK: state = 474;
pub const S_EGGMOBILE3_STND: state = 473;
pub const S_GOOPTRAIL: state = 472;
pub const S_GOOP3: state = 471;
pub const S_GOOP2: state = 470;
pub const S_GOOP1: state = 469;
pub const S_BOSSSPIGOT: state = 468;
pub const S_BOSSTANK2: state = 467;
pub const S_BOSSTANK1: state = 466;
pub const S_EGGMOBILE2_FLEE2: state = 465;
pub const S_EGGMOBILE2_FLEE1: state = 464;
pub const S_EGGMOBILE2_DIE4: state = 463;
pub const S_EGGMOBILE2_DIE3: state = 462;
pub const S_EGGMOBILE2_DIE2: state = 461;
pub const S_EGGMOBILE2_DIE1: state = 460;
pub const S_EGGMOBILE2_PAIN2: state = 459;
pub const S_EGGMOBILE2_PAIN: state = 458;
pub const S_EGGMOBILE2_POGO7: state = 457;
pub const S_EGGMOBILE2_POGO6: state = 456;
pub const S_EGGMOBILE2_POGO5: state = 455;
pub const S_EGGMOBILE2_POGO4: state = 454;
pub const S_EGGMOBILE2_POGO3: state = 453;
pub const S_EGGMOBILE2_POGO2: state = 452;
pub const S_EGGMOBILE2_POGO1: state = 451;
pub const S_EGGMOBILE2_STND: state = 450;
pub const S_BOSSEGLZ2: state = 449;
pub const S_BOSSEGLZ1: state = 448;
pub const S_EGGMOBILE_TARGET: state = 447;
pub const S_EGGMOBILE_BALL: state = 446;
pub const S_EGGMOBILE_FLEE2: state = 445;
pub const S_EGGMOBILE_FLEE1: state = 444;
pub const S_EGGMOBILE_DIE4: state = 443;
pub const S_EGGMOBILE_DIE3: state = 442;
pub const S_EGGMOBILE_DIE2: state = 441;
pub const S_EGGMOBILE_DIE1: state = 440;
pub const S_EGGMOBILE_PAIN2: state = 439;
pub const S_EGGMOBILE_PAIN: state = 438;
pub const S_EGGMOBILE_PANIC15: state = 437;
pub const S_EGGMOBILE_PANIC14: state = 436;
pub const S_EGGMOBILE_PANIC13: state = 435;
pub const S_EGGMOBILE_PANIC12: state = 434;
pub const S_EGGMOBILE_PANIC11: state = 433;
pub const S_EGGMOBILE_PANIC10: state = 432;
pub const S_EGGMOBILE_PANIC9: state = 431;
pub const S_EGGMOBILE_PANIC8: state = 430;
pub const S_EGGMOBILE_PANIC7: state = 429;
pub const S_EGGMOBILE_PANIC6: state = 428;
pub const S_EGGMOBILE_PANIC5: state = 427;
pub const S_EGGMOBILE_PANIC4: state = 426;
pub const S_EGGMOBILE_PANIC3: state = 425;
pub const S_EGGMOBILE_PANIC2: state = 424;
pub const S_EGGMOBILE_PANIC1: state = 423;
pub const S_EGGMOBILE_RATK9: state = 422;
pub const S_EGGMOBILE_RATK8: state = 421;
pub const S_EGGMOBILE_RATK7: state = 420;
pub const S_EGGMOBILE_RATK6: state = 419;
pub const S_EGGMOBILE_RATK5: state = 418;
pub const S_EGGMOBILE_RATK4: state = 417;
pub const S_EGGMOBILE_RATK3: state = 416;
pub const S_EGGMOBILE_RATK2: state = 415;
pub const S_EGGMOBILE_RATK1: state = 414;
pub const S_EGGMOBILE_LATK9: state = 413;
pub const S_EGGMOBILE_LATK8: state = 412;
pub const S_EGGMOBILE_LATK7: state = 411;
pub const S_EGGMOBILE_LATK6: state = 410;
pub const S_EGGMOBILE_LATK5: state = 409;
pub const S_EGGMOBILE_LATK4: state = 408;
pub const S_EGGMOBILE_LATK3: state = 407;
pub const S_EGGMOBILE_LATK2: state = 406;
pub const S_EGGMOBILE_LATK1: state = 405;
pub const S_EGGMOBILE_ROFL: state = 404;
pub const S_EGGMOBILE_STND: state = 403;
pub const S_JETFUME1: state = 402;
pub const S_SONIC3KBOSSEXPLOSION6: state = 401;
pub const S_SONIC3KBOSSEXPLOSION5: state = 400;
pub const S_SONIC3KBOSSEXPLOSION4: state = 399;
pub const S_SONIC3KBOSSEXPLOSION3: state = 398;
pub const S_SONIC3KBOSSEXPLOSION2: state = 397;
pub const S_SONIC3KBOSSEXPLOSION1: state = 396;
pub const S_BOSSEXPLODE: state = 395;
pub const S_DRAGONMINE_FASTLOOP: state = 394;
pub const S_DRAGONMINE_FASTFLASH2: state = 393;
pub const S_DRAGONMINE_FASTFLASH1: state = 392;
pub const S_DRAGONMINE_SLOWLOOP: state = 391;
pub const S_DRAGONMINE_SLOWFLASH2: state = 390;
pub const S_DRAGONMINE_SLOWFLASH1: state = 389;
pub const S_DRAGONMINE_LAND2: state = 388;
pub const S_DRAGONMINE_LAND1: state = 387;
pub const S_DRAGONMINE: state = 386;
pub const S_DRAGONTAIL_RELOAD: state = 385;
pub const S_DRAGONTAIL_EMPTYLOOP: state = 384;
pub const S_DRAGONTAIL_EMPTY: state = 383;
pub const S_DRAGONTAIL_LOADED: state = 382;
pub const S_DRAGONWING4: state = 381;
pub const S_DRAGONWING3: state = 380;
pub const S_DRAGONWING2: state = 379;
pub const S_DRAGONWING1: state = 378;
pub const S_DRAGONBOMBER: state = 377;
pub const S_PTERABYTE_SWOOPUP: state = 376;
pub const S_PTERABYTE_SWOOPDOWN: state = 375;
pub const S_PTERABYTE_FLY4: state = 374;
pub const S_PTERABYTE_FLY3: state = 373;
pub const S_PTERABYTE_FLY2: state = 372;
pub const S_PTERABYTE_FLY1: state = 371;
pub const S_PTERABYTEWAYPOINT: state = 370;
pub const S_PTERABYTESPAWNER: state = 369;
pub const S_PYREFIRE2: state = 368;
pub const S_PYREFIRE1: state = 367;
pub const S_PYREFLY_BURN: state = 366;
pub const S_PYREFLY_FLY: state = 365;
pub const S_CANARIVOREGAS_8: state = 364;
pub const S_CANARIVOREGAS_7: state = 363;
pub const S_CANARIVOREGAS_6: state = 362;
pub const S_CANARIVOREGAS_5: state = 361;
pub const S_CANARIVOREGAS_4: state = 360;
pub const S_CANARIVOREGAS_3: state = 359;
pub const S_CANARIVOREGAS_2: state = 358;
pub const S_CANARIVOREGAS_1: state = 357;
pub const S_CANARIVORE_CLOSE2: state = 356;
pub const S_CANARIVORE_CLOSE1: state = 355;
pub const S_CANARIVORE_GASREPEAT: state = 354;
pub const S_CANARIVORE_GAS5: state = 353;
pub const S_CANARIVORE_GAS4: state = 352;
pub const S_CANARIVORE_GAS3: state = 351;
pub const S_CANARIVORE_GAS2: state = 350;
pub const S_CANARIVORE_GAS1: state = 349;
pub const S_CANARIVORE_AWAKEN3: state = 348;
pub const S_CANARIVORE_AWAKEN2: state = 347;
pub const S_CANARIVORE_AWAKEN1: state = 346;
pub const S_CANARIVORE_LOOK: state = 345;
pub const S_UNIDUS_BALL: state = 344;
pub const S_UNIDUS_RUN: state = 343;
pub const S_UNIDUS_STND: state = 342;
pub const S_YSHELL_SPRING4: state = 341;
pub const S_YSHELL_SPRING3: state = 340;
pub const S_YSHELL_SPRING2: state = 339;
pub const S_YSHELL_SPRING1: state = 338;
pub const S_YSHELL_RUN4: state = 337;
pub const S_YSHELL_RUN3: state = 336;
pub const S_YSHELL_RUN2: state = 335;
pub const S_YSHELL_RUN1: state = 334;
pub const S_YSHELL_STND: state = 333;
pub const S_SSHELL_SPRING4: state = 332;
pub const S_SSHELL_SPRING3: state = 331;
pub const S_SSHELL_SPRING2: state = 330;
pub const S_SSHELL_SPRING1: state = 329;
pub const S_SSHELL_RUN4: state = 328;
pub const S_SSHELL_RUN3: state = 327;
pub const S_SSHELL_RUN2: state = 326;
pub const S_SSHELL_RUN1: state = 325;
pub const S_SSHELL_STND: state = 324;
pub const S_MINUSDIRT7: state = 323;
pub const S_MINUSDIRT6: state = 322;
pub const S_MINUSDIRT5: state = 321;
pub const S_MINUSDIRT4: state = 320;
pub const S_MINUSDIRT3: state = 319;
pub const S_MINUSDIRT2: state = 318;
pub const S_MINUSDIRT1: state = 317;
pub const S_MINUS_AERIAL4: state = 316;
pub const S_MINUS_AERIAL3: state = 315;
pub const S_MINUS_AERIAL2: state = 314;
pub const S_MINUS_AERIAL1: state = 313;
pub const S_MINUS_POPUP: state = 312;
pub const S_MINUS_BURST5: state = 311;
pub const S_MINUS_BURST4: state = 310;
pub const S_MINUS_BURST3: state = 309;
pub const S_MINUS_BURST2: state = 308;
pub const S_MINUS_BURST1: state = 307;
pub const S_MINUS_BURST0: state = 306;
pub const S_MINUS_DIGGING4: state = 305;
pub const S_MINUS_DIGGING3: state = 304;
pub const S_MINUS_DIGGING2: state = 303;
pub const S_MINUS_DIGGING1: state = 302;
pub const S_MINUS_STND: state = 301;
pub const S_MINUS_INIT: state = 300;
pub const S_SNAPPER_HEAD: state = 299;
pub const S_SNAPPER_LEGRAISE: state = 298;
pub const S_SNAPPER_LEG: state = 297;
pub const S_SNAPPER_XPLD: state = 296;
pub const S_GSNAPPER4: state = 295;
pub const S_GSNAPPER3: state = 294;
pub const S_GSNAPPER2: state = 293;
pub const S_GSNAPPER1: state = 292;
pub const S_GSNAPPER_STND: state = 291;
pub const S_SNAPPER_SPAWN2: state = 290;
pub const S_SNAPPER_SPAWN: state = 289;
pub const S_EGGSHIELDBREAK: state = 288;
pub const S_EGGSHIELD: state = 287;
pub const S_EGGGUARD_RUN4: state = 286;
pub const S_EGGGUARD_RUN3: state = 285;
pub const S_EGGGUARD_RUN2: state = 284;
pub const S_EGGGUARD_RUN1: state = 283;
pub const S_EGGGUARD_MAD3: state = 282;
pub const S_EGGGUARD_MAD2: state = 281;
pub const S_EGGGUARD_MAD1: state = 280;
pub const S_EGGGUARD_WALK4: state = 279;
pub const S_EGGGUARD_WALK3: state = 278;
pub const S_EGGGUARD_WALK2: state = 277;
pub const S_EGGGUARD_WALK1: state = 276;
pub const S_EGGGUARD_STND: state = 275;
pub const S_FACESTABBERSPEAR: state = 274;
pub const S_FACESTABBER_DIE3: state = 273;
pub const S_FACESTABBER_DIE2: state = 272;
pub const S_FACESTABBER_DIE1: state = 271;
pub const S_FACESTABBER_PAIN: state = 270;
pub const S_FACESTABBER_CHARGE4: state = 269;
pub const S_FACESTABBER_CHARGE3: state = 268;
pub const S_FACESTABBER_CHARGE2: state = 267;
pub const S_FACESTABBER_CHARGE1: state = 266;
pub const S_FACESTABBER_STND6: state = 265;
pub const S_FACESTABBER_STND5: state = 264;
pub const S_FACESTABBER_STND4: state = 263;
pub const S_FACESTABBER_STND3: state = 262;
pub const S_FACESTABBER_STND2: state = 261;
pub const S_FACESTABBER_STND1: state = 260;
pub const S_ROBOHOOD_JUMP3: state = 259;
pub const S_ROBOHOOD_JUMP2: state = 258;
pub const S_ROBOHOOD_JUMP1: state = 257;
pub const S_ROBOHOOD_FIRE2: state = 256;
pub const S_ROBOHOOD_FIRE1: state = 255;
pub const S_ROBOHOOD_STAND: state = 254;
pub const S_ROBOHOOD_LOOK: state = 253;
pub const S_POINTYBALL1: state = 252;
pub const S_POINTY1: state = 251;
pub const S_VULTURE_STUNNED: state = 250;
pub const S_VULTURE_ZOOM2: state = 249;
pub const S_VULTURE_ZOOM1: state = 248;
pub const S_VULTURE_DRIFT: state = 247;
pub const S_VULTURE_STND: state = 246;
pub const S_SNAILER_FLICKY: state = 245;
pub const S_SNAILER1: state = 244;
pub const S_JETJAW_SOUND: state = 243;
pub const S_JETJAW_CHOMP16: state = 242;
pub const S_JETJAW_CHOMP15: state = 241;
pub const S_JETJAW_CHOMP14: state = 240;
pub const S_JETJAW_CHOMP13: state = 239;
pub const S_JETJAW_CHOMP12: state = 238;
pub const S_JETJAW_CHOMP11: state = 237;
pub const S_JETJAW_CHOMP10: state = 236;
pub const S_JETJAW_CHOMP9: state = 235;
pub const S_JETJAW_CHOMP8: state = 234;
pub const S_JETJAW_CHOMP7: state = 233;
pub const S_JETJAW_CHOMP6: state = 232;
pub const S_JETJAW_CHOMP5: state = 231;
pub const S_JETJAW_CHOMP4: state = 230;
pub const S_JETJAW_CHOMP3: state = 229;
pub const S_JETJAW_CHOMP2: state = 228;
pub const S_JETJAW_CHOMP1: state = 227;
pub const S_JETJAW_ROAM8: state = 226;
pub const S_JETJAW_ROAM7: state = 225;
pub const S_JETJAW_ROAM6: state = 224;
pub const S_JETJAW_ROAM5: state = 223;
pub const S_JETJAW_ROAM4: state = 222;
pub const S_JETJAW_ROAM3: state = 221;
pub const S_JETJAW_ROAM2: state = 220;
pub const S_JETJAW_ROAM1: state = 219;
pub const S_CDIAG8: state = 218;
pub const S_CDIAG7: state = 217;
pub const S_CDIAG6: state = 216;
pub const S_CDIAG5: state = 215;
pub const S_CDIAG4: state = 214;
pub const S_CDIAG3: state = 213;
pub const S_CDIAG2: state = 212;
pub const S_CDIAG1: state = 211;
pub const S_BANPYURA_ROAMPAUSE: state = 210;
pub const S_BANPYURA_ROAM4: state = 209;
pub const S_BANPYURA_ROAM3: state = 208;
pub const S_BANPYURA_ROAM2: state = 207;
pub const S_BANPYURA_ROAM1: state = 206;
pub const S_CRUSHCHAIN: state = 205;
pub const S_CRUSHCLAW_WAIT: state = 204;
pub const S_CRUSHCLAW_IN: state = 203;
pub const S_CRUSHCLAW_STAY: state = 202;
pub const S_CRUSHCLAW_OUT: state = 201;
pub const S_CRUSHCLAW_AIM: state = 200;
pub const S_CRUSHSTACEAN_PUNCH2: state = 199;
pub const S_CRUSHSTACEAN_PUNCH1: state = 198;
pub const S_CRUSHSTACEAN_ROAMPAUSE: state = 197;
pub const S_CRUSHSTACEAN_ROAM4: state = 196;
pub const S_CRUSHSTACEAN_ROAM3: state = 195;
pub const S_CRUSHSTACEAN_ROAM2: state = 194;
pub const S_CRUSHSTACEAN_ROAM1: state = 193;
pub const S_SPINCUSHION_STOP4: state = 192;
pub const S_SPINCUSHION_STOP3: state = 191;
pub const S_SPINCUSHION_STOP2: state = 190;
pub const S_SPINCUSHION_STOP1: state = 189;
pub const S_SPINCUSHION_SPIN4: state = 188;
pub const S_SPINCUSHION_SPIN3: state = 187;
pub const S_SPINCUSHION_SPIN2: state = 186;
pub const S_SPINCUSHION_SPIN1: state = 185;
pub const S_SPINCUSHION_AIM5: state = 184;
pub const S_SPINCUSHION_AIM4: state = 183;
pub const S_SPINCUSHION_AIM3: state = 182;
pub const S_SPINCUSHION_AIM2: state = 181;
pub const S_SPINCUSHION_AIM1: state = 180;
pub const S_SPINCUSHION_CHASE4: state = 179;
pub const S_SPINCUSHION_CHASE3: state = 178;
pub const S_SPINCUSHION_CHASE2: state = 177;
pub const S_SPINCUSHION_CHASE1: state = 176;
pub const S_SPINCUSHION_LOOK: state = 175;
pub const S_TURRETPOPDOWN8: state = 174;
pub const S_TURRETPOPDOWN7: state = 173;
pub const S_TURRETPOPDOWN6: state = 172;
pub const S_TURRETPOPDOWN5: state = 171;
pub const S_TURRETPOPDOWN4: state = 170;
pub const S_TURRETPOPDOWN3: state = 169;
pub const S_TURRETPOPDOWN2: state = 168;
pub const S_TURRETPOPDOWN1: state = 167;
pub const S_TURRETSHOOT: state = 166;
pub const S_TURRETPOPUP8: state = 165;
pub const S_TURRETPOPUP7: state = 164;
pub const S_TURRETPOPUP6: state = 163;
pub const S_TURRETPOPUP5: state = 162;
pub const S_TURRETPOPUP4: state = 161;
pub const S_TURRETPOPUP3: state = 160;
pub const S_TURRETPOPUP2: state = 159;
pub const S_TURRETPOPUP1: state = 158;
pub const S_TURRETSEE: state = 157;
pub const S_TURRETLOOK: state = 156;
pub const S_TURRETSHOCK9: state = 155;
pub const S_TURRETSHOCK8: state = 154;
pub const S_TURRETSHOCK7: state = 153;
pub const S_TURRETSHOCK6: state = 152;
pub const S_TURRETSHOCK5: state = 151;
pub const S_TURRETSHOCK4: state = 150;
pub const S_TURRETSHOCK3: state = 149;
pub const S_TURRETSHOCK2: state = 148;
pub const S_TURRETSHOCK1: state = 147;
pub const S_TURRETFIRE: state = 146;
pub const S_TURRET: state = 145;
pub const S_SKIM4: state = 144;
pub const S_SKIM3: state = 143;
pub const S_SKIM2: state = 142;
pub const S_SKIM1: state = 141;
pub const S_DETON15: state = 140;
pub const S_DETON14: state = 139;
pub const S_DETON13: state = 138;
pub const S_DETON12: state = 137;
pub const S_DETON11: state = 136;
pub const S_DETON10: state = 135;
pub const S_DETON9: state = 134;
pub const S_DETON8: state = 133;
pub const S_DETON7: state = 132;
pub const S_DETON6: state = 131;
pub const S_DETON5: state = 130;
pub const S_DETON4: state = 129;
pub const S_DETON3: state = 128;
pub const S_DETON2: state = 127;
pub const S_DETON1: state = 126;
pub const S_CCOMMAND4: state = 125;
pub const S_CCOMMAND3: state = 124;
pub const S_CCOMMAND2: state = 123;
pub const S_CCOMMAND1: state = 122;
pub const S_JETGSHOOT2: state = 121;
pub const S_JETGSHOOT1: state = 120;
pub const S_JETGZOOM2: state = 119;
pub const S_JETGZOOM1: state = 118;
pub const S_JETGLOOK2: state = 117;
pub const S_JETGLOOK1: state = 116;
pub const S_JETBZOOM2: state = 115;
pub const S_JETBZOOM1: state = 114;
pub const S_JETBLOOK2: state = 113;
pub const S_JETBLOOK1: state = 112;
pub const S_RBUZZFLY2: state = 111;
pub const S_RBUZZFLY1: state = 110;
pub const S_RBUZZLOOK2: state = 109;
pub const S_RBUZZLOOK1: state = 108;
pub const S_BUZZFLY2: state = 107;
pub const S_BUZZFLY1: state = 106;
pub const S_BUZZLOOK2: state = 105;
pub const S_BUZZLOOK1: state = 104;
pub const S_FISH4: state = 103;
pub const S_FISH3: state = 102;
pub const S_FISH2: state = 101;
pub const S_FISH1: state = 100;
pub const S_SPOS_RUN6: state = 99;
pub const S_SPOS_RUN5: state = 98;
pub const S_SPOS_RUN4: state = 97;
pub const S_SPOS_RUN3: state = 96;
pub const S_SPOS_RUN2: state = 95;
pub const S_SPOS_RUN1: state = 94;
pub const S_SPOS_STND: state = 93;
pub const S_POSS_RUN6: state = 92;
pub const S_POSS_RUN5: state = 91;
pub const S_POSS_RUN4: state = 90;
pub const S_POSS_RUN3: state = 89;
pub const S_POSS_RUN2: state = 88;
pub const S_POSS_RUN1: state = 87;
pub const S_POSS_STND: state = 86;
pub const S_JETFUMEFLASH: state = 85;
pub const S_TAILSOVERLAY_DASH: state = 84;
pub const S_TAILSOVERLAY_EDGE: state = 83;
pub const S_TAILSOVERLAY_GASP: state = 82;
pub const S_TAILSOVERLAY_PAIN: state = 81;
pub const S_TAILSOVERLAY_TIRE: state = 80;
pub const S_TAILSOVERLAY_FLY: state = 79;
pub const S_TAILSOVERLAY_RUN: state = 78;
pub const S_TAILSOVERLAY_MINUS60DEGREES: state = 77;
pub const S_TAILSOVERLAY_MINUS30DEGREES: state = 76;
pub const S_TAILSOVERLAY_PLUS60DEGREES: state = 75;
pub const S_TAILSOVERLAY_PLUS30DEGREES: state = 74;
pub const S_TAILSOVERLAY_0DEGREES: state = 73;
pub const S_TAILSOVERLAY_STAND: state = 72;
pub const S_PLAY_NIGHTS_ATTACK: state = 71;
pub const S_PLAY_NIGHTS_PULL: state = 70;
pub const S_PLAY_NIGHTS_STUN: state = 69;
pub const S_PLAY_NIGHTS_DRILL: state = 68;
pub const S_PLAY_NIGHTS_FLY: state = 67;
pub const S_PLAY_NIGHTS_FLOAT: state = 66;
pub const S_PLAY_NIGHTS_STAND: state = 65;
pub const S_PLAY_NIGHTS_TRANS6: state = 64;
pub const S_PLAY_NIGHTS_TRANS5: state = 63;
pub const S_PLAY_NIGHTS_TRANS4: state = 62;
pub const S_PLAY_NIGHTS_TRANS3: state = 61;
pub const S_PLAY_NIGHTS_TRANS2: state = 60;
pub const S_PLAY_NIGHTS_TRANS1: state = 59;
pub const S_PLAY_SIGN: state = 58;
pub const S_PLAY_ICON3: state = 57;
pub const S_PLAY_ICON2: state = 56;
pub const S_PLAY_ICON1: state = 55;
pub const S_PLAY_BOX2: state = 54;
pub const S_PLAY_BOX1: state = 53;
pub const S_OBJPLACE_DUMMY: state = 52;
pub const S_PLAY_SUPER_TRANS6: state = 51;
pub const S_PLAY_SUPER_TRANS5: state = 50;
pub const S_PLAY_SUPER_TRANS4: state = 49;
pub const S_PLAY_SUPER_TRANS3: state = 48;
pub const S_PLAY_SUPER_TRANS2: state = 47;
pub const S_PLAY_SUPER_TRANS1: state = 46;
pub const S_PLAY_MELEE_LANDING: state = 45;
pub const S_PLAY_MELEE_FINISH: state = 44;
pub const S_PLAY_MELEE: state = 43;
pub const S_PLAY_TWINSPIN: state = 42;
pub const S_PLAY_FIRE_FINISH: state = 41;
pub const S_PLAY_FIRE: state = 40;
pub const S_PLAY_BOUNCE_LANDING: state = 39;
pub const S_PLAY_BOUNCE: state = 38;
pub const S_PLAY_FLOAT_RUN: state = 37;
pub const S_PLAY_FLOAT: state = 36;
pub const S_PLAY_CLIMB: state = 35;
pub const S_PLAY_CLING: state = 34;
pub const S_PLAY_GLIDE_LANDING: state = 33;
pub const S_PLAY_GLIDE: state = 32;
pub const S_PLAY_FLY_TIRED: state = 31;
pub const S_PLAY_SWIM: state = 30;
pub const S_PLAY_FLY: state = 29;
pub const S_PLAY_SPINDASH: state = 28;
pub const S_PLAY_RIDE: state = 27;
pub const S_PLAY_EDGE: state = 26;
pub const S_PLAY_FALL: state = 25;
pub const S_PLAY_SPRING: state = 24;
pub const S_PLAY_JUMP: state = 23;
pub const S_PLAY_GASP: state = 22;
pub const S_PLAY_ROLL: state = 21;
pub const S_PLAY_DRWN: state = 20;
pub const S_PLAY_DEAD: state = 19;
pub const S_PLAY_STUN: state = 18;
pub const S_PLAY_PAIN: state = 17;
pub const S_PLAY_DASH: state = 16;
pub const S_PLAY_RUN: state = 15;
pub const S_PLAY_SKID: state = 14;
pub const S_PLAY_WALK: state = 13;
pub const S_PLAY_WAIT: state = 12;
pub const S_PLAY_STND: state = 11;
pub const S_THOK: state = 10;
pub const S_RAISESTATE: state = 9;
pub const S_XDEATHSTATE: state = 8;
pub const S_DEATHSTATE: state = 7;
pub const S_MISSILESTATE: state = 6;
pub const S_MELEESTATE: state = 5;
pub const S_SEESTATE: state = 4;
pub const S_SPAWNSTATE: state = 3;
pub const S_INVISIBLE: state = 2;
pub const S_UNKNOWN: state = 1;
pub const S_NULL: state = 0;
pub type sfxenum_t = libc::c_uint;
pub const NUMSFX: sfxenum_t = 3008;
pub const sfx_lastskinsoundslot: sfxenum_t = 3007;
pub const sfx_skinsoundslot0: sfxenum_t = 2336;
pub const sfx_lastfreeslot: sfxenum_t = 2335;
pub const sfx_freeslot0: sfxenum_t = 736;
pub const sfx_kc6e: sfxenum_t = 735;
pub const sfx_kc6d: sfxenum_t = 734;
pub const sfx_kc6c: sfxenum_t = 733;
pub const sfx_kc6b: sfxenum_t = 732;
pub const sfx_kc69: sfxenum_t = 731;
pub const sfx_kc68: sfxenum_t = 730;
pub const sfx_kc67: sfxenum_t = 729;
pub const sfx_kc66: sfxenum_t = 728;
pub const sfx_kc65: sfxenum_t = 727;
pub const sfx_kc64: sfxenum_t = 726;
pub const sfx_kc63: sfxenum_t = 725;
pub const sfx_kc62: sfxenum_t = 724;
pub const sfx_kc61: sfxenum_t = 723;
pub const sfx_kc60: sfxenum_t = 722;
pub const sfx_kc5f: sfxenum_t = 721;
pub const sfx_kc5e: sfxenum_t = 720;
pub const sfx_kc5d: sfxenum_t = 719;
pub const sfx_kc5c: sfxenum_t = 718;
pub const sfx_kc5b: sfxenum_t = 717;
pub const sfx_kc5a: sfxenum_t = 716;
pub const sfx_kc59: sfxenum_t = 715;
pub const sfx_kc58: sfxenum_t = 714;
pub const sfx_kc57: sfxenum_t = 713;
pub const sfx_kc56: sfxenum_t = 712;
pub const sfx_kc55: sfxenum_t = 711;
pub const sfx_kc54: sfxenum_t = 710;
pub const sfx_kc53: sfxenum_t = 709;
pub const sfx_kc52: sfxenum_t = 708;
pub const sfx_kc51: sfxenum_t = 707;
pub const sfx_kc50: sfxenum_t = 706;
pub const sfx_kc4f: sfxenum_t = 705;
pub const sfx_kc4e: sfxenum_t = 704;
pub const sfx_kc4d: sfxenum_t = 703;
pub const sfx_kc4c: sfxenum_t = 702;
pub const sfx_kc4b: sfxenum_t = 701;
pub const sfx_kc4a: sfxenum_t = 700;
pub const sfx_kc49: sfxenum_t = 699;
pub const sfx_kc48: sfxenum_t = 698;
pub const sfx_kc47: sfxenum_t = 697;
pub const sfx_kc46: sfxenum_t = 696;
pub const sfx_kc45: sfxenum_t = 695;
pub const sfx_kc44: sfxenum_t = 694;
pub const sfx_kc43: sfxenum_t = 693;
pub const sfx_kc42: sfxenum_t = 692;
pub const sfx_kc41: sfxenum_t = 691;
pub const sfx_kc40: sfxenum_t = 690;
pub const sfx_kc3f: sfxenum_t = 689;
pub const sfx_kc3e: sfxenum_t = 688;
pub const sfx_kc3d: sfxenum_t = 687;
pub const sfx_kc3c: sfxenum_t = 686;
pub const sfx_kc3b: sfxenum_t = 685;
pub const sfx_kc3a: sfxenum_t = 684;
pub const sfx_kc39: sfxenum_t = 683;
pub const sfx_kc38: sfxenum_t = 682;
pub const sfx_kc37: sfxenum_t = 681;
pub const sfx_kc36: sfxenum_t = 680;
pub const sfx_kc35: sfxenum_t = 679;
pub const sfx_kc34: sfxenum_t = 678;
pub const sfx_kc33: sfxenum_t = 677;
pub const sfx_kc32: sfxenum_t = 676;
pub const sfx_kc31: sfxenum_t = 675;
pub const sfx_kc30: sfxenum_t = 674;
pub const sfx_kc2f: sfxenum_t = 673;
pub const sfx_kc2e: sfxenum_t = 672;
pub const sfx_kc2d: sfxenum_t = 671;
pub const sfx_kc2c: sfxenum_t = 670;
pub const sfx_kc2b: sfxenum_t = 669;
pub const sfx_kc2a: sfxenum_t = 668;
pub const sfx_cdpcm9: sfxenum_t = 667;
pub const sfx_cdpcm8: sfxenum_t = 666;
pub const sfx_cdpcm7: sfxenum_t = 665;
pub const sfx_cdpcm6: sfxenum_t = 664;
pub const sfx_cdpcm5: sfxenum_t = 663;
pub const sfx_cdpcm4: sfxenum_t = 662;
pub const sfx_cdpcm3: sfxenum_t = 661;
pub const sfx_cdpcm2: sfxenum_t = 660;
pub const sfx_cdpcm1: sfxenum_t = 659;
pub const sfx_cdpcm0: sfxenum_t = 658;
pub const sfx_cdfm79: sfxenum_t = 657;
pub const sfx_cdfm78: sfxenum_t = 656;
pub const sfx_cdfm77: sfxenum_t = 655;
pub const sfx_cdfm76: sfxenum_t = 654;
pub const sfx_cdfm75: sfxenum_t = 653;
pub const sfx_cdfm74: sfxenum_t = 652;
pub const sfx_cdfm73: sfxenum_t = 651;
pub const sfx_cdfm72: sfxenum_t = 650;
pub const sfx_cdfm71: sfxenum_t = 649;
pub const sfx_cdfm70: sfxenum_t = 648;
pub const sfx_cdfm69: sfxenum_t = 647;
pub const sfx_cdfm68: sfxenum_t = 646;
pub const sfx_cdfm67: sfxenum_t = 645;
pub const sfx_cdfm66: sfxenum_t = 644;
pub const sfx_cdfm65: sfxenum_t = 643;
pub const sfx_cdfm64: sfxenum_t = 642;
pub const sfx_cdfm63: sfxenum_t = 641;
pub const sfx_cdfm62: sfxenum_t = 640;
pub const sfx_cdfm61: sfxenum_t = 639;
pub const sfx_cdfm60: sfxenum_t = 638;
pub const sfx_cdfm59: sfxenum_t = 637;
pub const sfx_cdfm58: sfxenum_t = 636;
pub const sfx_cdfm57: sfxenum_t = 635;
pub const sfx_cdfm56: sfxenum_t = 634;
pub const sfx_cdfm55: sfxenum_t = 633;
pub const sfx_cdfm54: sfxenum_t = 632;
pub const sfx_cdfm53: sfxenum_t = 631;
pub const sfx_cdfm52: sfxenum_t = 630;
pub const sfx_cdfm51: sfxenum_t = 629;
pub const sfx_cdfm50: sfxenum_t = 628;
pub const sfx_cdfm49: sfxenum_t = 627;
pub const sfx_cdfm48: sfxenum_t = 626;
pub const sfx_cdfm47: sfxenum_t = 625;
pub const sfx_cdfm46: sfxenum_t = 624;
pub const sfx_cdfm45: sfxenum_t = 623;
pub const sfx_cdfm44: sfxenum_t = 622;
pub const sfx_cdfm43: sfxenum_t = 621;
pub const sfx_cdfm42: sfxenum_t = 620;
pub const sfx_cdfm41: sfxenum_t = 619;
pub const sfx_cdfm40: sfxenum_t = 618;
pub const sfx_cdfm39: sfxenum_t = 617;
pub const sfx_cdfm38: sfxenum_t = 616;
pub const sfx_cdfm37: sfxenum_t = 615;
pub const sfx_cdfm36: sfxenum_t = 614;
pub const sfx_cdfm35: sfxenum_t = 613;
pub const sfx_cdfm34: sfxenum_t = 612;
pub const sfx_cdfm33: sfxenum_t = 611;
pub const sfx_cdfm32: sfxenum_t = 610;
pub const sfx_cdfm31: sfxenum_t = 609;
pub const sfx_cdfm30: sfxenum_t = 608;
pub const sfx_cdfm29: sfxenum_t = 607;
pub const sfx_cdfm28: sfxenum_t = 606;
pub const sfx_cdfm27: sfxenum_t = 605;
pub const sfx_cdfm26: sfxenum_t = 604;
pub const sfx_cdfm25: sfxenum_t = 603;
pub const sfx_cdfm24: sfxenum_t = 602;
pub const sfx_cdfm23: sfxenum_t = 601;
pub const sfx_cdfm22: sfxenum_t = 600;
pub const sfx_cdfm21: sfxenum_t = 599;
pub const sfx_cdfm20: sfxenum_t = 598;
pub const sfx_cdfm19: sfxenum_t = 597;
pub const sfx_cdfm18: sfxenum_t = 596;
pub const sfx_cdfm17: sfxenum_t = 595;
pub const sfx_cdfm16: sfxenum_t = 594;
pub const sfx_cdfm15: sfxenum_t = 593;
pub const sfx_cdfm14: sfxenum_t = 592;
pub const sfx_cdfm13: sfxenum_t = 591;
pub const sfx_cdfm12: sfxenum_t = 590;
pub const sfx_cdfm11: sfxenum_t = 589;
pub const sfx_cdfm10: sfxenum_t = 588;
pub const sfx_cdfm09: sfxenum_t = 587;
pub const sfx_cdfm08: sfxenum_t = 586;
pub const sfx_cdfm07: sfxenum_t = 585;
pub const sfx_cdfm06: sfxenum_t = 584;
pub const sfx_cdfm05: sfxenum_t = 583;
pub const sfx_cdfm04: sfxenum_t = 582;
pub const sfx_cdfm03: sfxenum_t = 581;
pub const sfx_cdfm02: sfxenum_t = 580;
pub const sfx_cdfm01: sfxenum_t = 579;
pub const sfx_cdfm00: sfxenum_t = 578;
pub const sfx_3db16: sfxenum_t = 577;
pub const sfx_3db14: sfxenum_t = 576;
pub const sfx_3db09: sfxenum_t = 575;
pub const sfx_3db06: sfxenum_t = 574;
pub const sfx_s3kdbl: sfxenum_t = 573;
pub const sfx_s3kdbs: sfxenum_t = 572;
pub const sfx_s3kdal: sfxenum_t = 571;
pub const sfx_s3kdas: sfxenum_t = 570;
pub const sfx_s3kd9l: sfxenum_t = 569;
pub const sfx_s3kd9s: sfxenum_t = 568;
pub const sfx_s3kd8l: sfxenum_t = 567;
pub const sfx_s3kd8s: sfxenum_t = 566;
pub const sfx_s3kd7l: sfxenum_t = 565;
pub const sfx_s3kd7s: sfxenum_t = 564;
pub const sfx_s3kd6l: sfxenum_t = 563;
pub const sfx_s3kd6s: sfxenum_t = 562;
pub const sfx_s3kd5l: sfxenum_t = 561;
pub const sfx_s3kd5s: sfxenum_t = 560;
pub const sfx_s3kd4l: sfxenum_t = 559;
pub const sfx_s3kd4s: sfxenum_t = 558;
pub const sfx_s3kd3l: sfxenum_t = 557;
pub const sfx_s3kd3s: sfxenum_t = 556;
pub const sfx_s3kd2l: sfxenum_t = 555;
pub const sfx_s3kd2s: sfxenum_t = 554;
pub const sfx_s3kd1l: sfxenum_t = 553;
pub const sfx_s3kd1s: sfxenum_t = 552;
pub const sfx_s3kd0l: sfxenum_t = 551;
pub const sfx_s3kd0s: sfxenum_t = 550;
pub const sfx_s3kcfl: sfxenum_t = 549;
pub const sfx_s3kcfs: sfxenum_t = 548;
pub const sfx_s3kcel: sfxenum_t = 547;
pub const sfx_s3kces: sfxenum_t = 546;
pub const sfx_s3kcdl: sfxenum_t = 545;
pub const sfx_s3kcds: sfxenum_t = 544;
pub const sfx_s3kccl: sfxenum_t = 543;
pub const sfx_s3kccs: sfxenum_t = 542;
pub const sfx_s3kcbl: sfxenum_t = 541;
pub const sfx_s3kcbs: sfxenum_t = 540;
pub const sfx_s3kcal: sfxenum_t = 539;
pub const sfx_s3kcas: sfxenum_t = 538;
pub const sfx_s3kc9l: sfxenum_t = 537;
pub const sfx_s3kc9s: sfxenum_t = 536;
pub const sfx_s3kc8l: sfxenum_t = 535;
pub const sfx_s3kc8s: sfxenum_t = 534;
pub const sfx_s3kc7l: sfxenum_t = 533;
pub const sfx_s3kc7s: sfxenum_t = 532;
pub const sfx_s3kc6l: sfxenum_t = 531;
pub const sfx_s3kc6s: sfxenum_t = 530;
pub const sfx_s3kc5l: sfxenum_t = 529;
pub const sfx_s3kc5s: sfxenum_t = 528;
pub const sfx_s3kc4l: sfxenum_t = 527;
pub const sfx_s3kc4s: sfxenum_t = 526;
pub const sfx_s3kc3l: sfxenum_t = 525;
pub const sfx_s3kc3s: sfxenum_t = 524;
pub const sfx_s3kc2l: sfxenum_t = 523;
pub const sfx_s3kc2s: sfxenum_t = 522;
pub const sfx_s3kc1l: sfxenum_t = 521;
pub const sfx_s3kc1s: sfxenum_t = 520;
pub const sfx_s3kc0l: sfxenum_t = 519;
pub const sfx_s3kc0s: sfxenum_t = 518;
pub const sfx_s3kbfl: sfxenum_t = 517;
pub const sfx_s3kbfs: sfxenum_t = 516;
pub const sfx_s3kbel: sfxenum_t = 515;
pub const sfx_s3kbes: sfxenum_t = 514;
pub const sfx_s3kbdl: sfxenum_t = 513;
pub const sfx_s3kbds: sfxenum_t = 512;
pub const sfx_s3kbcl: sfxenum_t = 511;
pub const sfx_s3kbcs: sfxenum_t = 510;
pub const sfx_s3kbb: sfxenum_t = 509;
pub const sfx_s3kba: sfxenum_t = 508;
pub const sfx_s3kb9: sfxenum_t = 507;
pub const sfx_s3kb8: sfxenum_t = 506;
pub const sfx_s3kb7: sfxenum_t = 505;
pub const sfx_s3kb6: sfxenum_t = 504;
pub const sfx_s3kb5: sfxenum_t = 503;
pub const sfx_s3kb4: sfxenum_t = 502;
pub const sfx_s3kb3: sfxenum_t = 501;
pub const sfx_s3kb2: sfxenum_t = 500;
pub const sfx_s3kb1: sfxenum_t = 499;
pub const sfx_s3kb0: sfxenum_t = 498;
pub const sfx_s3kaf: sfxenum_t = 497;
pub const sfx_s3kae: sfxenum_t = 496;
pub const sfx_s3kad: sfxenum_t = 495;
pub const sfx_s3kac: sfxenum_t = 494;
pub const sfx_s3kabf: sfxenum_t = 493;
pub const sfx_s3kabe: sfxenum_t = 492;
pub const sfx_s3kabd: sfxenum_t = 491;
pub const sfx_s3kabc: sfxenum_t = 490;
pub const sfx_s3kabb: sfxenum_t = 489;
pub const sfx_s3kaba: sfxenum_t = 488;
pub const sfx_s3kab9: sfxenum_t = 487;
pub const sfx_s3kab8: sfxenum_t = 486;
pub const sfx_s3kab7: sfxenum_t = 485;
pub const sfx_s3kab6: sfxenum_t = 484;
pub const sfx_s3kab5: sfxenum_t = 483;
pub const sfx_s3kab4: sfxenum_t = 482;
pub const sfx_s3kab3: sfxenum_t = 481;
pub const sfx_s3kab2: sfxenum_t = 480;
pub const sfx_s3kab1: sfxenum_t = 479;
pub const sfx_s3kab: sfxenum_t = 478;
pub const sfx_s3kaa: sfxenum_t = 477;
pub const sfx_s3ka9: sfxenum_t = 476;
pub const sfx_s3ka8: sfxenum_t = 475;
pub const sfx_s3ka7: sfxenum_t = 474;
pub const sfx_s3ka6: sfxenum_t = 473;
pub const sfx_s3ka5: sfxenum_t = 472;
pub const sfx_s3ka4: sfxenum_t = 471;
pub const sfx_s3ka3: sfxenum_t = 470;
pub const sfx_s3ka2: sfxenum_t = 469;
pub const sfx_s3ka1: sfxenum_t = 468;
pub const sfx_s3ka0: sfxenum_t = 467;
pub const sfx_s3k9f: sfxenum_t = 466;
pub const sfx_s3k9e: sfxenum_t = 465;
pub const sfx_s3k9d: sfxenum_t = 464;
pub const sfx_s3k9c: sfxenum_t = 463;
pub const sfx_s3k9b: sfxenum_t = 462;
pub const sfx_s3k9a: sfxenum_t = 461;
pub const sfx_s3k99: sfxenum_t = 460;
pub const sfx_s3k98: sfxenum_t = 459;
pub const sfx_s3k97: sfxenum_t = 458;
pub const sfx_s3k96: sfxenum_t = 457;
pub const sfx_s3k95: sfxenum_t = 456;
pub const sfx_s3k94: sfxenum_t = 455;
pub const sfx_s3k93: sfxenum_t = 454;
pub const sfx_s3k92: sfxenum_t = 453;
pub const sfx_s3k91: sfxenum_t = 452;
pub const sfx_s3k90: sfxenum_t = 451;
pub const sfx_s3k8f: sfxenum_t = 450;
pub const sfx_s3k8e: sfxenum_t = 449;
pub const sfx_s3k8d: sfxenum_t = 448;
pub const sfx_s3k8c: sfxenum_t = 447;
pub const sfx_s3k8b: sfxenum_t = 446;
pub const sfx_s3k8a: sfxenum_t = 445;
pub const sfx_s3k89: sfxenum_t = 444;
pub const sfx_s3k88: sfxenum_t = 443;
pub const sfx_s3k87: sfxenum_t = 442;
pub const sfx_s3k86: sfxenum_t = 441;
pub const sfx_s3k85: sfxenum_t = 440;
pub const sfx_s3k84: sfxenum_t = 439;
pub const sfx_s3k83: sfxenum_t = 438;
pub const sfx_s3k82: sfxenum_t = 437;
pub const sfx_s3k81: sfxenum_t = 436;
pub const sfx_s3k80: sfxenum_t = 435;
pub const sfx_s3k7f: sfxenum_t = 434;
pub const sfx_s3k7e: sfxenum_t = 433;
pub const sfx_s3k7d: sfxenum_t = 432;
pub const sfx_s3k7c: sfxenum_t = 431;
pub const sfx_s3k7b: sfxenum_t = 430;
pub const sfx_s3k7a: sfxenum_t = 429;
pub const sfx_s3k79: sfxenum_t = 428;
pub const sfx_s3k78: sfxenum_t = 427;
pub const sfx_s3k77: sfxenum_t = 426;
pub const sfx_s3k76: sfxenum_t = 425;
pub const sfx_s3k75: sfxenum_t = 424;
pub const sfx_s3k74: sfxenum_t = 423;
pub const sfx_s3k73: sfxenum_t = 422;
pub const sfx_s3k72: sfxenum_t = 421;
pub const sfx_s3k71: sfxenum_t = 420;
pub const sfx_s3k70: sfxenum_t = 419;
pub const sfx_s3k6f: sfxenum_t = 418;
pub const sfx_s3k6e: sfxenum_t = 417;
pub const sfx_s3k6d: sfxenum_t = 416;
pub const sfx_s3k6c: sfxenum_t = 415;
pub const sfx_s3k6b: sfxenum_t = 414;
pub const sfx_s3k6a: sfxenum_t = 413;
pub const sfx_s3k69: sfxenum_t = 412;
pub const sfx_s3k68: sfxenum_t = 411;
pub const sfx_s3k67: sfxenum_t = 410;
pub const sfx_s3k66: sfxenum_t = 409;
pub const sfx_s3k65: sfxenum_t = 408;
pub const sfx_s3k64: sfxenum_t = 407;
pub const sfx_s3k63: sfxenum_t = 406;
pub const sfx_s3k62: sfxenum_t = 405;
pub const sfx_s3k61: sfxenum_t = 404;
pub const sfx_s3k60: sfxenum_t = 403;
pub const sfx_s3k5f: sfxenum_t = 402;
pub const sfx_s3k5e: sfxenum_t = 401;
pub const sfx_s3k5d: sfxenum_t = 400;
pub const sfx_s3k5c: sfxenum_t = 399;
pub const sfx_s3k5b: sfxenum_t = 398;
pub const sfx_s3k5a: sfxenum_t = 397;
pub const sfx_s3k59: sfxenum_t = 396;
pub const sfx_s3k58: sfxenum_t = 395;
pub const sfx_s3k57: sfxenum_t = 394;
pub const sfx_s3k56: sfxenum_t = 393;
pub const sfx_s3k55: sfxenum_t = 392;
pub const sfx_s3k54: sfxenum_t = 391;
pub const sfx_s3k53: sfxenum_t = 390;
pub const sfx_s3k52: sfxenum_t = 389;
pub const sfx_s3k51: sfxenum_t = 388;
pub const sfx_s3k50: sfxenum_t = 387;
pub const sfx_s3k4f: sfxenum_t = 386;
pub const sfx_s3k4e: sfxenum_t = 385;
pub const sfx_s3k4d: sfxenum_t = 384;
pub const sfx_s3k4c: sfxenum_t = 383;
pub const sfx_s3k4b: sfxenum_t = 382;
pub const sfx_s3k4a: sfxenum_t = 381;
pub const sfx_s3k49: sfxenum_t = 380;
pub const sfx_s3k48: sfxenum_t = 379;
pub const sfx_s3k47: sfxenum_t = 378;
pub const sfx_s3k46: sfxenum_t = 377;
pub const sfx_s3k45: sfxenum_t = 376;
pub const sfx_s3k44: sfxenum_t = 375;
pub const sfx_s3k43: sfxenum_t = 374;
pub const sfx_s3k42: sfxenum_t = 373;
pub const sfx_s3k41: sfxenum_t = 372;
pub const sfx_s3k40: sfxenum_t = 371;
pub const sfx_s3k3f: sfxenum_t = 370;
pub const sfx_s3k3e: sfxenum_t = 369;
pub const sfx_s3k3d: sfxenum_t = 368;
pub const sfx_s3k3c: sfxenum_t = 367;
pub const sfx_s3k3b: sfxenum_t = 366;
pub const sfx_s3k3a: sfxenum_t = 365;
pub const sfx_s3k39: sfxenum_t = 364;
pub const sfx_s3k38: sfxenum_t = 363;
pub const sfx_s3k37: sfxenum_t = 362;
pub const sfx_s3k36: sfxenum_t = 361;
pub const sfx_s3k35: sfxenum_t = 360;
pub const sfx_s3k34: sfxenum_t = 359;
pub const sfx_s3k33: sfxenum_t = 358;
pub const sfx_s3k2b: sfxenum_t = 357;
pub const sfx_s260: sfxenum_t = 356;
pub const sfx_s25f: sfxenum_t = 355;
pub const sfx_s25e: sfxenum_t = 354;
pub const sfx_s25d: sfxenum_t = 353;
pub const sfx_s25c: sfxenum_t = 352;
pub const sfx_s25b: sfxenum_t = 351;
pub const sfx_s25a: sfxenum_t = 350;
pub const sfx_s259: sfxenum_t = 349;
pub const sfx_s258: sfxenum_t = 348;
pub const sfx_s257: sfxenum_t = 347;
pub const sfx_s256: sfxenum_t = 346;
pub const sfx_s255: sfxenum_t = 345;
pub const sfx_s254: sfxenum_t = 344;
pub const sfx_s253: sfxenum_t = 343;
pub const sfx_s252: sfxenum_t = 342;
pub const sfx_s251: sfxenum_t = 341;
pub const sfx_s250: sfxenum_t = 340;
pub const sfx_s24f: sfxenum_t = 339;
pub const sfx_s24e: sfxenum_t = 338;
pub const sfx_s24d: sfxenum_t = 337;
pub const sfx_s24c: sfxenum_t = 336;
pub const sfx_s24b: sfxenum_t = 335;
pub const sfx_s24a: sfxenum_t = 334;
pub const sfx_s249: sfxenum_t = 333;
pub const sfx_s248: sfxenum_t = 332;
pub const sfx_s247: sfxenum_t = 331;
pub const sfx_s246: sfxenum_t = 330;
pub const sfx_s245: sfxenum_t = 329;
pub const sfx_s244: sfxenum_t = 328;
pub const sfx_s243: sfxenum_t = 327;
pub const sfx_s242: sfxenum_t = 326;
pub const sfx_s241: sfxenum_t = 325;
pub const sfx_s240: sfxenum_t = 324;
pub const sfx_s23f: sfxenum_t = 323;
pub const sfx_s23e: sfxenum_t = 322;
pub const sfx_s23d: sfxenum_t = 321;
pub const sfx_s23c: sfxenum_t = 320;
pub const sfx_s23b: sfxenum_t = 319;
pub const sfx_s23a: sfxenum_t = 318;
pub const sfx_s239: sfxenum_t = 317;
pub const sfx_s238: sfxenum_t = 316;
pub const sfx_s237: sfxenum_t = 315;
pub const sfx_s236: sfxenum_t = 314;
pub const sfx_s235: sfxenum_t = 313;
pub const sfx_s234: sfxenum_t = 312;
pub const sfx_s233: sfxenum_t = 311;
pub const sfx_s232: sfxenum_t = 310;
pub const sfx_s231: sfxenum_t = 309;
pub const sfx_s230: sfxenum_t = 308;
pub const sfx_s22f: sfxenum_t = 307;
pub const sfx_s22e: sfxenum_t = 306;
pub const sfx_s22d: sfxenum_t = 305;
pub const sfx_s22c: sfxenum_t = 304;
pub const sfx_s22b: sfxenum_t = 303;
pub const sfx_s22a: sfxenum_t = 302;
pub const sfx_s229: sfxenum_t = 301;
pub const sfx_s228: sfxenum_t = 300;
pub const sfx_s227: sfxenum_t = 299;
pub const sfx_s226: sfxenum_t = 298;
pub const sfx_s225: sfxenum_t = 297;
pub const sfx_s224: sfxenum_t = 296;
pub const sfx_s223: sfxenum_t = 295;
pub const sfx_s222: sfxenum_t = 294;
pub const sfx_s221: sfxenum_t = 293;
pub const sfx_s220: sfxenum_t = 292;
pub const sfx_s1cf: sfxenum_t = 291;
pub const sfx_s1ce: sfxenum_t = 290;
pub const sfx_s1cd: sfxenum_t = 289;
pub const sfx_s1cc: sfxenum_t = 288;
pub const sfx_s1cb: sfxenum_t = 287;
pub const sfx_s1ca: sfxenum_t = 286;
pub const sfx_s1c9: sfxenum_t = 285;
pub const sfx_s1c8: sfxenum_t = 284;
pub const sfx_s1c7: sfxenum_t = 283;
pub const sfx_s1c6: sfxenum_t = 282;
pub const sfx_s1c5: sfxenum_t = 281;
pub const sfx_s1c4: sfxenum_t = 280;
pub const sfx_s1c3: sfxenum_t = 279;
pub const sfx_s1c2: sfxenum_t = 278;
pub const sfx_s1c1: sfxenum_t = 277;
pub const sfx_s1c0: sfxenum_t = 276;
pub const sfx_s1bf: sfxenum_t = 275;
pub const sfx_s1be: sfxenum_t = 274;
pub const sfx_s1bd: sfxenum_t = 273;
pub const sfx_s1bc: sfxenum_t = 272;
pub const sfx_s1bb: sfxenum_t = 271;
pub const sfx_s1ba: sfxenum_t = 270;
pub const sfx_s1b9: sfxenum_t = 269;
pub const sfx_s1b8: sfxenum_t = 268;
pub const sfx_s1b7: sfxenum_t = 267;
pub const sfx_s1b6: sfxenum_t = 266;
pub const sfx_s1b5: sfxenum_t = 265;
pub const sfx_s1b4: sfxenum_t = 264;
pub const sfx_s1b3: sfxenum_t = 263;
pub const sfx_s1b2: sfxenum_t = 262;
pub const sfx_s1b1: sfxenum_t = 261;
pub const sfx_s1b0: sfxenum_t = 260;
pub const sfx_s1af: sfxenum_t = 259;
pub const sfx_s1ae: sfxenum_t = 258;
pub const sfx_s1ad: sfxenum_t = 257;
pub const sfx_s1ac: sfxenum_t = 256;
pub const sfx_s1ab: sfxenum_t = 255;
pub const sfx_s1aa: sfxenum_t = 254;
pub const sfx_s1a9: sfxenum_t = 253;
pub const sfx_s1a8: sfxenum_t = 252;
pub const sfx_s1a7: sfxenum_t = 251;
pub const sfx_s1a6: sfxenum_t = 250;
pub const sfx_s1a5: sfxenum_t = 249;
pub const sfx_s1a4: sfxenum_t = 248;
pub const sfx_s1a3: sfxenum_t = 247;
pub const sfx_s1a2: sfxenum_t = 246;
pub const sfx_s1a1: sfxenum_t = 245;
pub const sfx_s1a0: sfxenum_t = 244;
pub const sfx_brakrx: sfxenum_t = 243;
pub const sfx_brakrl: sfxenum_t = 242;
pub const sfx_beelec: sfxenum_t = 241;
pub const sfx_bgxpld: sfxenum_t = 240;
pub const sfx_bexpld: sfxenum_t = 239;
pub const sfx_bewar4: sfxenum_t = 238;
pub const sfx_bewar3: sfxenum_t = 237;
pub const sfx_bewar2: sfxenum_t = 236;
pub const sfx_bewar1: sfxenum_t = 235;
pub const sfx_bestp2: sfxenum_t = 234;
pub const sfx_bestep: sfxenum_t = 233;
pub const sfx_beshot: sfxenum_t = 232;
pub const sfx_beragh: sfxenum_t = 231;
pub const sfx_beoutb: sfxenum_t = 230;
pub const sfx_belnch: sfxenum_t = 229;
pub const sfx_bejet1: sfxenum_t = 228;
pub const sfx_behurt: sfxenum_t = 227;
pub const sfx_begrnd: sfxenum_t = 226;
pub const sfx_begoop: sfxenum_t = 225;
pub const sfx_beflap: sfxenum_t = 224;
pub const sfx_befire: sfxenum_t = 223;
pub const sfx_befall: sfxenum_t = 222;
pub const sfx_beeyow: sfxenum_t = 221;
pub const sfx_bedie2: sfxenum_t = 220;
pub const sfx_bedie1: sfxenum_t = 219;
pub const sfx_bedeen: sfxenum_t = 218;
pub const sfx_becrsh: sfxenum_t = 217;
pub const sfx_bechrg: sfxenum_t = 216;
pub const sfx_bebomb: sfxenum_t = 215;
pub const sfx_thwomp: sfxenum_t = 214;
pub const sfx_marioa: sfxenum_t = 213;
pub const sfx_mario9: sfxenum_t = 212;
pub const sfx_mario8: sfxenum_t = 211;
pub const sfx_mario7: sfxenum_t = 210;
pub const sfx_mario6: sfxenum_t = 209;
pub const sfx_mario5: sfxenum_t = 208;
pub const sfx_mario4: sfxenum_t = 207;
pub const sfx_mario3: sfxenum_t = 206;
pub const sfx_mario2: sfxenum_t = 205;
pub const sfx_mario1: sfxenum_t = 204;
pub const sfx_koopfr: sfxenum_t = 203;
pub const sfx_ghosty: sfxenum_t = 202;
pub const sfx_pumpkn: sfxenum_t = 201;
pub const sfx_lntdie: sfxenum_t = 200;
pub const sfx_lntsit: sfxenum_t = 199;
pub const sfx_peww: sfxenum_t = 198;
pub const sfx_ngjump: sfxenum_t = 197;
pub const sfx_timeup: sfxenum_t = 196;
pub const sfx_prloop: sfxenum_t = 195;
pub const sfx_hidden: sfxenum_t = 194;
pub const sfx_hoop3: sfxenum_t = 193;
pub const sfx_hoop2: sfxenum_t = 192;
pub const sfx_hoop1: sfxenum_t = 191;
pub const sfx_ngskid: sfxenum_t = 190;
pub const sfx_nghurt: sfxenum_t = 189;
pub const sfx_ncspec: sfxenum_t = 188;
pub const sfx_drill2: sfxenum_t = 187;
pub const sfx_drill1: sfxenum_t = 186;
pub const sfx_nxdone: sfxenum_t = 185;
pub const sfx_ngdone: sfxenum_t = 184;
pub const sfx_nxitem: sfxenum_t = 183;
pub const sfx_ncitem: sfxenum_t = 182;
pub const sfx_ncchip: sfxenum_t = 181;
pub const sfx_nxbump: sfxenum_t = 180;
pub const sfx_nbmper: sfxenum_t = 179;
pub const sfx_xideya: sfxenum_t = 178;
pub const sfx_ideya: sfxenum_t = 177;
pub const sfx_addfil: sfxenum_t = 176;
pub const sfx_notadd: sfxenum_t = 175;
pub const sfx_adderr: sfxenum_t = 174;
pub const sfx_zelda: sfxenum_t = 173;
pub const sfx_wtrdng: sfxenum_t = 172;
pub const sfx_wepchg: sfxenum_t = 171;
pub const sfx_radio: sfxenum_t = 170;
pub const sfx_ptally: sfxenum_t = 169;
pub const sfx_oneup: sfxenum_t = 168;
pub const sfx_menu1: sfxenum_t = 167;
pub const sfx_flgcap: sfxenum_t = 166;
pub const sfx_emfind: sfxenum_t = 165;
pub const sfx_dwnind: sfxenum_t = 164;
pub const sfx_chchng: sfxenum_t = 163;
pub const sfx_antiri: sfxenum_t = 162;
pub const sfx_shattr: sfxenum_t = 161;
pub const sfx_iceb: sfxenum_t = 160;
pub const sfx_pscree: sfxenum_t = 159;
pub const sfx_lvfal1: sfxenum_t = 158;
pub const sfx_sprong: sfxenum_t = 157;
pub const sfx_bsnipe: sfxenum_t = 156;
pub const sfx_chuchu: sfxenum_t = 155;
pub const sfx_bowl: sfxenum_t = 154;
pub const sfx_vwre: sfxenum_t = 153;
pub const sfx_alart: sfxenum_t = 152;
pub const sfx_corkh: sfxenum_t = 151;
pub const sfx_corkp: sfxenum_t = 150;
pub const sfx_boingf: sfxenum_t = 149;
pub const sfx_mspogo: sfxenum_t = 148;
pub const sfx_mswarp: sfxenum_t = 147;
pub const sfx_shrpgo: sfxenum_t = 146;
pub const sfx_shrpsp: sfxenum_t = 145;
pub const sfx_wdjump: sfxenum_t = 144;
pub const sfx_turhit: sfxenum_t = 143;
pub const sfx_trpowr: sfxenum_t = 142;
pub const sfx_trfire: sfxenum_t = 141;
pub const sfx_token: sfxenum_t = 140;
pub const sfx_tink: sfxenum_t = 139;
pub const sfx_telept: sfxenum_t = 138;
pub const sfx_supert: sfxenum_t = 137;
pub const sfx_strpst: sfxenum_t = 136;
pub const sfx_statu2: sfxenum_t = 135;
pub const sfx_statu1: sfxenum_t = 134;
pub const sfx_spring: sfxenum_t = 133;
pub const sfx_spkdth: sfxenum_t = 132;
pub const sfx_spdpad: sfxenum_t = 131;
pub const sfx_shldls: sfxenum_t = 130;
pub const sfx_attrsg: sfxenum_t = 129;
pub const sfx_armasg: sfxenum_t = 128;
pub const sfx_elemsg: sfxenum_t = 127;
pub const sfx_frcssg: sfxenum_t = 126;
pub const sfx_forcsg: sfxenum_t = 125;
pub const sfx_wirlsg: sfxenum_t = 124;
pub const sfx_shield: sfxenum_t = 123;
pub const sfx_rlaunc: sfxenum_t = 122;
pub const sfx_rail2: sfxenum_t = 121;
pub const sfx_rail1: sfxenum_t = 120;
pub const sfx_pop: sfxenum_t = 119;
pub const sfx_pogo: sfxenum_t = 118;
pub const sfx_monton: sfxenum_t = 117;
pub const sfx_mixup: sfxenum_t = 116;
pub const sfx_mindig: sfxenum_t = 115;
pub const sfx_lvpass: sfxenum_t = 114;
pub const sfx_lose: sfxenum_t = 113;
pub const sfx_jshard: sfxenum_t = 112;
pub const sfx_jet: sfxenum_t = 111;
pub const sfx_itemup: sfxenum_t = 110;
pub const sfx_gravch: sfxenum_t = 109;
pub const sfx_gspray: sfxenum_t = 108;
pub const sfx_gloop: sfxenum_t = 107;
pub const sfx_ghit: sfxenum_t = 106;
pub const sfx_wepfir: sfxenum_t = 105;
pub const sfx_gbeep: sfxenum_t = 104;
pub const sfx_fizzle: sfxenum_t = 103;
pub const sfx_drown: sfxenum_t = 102;
pub const sfx_dmpain: sfxenum_t = 101;
pub const sfx_ding: sfxenum_t = 100;
pub const sfx_deton: sfxenum_t = 99;
pub const sfx_cybdth: sfxenum_t = 98;
pub const sfx_cgot: sfxenum_t = 97;
pub const sfx_cannon: sfxenum_t = 96;
pub const sfx_bnce2: sfxenum_t = 95;
pub const sfx_bnce1: sfxenum_t = 94;
pub const sfx_bkpoof: sfxenum_t = 93;
pub const sfx_appear: sfxenum_t = 92;
pub const sfx_rumble: sfxenum_t = 91;
pub const sfx_rumbam: sfxenum_t = 90;
pub const sfx_rocks4: sfxenum_t = 89;
pub const sfx_rocks3: sfxenum_t = 88;
pub const sfx_rocks2: sfxenum_t = 87;
pub const sfx_rocks1: sfxenum_t = 86;
pub const sfx_lavbub: sfxenum_t = 85;
pub const sfx_ambin2: sfxenum_t = 84;
pub const sfx_elevb3: sfxenum_t = 83;
pub const sfx_elevb2: sfxenum_t = 82;
pub const sfx_elevb1: sfxenum_t = 81;
pub const sfx_eleva3: sfxenum_t = 80;
pub const sfx_eleva2: sfxenum_t = 79;
pub const sfx_eleva1: sfxenum_t = 78;
pub const sfx_doord2: sfxenum_t = 77;
pub const sfx_doord1: sfxenum_t = 76;
pub const sfx_doorc2: sfxenum_t = 75;
pub const sfx_doorc1: sfxenum_t = 74;
pub const sfx_doorb1: sfxenum_t = 73;
pub const sfx_doora1: sfxenum_t = 72;
pub const sfx_wslap: sfxenum_t = 71;
pub const sfx_wdrip8: sfxenum_t = 70;
pub const sfx_wdrip7: sfxenum_t = 69;
pub const sfx_wdrip6: sfxenum_t = 68;
pub const sfx_wdrip5: sfxenum_t = 67;
pub const sfx_wdrip4: sfxenum_t = 66;
pub const sfx_wdrip3: sfxenum_t = 65;
pub const sfx_wdrip2: sfxenum_t = 64;
pub const sfx_wdrip1: sfxenum_t = 63;
pub const sfx_splish: sfxenum_t = 62;
pub const sfx_splash: sfxenum_t = 61;
pub const sfx_floush: sfxenum_t = 60;
pub const sfx_bubbl5: sfxenum_t = 59;
pub const sfx_bubbl4: sfxenum_t = 58;
pub const sfx_bubbl3: sfxenum_t = 57;
pub const sfx_bubbl2: sfxenum_t = 56;
pub const sfx_bubbl1: sfxenum_t = 55;
pub const sfx_amwtr8: sfxenum_t = 54;
pub const sfx_amwtr7: sfxenum_t = 53;
pub const sfx_amwtr6: sfxenum_t = 52;
pub const sfx_amwtr5: sfxenum_t = 51;
pub const sfx_amwtr4: sfxenum_t = 50;
pub const sfx_amwtr3: sfxenum_t = 49;
pub const sfx_amwtr2: sfxenum_t = 48;
pub const sfx_amwtr1: sfxenum_t = 47;
pub const sfx_athun2: sfxenum_t = 46;
pub const sfx_athun1: sfxenum_t = 45;
pub const sfx_litng4: sfxenum_t = 44;
pub const sfx_litng3: sfxenum_t = 43;
pub const sfx_litng2: sfxenum_t = 42;
pub const sfx_litng1: sfxenum_t = 41;
pub const sfx_rainin: sfxenum_t = 40;
pub const sfx_spsmsh: sfxenum_t = 39;
pub const sfx_ambmac: sfxenum_t = 38;
pub const sfx_wbreak: sfxenum_t = 37;
pub const sfx_steam2: sfxenum_t = 36;
pub const sfx_steam1: sfxenum_t = 35;
pub const sfx_pstop: sfxenum_t = 34;
pub const sfx_pstart: sfxenum_t = 33;
pub const sfx_mswing: sfxenum_t = 32;
pub const sfx_laser: sfxenum_t = 31;
pub const sfx_grind: sfxenum_t = 30;
pub const sfx_fire: sfxenum_t = 29;
pub const sfx_crumbl: sfxenum_t = 28;
pub const sfx_buzz4: sfxenum_t = 27;
pub const sfx_buzz3: sfxenum_t = 26;
pub const sfx_buzz2: sfxenum_t = 25;
pub const sfx_buzz1: sfxenum_t = 24;
pub const sfx_alarm: sfxenum_t = 23;
pub const sfx_ambint: sfxenum_t = 22;
pub const sfx_skid: sfxenum_t = 21;
pub const sfx_zoom: sfxenum_t = 20;
pub const sfx_thok: sfxenum_t = 19;
pub const sfx_spndsh: sfxenum_t = 18;
pub const sfx_spin: sfxenum_t = 17;
pub const sfx_putput: sfxenum_t = 16;
pub const sfx_pudpud: sfxenum_t = 15;
pub const sfx_jump: sfxenum_t = 14;
pub const sfx_gasp: sfxenum_t = 13;
pub const sfx_victr4: sfxenum_t = 12;
pub const sfx_victr3: sfxenum_t = 11;
pub const sfx_victr2: sfxenum_t = 10;
pub const sfx_victr1: sfxenum_t = 9;
pub const sfx_altow4: sfxenum_t = 8;
pub const sfx_altow3: sfxenum_t = 7;
pub const sfx_altow2: sfxenum_t = 6;
pub const sfx_altow1: sfxenum_t = 5;
pub const sfx_altdi4: sfxenum_t = 4;
pub const sfx_altdi3: sfxenum_t = 3;
pub const sfx_altdi2: sfxenum_t = 2;
pub const sfx_altdi1: sfxenum_t = 1;
pub const sfx_None: sfxenum_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct state_t {
    pub sprite: spritenum_t,
    pub frame: uint32_t,
    pub tics: int32_t,
    pub action: actionf_t,
    pub var1: int32_t,
    pub var2: int32_t,
    pub nextstate: statenum_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union actionf_t {
    pub acv: actionf_v,
    pub acp1: actionf_p1,
}
pub type actionf_p1 = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type actionf_v = Option::<unsafe extern "C" fn() -> ()>;
pub type spritenum_t = sprite;
pub type sprite = libc::c_uint;
pub const NUMSPRITES: sprite = 907;
pub const SPR_LASTFREESLOT: sprite = 906;
pub const SPR_FIRSTFREESLOT: sprite = 395;
pub const SPR_GWLR: sprite = 394;
pub const SPR_GWLG: sprite = 393;
pub const SPR_BRIY: sprite = 392;
pub const SPR_BRIB: sprite = 391;
pub const SPR_BRIR: sprite = 390;
pub const SPR_WDDB: sprite = 389;
pub const SPR_BRIC: sprite = 388;
pub const SPR_GFZD: sprite = 387;
pub const SPR_ROIP: sprite = 386;
pub const SPR_ROIO: sprite = 385;
pub const SPR_ROIN: sprite = 384;
pub const SPR_ROIM: sprite = 383;
pub const SPR_ROIL: sprite = 382;
pub const SPR_ROIK: sprite = 381;
pub const SPR_ROIJ: sprite = 380;
pub const SPR_ROII: sprite = 379;
pub const SPR_ROIH: sprite = 378;
pub const SPR_ROIG: sprite = 377;
pub const SPR_ROIF: sprite = 376;
pub const SPR_ROIE: sprite = 375;
pub const SPR_ROID: sprite = 374;
pub const SPR_ROIC: sprite = 373;
pub const SPR_ROIB: sprite = 372;
pub const SPR_ROIA: sprite = 371;
pub const SPR_BMNB: sprite = 370;
pub const SPR_BOM4: sprite = 369;
pub const SPR_BOM3: sprite = 368;
pub const SPR_BOM2: sprite = 367;
pub const SPR_BOM1: sprite = 366;
pub const SPR_SPRK: sprite = 365;
pub const SPR_HBAT: sprite = 364;
pub const SPR_SBSK: sprite = 363;
pub const SPR_SBFL: sprite = 362;
pub const SPR_SBOB: sprite = 361;
pub const SPR_BAL2: sprite = 360;
pub const SPR_CACO: sprite = 359;
pub const SPR_HMCE: sprite = 358;
pub const SPR_FMCE: sprite = 357;
pub const SPR_BBUZ: sprite = 356;
pub const SPR_BUMB: sprite = 355;
pub const SPR_HIVE: sprite = 354;
pub const SPR_POPH: sprite = 353;
pub const SPR_PENG: sprite = 352;
pub const SPR_SHLP: sprite = 351;
pub const SPR_NTPN: sprite = 350;
pub const SPR_IDYA: sprite = 349;
pub const SPR_CAPS: sprite = 348;
pub const SPR_NPRU: sprite = 347;
pub const SPR_NSCR: sprite = 346;
pub const SPR_HOOP: sprite = 345;
pub const SPR_NBMP: sprite = 344;
pub const SPR_NSPK: sprite = 343;
pub const SPR_NDRN: sprite = 342;
pub const SPR_TOAD: sprite = 341;
pub const SPR_MUS2: sprite = 340;
pub const SPR_MUS1: sprite = 339;
pub const SPR_MAXE: sprite = 338;
pub const SPR_BFLM: sprite = 337;
pub const SPR_KOOP: sprite = 336;
pub const SPR_HAMM: sprite = 335;
pub const SPR_PUMA: sprite = 334;
pub const SPR_SHLL: sprite = 333;
pub const SPR_FBLL: sprite = 332;
pub const SPR_FFWR: sprite = 331;
pub const SPR_BGOM: sprite = 330;
pub const SPR_GOOM: sprite = 329;
pub const SPR_CPRK: sprite = 328;
pub const SPR_COIN: sprite = 327;
pub const SPR_TSCR: sprite = 326;
pub const SPR_TGRE: sprite = 325;
pub const SPR_TAUT: sprite = 324;
pub const SPR_PIKG: sprite = 323;
pub const SPR_PIKS: sprite = 322;
pub const SPR_PIKE: sprite = 321;
pub const SPR_PIKA: sprite = 320;
pub const SPR_PIKR: sprite = 319;
pub const SPR_PIKB: sprite = 318;
pub const SPR_RNGG: sprite = 317;
pub const SPR_RNGS: sprite = 316;
pub const SPR_RNGE: sprite = 315;
pub const SPR_RNGA: sprite = 314;
pub const SPR_RNGI: sprite = 313;
pub const SPR_RNGR: sprite = 312;
pub const SPR_RNGB: sprite = 311;
pub const SPR_RRNG: sprite = 310;
pub const SPR_LHRT: sprite = 309;
pub const SPR_CORK: sprite = 308;
pub const SPR_FNSF: sprite = 307;
pub const SPR_GFLG: sprite = 306;
pub const SPR_TTAG: sprite = 305;
pub const SPR_LCKN: sprite = 304;
pub const SPR_FLII: sprite = 303;
pub const SPR_DRWN: sprite = 302;
pub const SPR_SCOR: sprite = 301;
pub const SPR_PRTL: sprite = 300;
pub const SPR_SEED: sprite = 299;
pub const SPR_TFOG: sprite = 298;
pub const SPR_FPRT: sprite = 297;
pub const SPR_DUST: sprite = 296;
pub const SPR_WZAP: sprite = 295;
pub const SPR_BUBL: sprite = 294;
pub const SPR_SMOK: sprite = 293;
pub const SPR_SPLA: sprite = 292;
pub const SPR_LSPL: sprite = 291;
pub const SPR_SPLH: sprite = 290;
pub const SPR_SNO1: sprite = 289;
pub const SPR_RAIN: sprite = 288;
pub const SPR_BSTR: sprite = 287;
pub const SPR_BSTY: sprite = 286;
pub const SPR_SSWB: sprite = 285;
pub const SPR_SSWR: sprite = 284;
pub const SPR_SSWY: sprite = 283;
pub const SPR_BSPR: sprite = 282;
pub const SPR_RSPR: sprite = 281;
pub const SPR_YSPR: sprite = 280;
pub const SPR_SPRB: sprite = 279;
pub const SPR_SPRR: sprite = 278;
pub const SPR_SPRY: sprite = 277;
pub const SPR_BLON: sprite = 276;
pub const SPR_BUMP: sprite = 275;
pub const SPR_STEM: sprite = 274;
pub const SPR_FANS: sprite = 273;
pub const SPR_FS02: sprite = 272;
pub const SPR_FS01: sprite = 271;
pub const SPR_FL16: sprite = 270;
pub const SPR_FL15: sprite = 269;
pub const SPR_FL14: sprite = 268;
pub const SPR_FL13: sprite = 267;
pub const SPR_FL12: sprite = 266;
pub const SPR_FL11: sprite = 265;
pub const SPR_FL10: sprite = 264;
pub const SPR_FL09: sprite = 263;
pub const SPR_FL08: sprite = 262;
pub const SPR_FL07: sprite = 261;
pub const SPR_FL06: sprite = 260;
pub const SPR_FL05: sprite = 259;
pub const SPR_FL04: sprite = 258;
pub const SPR_FL03: sprite = 257;
pub const SPR_FL02: sprite = 256;
pub const SPR_FL01: sprite = 255;
pub const SPR_FBUB: sprite = 254;
pub const SPR_GOAL: sprite = 253;
pub const SPR_SSPK: sprite = 252;
pub const SPR_IVSP: sprite = 251;
pub const SPR_ZAPS: sprite = 250;
pub const SPR_BUBS: sprite = 249;
pub const SPR_FIRS: sprite = 248;
pub const SPR_PITY: sprite = 247;
pub const SPR_FORC: sprite = 246;
pub const SPR_ELEM: sprite = 245;
pub const SPR_MAGN: sprite = 244;
pub const SPR_WIND: sprite = 243;
pub const SPR_ARMB: sprite = 242;
pub const SPR_ARMF: sprite = 241;
pub const SPR_ARMA: sprite = 240;
pub const SPR_DBAL: sprite = 239;
pub const SPR_STLG: sprite = 238;
pub const SPR_BSZ8: sprite = 237;
pub const SPR_BSZ7: sprite = 236;
pub const SPR_BSZ6: sprite = 235;
pub const SPR_BSZ5: sprite = 234;
pub const SPR_BST6: sprite = 233;
pub const SPR_BST5: sprite = 232;
pub const SPR_BST4: sprite = 231;
pub const SPR_BST3: sprite = 230;
pub const SPR_BST2: sprite = 229;
pub const SPR_BST1: sprite = 228;
pub const SPR_BSZ3: sprite = 227;
pub const SPR_BSZ2: sprite = 226;
pub const SPR_BSZ1: sprite = 225;
pub const SPR_CFLM: sprite = 224;
pub const SPR_RCRY: sprite = 223;
pub const SPR_BGAR: sprite = 222;
pub const SPR_HHZM: sprite = 221;
pub const SPR_SHRM: sprite = 220;
pub const SPR_HHPL: sprite = 219;
pub const SPR_PUMK: sprite = 218;
pub const SPR_ROSY: sprite = 217;
pub const SPR_FHZI: sprite = 216;
pub const SPR_XMS6: sprite = 215;
pub const SPR_XMS5: sprite = 214;
pub const SPR_XMS4: sprite = 213;
pub const SPR_XMS3: sprite = 212;
pub const SPR_XMS2: sprite = 211;
pub const SPR_XMS1: sprite = 210;
pub const SPR_WVIN: sprite = 209;
pub const SPR_TFLO: sprite = 208;
pub const SPR_JPLA: sprite = 207;
pub const SPR_LFAL: sprite = 206;
pub const SPR_DFLM: sprite = 205;
pub const SPR_FLME: sprite = 204;
pub const SPR_STEA: sprite = 203;
pub const SPR_TRAI: sprite = 202;
pub const SPR_TRAE: sprite = 201;
pub const SPR_SALD: sprite = 200;
pub const SPR_MCSP: sprite = 199;
pub const SPR_MCRT: sprite = 198;
pub const SPR_ADST: sprite = 197;
pub const SPR_TAZD: sprite = 196;
pub const SPR_REMT: sprite = 195;
pub const SPR_BARR: sprite = 194;
pub const SPR_OILF: sprite = 193;
pub const SPR_OILL: sprite = 192;
pub const SPR_WWS3: sprite = 191;
pub const SPR_WWS2: sprite = 190;
pub const SPR_WWSG: sprite = 189;
pub const SPR_CACT: sprite = 188;
pub const SPR_STBL: sprite = 187;
pub const SPR_BTBL: sprite = 186;
pub const SPR_CABR: sprite = 185;
pub const SPR_CBBS: sprite = 184;
pub const SPR_CSTA: sprite = 183;
pub const SPR_CFLG: sprite = 182;
pub const SPR_CTRC: sprite = 181;
pub const SPR_FLMH: sprite = 180;
pub const SPR_CNDL: sprite = 179;
pub const SPR_CEZB: sprite = 178;
pub const SPR_PINE: sprite = 177;
pub const SPR_BANR: sprite = 176;
pub const SPR_BFBR: sprite = 175;
pub const SPR_SFBR: sprite = 174;
pub const SPR_RSPB: sprite = 173;
pub const SPR_YSPB: sprite = 172;
pub const SPR_BMCE: sprite = 171;
pub const SPR_SMCE: sprite = 170;
pub const SPR_BMCH: sprite = 169;
pub const SPR_SMCH: sprite = 168;
pub const SPR_ESTA: sprite = 167;
pub const SPR_FLAM: sprite = 166;
pub const SPR_CHAN: sprite = 165;
pub const SPR_LIBE: sprite = 164;
pub const SPR_DSTG: sprite = 163;
pub const SPR_ALGB: sprite = 162;
pub const SPR_ALGA: sprite = 161;
pub const SPR_KELP: sprite = 160;
pub const SPR_BCRY: sprite = 159;
pub const SPR_CORL: sprite = 158;
pub const SPR_DRIP: sprite = 157;
pub const SPR_SEWE: sprite = 156;
pub const SPR_GARG: sprite = 155;
pub const SPR_ALRM: sprite = 154;
pub const SPR_THZT: sprite = 153;
pub const SPR_FWR6: sprite = 152;
pub const SPR_FWR5: sprite = 151;
pub const SPR_THZP: sprite = 150;
pub const SPR_TRE6: sprite = 149;
pub const SPR_TRE5: sprite = 148;
pub const SPR_TRE4: sprite = 147;
pub const SPR_TRE3: sprite = 146;
pub const SPR_TRE2: sprite = 145;
pub const SPR_TRE1: sprite = 144;
pub const SPR_BUS3: sprite = 143;
pub const SPR_BUS2: sprite = 142;
pub const SPR_BUS1: sprite = 141;
pub const SPR_FWR4: sprite = 140;
pub const SPR_FWR3: sprite = 139;
pub const SPR_FWR2: sprite = 138;
pub const SPR_FWR1: sprite = 137;
pub const SPR_TUPF: sprite = 136;
pub const SPR_TUPL: sprite = 135;
pub const SPR_LETR: sprite = 134;
pub const SPR_CFIR: sprite = 133;
pub const SPR_AROW: sprite = 132;
pub const SPR_CBLL: sprite = 131;
pub const SPR_TRLS: sprite = 130;
pub const SPR_JBUL: sprite = 129;
pub const SPR_MINE: sprite = 128;
pub const SPR_ENRG: sprite = 127;
pub const SPR_TORP: sprite = 126;
pub const SPR_LASF: sprite = 125;
pub const SPR_LASR: sprite = 124;
pub const SPR_MISL: sprite = 123;
pub const SPR_TVZP: sprite = 122;
pub const SPR_TVBB: sprite = 121;
pub const SPR_TVFL: sprite = 120;
pub const SPR_TVTK: sprite = 119;
pub const SPR_TV1K: sprite = 118;
pub const SPR_TVRC: sprite = 117;
pub const SPR_TVGV: sprite = 116;
pub const SPR_TVMY: sprite = 115;
pub const SPR_TVMX: sprite = 114;
pub const SPR_TVEG: sprite = 113;
pub const SPR_TV1P: sprite = 112;
pub const SPR_TV1U: sprite = 111;
pub const SPR_TVIV: sprite = 110;
pub const SPR_TVSS: sprite = 109;
pub const SPR_TVEL: sprite = 108;
pub const SPR_TVWW: sprite = 107;
pub const SPR_TVAR: sprite = 106;
pub const SPR_TVFO: sprite = 105;
pub const SPR_TVAT: sprite = 104;
pub const SPR_TVPI: sprite = 103;
pub const SPR_TVRI: sprite = 102;
pub const SPR_TBRI: sprite = 101;
pub const SPR_TRRI: sprite = 100;
pub const SPR_XLTV: sprite = 99;
pub const SPR_MSTV: sprite = 98;
pub const SPR_PUMI: sprite = 97;
pub const SPR_BMNE: sprite = 96;
pub const SPR_STPT: sprite = 95;
pub const SPR_WSPB: sprite = 94;
pub const SPR_WSPK: sprite = 93;
pub const SPR_USPK: sprite = 92;
pub const SPR_TFLM: sprite = 91;
pub const SPR_SFLM: sprite = 90;
pub const SPR_SPIK: sprite = 89;
pub const SPR_SIGN: sprite = 88;
pub const SPR_BBLS: sprite = 87;
pub const SPR_SHRD: sprite = 86;
pub const SPR_CEMG: sprite = 85;
pub const SPR_EMBM: sprite = 84;
pub const SPR_NSTR: sprite = 83;
pub const SPR_NCHP: sprite = 82;
pub const SPR_SPHR: sprite = 81;
pub const SPR_BFLG: sprite = 80;
pub const SPR_RFLG: sprite = 79;
pub const SPR_TOKE: sprite = 78;
pub const SPR_TRNG: sprite = 77;
pub const SPR_RING: sprite = 76;
pub const SPR_MSCB: sprite = 75;
pub const SPR_MSCF: sprite = 74;
pub const SPR_METL: sprite = 73;
pub const SPR_MNPL: sprite = 72;
pub const SPR_NPLM: sprite = 71;
pub const SPR_TARG: sprite = 70;
pub const SPR_ELEC: sprite = 69;
pub const SPR_RCKT: sprite = 68;
pub const SPR_EGGT: sprite = 67;
pub const SPR_BMSL: sprite = 66;
pub const SPR_BGOO: sprite = 65;
pub const SPR_BRAK: sprite = 64;
pub const SPR_EGGR: sprite = 63;
pub const SPR_BARD: sprite = 62;
pub const SPR_BARX: sprite = 61;
pub const SPR_FSGN: sprite = 60;
pub const SPR_FBOM: sprite = 59;
pub const SPR_PROJ: sprite = 58;
pub const SPR_VWRE: sprite = 57;
pub const SPR_WHAT: sprite = 56;
pub const SPR_BRKN: sprite = 55;
pub const SPR_FANG: sprite = 54;
pub const SPR_EGR1: sprite = 53;
pub const SPR_EFIR: sprite = 52;
pub const SPR_EGGP: sprite = 51;
pub const SPR_SHCK: sprite = 50;
pub const SPR_FAKE: sprite = 49;
pub const SPR_SEBH: sprite = 48;
pub const SPR_EGGO: sprite = 47;
pub const SPR_GOOP: sprite = 46;
pub const SPR_TANK: sprite = 45;
pub const SPR_EGGN: sprite = 44;
pub const SPR_EGLZ: sprite = 43;
pub const SPR_EGGM: sprite = 42;
pub const SPR_JETF: sprite = 41;
pub const SPR_DRAB: sprite = 40;
pub const SPR_PTER: sprite = 39;
pub const SPR_PYRE: sprite = 38;
pub const SPR_CANG: sprite = 37;
pub const SPR_CANA: sprite = 36;
pub const SPR_UNID: sprite = 35;
pub const SPR_SSHL: sprite = 34;
pub const SPR_MNUD: sprite = 33;
pub const SPR_MNUS: sprite = 32;
pub const SPR_GSNH: sprite = 31;
pub const SPR_GSNL: sprite = 30;
pub const SPR_GSNP: sprite = 29;
pub const SPR_ESHI: sprite = 28;
pub const SPR_SPSH: sprite = 27;
pub const SPR_STAB: sprite = 26;
pub const SPR_CBFS: sprite = 25;
pub const SPR_ARCH: sprite = 24;
pub const SPR_PNTY: sprite = 23;
pub const SPR_VLTR: sprite = 22;
pub const SPR_SNLR: sprite = 21;
pub const SPR_JJAW: sprite = 20;
pub const SPR_CSPR: sprite = 19;
pub const SPR_CR2B: sprite = 18;
pub const SPR_CRAB: sprite = 17;
pub const SPR_SHRP: sprite = 16;
pub const SPR_TURR: sprite = 15;
pub const SPR_TRET: sprite = 14;
pub const SPR_SKIM: sprite = 13;
pub const SPR_DETN: sprite = 12;
pub const SPR_CCOM: sprite = 11;
pub const SPR_JETG: sprite = 10;
pub const SPR_JETB: sprite = 9;
pub const SPR_RBUZ: sprite = 8;
pub const SPR_BUZZ: sprite = 7;
pub const SPR_FISH: sprite = 6;
pub const SPR_SPOS: sprite = 5;
pub const SPR_POSS: sprite = 4;
pub const SPR_PLAY: sprite = 3;
pub const SPR_THOK: sprite = 2;
pub const SPR_UNKN: sprite = 1;
pub const SPR_NULL: sprite = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ffloor_s {
    pub topheight: *mut fixed_t,
    pub toppic: *mut int32_t,
    pub toplightlevel: *mut int16_t,
    pub topxoffs: *mut fixed_t,
    pub topyoffs: *mut fixed_t,
    pub topangle: *mut angle_t,
    pub bottomheight: *mut fixed_t,
    pub bottompic: *mut int32_t,
    pub bottomxoffs: *mut fixed_t,
    pub bottomyoffs: *mut fixed_t,
    pub bottomangle: *mut angle_t,
    pub t_slope: *mut *mut pslope_s,
    pub b_slope: *mut *mut pslope_s,
    pub secnum: size_t,
    pub fofflags: ffloortype_e,
    pub master: *mut line_s,
    pub target: *mut sector_s,
    pub next: *mut ffloor_s,
    pub prev: *mut ffloor_s,
    pub lastlight: int32_t,
    pub alpha: int32_t,
    pub blend: uint8_t,
    pub norender: tic_t,
    pub bustflags: ffloorbustflags_e,
    pub busttype: uint8_t,
    pub busttag: int16_t,
    pub sinkspeed: fixed_t,
    pub friction: fixed_t,
    pub bouncestrength: fixed_t,
    pub spawnflags: ffloortype_e,
    pub spawnalpha: int32_t,
    pub fadingdata: *mut libc::c_void,
}
pub type ffloortype_e = libc::c_uint;
pub const FOF_SPLAT: ffloortype_e = 1073741824;
pub const FOF_BOUNCY: ffloortype_e = 536870912;
pub const FOF_COLORMAPONLY: ffloortype_e = 268435456;
pub const FOF_RIPPLE: ffloortype_e = 134217728;
pub const FOF_INTANGIBLEFLATS: ffloortype_e = 100663296;
pub const FOF_REVERSEPLATFORM: ffloortype_e = 67108864;
pub const FOF_PLATFORM: ffloortype_e = 33554432;
pub const FOF_QUICKSAND: ffloortype_e = 16777216;
pub const FOF_BUSTUP: ffloortype_e = 8388608;
pub const FOF_MARIO: ffloortype_e = 4194304;
pub const FOF_GOOWATER: ffloortype_e = 2097152;
pub const FOF_CRUMBLE: ffloortype_e = 1048576;
pub const FOF_NORETURN: ffloortype_e = 524288;
pub const FOF_FLOATBOB: ffloortype_e = 262144;
pub const FOF_DOUBLESHADOW: ffloortype_e = 131072;
pub const FOF_INVERTSIDES: ffloortype_e = 65536;
pub const FOF_ALLSIDES: ffloortype_e = 32768;
pub const FOF_INVERTPLANES: ffloortype_e = 16384;
pub const FOF_FOG: ffloortype_e = 8192;
pub const FOF_TRANSLUCENT: ffloortype_e = 4096;
pub const FOF_EXTRA: ffloortype_e = 2048;
pub const FOF_BOTHPLANES: ffloortype_e = 1024;
pub const FOF_CUTSPRITES: ffloortype_e = 512;
pub const FOF_CUTLEVEL: ffloortype_e = 384;
pub const FOF_CUTEXTRA: ffloortype_e = 256;
pub const FOF_CUTSOLIDS: ffloortype_e = 128;
pub const FOF_NOSHADE: ffloortype_e = 64;
pub const FOF_SWIMMABLE: ffloortype_e = 32;
pub const FOF_RENDERALL: ffloortype_e = 24;
pub const FOF_RENDERPLANES: ffloortype_e = 16;
pub const FOF_RENDERSIDES: ffloortype_e = 8;
pub const FOF_SOLID: ffloortype_e = 6;
pub const FOF_BLOCKOTHERS: ffloortype_e = 4;
pub const FOF_BLOCKPLAYER: ffloortype_e = 2;
pub const FOF_EXISTS: ffloortype_e = 1;
pub type ffloorbustflags_e = libc::c_uint;
pub const FB_ONLYBOTTOM: ffloorbustflags_e = 4;
pub const FB_EXECUTOR: ffloorbustflags_e = 2;
pub const FB_PUSHABLES: ffloorbustflags_e = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sector_s {
    pub floorheight: fixed_t,
    pub ceilingheight: fixed_t,
    pub floorpic: int32_t,
    pub ceilingpic: int32_t,
    pub lightlevel: int16_t,
    pub special: int16_t,
    pub tags: taglist_t,
    pub soundorg: degenmobj_t,
    pub validcount: size_t,
    pub thinglist: *mut mobj_t,
    pub floordata: *mut libc::c_void,
    pub ceilingdata: *mut libc::c_void,
    pub lightingdata: *mut libc::c_void,
    pub fadecolormapdata: *mut libc::c_void,
    pub floorxoffset: fixed_t,
    pub flooryoffset: fixed_t,
    pub ceilingxoffset: fixed_t,
    pub ceilingyoffset: fixed_t,
    pub floorangle: angle_t,
    pub ceilingangle: angle_t,
    pub heightsec: int32_t,
    pub camsec: int32_t,
    pub floorlightlevel: int16_t,
    pub ceilinglightlevel: int16_t,
    pub floorlightabsolute: boolean,
    pub ceilinglightabsolute: boolean,
    pub floorlightsec: int32_t,
    pub ceilinglightsec: int32_t,
    pub crumblestate: int32_t,
    pub touching_thinglist: *mut msecnode_s,
    pub linecount: size_t,
    pub lines: *mut *mut line_s,
    pub ffloors: *mut ffloor_t,
    pub attached: *mut size_t,
    pub attachedsolid: *mut boolean,
    pub numattached: size_t,
    pub maxattached: size_t,
    pub lightlist: *mut lightlist_t,
    pub numlights: int32_t,
    pub moved: boolean,
    pub extra_colormap: *mut extracolormap_t,
    pub colormap_protected: boolean,
    pub gravity: fixed_t,
    pub gravityptr: *mut fixed_t,
    pub flags: sectorflags_t,
    pub specialflags: sectorspecialflags_t,
    pub damagetype: uint8_t,
    pub triggertag: mtag_t,
    pub triggerer: uint8_t,
    pub friction: fixed_t,
    pub cullheight: *mut line_s,
    pub floorspeed: fixed_t,
    pub ceilspeed: fixed_t,
    pub preciplist: *mut precipmobj_t,
    pub touching_preciplist: *mut mprecipsecnode_s,
    pub f_slope: *mut pslope_t,
    pub c_slope: *mut pslope_t,
    pub hasslope: boolean,
    pub spawn_lightlevel: int16_t,
    pub spawn_extra_colormap: *mut extracolormap_t,
}
pub type extracolormap_t = extracolormap_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct extracolormap_s {
    pub fadestart: uint8_t,
    pub fadeend: uint8_t,
    pub flags: uint8_t,
    pub rgba: int32_t,
    pub fadergba: int32_t,
    pub colormap: *mut lighttable_t,
    pub next: *mut extracolormap_s,
    pub prev: *mut extracolormap_s,
}
pub type lighttable_t = uint8_t;
pub type pslope_t = pslope_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mprecipsecnode_s {
    pub m_sector: *mut sector_t,
    pub m_thing: *mut precipmobj_s,
    pub m_sectorlist_prev: *mut mprecipsecnode_s,
    pub m_sectorlist_next: *mut mprecipsecnode_s,
    pub m_thinglist_prev: *mut mprecipsecnode_s,
    pub m_thinglist_next: *mut mprecipsecnode_s,
    pub visited: boolean,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct precipmobj_s {
    pub thinker: thinker_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub old_x: fixed_t,
    pub old_y: fixed_t,
    pub old_z: fixed_t,
    pub old_x2: fixed_t,
    pub old_y2: fixed_t,
    pub old_z2: fixed_t,
    pub snext: *mut precipmobj_s,
    pub sprev: *mut *mut precipmobj_s,
    pub angle: angle_t,
    pub pitch: angle_t,
    pub roll: angle_t,
    pub old_angle: angle_t,
    pub old_pitch: angle_t,
    pub old_roll: angle_t,
    pub old_angle2: angle_t,
    pub old_pitch2: angle_t,
    pub old_roll2: angle_t,
    pub spriteroll: angle_t,
    pub old_spriteroll: angle_t,
    pub old_spriteroll2: angle_t,
    pub sprite: spritenum_t,
    pub frame: uint32_t,
    pub sprite2: uint8_t,
    pub anim_duration: uint16_t,
    pub renderflags: uint32_t,
    pub blendmode: int32_t,
    pub spritexscale: fixed_t,
    pub spriteyscale: fixed_t,
    pub spritexoffset: fixed_t,
    pub spriteyoffset: fixed_t,
    pub old_spritexscale: fixed_t,
    pub old_spriteyscale: fixed_t,
    pub old_spritexoffset: fixed_t,
    pub old_spriteyoffset: fixed_t,
    pub floorspriteslope: *mut pslope_s,
    pub touching_sectorlist: *mut mprecipsecnode_s,
    pub subsector: *mut subsector_s,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
    pub floorrover: *mut ffloor_s,
    pub ceilingrover: *mut ffloor_s,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub momx: fixed_t,
    pub momy: fixed_t,
    pub momz: fixed_t,
    pub precipflags: fixed_t,
    pub tics: int32_t,
    pub state: *mut state_t,
    pub flags: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct subsector_s {
    pub sector: *mut sector_t,
    pub numlines: int16_t,
    pub firstline: uint32_t,
    pub polyList: *mut polyobj_s,
    pub validcount: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct polyobj_s {
    pub link: mdllistitem_t,
    pub id: int32_t,
    pub first: int32_t,
    pub next: int32_t,
    pub parent: int32_t,
    pub segCount: size_t,
    pub numSegsAlloc: size_t,
    pub segs: *mut *mut seg_s,
    pub numVertices: size_t,
    pub numVerticesAlloc: size_t,
    pub origVerts: *mut vertex_t,
    pub tmpVerts: *mut vertex_t,
    pub vertices: *mut *mut vertex_t,
    pub numLines: size_t,
    pub numLinesAlloc: size_t,
    pub lines: *mut *mut line_s,
    pub spawnSpot: degenmobj_t,
    pub centerPt: vertex_t,
    pub zdist: fixed_t,
    pub angle: angle_t,
    pub attached: uint8_t,
    pub blockbox: [fixed_t; 4],
    pub linked: uint8_t,
    pub validcount: size_t,
    pub damage: int32_t,
    pub thrust: fixed_t,
    pub flags: int32_t,
    pub thinker: *mut thinker_t,
    pub isBad: uint8_t,
    pub translucency: int32_t,
    pub triggertag: int16_t,
    pub visplane: *mut visplane_s,
    pub spawnflags: int32_t,
    pub spawntrans: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct visplane_s {
    pub next: *mut visplane_s,
    pub height: fixed_t,
    pub viewx: fixed_t,
    pub viewy: fixed_t,
    pub viewz: fixed_t,
    pub viewangle: angle_t,
    pub plangle: angle_t,
    pub picnum: int32_t,
    pub lightlevel: int32_t,
    pub minx: int32_t,
    pub maxx: int32_t,
    pub extra_colormap: *mut extracolormap_t,
    pub padtopstart: uint16_t,
    pub top: [uint16_t; 1920],
    pub padtopend: uint16_t,
    pub padbottomstart: uint16_t,
    pub bottom: [uint16_t; 1920],
    pub padbottomend: uint16_t,
    pub high: int32_t,
    pub low: int32_t,
    pub xoffs: fixed_t,
    pub yoffs: fixed_t,
    pub ffloor: *mut ffloor_s,
    pub polyobj: *mut polyobj_t,
    pub slope: *mut pslope_t,
}
pub type polyobj_t = polyobj_s;
pub type thinker_t = thinker_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct thinker_s {
    pub prev: *mut thinker_s,
    pub next: *mut thinker_s,
    pub function: think_t,
    pub references: int32_t,
}
pub type think_t = actionf_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vertex_t {
    pub x: fixed_t,
    pub y: fixed_t,
    pub floorzset: boolean,
    pub ceilingzset: boolean,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct degenmobj_t {
    pub thinker: thinker_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct line_s {
    pub v1: *mut vertex_t,
    pub v2: *mut vertex_t,
    pub dx: fixed_t,
    pub dy: fixed_t,
    pub angle: angle_t,
    pub flags: int16_t,
    pub special: int16_t,
    pub tags: taglist_t,
    pub args: [int32_t; 10],
    pub stringargs: [*mut libc::c_char; 2],
    pub sidenum: [uint16_t; 2],
    pub alpha: fixed_t,
    pub blendmode: uint8_t,
    pub executordelay: int32_t,
    pub bbox: [fixed_t; 4],
    pub slopetype: slopetype_t,
    pub frontsector: *mut sector_t,
    pub backsector: *mut sector_t,
    pub validcount: size_t,
    pub polyobj: *mut polyobj_t,
    pub callcount: int16_t,
}
pub type sector_t = sector_s;
pub type slopetype_t = libc::c_uint;
pub const ST_NEGATIVE: slopetype_t = 3;
pub const ST_POSITIVE: slopetype_t = 2;
pub const ST_VERTICAL: slopetype_t = 1;
pub const ST_HORIZONTAL: slopetype_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct seg_s {
    pub v1: *mut vertex_t,
    pub v2: *mut vertex_t,
    pub side: int32_t,
    pub offset: fixed_t,
    pub angle: angle_t,
    pub sidedef: *mut side_t,
    pub linedef: *mut line_t,
    pub frontsector: *mut sector_t,
    pub backsector: *mut sector_t,
    pub length: fixed_t,
    pub numlights: size_t,
    pub rlights: *mut r_lightlist_t,
    pub polyseg: *mut polyobj_t,
    pub dontrenderme: boolean,
    pub glseg: boolean,
}
pub type r_lightlist_t = r_lightlist_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct r_lightlist_s {
    pub height: fixed_t,
    pub heightstep: fixed_t,
    pub botheight: fixed_t,
    pub botheightstep: fixed_t,
    pub startheight: fixed_t,
    pub lightlevel: int16_t,
    pub extra_colormap: *mut extracolormap_t,
    pub rcolormap: *mut lighttable_t,
    pub flags: ffloortype_e,
    pub lightnum: int32_t,
}
pub type line_t = line_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct side_t {
    pub textureoffset: fixed_t,
    pub rowoffset: fixed_t,
    pub offsetx_top: fixed_t,
    pub offsetx_mid: fixed_t,
    pub offsetx_bot: fixed_t,
    pub offsety_top: fixed_t,
    pub offsety_mid: fixed_t,
    pub offsety_bot: fixed_t,
    pub toptexture: int32_t,
    pub bottomtexture: int32_t,
    pub midtexture: int32_t,
    pub line: *mut line_t,
    pub sector: *mut sector_t,
    pub special: int16_t,
    pub repeatcnt: int16_t,
    pub colormap_data: *mut extracolormap_t,
}
pub type mdllistitem_t = mdllistitem_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mdllistitem_s {
    pub next: *mut mdllistitem_s,
    pub prev: *mut *mut mdllistitem_s,
}
pub type precipmobj_t = precipmobj_s;
pub type sectorspecialflags_t = libc::c_uint;
pub const SSF_GRAVITYOVERRIDE: sectorspecialflags_t = 1048576;
pub const SSF_JUMPFLIP: sectorspecialflags_t = 524288;
pub const SSF_ROPEHANG: sectorspecialflags_t = 262144;
pub const SSF_FINISHLINE: sectorspecialflags_t = 131072;
pub const SSF_ZOOMTUBEEND: sectorspecialflags_t = 65536;
pub const SSF_ZOOMTUBESTART: sectorspecialflags_t = 32768;
pub const SSF_FORCESPIN: sectorspecialflags_t = 16384;
pub const SSF_SUPERTRANSFORM: sectorspecialflags_t = 8192;
pub const SSF_FAN: sectorspecialflags_t = 4096;
pub const SSF_BLUETEAMBASE: sectorspecialflags_t = 2048;
pub const SSF_REDTEAMBASE: sectorspecialflags_t = 1024;
pub const SSF_RETURNFLAG: sectorspecialflags_t = 512;
pub const SSF_SPECIALSTAGEPIT: sectorspecialflags_t = 256;
pub const SSF_EXIT: sectorspecialflags_t = 128;
pub const SSF_STARPOSTACTIVATOR: sectorspecialflags_t = 64;
pub const SSF_SPEEDPAD: sectorspecialflags_t = 32;
pub const SSF_CONVEYOR: sectorspecialflags_t = 16;
pub const SSF_WINDCURRENT: sectorspecialflags_t = 8;
pub const SSF_NOSTEPDOWN: sectorspecialflags_t = 4;
pub const SSF_DOUBLESTEPUP: sectorspecialflags_t = 2;
pub const SSF_OUTERSPACE: sectorspecialflags_t = 1;
pub type sectorflags_t = libc::c_uint;
pub const MSF_NOCLIPCAMERA: sectorflags_t = 512;
pub const MSF_HEATWAVE: sectorflags_t = 256;
pub const MSF_GRAVITYFLIP: sectorflags_t = 128;
pub const MSF_INVERTPRECIP: sectorflags_t = 64;
pub const MSF_TRIGGERLINE_MOBJ: sectorflags_t = 32;
pub const MSF_TRIGGERLINE_PLANE: sectorflags_t = 16;
pub const MSF_TRIGGERSPECIAL_HEADBUMP: sectorflags_t = 8;
pub const MSF_TRIGGERSPECIAL_TOUCH: sectorflags_t = 4;
pub const MSF_FLIPSPECIAL_BOTH: sectorflags_t = 3;
pub const MSF_FLIPSPECIAL_CEILING: sectorflags_t = 2;
pub const MSF_FLIPSPECIAL_FLOOR: sectorflags_t = 1;
pub type lightlist_t = lightlist_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lightlist_s {
    pub height: fixed_t,
    pub lightlevel: *mut int16_t,
    pub extra_colormap: *mut *mut extracolormap_t,
    pub flags: int32_t,
    pub caster: *mut ffloor_t,
    pub slope: *mut pslope_s,
}
pub type ffloor_t = ffloor_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct msecnode_s {
    pub m_sector: *mut sector_t,
    pub m_thing: *mut mobj_s,
    pub m_sectorlist_prev: *mut msecnode_s,
    pub m_sectorlist_next: *mut msecnode_s,
    pub m_thinglist_prev: *mut msecnode_s,
    pub m_thinglist_next: *mut msecnode_s,
    pub visited: boolean,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sfxinfo_struct {
    pub name: *const libc::c_char,
    pub singularity: boolean,
    pub priority: int32_t,
    pub pitch: int32_t,
    pub volume: int32_t,
    pub data: *mut libc::c_void,
    pub length: size_t,
    pub skinsound: int32_t,
    pub usefulness: int32_t,
    pub lumpnum: lumpnum_t,
    pub caption: [libc::c_char; 32],
}
pub type sfxinfo_t = sfxinfo_struct;
pub type C2RustUnnamed_2 = libc::c_uint;
pub const MF_RUNSPAWNFUNC: C2RustUnnamed_2 = 536870912;
pub const MF_GRENADEBOUNCE: C2RustUnnamed_2 = 268435456;
pub const MF_NOCLIPTHING: C2RustUnnamed_2 = 134217728;
pub const MF_NIGHTSITEM: C2RustUnnamed_2 = 67108864;
pub const MF_STICKY: C2RustUnnamed_2 = 33554432;
pub const MF_PAIN: C2RustUnnamed_2 = 16777216;
pub const MF_SCENERY: C2RustUnnamed_2 = 8388608;
pub const MF_ENEMY: C2RustUnnamed_2 = 4194304;
pub const MF_NOCLIPHEIGHT: C2RustUnnamed_2 = 2097152;
pub const MF_FIRE: C2RustUnnamed_2 = 1048576;
pub const MF_NOTHINK: C2RustUnnamed_2 = 524288;
pub const MF_MONITOR: C2RustUnnamed_2 = 262144;
pub const MF_BOUNCE: C2RustUnnamed_2 = 131072;
pub const MF_SPRING: C2RustUnnamed_2 = 65536;
pub const MF_MISSILE: C2RustUnnamed_2 = 32768;
pub const MF_BOXICON: C2RustUnnamed_2 = 16384;
pub const MF_FLOAT: C2RustUnnamed_2 = 8192;
pub const MF_NOCLIP: C2RustUnnamed_2 = 4096;
pub const MF_SLIDEME: C2RustUnnamed_2 = 2048;
pub const MF_AMBIENT: C2RustUnnamed_2 = 1024;
pub const MF_NOGRAVITY: C2RustUnnamed_2 = 512;
pub const MF_SPAWNCEILING: C2RustUnnamed_2 = 256;
pub const MF_BOSS: C2RustUnnamed_2 = 128;
pub const MF_PUSHABLE: C2RustUnnamed_2 = 64;
pub const MF_PAPERCOLLISION: C2RustUnnamed_2 = 32;
pub const MF_NOBLOCKMAP: C2RustUnnamed_2 = 16;
pub const MF_NOSECTOR: C2RustUnnamed_2 = 8;
pub const MF_SHOOTABLE: C2RustUnnamed_2 = 4;
pub const MF_SOLID: C2RustUnnamed_2 = 2;
pub const MF_SPECIAL: C2RustUnnamed_2 = 1;
pub type C2RustUnnamed_3 = libc::c_uint;
pub const MF2_SPLAT: C2RustUnnamed_3 = 1073741824;
pub const MF2_SHIELD: C2RustUnnamed_3 = 536870912;
pub const MF2_LINKDRAW: C2RustUnnamed_3 = 268435456;
pub const MF2_AMBUSH: C2RustUnnamed_3 = 134217728;
pub const MF2_BOSSDEAD: C2RustUnnamed_3 = 67108864;
pub const MF2_BOSSFLEE: C2RustUnnamed_3 = 33554432;
pub const MF2_BOSSNOTRAP: C2RustUnnamed_3 = 16777216;
pub const MF2_FRET: C2RustUnnamed_3 = 8388608;
pub const MF2_SKULLFLY: C2RustUnnamed_3 = 4194304;
pub const MF2_OBJECTFLIP: C2RustUnnamed_3 = 2097152;
pub const MF2_STRONGBOX: C2RustUnnamed_3 = 1048576;
pub const MF2_SHADOW: C2RustUnnamed_3 = 524288;
pub const MF2_SUPERFIRE: C2RustUnnamed_3 = 262144;
pub const MF2_FIRING: C2RustUnnamed_3 = 131072;
pub const MF2_JUSTATTACKED: C2RustUnnamed_3 = 65536;
pub const MF2_NIGHTSPULL: C2RustUnnamed_3 = 32768;
pub const MF2_DEBRIS: C2RustUnnamed_3 = 16384;
pub const MF2_INFLOAT: C2RustUnnamed_3 = 8192;
pub const MF2_INVERTAIMABLE: C2RustUnnamed_3 = 4096;
pub const MF2_CLASSICPUSH: C2RustUnnamed_3 = 2048;
pub const MF2_SLIDEPUSH: C2RustUnnamed_3 = 1024;
pub const MF2_BEYONDTHEGRAVE: C2RustUnnamed_3 = 512;
pub const MF2_SCATTER: C2RustUnnamed_3 = 256;
pub const MF2_EXPLOSION: C2RustUnnamed_3 = 128;
pub const MF2_BOUNCERING: C2RustUnnamed_3 = 64;
pub const MF2_RAILRING: C2RustUnnamed_3 = 32;
pub const MF2_AUTOMATIC: C2RustUnnamed_3 = 16;
pub const MF2_DONTDRAW: C2RustUnnamed_3 = 8;
pub const MF2_DONTRESPAWN: C2RustUnnamed_3 = 4;
pub const MF2_TWOD: C2RustUnnamed_3 = 2;
pub const MF2_AXIS: C2RustUnnamed_3 = 1;
pub type skinflags_t = libc::c_uint;
pub const SF_NOSHIELDABILITY: skinflags_t = 524288;
pub const SF_CANBUSTWALLS: skinflags_t = 262144;
pub const SF_NOSUPERJUMPBOOST: skinflags_t = 131072;
pub const SF_NOSUPERSPRITES: skinflags_t = 65536;
pub const SF_NONIGHTSSUPER: skinflags_t = 32768;
pub const SF_NONIGHTSROTATION: skinflags_t = 16384;
pub const SF_MULTIABILITY: skinflags_t = 8192;
pub const SF_FASTEDGE: skinflags_t = 4096;
pub const SF_DASHMODE: skinflags_t = 2048;
pub const SF_MACHINE: skinflags_t = 1024;
pub const SF_MARIODAMAGE: skinflags_t = 768;
pub const SF_STOMPDAMAGE: skinflags_t = 512;
pub const SF_NOJUMPDAMAGE: skinflags_t = 256;
pub const SF_NOJUMPSPIN: skinflags_t = 128;
pub const SF_RUNONWATER: skinflags_t = 64;
pub const SF_NOSPEEDADJUST: skinflags_t = 32;
pub const SF_NOSKID: skinflags_t = 16;
pub const SF_HIRES: skinflags_t = 8;
pub const SF_NOSPINDASHDUST: skinflags_t = 4;
pub const SF_NOSUPERSPIN: skinflags_t = 2;
pub const SF_SUPER: skinflags_t = 1;
pub type player_t = player_s;
pub type marathonmode_t = libc::c_uint;
pub const MA_INGAME: marathonmode_t = 8;
pub const MA_NOCUTSCENES: marathonmode_t = 4;
pub const MA_INIT: marathonmode_t = 2;
pub const MA_RUNNING: marathonmode_t = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct textpage_t {
    pub numpics: uint8_t,
    pub picmode: uint8_t,
    pub pictoloop: uint8_t,
    pub pictostart: uint8_t,
    pub picname: [[libc::c_char; 8]; 8],
    pub pichires: [uint8_t; 8],
    pub xcoord: [uint16_t; 8],
    pub ycoord: [uint16_t; 8],
    pub picduration: [uint16_t; 8],
    pub musswitch: [libc::c_char; 7],
    pub musswitchflags: uint16_t,
    pub musicloop: uint8_t,
    pub tag: [libc::c_char; 33],
    pub name: [libc::c_char; 34],
    pub iconname: [libc::c_char; 8],
    pub rightside: boolean,
    pub iconflip: boolean,
    pub hidehud: uint8_t,
    pub lines: uint8_t,
    pub backcolor: int32_t,
    pub align: uint8_t,
    pub verticalalign: uint8_t,
    pub textspeed: uint8_t,
    pub textsfx: sfxenum_t,
    pub nextprompt: uint8_t,
    pub nextpage: uint8_t,
    pub nexttag: [libc::c_char; 33],
    pub timetonext: int32_t,
    pub text: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct textprompt_t {
    pub page: [textpage_t; 128],
    pub numpages: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mappoint_t {
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct quake {
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub time: uint16_t,
    pub epicenter: *mut mappoint_t,
    pub radius: fixed_t,
    pub intensity: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nightsgrades_t {
    pub grade: [uint32_t; 6],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct customoption_t {
    pub option: [libc::c_char; 32],
    pub value: [libc::c_char; 256],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mapheader_t {
    pub lvlttl: [libc::c_char; 22],
    pub subttl: [libc::c_char; 33],
    pub actnum: uint8_t,
    pub typeoflevel: uint32_t,
    pub nextlevel: int16_t,
    pub marathonnext: int16_t,
    pub keywords: [libc::c_char; 33],
    pub musname: [libc::c_char; 7],
    pub mustrack: uint16_t,
    pub muspos: uint32_t,
    pub forcecharacter: [libc::c_char; 17],
    pub weather: uint8_t,
    pub skynum: int16_t,
    pub skybox_scalex: int16_t,
    pub skybox_scaley: int16_t,
    pub skybox_scalez: int16_t,
    pub interscreen: [libc::c_char; 8],
    pub runsoc: [libc::c_char; 33],
    pub scriptname: [libc::c_char; 33],
    pub precutscenenum: uint8_t,
    pub cutscenenum: uint8_t,
    pub countdown: int16_t,
    pub palette: uint16_t,
    pub numlaps: uint8_t,
    pub unlockrequired: int8_t,
    pub levelselect: uint8_t,
    pub bonustype: int8_t,
    pub maxbonuslives: int8_t,
    pub levelflags: uint16_t,
    pub menuflags: uint8_t,
    pub selectheading: [libc::c_char; 22],
    pub startrings: uint16_t,
    pub sstimer: int32_t,
    pub ssspheres: uint32_t,
    pub gravity: fixed_t,
    pub ltzzpatch: [libc::c_char; 9],
    pub ltzztext: [libc::c_char; 9],
    pub ltactdiamond: [libc::c_char; 9],
    pub numFlickies: uint8_t,
    pub flickies: *mut mobjtype_t,
    pub numGradedMares: uint8_t,
    pub grades: *mut nightsgrades_t,
    pub musinterfadeout: uint32_t,
    pub musintername: [libc::c_char; 7],
    pub muspostbossname: [libc::c_char; 7],
    pub muspostbosstrack: uint16_t,
    pub muspostbosspos: uint32_t,
    pub muspostbossfadein: uint32_t,
    pub musforcereset: int8_t,
    pub numCustomOptions: uint8_t,
    pub customopts: *mut customoption_t,
}
pub type GameTypeRules = libc::c_int;
pub const GTR_CUTSCENES: GameTypeRules = -2147483648;
pub const GTR_NOTITLECARD: GameTypeRules = 1073741824;
pub const GTR_ALLOWEXIT: GameTypeRules = 536870912;
pub const GTR_SPAWNENEMIES: GameTypeRules = 268435456;
pub const GTR_SPAWNINVUL: GameTypeRules = 134217728;
pub const GTR_DEATHMATCHSTARTS: GameTypeRules = 67108864;
pub const GTR_NOSPECTATORSPAWN: GameTypeRules = 33554432;
pub const GTR_DEATHPENALTY: GameTypeRules = 16777216;
pub const GTR_PITYSHIELD: GameTypeRules = 8388608;
pub const GTR_RESPAWNDELAY: GameTypeRules = 4194304;
pub const GTR_BLINDFOLDED: GameTypeRules = 2097152;
pub const GTR_HIDEFROZEN: GameTypeRules = 1048576;
pub const GTR_STARTCOUNTDOWN: GameTypeRules = 524288;
pub const GTR_FRIENDLYFIRE: GameTypeRules = 262144;
pub const GTR_HURTMESSAGES: GameTypeRules = 131072;
pub const GTR_OVERTIME: GameTypeRules = 65536;
pub const GTR_TIMELIMIT: GameTypeRules = 32768;
pub const GTR_POINTLIMIT: GameTypeRules = 16384;
pub const GTR_TAG: GameTypeRules = 8192;
pub const GTR_RACE: GameTypeRules = 4096;
pub const GTR_EMERALDHUNT: GameTypeRules = 2048;
pub const GTR_EMERALDTOKENS: GameTypeRules = 1024;
pub const GTR_SPECIALSTAGES: GameTypeRules = 512;
pub const GTR_FRIENDLY: GameTypeRules = 256;
pub const GTR_TEAMFLAGS: GameTypeRules = 128;
pub const GTR_POWERSTONES: GameTypeRules = 64;
pub const GTR_FIRSTPERSON: GameTypeRules = 32;
pub const GTR_TEAMS: GameTypeRules = 16;
pub const GTR_LIVES: GameTypeRules = 8;
pub const GTR_SPECTATORS: GameTypeRules = 4;
pub const GTR_RINGSLINGER: GameTypeRules = 2;
pub const GTR_CAMPAIGN: GameTypeRules = 1;
pub type TypeOfLevel = libc::c_uint;
pub const TOL_XMAS: TypeOfLevel = 4096;
pub const TOL_ERZ3: TypeOfLevel = 2048;
pub const TOL_NIGHTS: TypeOfLevel = 1024;
pub const TOL_MARIO: TypeOfLevel = 512;
pub const TOL_2D: TypeOfLevel = 256;
pub const TOL_CTF: TypeOfLevel = 64;
pub const TOL_TAG: TypeOfLevel = 32;
pub const TOL_MATCH: TypeOfLevel = 16;
pub const TOL_RACE: TypeOfLevel = 8;
pub const TOL_COMPETITION: TypeOfLevel = 4;
pub const TOL_COOP: TypeOfLevel = 2;
pub const TOL_SP: TypeOfLevel = 1;
pub type com_flags_t = libc::c_uint;
pub const COM_LUA: com_flags_t = 8;
pub const COM_LOCAL: com_flags_t = 4;
pub const COM_SPLITSCREEN: com_flags_t = 2;
pub const COM_ADMIN: com_flags_t = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CV_PossibleValue_s {
    pub value: int32_t,
    pub strvalue: *const libc::c_char,
}
pub type CV_PossibleValue_t = CV_PossibleValue_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct consvar_s {
    pub name: *const libc::c_char,
    pub defaultvalue: *const libc::c_char,
    pub flags: int32_t,
    pub PossibleValue: *mut CV_PossibleValue_t,
    pub func: Option::<unsafe extern "C" fn() -> ()>,
    pub value: int32_t,
    pub string: *const libc::c_char,
    pub zstring: *mut libc::c_char,
    pub revert: C2RustUnnamed_4,
    pub netid: uint16_t,
    pub changed: libc::c_char,
    pub next: *mut consvar_s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub allocated: libc::c_char,
    pub v: C2RustUnnamed_5,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_5 {
    pub string: *mut libc::c_char,
    pub const_munge: *const libc::c_char,
}
pub type consvar_t = consvar_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct recorddata_t {
    pub time: tic_t,
    pub score: uint32_t,
    pub rings: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nightsdata_t {
    pub nummares: uint8_t,
    pub score: [uint32_t; 9],
    pub grade: [uint8_t; 9],
    pub time: [tic_t; 9],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct gamedata_t {
    pub loaded: boolean,
    pub achieved: [boolean; 128],
    pub collected: [boolean; 512],
    pub extraCollected: [boolean; 48],
    pub unlocked: [boolean; 80],
    pub mainrecords: [*mut recorddata_t; 1035],
    pub nightsrecords: [*mut nightsdata_t; 1035],
    pub mapvisited: [uint8_t; 1035],
    pub timesBeaten: uint32_t,
    pub timesBeatenWithEmeralds: uint32_t,
    pub timesBeatenUltimate: uint32_t,
    pub totalplaytime: uint32_t,
}
pub type C2RustUnnamed_6 = libc::c_uint;
pub const BOXRIGHT: C2RustUnnamed_6 = 3;
pub const BOXLEFT: C2RustUnnamed_6 = 2;
pub const BOXBOTTOM: C2RustUnnamed_6 = 1;
pub const BOXTOP: C2RustUnnamed_6 = 0;
pub type C2RustUnnamed_7 = libc::c_uint;
pub const TMPF_SPLAT: C2RustUnnamed_7 = 64;
pub const TMPF_CRUSH: C2RustUnnamed_7 = 32;
pub const TMPF_EXECUTOR: C2RustUnnamed_7 = 16;
pub const TMPF_INVISIBLEPLANES: C2RustUnnamed_7 = 8;
pub const TMPF_PUSHABLESTOP: C2RustUnnamed_7 = 4;
pub const TMPF_INTANGIBLE: C2RustUnnamed_7 = 2;
pub const TMPF_NOINSIDES: C2RustUnnamed_7 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct polymaplink_s {
    pub link: mdllistitem_t,
    pub po: *mut polyobj_t,
}
pub type polymaplink_t = polymaplink_s;
pub type C2RustUnnamed_8 = libc::c_uint;
pub const PWR_COMEBACK: C2RustUnnamed_8 = 2;
pub const PWR_WRAP: C2RustUnnamed_8 = 1;
pub const PWR_STOP: C2RustUnnamed_8 = 0;
pub type C2RustUnnamed_9 = libc::c_uint;
pub const TMPR_OVERRIDE: C2RustUnnamed_9 = 8;
pub const TMPR_CONTINUOUS: C2RustUnnamed_9 = 4;
pub const TMPR_ROTATEPLAYERS: C2RustUnnamed_9 = 2;
pub const TMPR_DONTROTATEOTHERS: C2RustUnnamed_9 = 1;
pub type C2RustUnnamed_10 = libc::c_uint;
pub const PWF_LOOP: C2RustUnnamed_10 = 2;
pub const PWF_REVERSE: C2RustUnnamed_10 = 1;
pub type C2RustUnnamed_11 = libc::c_uint;
pub const TMPF_GHOSTFADE: C2RustUnnamed_11 = 16;
pub const TMPF_IGNORECOLLISION: C2RustUnnamed_11 = 8;
pub const TMPF_TICBASED: C2RustUnnamed_11 = 4;
pub const TMPF_OVERRIDE: C2RustUnnamed_11 = 2;
pub const TMPF_RELATIVE: C2RustUnnamed_11 = 1;
pub type C2RustUnnamed_12 = libc::c_uint;
pub const FF_OLD_COLORMAPONLY: C2RustUnnamed_12 = 2147483648;
pub const FF_OLD_RIPPLE: C2RustUnnamed_12 = 1073741824;
pub const FF_OLD_STRONGBUST: C2RustUnnamed_12 = 536870912;
pub const FF_OLD_SPINBUST: C2RustUnnamed_12 = 268435456;
pub const FF_OLD_SHATTER: C2RustUnnamed_12 = 134217728;
pub const FF_OLD_INTANGIBLEFLATS: C2RustUnnamed_12 = 100663296;
pub const FF_OLD_REVERSEPLATFORM: C2RustUnnamed_12 = 67108864;
pub const FF_OLD_PLATFORM: C2RustUnnamed_12 = 33554432;
pub const FF_OLD_QUICKSAND: C2RustUnnamed_12 = 16777216;
pub const FF_OLD_BUSTUP: C2RustUnnamed_12 = 8388608;
pub const FF_OLD_MARIO: C2RustUnnamed_12 = 4194304;
pub const FF_OLD_GOOWATER: C2RustUnnamed_12 = 2097152;
pub const FF_OLD_SHATTERBOTTOM: C2RustUnnamed_12 = 2097152;
pub const FF_OLD_CRUMBLE: C2RustUnnamed_12 = 1048576;
pub const FF_OLD_NORETURN: C2RustUnnamed_12 = 524288;
pub const FF_OLD_FLOATBOB: C2RustUnnamed_12 = 262144;
pub const FF_OLD_DOUBLESHADOW: C2RustUnnamed_12 = 131072;
pub const FF_OLD_INVERTSIDES: C2RustUnnamed_12 = 65536;
pub const FF_OLD_ALLSIDES: C2RustUnnamed_12 = 32768;
pub const FF_OLD_INVERTPLANES: C2RustUnnamed_12 = 16384;
pub const FF_OLD_FOG: C2RustUnnamed_12 = 8192;
pub const FF_OLD_TRANSLUCENT: C2RustUnnamed_12 = 4096;
pub const FF_OLD_EXTRA: C2RustUnnamed_12 = 2048;
pub const FF_OLD_BOTHPLANES: C2RustUnnamed_12 = 1024;
pub const FF_OLD_CUTSPRITES: C2RustUnnamed_12 = 512;
pub const FF_OLD_CUTLEVEL: C2RustUnnamed_12 = 384;
pub const FF_OLD_CUTEXTRA: C2RustUnnamed_12 = 256;
pub const FF_OLD_CUTSOLIDS: C2RustUnnamed_12 = 128;
pub const FF_OLD_NOSHADE: C2RustUnnamed_12 = 64;
pub const FF_OLD_SWIMMABLE: C2RustUnnamed_12 = 32;
pub const FF_OLD_RENDERALL: C2RustUnnamed_12 = 24;
pub const FF_OLD_RENDERPLANES: C2RustUnnamed_12 = 16;
pub const FF_OLD_RENDERSIDES: C2RustUnnamed_12 = 8;
pub const FF_OLD_SOLID: C2RustUnnamed_12 = 6;
pub const FF_OLD_BLOCKOTHERS: C2RustUnnamed_12 = 4;
pub const FF_OLD_BLOCKPLAYER: C2RustUnnamed_12 = 2;
pub const FF_OLD_EXISTS: C2RustUnnamed_12 = 1;
pub type C2RustUnnamed_13 = libc::c_uint;
pub const SD_SPECIALSTAGE: C2RustUnnamed_13 = 10;
pub const SD_INSTAKILL: C2RustUnnamed_13 = 9;
pub const SD_DEATHPITNOTILT: C2RustUnnamed_13 = 8;
pub const SD_DEATHPITTILT: C2RustUnnamed_13 = 7;
pub const SD_SPIKE: C2RustUnnamed_13 = 6;
pub const SD_ELECTRIC: C2RustUnnamed_13 = 5;
pub const SD_LAVA: C2RustUnnamed_13 = 4;
pub const SD_FIRE: C2RustUnnamed_13 = 3;
pub const SD_WATER: C2RustUnnamed_13 = 2;
pub const SD_GENERIC: C2RustUnnamed_13 = 1;
pub const SD_NONE: C2RustUnnamed_13 = 0;
pub type C2RustUnnamed_14 = libc::c_uint;
pub const TO_PLAYERNIGHTS: C2RustUnnamed_14 = 4;
pub const TO_PLAYEREMERALDS: C2RustUnnamed_14 = 3;
pub const TO_MOBJ: C2RustUnnamed_14 = 2;
pub const TO_ALLPLAYERS: C2RustUnnamed_14 = 1;
pub const TO_PLAYER: C2RustUnnamed_14 = 0;
pub type C2RustUnnamed_15 = libc::c_uint;
pub const CRUMBLE_RESTORE: C2RustUnnamed_15 = 4;
pub const CRUMBLE_FALL: C2RustUnnamed_15 = 3;
pub const CRUMBLE_ACTIVATED: C2RustUnnamed_15 = 2;
pub const CRUMBLE_WAIT: C2RustUnnamed_15 = 1;
pub const CRUMBLE_NONE: C2RustUnnamed_15 = 0;
pub type subsector_t = subsector_s;
pub type seg_t = seg_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct node_t {
    pub x: fixed_t,
    pub y: fixed_t,
    pub dx: fixed_t,
    pub dy: fixed_t,
    pub bbox: [[fixed_t; 4]; 2],
    pub children: [uint16_t; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rotsprite_t {
    pub angles: int32_t,
    pub patches: *mut *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct softwarepatch_t {
    pub width: int16_t,
    pub height: int16_t,
    pub leftoffset: int16_t,
    pub topoffset: int16_t,
    pub columnofs: [int32_t; 8],
}
pub type patchalphastyle = libc::c_uint;
pub const AST_FOG: patchalphastyle = 7;
pub const AST_OVERLAY: patchalphastyle = 6;
pub const AST_MODULATE: patchalphastyle = 5;
pub const AST_REVERSESUBTRACT: patchalphastyle = 4;
pub const AST_SUBTRACT: patchalphastyle = 3;
pub const AST_ADD: patchalphastyle = 2;
pub const AST_TRANSLUCENT: patchalphastyle = 1;
pub const AST_COPY: patchalphastyle = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spriteframe_t {
    pub rotate: uint8_t,
    pub lumppat: [lumpnum_t; 16],
    pub lumpid: [size_t; 16],
    pub flip: uint16_t,
    pub rotated: [[*mut rotsprite_t; 16]; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spritedef_t {
    pub numframes: size_t,
    pub spriteframes: *mut spriteframe_t,
}
pub type C2RustUnnamed_16 = libc::c_uint;
pub const NUM_THINKERLISTS: C2RustUnnamed_16 = 5;
pub const THINK_PRECIP: C2RustUnnamed_16 = 4;
pub const THINK_DYNSLOPE: C2RustUnnamed_16 = 3;
pub const THINK_MOBJ: C2RustUnnamed_16 = 2;
pub const THINK_MAIN: C2RustUnnamed_16 = 1;
pub const THINK_POLYOBJ: C2RustUnnamed_16 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct camera_s {
    pub chase: boolean,
    pub aiming: angle_t,
    pub viewheight: fixed_t,
    pub startangle: angle_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub reset: boolean,
    pub angle: angle_t,
    pub subsector: *mut subsector_s,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub relativex: fixed_t,
    pub momx: fixed_t,
    pub momy: fixed_t,
    pub momz: fixed_t,
}
pub type camera_t = camera_s;
pub type C2RustUnnamed_17 = libc::c_uint;
pub const TMM_ALWAYSTHINK: C2RustUnnamed_17 = 128;
pub const TMM_CLIP: C2RustUnnamed_17 = 64;
pub const TMM_CENTERLINK: C2RustUnnamed_17 = 32;
pub const TMM_MACELINKS: C2RustUnnamed_17 = 16;
pub const TMM_SWING: C2RustUnnamed_17 = 8;
pub const TMM_ALLOWYAWCONTROL: C2RustUnnamed_17 = 4;
pub const TMM_SILENT: C2RustUnnamed_17 = 2;
pub const TMM_DOUBLESIZE: C2RustUnnamed_17 = 1;
pub type C2RustUnnamed_18 = libc::c_uint;
pub const TMDA_TOP: C2RustUnnamed_18 = 8;
pub const TMDA_MIDDLE: C2RustUnnamed_18 = 4;
pub const TMDA_BOTTOM: C2RustUnnamed_18 = 2;
pub const TMDA_BOTTOMOFFSET: C2RustUnnamed_18 = 1;
pub type C2RustUnnamed_19 = libc::c_uint;
pub const TMSF_INTANGIBLE: C2RustUnnamed_19 = 2;
pub const TMSF_RETRACTED: C2RustUnnamed_19 = 1;
pub type C2RustUnnamed_20 = libc::c_uint;
pub const TMFF_HOP: C2RustUnnamed_20 = 4;
pub const TMFF_STATIONARY: C2RustUnnamed_20 = 2;
pub const TMFF_AIMLESS: C2RustUnnamed_20 = 1;
pub type C2RustUnnamed_21 = libc::c_uint;
pub const TMFH_CORONA: C2RustUnnamed_21 = 2;
pub const TMFH_NOFLAME: C2RustUnnamed_21 = 1;
pub type C2RustUnnamed_22 = libc::c_uint;
pub const TMDS_ROTATEEXTRA: C2RustUnnamed_22 = 2;
pub const TMDS_NOGRAVITY: C2RustUnnamed_22 = 1;
pub type C2RustUnnamed_23 = libc::c_uint;
pub const TMF_NODISTANCECHECK: C2RustUnnamed_23 = 2;
pub const TMF_INVISIBLE: C2RustUnnamed_23 = 1;
pub type C2RustUnnamed_24 = libc::c_uint;
pub const TMGD_LEFT: C2RustUnnamed_24 = 2;
pub const TMGD_RIGHT: C2RustUnnamed_24 = 1;
pub const TMGD_BACK: C2RustUnnamed_24 = 0;
pub type C2RustUnnamed_25 = libc::c_uint;
pub const TMNI_REVEAL: C2RustUnnamed_25 = 2;
pub const TMNI_BONUSONLY: C2RustUnnamed_25 = 1;
pub type C2RustUnnamed_26 = libc::c_uint;
pub const TMP_CLASSIC: C2RustUnnamed_26 = 3;
pub const TMP_IMMOVABLE: C2RustUnnamed_26 = 2;
pub const TMP_SLIDE: C2RustUnnamed_26 = 1;
pub const TMP_NORMAL: C2RustUnnamed_26 = 0;
pub type C2RustUnnamed_27 = libc::c_uint;
pub const TMED_LEFT: C2RustUnnamed_27 = 2;
pub const TMED_RIGHT: C2RustUnnamed_27 = 1;
pub const TMED_NONE: C2RustUnnamed_27 = 0;
pub type C2RustUnnamed_28 = libc::c_uint;
pub const TMMR_STRONG: C2RustUnnamed_28 = 2;
pub const TMMR_WEAK: C2RustUnnamed_28 = 1;
pub const TMMR_SAME: C2RustUnnamed_28 = 0;
pub type C2RustUnnamed_29 = libc::c_uint;
pub const TMF_SKIPINTRO: C2RustUnnamed_29 = 2;
pub const TMF_GRAYSCALE: C2RustUnnamed_29 = 1;
pub type C2RustUnnamed_30 = libc::c_uint;
pub const TMB_BARRIER: C2RustUnnamed_30 = 2;
pub const TMB_NODEATHFLING: C2RustUnnamed_30 = 1;
pub type C2RustUnnamed_31 = libc::c_uint;
pub const TMEF_EMERALDCHECK: C2RustUnnamed_31 = 2;
pub const TMEF_SKIPTALLY: C2RustUnnamed_31 = 1;
pub type C2RustUnnamed_32 = libc::c_uint;
pub const TMSP_FORCESPIN: C2RustUnnamed_32 = 2;
pub const TMSP_NOTELEPORT: C2RustUnnamed_32 = 1;
pub type C2RustUnnamed_33 = libc::c_uint;
pub const TMFA_SPLAT: C2RustUnnamed_33 = 32;
pub const TMFA_NOSHADE: C2RustUnnamed_33 = 16;
pub const TMFA_ONLYINSIDES: C2RustUnnamed_33 = 8;
pub const TMFA_INSIDES: C2RustUnnamed_33 = 4;
pub const TMFA_NOSIDES: C2RustUnnamed_33 = 2;
pub const TMFA_NOPLANES: C2RustUnnamed_33 = 1;
pub type C2RustUnnamed_34 = libc::c_uint;
pub const TMFT_INTANGIBLE: C2RustUnnamed_34 = 12;
pub const TMFT_DONTBLOCKOTHERS: C2RustUnnamed_34 = 8;
pub const TMFT_VISIBLEFROMINSIDE: C2RustUnnamed_34 = 7;
pub const TMFT_DONTBLOCKPLAYER: C2RustUnnamed_34 = 4;
pub const TMFT_INTANGIBLEBOTTOM: C2RustUnnamed_34 = 2;
pub const TMFT_INTANGIBLETOP: C2RustUnnamed_34 = 1;
pub type C2RustUnnamed_35 = libc::c_uint;
pub const TMFW_SPLAT: C2RustUnnamed_35 = 32;
pub const TMFW_GOOWATER: C2RustUnnamed_35 = 16;
pub const TMFW_NORIPPLE: C2RustUnnamed_35 = 8;
pub const TMFW_COLORMAPONLY: C2RustUnnamed_35 = 4;
pub const TMFW_DOUBLESHADOW: C2RustUnnamed_35 = 2;
pub const TMFW_NOSIDES: C2RustUnnamed_35 = 1;
pub type C2RustUnnamed_36 = libc::c_uint;
pub const TMFB_DYNAMIC: C2RustUnnamed_36 = 4;
pub const TMFB_SPINDASH: C2RustUnnamed_36 = 2;
pub const TMFB_REVERSE: C2RustUnnamed_36 = 1;
pub type C2RustUnnamed_37 = libc::c_uint;
pub const TMFC_SPLAT: C2RustUnnamed_37 = 16;
pub const TMFC_FLOATBOB: C2RustUnnamed_37 = 8;
pub const TMFC_AIRBOB: C2RustUnnamed_37 = 4;
pub const TMFC_NORETURN: C2RustUnnamed_37 = 2;
pub const TMFC_NOSHADE: C2RustUnnamed_37 = 1;
pub type C2RustUnnamed_38 = libc::c_uint;
pub const TMFR_SPINDASH: C2RustUnnamed_38 = 2;
pub const TMFR_REVERSE: C2RustUnnamed_38 = 1;
pub type C2RustUnnamed_39 = libc::c_uint;
pub const TMFM_INVISIBLE: C2RustUnnamed_39 = 2;
pub const TMFM_BRICK: C2RustUnnamed_39 = 1;
pub type C2RustUnnamed_40 = libc::c_uint;
pub const TMFB_STRONG: C2RustUnnamed_40 = 3;
pub const TMFB_REGULAR: C2RustUnnamed_40 = 2;
pub const TMFB_SPIN: C2RustUnnamed_40 = 1;
pub const TMFB_TOUCH: C2RustUnnamed_40 = 0;
pub type C2RustUnnamed_41 = libc::c_uint;
pub const TMFB_SPLAT: C2RustUnnamed_41 = 8;
pub const TMFB_ONLYBOTTOM: C2RustUnnamed_41 = 4;
pub const TMFB_EXECUTOR: C2RustUnnamed_41 = 2;
pub const TMFB_PUSHABLES: C2RustUnnamed_41 = 1;
pub type C2RustUnnamed_42 = libc::c_uint;
pub const TMFL_SPLAT: C2RustUnnamed_42 = 2;
pub const TMFL_NOBOSSES: C2RustUnnamed_42 = 1;
pub type C2RustUnnamed_43 = libc::c_uint;
pub const TMT_EACHTIMEENTERANDEXIT: C2RustUnnamed_43 = 3;
pub const TMT_EACHTIMEENTER: C2RustUnnamed_43 = 2;
pub const TMT_EACHTIMEMASK: C2RustUnnamed_43 = 1;
pub const TMT_ONCE: C2RustUnnamed_43 = 1;
pub const TMT_CONTINUOUS: C2RustUnnamed_43 = 0;
pub type C2RustUnnamed_44 = libc::c_uint;
pub const TMXT_EACHTIMEENTERANDEXIT: C2RustUnnamed_44 = 2;
pub const TMXT_EACHTIMEENTER: C2RustUnnamed_44 = 1;
pub const TMXT_EACHTIMEMASK: C2RustUnnamed_44 = 0;
pub const TMXT_CONTINUOUS: C2RustUnnamed_44 = 0;
pub type C2RustUnnamed_45 = libc::c_uint;
pub const TMF_DOESNTHAVEANY: C2RustUnnamed_45 = 4;
pub const TMF_DOESNTHAVEALL: C2RustUnnamed_45 = 3;
pub const TMF_HASEXACTLY: C2RustUnnamed_45 = 2;
pub const TMF_HASANY: C2RustUnnamed_45 = 1;
pub const TMF_HASALL: C2RustUnnamed_45 = 0;
pub type C2RustUnnamed_46 = libc::c_uint;
pub const TMT_BLUE: C2RustUnnamed_46 = 1;
pub const TMT_RED: C2RustUnnamed_46 = 0;
pub type C2RustUnnamed_47 = libc::c_uint;
pub const TMC_GTE: C2RustUnnamed_47 = 2;
pub const TMC_LTE: C2RustUnnamed_47 = 1;
pub const TMC_EQUAL: C2RustUnnamed_47 = 0;
pub type C2RustUnnamed_48 = libc::c_uint;
pub const TMG_TEMPREVERSE: C2RustUnnamed_48 = 2;
pub const TMG_REVERSE: C2RustUnnamed_48 = 1;
pub const TMG_NORMAL: C2RustUnnamed_48 = 0;
pub type C2RustUnnamed_49 = libc::c_uint;
pub const TMNP_TRIGGERER: C2RustUnnamed_49 = 2;
pub const TMNP_SLOWEST: C2RustUnnamed_49 = 1;
pub const TMNP_FASTEST: C2RustUnnamed_49 = 0;
pub type C2RustUnnamed_50 = libc::c_uint;
pub const TMN_FROMNIGHTS: C2RustUnnamed_50 = 2;
pub const TMN_FROMNONIGHTS: C2RustUnnamed_50 = 1;
pub const TMN_ALWAYS: C2RustUnnamed_50 = 0;
pub type C2RustUnnamed_51 = libc::c_uint;
pub const TMN_LEVELCOMPLETION: C2RustUnnamed_51 = 4;
pub const TMN_BONUSLAPS: C2RustUnnamed_51 = 1;
pub type C2RustUnnamed_52 = libc::c_uint;
pub const TMD_SOMEBODYNIGHTS: C2RustUnnamed_52 = 2;
pub const TMD_NOBODYNIGHTS: C2RustUnnamed_52 = 1;
pub const TMD_ALWAYS: C2RustUnnamed_52 = 0;
pub type C2RustUnnamed_53 = libc::c_uint;
pub const TMS_ALWAYS: C2RustUnnamed_53 = 2;
pub const TMS_IFNOTENOUGH: C2RustUnnamed_53 = 1;
pub const TMS_IFENOUGH: C2RustUnnamed_53 = 0;
pub type C2RustUnnamed_54 = libc::c_uint;
pub const TMI_ENTER: C2RustUnnamed_54 = 4;
pub const TMI_BONUSLAPS: C2RustUnnamed_54 = 1;
pub type C2RustUnnamed_55 = libc::c_uint;
pub const TMP_BOTH: C2RustUnnamed_55 = 2;
pub const TMP_CEILING: C2RustUnnamed_55 = 1;
pub const TMP_FLOOR: C2RustUnnamed_55 = 0;
pub type C2RustUnnamed_56 = libc::c_uint;
pub const TMT_TRIGGERTAG: C2RustUnnamed_56 = 3;
pub const TMT_REPLACEFIRST: C2RustUnnamed_56 = 2;
pub const TMT_REMOVE: C2RustUnnamed_56 = 1;
pub const TMT_ADD: C2RustUnnamed_56 = 0;
pub type C2RustUnnamed_57 = libc::c_uint;
pub const TMT_RELATIVE: C2RustUnnamed_57 = 8;
pub const TMT_KEEPMOMENTUM: C2RustUnnamed_57 = 4;
pub const TMT_KEEPANGLE: C2RustUnnamed_57 = 2;
pub const TMT_SILENT: C2RustUnnamed_57 = 1;
pub type C2RustUnnamed_58 = libc::c_uint;
pub const TMM_NOLOOP: C2RustUnnamed_58 = 32;
pub const TMM_FORCERESET: C2RustUnnamed_58 = 16;
pub const TMM_NORELOAD: C2RustUnnamed_58 = 8;
pub const TMM_FADE: C2RustUnnamed_58 = 4;
pub const TMM_OFFSET: C2RustUnnamed_58 = 2;
pub const TMM_ALLPLAYERS: C2RustUnnamed_58 = 1;
pub type C2RustUnnamed_59 = libc::c_uint;
pub const TMSS_TAGGEDSECTOR: C2RustUnnamed_59 = 3;
pub const TMSS_NOWHERE: C2RustUnnamed_59 = 2;
pub const TMSS_TRIGGERSECTOR: C2RustUnnamed_59 = 1;
pub const TMSS_TRIGGERMOBJ: C2RustUnnamed_59 = 0;
pub type C2RustUnnamed_60 = libc::c_uint;
pub const TMSL_TAGGEDSECTOR: C2RustUnnamed_60 = 2;
pub const TMSL_TRIGGERER: C2RustUnnamed_60 = 1;
pub const TMSL_EVERYONE: C2RustUnnamed_60 = 0;
pub type C2RustUnnamed_61 = libc::c_uint;
pub const TML_CEILING: C2RustUnnamed_61 = 2;
pub const TML_FLOOR: C2RustUnnamed_61 = 1;
pub const TML_SECTOR: C2RustUnnamed_61 = 0;
pub type C2RustUnnamed_62 = libc::c_uint;
pub const TMF_TICBASED: C2RustUnnamed_62 = 4;
pub const TMF_OVERRIDE: C2RustUnnamed_62 = 2;
pub const TMF_RELATIVE: C2RustUnnamed_62 = 1;
pub type C2RustUnnamed_63 = libc::c_uint;
pub const TMB_SYNC: C2RustUnnamed_63 = 2;
pub const TMB_USETARGET: C2RustUnnamed_63 = 1;
pub type C2RustUnnamed_64 = libc::c_uint;
pub const TMFR_CHECKFLAG: C2RustUnnamed_64 = 2;
pub const TMFR_NORETURN: C2RustUnnamed_64 = 1;
pub type C2RustUnnamed_65 = libc::c_uint;
pub const TMST_DONTDOTRANSLUCENT: C2RustUnnamed_65 = 2;
pub const TMST_RELATIVE: C2RustUnnamed_65 = 1;
pub type C2RustUnnamed_66 = libc::c_uint;
pub const TMFT_USEEXACTALPHA: C2RustUnnamed_66 = 512;
pub const TMFT_DONTDOCOLORMAP: C2RustUnnamed_66 = 256;
pub const TMFT_DONTDOLIGHTING: C2RustUnnamed_66 = 128;
pub const TMFT_DONTDOEXISTS: C2RustUnnamed_66 = 64;
pub const TMFT_DONTDOTRANSLUCENT: C2RustUnnamed_66 = 32;
pub const TMFT_GHOSTFADE: C2RustUnnamed_66 = 16;
pub const TMFT_IGNORECOLLISION: C2RustUnnamed_66 = 8;
pub const TMFT_TICBASED: C2RustUnnamed_66 = 4;
pub const TMFT_OVERRIDE: C2RustUnnamed_66 = 2;
pub const TMFT_RELATIVE: C2RustUnnamed_66 = 1;
pub type C2RustUnnamed_67 = libc::c_uint;
pub const TMS_BOTH: C2RustUnnamed_67 = 2;
pub const TMS_CENTERPOINT: C2RustUnnamed_67 = 1;
pub const TMS_VIEWPOINT: C2RustUnnamed_67 = 0;
pub type C2RustUnnamed_68 = libc::c_uint;
pub const TMP_KEEPREALTIME: C2RustUnnamed_68 = 16;
pub const TMP_KEEPCONTROLS: C2RustUnnamed_68 = 8;
pub const TMP_CALLBYNAME: C2RustUnnamed_68 = 4;
pub const TMP_RUNPOSTEXEC: C2RustUnnamed_68 = 2;
pub const TMP_CLOSE: C2RustUnnamed_68 = 1;
pub type C2RustUnnamed_69 = libc::c_uint;
pub const TMSD_FRONTBACK: C2RustUnnamed_69 = 2;
pub const TMSD_BACK: C2RustUnnamed_69 = 1;
pub const TMSD_FRONT: C2RustUnnamed_69 = 0;
pub type C2RustUnnamed_70 = libc::c_uint;
pub const TMS_CARRYONLY: C2RustUnnamed_70 = 2;
pub const TMS_SCROLLONLY: C2RustUnnamed_70 = 1;
pub const TMS_SCROLLCARRY: C2RustUnnamed_70 = 0;
pub type C2RustUnnamed_71 = libc::c_uint;
pub const TMST_NONEXCLUSIVE: C2RustUnnamed_71 = 4;
pub const TMST_TYPEMASK: C2RustUnnamed_71 = 3;
pub const TMST_DISPLACEMENT: C2RustUnnamed_71 = 2;
pub const TMST_ACCELERATIVE: C2RustUnnamed_71 = 1;
pub const TMST_REGULAR: C2RustUnnamed_71 = 0;
pub type C2RustUnnamed_72 = libc::c_uint;
pub const TMPF_NONEXCLUSIVE: C2RustUnnamed_72 = 2;
pub const TMPF_SLIDE: C2RustUnnamed_72 = 1;
pub type C2RustUnnamed_73 = libc::c_uint;
pub const TMPP_NONEXCLUSIVE: C2RustUnnamed_73 = 4;
pub const TMPP_PUSHZ: C2RustUnnamed_73 = 2;
pub const TMPP_NOZFADE: C2RustUnnamed_73 = 1;
pub type C2RustUnnamed_74 = libc::c_uint;
pub const TMB_MODULATE: C2RustUnnamed_74 = 4;
pub const TMB_REVERSESUBTRACT: C2RustUnnamed_74 = 3;
pub const TMB_SUBTRACT: C2RustUnnamed_74 = 2;
pub const TMB_ADD: C2RustUnnamed_74 = 1;
pub const TMB_TRANSLUCENT: C2RustUnnamed_74 = 0;
pub type C2RustUnnamed_75 = libc::c_uint;
pub const p_current: C2RustUnnamed_75 = 1;
pub const p_wind: C2RustUnnamed_75 = 0;
pub type C2RustUnnamed_76 = libc::c_uint;
pub const LEVELFLAT_TEXTURE: C2RustUnnamed_76 = 4;
pub const LEVELFLAT_PNG: C2RustUnnamed_76 = 3;
pub const LEVELFLAT_PATCH: C2RustUnnamed_76 = 2;
pub const LEVELFLAT_FLAT: C2RustUnnamed_76 = 1;
pub const LEVELFLAT_NONE: C2RustUnnamed_76 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct levelflat_t {
    pub name: [libc::c_char; 9],
    pub type_0: uint8_t,
    pub u: C2RustUnnamed_77,
    pub width: uint16_t,
    pub height: uint16_t,
    pub animseq: int32_t,
    pub numpics: int32_t,
    pub speed: int32_t,
    pub picture: *mut uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_77 {
    pub flat: C2RustUnnamed_79,
    pub texture: C2RustUnnamed_78,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_78 {
    pub num: int32_t,
    pub lastnum: int32_t,
    pub basenum: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_79 {
    pub lumpnum: lumpnum_t,
    pub baselumpnum: lumpnum_t,
}
pub const PU_CACHE: C2RustUnnamed_81 = 49;
pub const PU_LEVEL: C2RustUnnamed_81 = 50;
pub const render_none: rendermode_t = 3;
pub type rendermode_t = libc::c_uint;
pub const render_opengl: rendermode_t = 2;
pub const render_soft: rendermode_t = 1;
pub const hook_MapLoad: C2RustUnnamed_84 = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct skin_t {
    pub name: [libc::c_char; 17],
    pub wadnum: uint16_t,
    pub flags: skinflags_t,
    pub realname: [libc::c_char; 17],
    pub hudname: [libc::c_char; 17],
    pub supername: [libc::c_char; 23],
    pub ability: uint8_t,
    pub ability2: uint8_t,
    pub thokitem: int32_t,
    pub spinitem: int32_t,
    pub revitem: int32_t,
    pub followitem: int32_t,
    pub actionspd: fixed_t,
    pub mindash: fixed_t,
    pub maxdash: fixed_t,
    pub normalspeed: fixed_t,
    pub runspeed: fixed_t,
    pub thrustfactor: uint8_t,
    pub accelstart: uint8_t,
    pub acceleration: uint8_t,
    pub jumpfactor: fixed_t,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub spinheight: fixed_t,
    pub shieldscale: fixed_t,
    pub camerascale: fixed_t,
    pub starttranscolor: uint8_t,
    pub prefcolor: uint16_t,
    pub supercolor: uint16_t,
    pub prefoppositecolor: uint16_t,
    pub highresscale: fixed_t,
    pub contspeed: uint8_t,
    pub contangle: uint8_t,
    pub soundsid: [sfxenum_t; 21],
    pub sprites: [spritedef_t; 256],
    pub sprinfo: [spriteinfo_t; 256],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spriteinfo_t {
    pub pivot: [spriteframepivot_t; 64],
    pub available: boolean,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spriteframepivot_t {
    pub x: int32_t,
    pub y: int32_t,
}
pub const PU_STATIC: C2RustUnnamed_81 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sectorspecialthings_t {
    pub teleport: *mut mapthing_t,
    pub altview: *mut mapthing_t,
    pub angleanchor: *mut mapthing_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct texture_t {
    pub name: [libc::c_char; 8],
    pub hash: uint32_t,
    pub type_0: uint8_t,
    pub width: int16_t,
    pub height: int16_t,
    pub holes: boolean,
    pub flip: uint8_t,
    pub flat: *mut libc::c_void,
    pub patchcount: int16_t,
    pub patches: [texpatch_t; 0],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct texpatch_t {
    pub originx: int16_t,
    pub originy: int16_t,
    pub wad: uint16_t,
    pub lump: uint16_t,
    pub flip: uint8_t,
    pub alpha: uint8_t,
    pub style: patchalphastyle,
}
pub const TMSC_BACKTOFRONTCEILING: C2RustUnnamed_86 = 8;
pub const TMSC_BACKTOFRONTFLOOR: C2RustUnnamed_86 = 2;
pub const TMSC_FRONTTOBACKCEILING: C2RustUnnamed_86 = 4;
pub const TMSC_FRONTTOBACKFLOOR: C2RustUnnamed_86 = 1;
pub const TMSL_DYNAMIC: C2RustUnnamed_88 = 2;
pub const TMSL_NOPHYSICS: C2RustUnnamed_88 = 1;
pub const TMSP_BACKCEILING: C2RustUnnamed_85 = 3;
pub const TMSP_BACKFLOOR: C2RustUnnamed_85 = 2;
pub const TMSP_FRONTCEILING: C2RustUnnamed_85 = 1;
pub const TMSP_FRONTFLOOR: C2RustUnnamed_85 = 0;
pub const TMSL_COPY: C2RustUnnamed_88 = 4;
pub const TMS_NONE: C2RustUnnamed_87 = 0;
pub const TMS_FRONT: C2RustUnnamed_87 = 1;
pub const TMS_BACK: C2RustUnnamed_87 = 2;
pub const TMCF_OVERRIDE: C2RustUnnamed_80 = 8192;
pub const TMCF_FROMBLACK: C2RustUnnamed_80 = 4096;
pub const TMCF_SUBFADEB: C2RustUnnamed_80 = 128;
pub const TMCF_SUBLIGHTB: C2RustUnnamed_80 = 8;
pub const TMCF_SUBFADEG: C2RustUnnamed_80 = 64;
pub const TMCF_SUBLIGHTG: C2RustUnnamed_80 = 4;
pub const TMCF_SUBFADER: C2RustUnnamed_80 = 32;
pub const TMCF_SUBLIGHTR: C2RustUnnamed_80 = 2;
pub const TMCF_RELATIVE: C2RustUnnamed_80 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bmap_t {
    pub n: int32_t,
    pub nalloc: int32_t,
    pub list: *mut int32_t,
}
pub type nodetype_t = libc::c_uint;
pub const NUMNODETYPES: nodetype_t = 10;
pub const NT_UNSUPPORTED: nodetype_t = 9;
pub const NT_ZGL3: nodetype_t = 8;
pub const NT_XGL3: nodetype_t = 7;
pub const NT_ZGL2: nodetype_t = 6;
pub const NT_XGL2: nodetype_t = 5;
pub const NT_ZGLN: nodetype_t = 4;
pub const NT_XGLN: nodetype_t = 3;
pub const NT_ZNOD: nodetype_t = 2;
pub const NT_XNOD: nodetype_t = 1;
pub const NT_DOOM: nodetype_t = 0;
pub const TMCF_SUBFADEA: C2RustUnnamed_80 = 256;
pub const TMCF_SUBLIGHTA: C2RustUnnamed_80 = 16;
pub type textmap_plane_t = textmap_plane_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct textmap_plane_s {
    pub defined: uint8_t,
    pub a: fixed_t,
    pub b: fixed_t,
    pub c: fixed_t,
    pub d: fixed_t,
}
pub const PD_D: C2RustUnnamed_89 = 8;
pub const PD_C: C2RustUnnamed_89 = 4;
pub const PD_B: C2RustUnnamed_89 = 2;
pub const PD_A: C2RustUnnamed_89 = 1;
pub type textmap_colormap_t = textmap_colormap_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct textmap_colormap_s {
    pub used: boolean,
    pub lightcolor: int32_t,
    pub lightalpha: uint8_t,
    pub fadecolor: int32_t,
    pub fadealpha: uint8_t,
    pub fadestart: uint8_t,
    pub fadeend: uint8_t,
    pub flags: uint8_t,
}
pub const PU_PURGELEVEL: C2RustUnnamed_81 = 100;
pub const PU_PATCH_ROTATED: C2RustUnnamed_81 = 16;
pub const PU_PATCH_LOWPRIORITY: C2RustUnnamed_81 = 15;
pub const wipe_level_toblack: C2RustUnnamed_82 = 1;
pub type wipestyleflags_t = libc::c_uint;
pub const WSF_CROSSFADE: wipestyleflags_t = 8;
pub const WSF_TOWHITE: wipestyleflags_t = 4;
pub const WSF_FADEIN: wipestyleflags_t = 2;
pub const WSF_FADEOUT: wipestyleflags_t = 1;
pub type moviemode_t = libc::c_uint;
pub const MM_SCREENSHOT: moviemode_t = 3;
pub const MM_GIF: moviemode_t = 2;
pub const MM_APNG: moviemode_t = 1;
pub const MM_OFF: moviemode_t = 0;
pub const wipe_speclevel_towhite: C2RustUnnamed_82 = 14;
pub const PU_SPRITE: C2RustUnnamed_81 = 18;
pub const REFRESHDIR_NOTLOADED: C2RustUnnamed_83 = 16;
pub type C2RustUnnamed_80 = libc::c_uint;
pub const TMCF_IGNOREFLAGS: C2RustUnnamed_80 = 2048;
pub const TMCF_SUBFADEEND: C2RustUnnamed_80 = 1024;
pub const TMCF_SUBFADESTART: C2RustUnnamed_80 = 512;
pub type C2RustUnnamed_81 = libc::c_uint;
pub const PU_HWRMODELTEXTURE_UNLOCKED: C2RustUnnamed_81 = 103;
pub const PU_HWRCACHE_UNLOCKED: C2RustUnnamed_81 = 102;
pub const PU_CACHE_UNLOCKED: C2RustUnnamed_81 = 101;
pub const PU_HWRPLANE: C2RustUnnamed_81 = 52;
pub const PU_LEVSPEC: C2RustUnnamed_81 = 51;
pub const PU_HWRCACHE: C2RustUnnamed_81 = 48;
pub const PU_HWRMODELTEXTURE: C2RustUnnamed_81 = 23;
pub const PU_HWRPATCHCOLMIPMAP: C2RustUnnamed_81 = 22;
pub const PU_HWRPATCHINFO: C2RustUnnamed_81 = 21;
pub const PU_HUDGFX: C2RustUnnamed_81 = 19;
pub const PU_PATCH_DATA: C2RustUnnamed_81 = 17;
pub const PU_PATCH: C2RustUnnamed_81 = 14;
pub const PU_MUSIC: C2RustUnnamed_81 = 12;
pub const PU_SOUND: C2RustUnnamed_81 = 11;
pub const PU_PERFSTATS: C2RustUnnamed_81 = 3;
pub const PU_LUA: C2RustUnnamed_81 = 2;
pub type C2RustUnnamed_82 = libc::c_uint;
pub const WIPEFINALSHIFT: C2RustUnnamed_82 = 14;
pub const NUMWIPEDEFS: C2RustUnnamed_82 = 28;
pub const wipe_multinter_final: C2RustUnnamed_82 = 27;
pub const wipe_specinter_final: C2RustUnnamed_82 = 26;
pub const wipe_cutscene_final: C2RustUnnamed_82 = 25;
pub const wipe_ending_final: C2RustUnnamed_82 = 24;
pub const wipe_intro_final: C2RustUnnamed_82 = 23;
pub const wipe_gameend_final: C2RustUnnamed_82 = 22;
pub const wipe_evaluation_final: C2RustUnnamed_82 = 21;
pub const wipe_credits_final: C2RustUnnamed_82 = 20;
pub const wipe_timeattack_final: C2RustUnnamed_82 = 19;
pub const wipe_titlescreen_final: C2RustUnnamed_82 = 18;
pub const wipe_continuing_final: C2RustUnnamed_82 = 17;
pub const wipe_intermission_final: C2RustUnnamed_82 = 16;
pub const wipe_level_final: C2RustUnnamed_82 = 15;
pub const wipe_multinter_toblack: C2RustUnnamed_82 = 13;
pub const wipe_specinter_toblack: C2RustUnnamed_82 = 12;
pub const wipe_cutscene_toblack: C2RustUnnamed_82 = 11;
pub const wipe_ending_toblack: C2RustUnnamed_82 = 10;
pub const wipe_intro_toblack: C2RustUnnamed_82 = 9;
pub const wipe_gameend_toblack: C2RustUnnamed_82 = 8;
pub const wipe_evaluation_toblack: C2RustUnnamed_82 = 7;
pub const wipe_credits_toblack: C2RustUnnamed_82 = 6;
pub const wipe_timeattack_toblack: C2RustUnnamed_82 = 5;
pub const wipe_titlescreen_toblack: C2RustUnnamed_82 = 4;
pub const wipe_continuing_toblack: C2RustUnnamed_82 = 3;
pub const wipe_intermission_toblack: C2RustUnnamed_82 = 2;
pub const wipe_credits_intermediate: C2RustUnnamed_82 = 0;
pub type C2RustUnnamed_83 = libc::c_uint;
pub const REFRESHDIR_MAX: C2RustUnnamed_83 = 32;
pub const REFRESHDIR_ERROR: C2RustUnnamed_83 = 8;
pub const REFRESHDIR_WARNING: C2RustUnnamed_83 = 4;
pub const REFRESHDIR_ADDFILE: C2RustUnnamed_83 = 2;
pub const REFRESHDIR_NORMAL: C2RustUnnamed_83 = 1;
pub type C2RustUnnamed_84 = libc::c_uint;
pub const hook_MAX: C2RustUnnamed_84 = 30;
pub const hook_KeyUp: C2RustUnnamed_84 = 29;
pub const hook_KeyDown: C2RustUnnamed_84 = 28;
pub const hook_PlayerCanEnterSpinGaps: C2RustUnnamed_84 = 27;
pub const hook_PlayerHeight: C2RustUnnamed_84 = 26;
pub const hook_MusicChange: C2RustUnnamed_84 = 25;
pub const hook_PlayerCmd: C2RustUnnamed_84 = 24;
pub const hook_GameQuit: C2RustUnnamed_84 = 23;
pub const hook_PlayerThink: C2RustUnnamed_84 = 22;
pub const hook_SeenPlayer: C2RustUnnamed_84 = 21;
pub const hook_ViewpointSwitch: C2RustUnnamed_84 = 20;
pub const hook_TeamSwitch: C2RustUnnamed_84 = 19;
pub const hook_IntermissionThinker: C2RustUnnamed_84 = 18;
pub const hook_PlayerQuit: C2RustUnnamed_84 = 17;
pub const hook_PlayerCanDamage: C2RustUnnamed_84 = 16;
pub const hook_ShieldSpecial: C2RustUnnamed_84 = 15;
pub const hook_ShieldSpawn: C2RustUnnamed_84 = 14;
pub const hook_PlayerSpawn: C2RustUnnamed_84 = 13;
pub const hook_PlayerMsg: C2RustUnnamed_84 = 12;
pub const hook_BotTiccmd: C2RustUnnamed_84 = 11;
pub const hook_JumpSpinSpecial: C2RustUnnamed_84 = 10;
pub const hook_SpinSpecial: C2RustUnnamed_84 = 9;
pub const hook_AbilitySpecial: C2RustUnnamed_84 = 8;
pub const hook_JumpSpecial: C2RustUnnamed_84 = 7;
pub const hook_PostThinkFrame: C2RustUnnamed_84 = 6;
pub const hook_ThinkFrame: C2RustUnnamed_84 = 5;
pub const hook_PreThinkFrame: C2RustUnnamed_84 = 4;
pub const hook_PlayerJoin: C2RustUnnamed_84 = 3;
pub const hook_MapChange: C2RustUnnamed_84 = 1;
pub const hook_NetVars: C2RustUnnamed_84 = 0;
pub type C2RustUnnamed_85 = libc::c_uint;
pub type C2RustUnnamed_86 = libc::c_uint;
pub type C2RustUnnamed_87 = libc::c_uint;
pub type C2RustUnnamed_88 = libc::c_uint;
pub type C2RustUnnamed_89 = libc::c_uint;
#[inline]
unsafe extern "C" fn atof(mut __nptr: *const libc::c_char) -> libc::c_double {
    return strtod(__nptr, 0 as *mut libc::c_void as *mut *mut libc::c_char);
}
#[inline]
unsafe extern "C" fn atol(mut __nptr: *const libc::c_char) -> libc::c_long {
    return strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    );
}
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    return strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    ) as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn InvAngle(mut a: angle_t) -> angle_t {
    return (0xffffffff as libc::c_uint)
        .wrapping_sub(a)
        .wrapping_add(1 as libc::c_int as libc::c_uint);
}
#[inline(always)]
unsafe extern "C" fn FixedDiv(mut a: fixed_t, mut b: fixed_t) -> fixed_t {
    if abs(a) >> 16 as libc::c_int - 2 as libc::c_int >= abs(b) {
        return if a ^ b < 0 as libc::c_int {
            -(2147483647 as libc::c_int) - 1 as libc::c_int
        } else {
            2147483647 as libc::c_int
        };
    }
    return FixedDiv2(a, b);
}
#[inline(always)]
unsafe extern "C" fn FixedDiv2(mut a: fixed_t, mut b: fixed_t) -> fixed_t {
    return (a as int64_t * ((1 as libc::c_int) << 16 as libc::c_int) as int64_t
        / b as int64_t) as fixed_t;
}
#[inline(always)]
unsafe extern "C" fn FixedMul(mut a: fixed_t, mut b: fixed_t) -> fixed_t {
    return ((a as int64_t * b as int64_t) as uint64_t >> 16 as libc::c_int) as fixed_t;
}
#[inline(always)]
unsafe extern "C" fn FloatToFixed(mut f: libc::c_float) -> fixed_t {
    return (f * ((1 as libc::c_int) << 16 as libc::c_int) as libc::c_float) as fixed_t;
}
#[inline(always)]
unsafe extern "C" fn FixedToFloat(mut x: fixed_t) -> libc::c_float {
    return x as libc::c_float
        / ((1 as libc::c_int) << 16 as libc::c_int) as libc::c_float;
}
#[inline(always)]
unsafe extern "C" fn fastcmp(
    mut s: *const libc::c_char,
    mut c: *const libc::c_char,
) -> boolean {
    while *s as libc::c_int != 0 && *s as libc::c_int == *c as libc::c_int {
        s = s.offset(1);
        s;
        c = c.offset(1);
        c;
    }
    return (*s as libc::c_int == *c as libc::c_int) as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn fastncmp(
    mut s: *const libc::c_char,
    mut c: *const libc::c_char,
    mut l: uint16_t,
) -> boolean {
    while *s as libc::c_int != 0 && *s as libc::c_int == *c as libc::c_int
        && {
            l = l.wrapping_sub(1);
            l as libc::c_int != 0
        }
    {
        s = s.offset(1);
        s;
        c = c.offset(1);
        c;
    }
    return (l == 0) as libc::c_int;
}
#[no_mangle]
pub static mut mapmd5: [libc::c_uchar; 16] = [0; 16];
#[no_mangle]
pub static mut udmf: boolean = 0;
#[no_mangle]
pub static mut numvertexes: size_t = 0;
#[no_mangle]
pub static mut numsegs: size_t = 0;
#[no_mangle]
pub static mut numsectors: size_t = 0;
#[no_mangle]
pub static mut numsubsectors: size_t = 0;
#[no_mangle]
pub static mut numnodes: size_t = 0;
#[no_mangle]
pub static mut numlines: size_t = 0;
#[no_mangle]
pub static mut numsides: size_t = 0;
#[no_mangle]
pub static mut nummapthings: size_t = 0;
#[no_mangle]
pub static mut vertexes: *mut vertex_t = 0 as *const vertex_t as *mut vertex_t;
#[no_mangle]
pub static mut segs: *mut seg_t = 0 as *const seg_t as *mut seg_t;
#[no_mangle]
pub static mut sectors: *mut sector_t = 0 as *const sector_t as *mut sector_t;
#[no_mangle]
pub static mut subsectors: *mut subsector_t = 0 as *const subsector_t
    as *mut subsector_t;
#[no_mangle]
pub static mut nodes: *mut node_t = 0 as *const node_t as *mut node_t;
#[no_mangle]
pub static mut lines: *mut line_t = 0 as *const line_t as *mut line_t;
#[no_mangle]
pub static mut sides: *mut side_t = 0 as *const side_t as *mut side_t;
#[no_mangle]
pub static mut mapthings: *mut mapthing_t = 0 as *const mapthing_t as *mut mapthing_t;
#[no_mangle]
pub static mut spawnsectors: *mut sector_t = 0 as *const sector_t as *mut sector_t;
#[no_mangle]
pub static mut spawnlines: *mut line_t = 0 as *const line_t as *mut line_t;
#[no_mangle]
pub static mut spawnsides: *mut side_t = 0 as *const side_t as *mut side_t;
#[no_mangle]
pub static mut numstarposts: int32_t = 0;
#[no_mangle]
pub static mut bossdisabled: uint16_t = 0;
#[no_mangle]
pub static mut stoppedclock: boolean = 0;
#[no_mangle]
pub static mut levelloading: boolean = 0;
#[no_mangle]
pub static mut levelfadecol: uint8_t = 0;
#[no_mangle]
pub static mut bmapwidth: int32_t = 0;
#[no_mangle]
pub static mut bmapheight: int32_t = 0;
#[no_mangle]
pub static mut blockmap: *mut int32_t = 0 as *const int32_t as *mut int32_t;
#[no_mangle]
pub static mut blockmaplump: *mut int32_t = 0 as *const int32_t as *mut int32_t;
#[no_mangle]
pub static mut bmaporgx: fixed_t = 0;
#[no_mangle]
pub static mut bmaporgy: fixed_t = 0;
#[no_mangle]
pub static mut blocklinks: *mut *mut mobj_t = 0 as *const *mut mobj_t
    as *mut *mut mobj_t;
#[no_mangle]
pub static mut rejectmatrix: *mut uint8_t = 0 as *const uint8_t as *mut uint8_t;
#[no_mangle]
pub static mut numdmstarts: int32_t = 0;
#[no_mangle]
pub static mut numcoopstarts: int32_t = 0;
#[no_mangle]
pub static mut numredctfstarts: int32_t = 0;
#[no_mangle]
pub static mut numbluectfstarts: int32_t = 0;
#[no_mangle]
pub static mut deathmatchstarts: [*mut mapthing_t; 64] = [0 as *const mapthing_t
    as *mut mapthing_t; 64];
#[no_mangle]
pub static mut playerstarts: [*mut mapthing_t; 32] = [0 as *const mapthing_t
    as *mut mapthing_t; 32];
#[no_mangle]
pub static mut bluectfstarts: [*mut mapthing_t; 32] = [0 as *const mapthing_t
    as *mut mapthing_t; 32];
#[no_mangle]
pub static mut redctfstarts: [*mut mapthing_t; 32] = [0 as *const mapthing_t
    as *mut mapthing_t; 32];
#[no_mangle]
pub static mut waypoints: [[*mut mobj_t; 256]; 256] = [[0 as *const mobj_t
    as *mut mobj_t; 256]; 256];
#[no_mangle]
pub static mut numwaypoints: [uint16_t; 256] = [0; 256];
#[no_mangle]
pub unsafe extern "C" fn P_AddWaypoint(
    mut sequence: uint8_t,
    mut id: uint8_t,
    mut waypoint: *mut mobj_t,
) {
    waypoints[sequence as usize][id as usize] = waypoint;
    if id as libc::c_int >= numwaypoints[sequence as usize] as libc::c_int {
        numwaypoints[sequence
            as usize] = (id as libc::c_int + 1 as libc::c_int) as uint16_t;
    }
}
unsafe extern "C" fn P_ResetWaypoints() {
    let mut sequence: uint16_t = 0;
    let mut id: uint16_t = 0;
    sequence = 0 as libc::c_int as uint16_t;
    while (sequence as libc::c_int) < 256 as libc::c_int {
        id = 0 as libc::c_int as uint16_t;
        while (id as libc::c_int) < numwaypoints[sequence as usize] as libc::c_int {
            waypoints[sequence as usize][id as usize] = 0 as *mut mobj_t;
            id = id.wrapping_add(1);
            id;
        }
        numwaypoints[sequence as usize] = 0 as libc::c_int as uint16_t;
        sequence = sequence.wrapping_add(1);
        sequence;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_GetFirstWaypoint(mut sequence: uint8_t) -> *mut mobj_t {
    return waypoints[sequence as usize][0 as libc::c_int as usize];
}
#[no_mangle]
pub unsafe extern "C" fn P_GetLastWaypoint(mut sequence: uint8_t) -> *mut mobj_t {
    return waypoints[sequence
        as usize][(numwaypoints[sequence as usize] as libc::c_int - 1 as libc::c_int)
        as usize];
}
#[no_mangle]
pub unsafe extern "C" fn P_GetPreviousWaypoint(
    mut current: *mut mobj_t,
    mut wrap: boolean,
) -> *mut mobj_t {
    let mut sequence: uint8_t = (*current).threshold as uint8_t;
    let mut id: uint8_t = (*current).health as uint8_t;
    if id as libc::c_int == 0 as libc::c_int {
        if wrap == 0 {
            return 0 as *mut mobj_t;
        }
        id = (numwaypoints[sequence as usize] as libc::c_int - 1 as libc::c_int)
            as uint8_t;
    } else {
        id = id.wrapping_sub(1);
        id;
    }
    return waypoints[sequence as usize][id as usize];
}
#[no_mangle]
pub unsafe extern "C" fn P_GetNextWaypoint(
    mut current: *mut mobj_t,
    mut wrap: boolean,
) -> *mut mobj_t {
    let mut sequence: uint8_t = (*current).threshold as uint8_t;
    let mut id: uint8_t = (*current).health as uint8_t;
    if id as libc::c_int
        == numwaypoints[sequence as usize] as libc::c_int - 1 as libc::c_int
    {
        if wrap == 0 {
            return 0 as *mut mobj_t;
        }
        id = 0 as libc::c_int as uint8_t;
    } else {
        id = id.wrapping_add(1);
        id;
    }
    return waypoints[sequence as usize][id as usize];
}
#[no_mangle]
pub unsafe extern "C" fn P_GetClosestWaypoint(
    mut sequence: uint8_t,
    mut mo: *mut mobj_t,
) -> *mut mobj_t {
    let mut wp: uint8_t = 0;
    let mut mo2: *mut mobj_t = 0 as *mut mobj_t;
    let mut result: *mut mobj_t = 0 as *mut mobj_t;
    let mut bestdist: fixed_t = 0 as libc::c_int;
    let mut curdist: fixed_t = 0;
    wp = 0 as libc::c_int as uint8_t;
    while (wp as libc::c_int) < numwaypoints[sequence as usize] as libc::c_int {
        mo2 = waypoints[sequence as usize][wp as usize];
        if !mo2.is_null() {
            curdist = P_AproxDistance(
                P_AproxDistance((*mo).x - (*mo2).x, (*mo).y - (*mo2).y),
                (*mo).z - (*mo2).z,
            );
            if !(!result.is_null() && curdist > bestdist) {
                result = mo2;
                bestdist = curdist;
            }
        }
        wp = wp.wrapping_add(1);
        wp;
    }
    return result;
}
#[no_mangle]
pub unsafe extern "C" fn P_IsDegeneratedWaypointSequence(
    mut sequence: uint8_t,
) -> boolean {
    let mut first: *mut mobj_t = 0 as *mut mobj_t;
    let mut waypoint: *mut mobj_t = 0 as *mut mobj_t;
    let mut wp: uint8_t = 0;
    if numwaypoints[sequence as usize] as libc::c_int <= 1 as libc::c_int {
        return true_0 as libc::c_int;
    }
    first = waypoints[sequence as usize][0 as libc::c_int as usize];
    wp = 1 as libc::c_int as uint8_t;
    while (wp as libc::c_int) < numwaypoints[sequence as usize] as libc::c_int {
        waypoint = waypoints[sequence as usize][wp as usize];
        if !waypoint.is_null() {
            if (*waypoint).x != (*first).x {
                return false_0 as libc::c_int;
            }
            if (*waypoint).y != (*first).y {
                return false_0 as libc::c_int;
            }
            if (*waypoint).z != (*first).z {
                return false_0 as libc::c_int;
            }
        }
        wp = wp.wrapping_add(1);
        wp;
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn CorruptMapError(mut msg: *const libc::c_char) -> ! {
    let mut mapnum: [libc::c_char; 10] = [0; 10];
    sprintf(
        mapnum.as_mut_ptr(),
        b"%hd\0" as *const u8 as *const libc::c_char,
        gamemap as libc::c_int,
    );
    CON_LogMessage(b"Map \0" as *const u8 as *const libc::c_char);
    CON_LogMessage(mapnum.as_mut_ptr());
    CON_LogMessage(b" is corrupt: \0" as *const u8 as *const libc::c_char);
    CON_LogMessage(msg);
    CON_LogMessage(b"\n\0" as *const u8 as *const libc::c_char);
    I_Error(
        b"Invalid or corrupt map.\nLook in log file or text console for technical details.\0"
            as *const u8 as *const libc::c_char,
    );
}
#[no_mangle]
pub unsafe extern "C" fn P_SetDemoFlickies(mut i: int16_t) {
    (*mapheaderinfo[i as usize]).numFlickies = 5 as libc::c_int as uint8_t;
    (*mapheaderinfo[i as usize])
        .flickies = Z_ReallocAlign(
        (*mapheaderinfo[i as usize]).flickies as *mut libc::c_void,
        (5 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<mobjtype_t>() as libc::c_ulong),
        PU_STATIC as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut mobjtype_t;
    *((*mapheaderinfo[i as usize]).flickies)
        .offset(0 as libc::c_int as isize) = MT_FLICKY_02;
    *((*mapheaderinfo[i as usize]).flickies)
        .offset(1 as libc::c_int as isize) = MT_FLICKY_01;
    *((*mapheaderinfo[i as usize]).flickies)
        .offset(2 as libc::c_int as isize) = MT_FLICKY_12;
    *((*mapheaderinfo[i as usize]).flickies)
        .offset(3 as libc::c_int as isize) = MT_FLICKY_11;
    *((*mapheaderinfo[i as usize]).flickies)
        .offset(4 as libc::c_int as isize) = MT_FLICKY_03;
}
#[no_mangle]
pub unsafe extern "C" fn P_DeleteFlickies(mut i: int16_t) {
    if !((*mapheaderinfo[i as usize]).flickies).is_null() {
        Z_Free((*mapheaderinfo[i as usize]).flickies as *mut libc::c_void);
    }
    (*mapheaderinfo[i as usize]).flickies = 0 as *mut mobjtype_t;
    (*mapheaderinfo[i as usize]).numFlickies = 0 as libc::c_int as uint8_t;
}
unsafe extern "C" fn P_ClearSingleMapHeaderInfo(mut i: int16_t) {
    let num: int16_t = (i as libc::c_int - 1 as libc::c_int) as int16_t;
    (*mapheaderinfo[num as usize])
        .lvlttl[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    (*mapheaderinfo[num as usize])
        .selectheading[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    (*mapheaderinfo[num as usize])
        .subttl[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    (*mapheaderinfo[num as usize])
        .ltzzpatch[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    (*mapheaderinfo[num as usize])
        .ltzztext[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    (*mapheaderinfo[num as usize])
        .ltactdiamond[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    (*mapheaderinfo[num as usize]).actnum = 0 as libc::c_int as uint8_t;
    (*mapheaderinfo[num as usize]).typeoflevel = 0 as libc::c_int as uint32_t;
    (*mapheaderinfo[num as usize])
        .nextlevel = (i as libc::c_int + 1 as libc::c_int) as int16_t;
    (*mapheaderinfo[num as usize]).marathonnext = 0 as libc::c_int as int16_t;
    (*mapheaderinfo[num as usize]).startrings = 0 as libc::c_int as uint16_t;
    (*mapheaderinfo[num as usize]).sstimer = 90 as libc::c_int;
    (*mapheaderinfo[num as usize]).ssspheres = 1 as libc::c_int as uint32_t;
    (*mapheaderinfo[num as usize])
        .gravity = ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int;
    (*mapheaderinfo[num as usize])
        .keywords[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    snprintf(
        ((*mapheaderinfo[num as usize]).musname).as_mut_ptr(),
        7 as libc::c_int as libc::c_ulong,
        b"%sM\0" as *const u8 as *const libc::c_char,
        G_BuildMapName(i as int32_t),
    );
    (*mapheaderinfo[num as usize])
        .musname[6 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    (*mapheaderinfo[num as usize]).mustrack = 0 as libc::c_int as uint16_t;
    (*mapheaderinfo[num as usize]).muspos = 0 as libc::c_int as uint32_t;
    (*mapheaderinfo[num as usize]).musinterfadeout = 0 as libc::c_int as uint32_t;
    (*mapheaderinfo[num as usize])
        .musintername[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    (*mapheaderinfo[num as usize])
        .muspostbossname[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    (*mapheaderinfo[num as usize]).muspostbosstrack = 0 as libc::c_int as uint16_t;
    (*mapheaderinfo[num as usize]).muspostbosspos = 0 as libc::c_int as uint32_t;
    (*mapheaderinfo[num as usize]).muspostbossfadein = 0 as libc::c_int as uint32_t;
    (*mapheaderinfo[num as usize]).musforcereset = -(1 as libc::c_int) as int8_t;
    (*mapheaderinfo[num as usize])
        .forcecharacter[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    (*mapheaderinfo[num as usize]).weather = 0 as libc::c_int as uint8_t;
    (*mapheaderinfo[num as usize]).skynum = 1 as libc::c_int as int16_t;
    (*mapheaderinfo[num as usize]).skybox_scalex = 16 as libc::c_int as int16_t;
    (*mapheaderinfo[num as usize]).skybox_scaley = 16 as libc::c_int as int16_t;
    (*mapheaderinfo[num as usize]).skybox_scalez = 16 as libc::c_int as int16_t;
    (*mapheaderinfo[num as usize])
        .interscreen[0 as libc::c_int as usize] = '#' as i32 as libc::c_char;
    (*mapheaderinfo[num as usize])
        .runsoc[0 as libc::c_int as usize] = '#' as i32 as libc::c_char;
    (*mapheaderinfo[num as usize])
        .scriptname[0 as libc::c_int as usize] = '#' as i32 as libc::c_char;
    (*mapheaderinfo[num as usize]).precutscenenum = 0 as libc::c_int as uint8_t;
    (*mapheaderinfo[num as usize]).cutscenenum = 0 as libc::c_int as uint8_t;
    (*mapheaderinfo[num as usize]).countdown = 0 as libc::c_int as int16_t;
    (*mapheaderinfo[num as usize]).palette = 65535 as libc::c_int as uint16_t;
    (*mapheaderinfo[num as usize]).numlaps = 4 as libc::c_int as uint8_t;
    (*mapheaderinfo[num as usize]).unlockrequired = -(1 as libc::c_int) as int8_t;
    (*mapheaderinfo[num as usize]).levelselect = 0 as libc::c_int as uint8_t;
    (*mapheaderinfo[num as usize]).bonustype = 0 as libc::c_int as int8_t;
    (*mapheaderinfo[num as usize]).maxbonuslives = -(1 as libc::c_int) as int8_t;
    (*mapheaderinfo[num as usize]).levelflags = 0 as libc::c_int as uint16_t;
    (*mapheaderinfo[num as usize]).menuflags = 0 as libc::c_int as uint8_t;
    P_SetDemoFlickies(num);
    P_DeleteGrades(num);
    (*mapheaderinfo[num as usize]).customopts = 0 as *mut customoption_t;
    (*mapheaderinfo[num as usize]).numCustomOptions = 0 as libc::c_int as uint8_t;
}
#[no_mangle]
pub unsafe extern "C" fn P_AllocMapHeader(mut i: int16_t) {
    if (mapheaderinfo[i as usize]).is_null() {
        mapheaderinfo[i
            as usize] = Z_MallocAlign(
            ::core::mem::size_of::<mapheader_t>() as libc::c_ulong,
            PU_STATIC as libc::c_int,
            0 as *mut libc::c_void,
            ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
        ) as *mut mapheader_t;
        (*mapheaderinfo[i as usize]).flickies = 0 as *mut mobjtype_t;
        (*mapheaderinfo[i as usize]).grades = 0 as *mut nightsgrades_t;
    }
    P_ClearSingleMapHeaderInfo((i as libc::c_int + 1 as libc::c_int) as int16_t);
}
#[no_mangle]
pub unsafe extern "C" fn P_AddGradesForMare(
    mut i: int16_t,
    mut mare: uint8_t,
    mut gtext: *mut libc::c_char,
) {
    let mut g: int32_t = 0;
    let mut spos: *mut libc::c_char = gtext;
    CONS_Debug(
        0x400 as libc::c_int,
        b"Map %d Mare %d: \0" as *const u8 as *const libc::c_char,
        i as libc::c_int + 1 as libc::c_int,
        mare as uint16_t as libc::c_int + 1 as libc::c_int,
    );
    if ((*mapheaderinfo[i as usize]).numGradedMares as libc::c_int)
        < mare as libc::c_int + 1 as libc::c_int
    {
        (*mapheaderinfo[i as usize])
            .numGradedMares = (mare as libc::c_int + 1 as libc::c_int) as uint8_t;
        (*mapheaderinfo[i as usize])
            .grades = Z_ReallocAlign(
            (*mapheaderinfo[i as usize]).grades as *mut libc::c_void,
            (::core::mem::size_of::<nightsgrades_t>() as libc::c_ulong)
                .wrapping_mul(
                    (*mapheaderinfo[i as usize]).numGradedMares as libc::c_ulong,
                ),
            PU_STATIC as libc::c_int,
            0 as *mut libc::c_void,
            ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
        ) as *mut nightsgrades_t;
    }
    g = 0 as libc::c_int;
    while g < 6 as libc::c_int {
        if !spos.is_null() {
            (*((*mapheaderinfo[i as usize]).grades).offset(mare as isize))
                .grade[g as usize] = atoi(spos) as uint32_t;
            CONS_Debug(
                0x400 as libc::c_int,
                b"%u \0" as *const u8 as *const libc::c_char,
                atoi(spos),
            );
            spos = strchr(spos, ',' as i32);
            if !spos.is_null() {
                spos = spos.offset(1);
                spos;
            }
        } else {
            (*((*mapheaderinfo[i as usize]).grades).offset(mare as isize))
                .grade[g as usize] = 4294967295 as libc::c_uint;
        }
        g += 1;
        g;
    }
    CONS_Debug(0x400 as libc::c_int, b"\n\0" as *const u8 as *const libc::c_char);
}
#[no_mangle]
pub unsafe extern "C" fn P_DeleteGrades(mut i: int16_t) {
    if !((*mapheaderinfo[i as usize]).grades).is_null() {
        Z_Free((*mapheaderinfo[i as usize]).grades as *mut libc::c_void);
    }
    (*mapheaderinfo[i as usize]).grades = 0 as *mut nightsgrades_t;
    (*mapheaderinfo[i as usize]).numGradedMares = 0 as libc::c_int as uint8_t;
}
#[no_mangle]
pub unsafe extern "C" fn P_GetGrade(
    mut pscore: uint32_t,
    mut map: int16_t,
    mut mare: uint8_t,
) -> uint8_t {
    let mut i: int32_t = 0;
    if !(mapheaderinfo[(map as libc::c_int - 1 as libc::c_int) as usize]).is_null()
        && !((*mapheaderinfo[(map as libc::c_int - 1 as libc::c_int) as usize]).grades)
            .is_null()
        && (*mapheaderinfo[(map as libc::c_int - 1 as libc::c_int) as usize])
            .numGradedMares as libc::c_int >= mare as libc::c_int + 1 as libc::c_int
    {
        let mut pgrade: int32_t = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while i < 6 as libc::c_int {
            if pscore
                >= (*((*mapheaderinfo[(map as libc::c_int - 1 as libc::c_int) as usize])
                    .grades)
                    .offset(mare as isize))
                    .grade[i as usize]
            {
                pgrade += 1;
                pgrade;
            }
            i += 1;
            i;
        }
        return pgrade as uint8_t;
    }
    return 0 as libc::c_int as uint8_t;
}
#[no_mangle]
pub unsafe extern "C" fn P_HasGrades(mut map: int16_t, mut mare: uint8_t) -> uint8_t {
    if !(mapheaderinfo[(map as libc::c_int - 1 as libc::c_int) as usize]).is_null()
        && !((*mapheaderinfo[(map as libc::c_int - 1 as libc::c_int) as usize]).grades)
            .is_null()
        && (mare as libc::c_int == 0 as libc::c_int
            || (*mapheaderinfo[(map as libc::c_int - 1 as libc::c_int) as usize])
                .numGradedMares as libc::c_int >= mare as libc::c_int)
    {
        return true_0 as libc::c_int as uint8_t;
    }
    return false_0 as libc::c_int as uint8_t;
}
#[no_mangle]
pub unsafe extern "C" fn P_GetScoreForGrade(
    mut map: int16_t,
    mut mare: uint8_t,
    mut grade: uint8_t,
) -> uint32_t {
    if grade as libc::c_int == 0 as libc::c_int
        || grade as libc::c_int > 6 as libc::c_int || P_HasGrades(map, mare) == 0
    {
        return 0 as libc::c_int as uint32_t;
    }
    return (*((*mapheaderinfo[(map as libc::c_int - 1 as libc::c_int) as usize]).grades)
        .offset(mare as isize))
        .grade[(grade as libc::c_int - 1 as libc::c_int) as usize];
}
#[no_mangle]
pub unsafe extern "C" fn P_GetScoreForGradeOverall(
    mut map: int16_t,
    mut grade: uint8_t,
) -> uint32_t {
    let mut mares: uint8_t = 0;
    let mut i: int32_t = 0;
    let mut score: uint32_t = 0 as libc::c_int as uint32_t;
    mares = (*mapheaderinfo[(map as libc::c_int - 1 as libc::c_int) as usize])
        .numGradedMares;
    i = 0 as libc::c_int;
    while i < mares as libc::c_int {
        score = score.wrapping_add(P_GetScoreForGrade(map, i as uint8_t, grade));
        i += 1;
        i;
    }
    return score;
}
#[no_mangle]
pub static mut numlevelflats: size_t = 0;
#[no_mangle]
pub static mut levelflats: *mut levelflat_t = 0 as *const levelflat_t
    as *mut levelflat_t;
#[no_mangle]
pub static mut foundflats: *mut levelflat_t = 0 as *const levelflat_t
    as *mut levelflat_t;
#[no_mangle]
pub unsafe extern "C" fn P_PrecacheLevelFlats() -> size_t {
    let mut lump: lumpnum_t = 0;
    let mut i: size_t = 0;
    flatmemory = 0 as libc::c_int as size_t;
    i = 0 as libc::c_int as size_t;
    while i < numlevelflats {
        if (*levelflats.offset(i as isize)).type_0 as libc::c_int
            == LEVELFLAT_FLAT as libc::c_int
        {
            lump = (*levelflats.offset(i as isize)).u.flat.lumpnum;
            if devparm != 0 {
                flatmemory = flatmemory.wrapping_add(W_LumpLength(lump));
            }
            R_GetFlat(lump);
        }
        i = i.wrapping_add(1);
        i;
    }
    return flatmemory;
}
unsafe extern "C" fn Ploadflat(
    mut levelflat: *mut levelflat_t,
    mut flatname: *const libc::c_char,
    mut resize: boolean,
) -> int32_t {
    let mut buffer: [uint8_t; 8] = [0; 8];
    let mut flatnum: lumpnum_t = 0;
    let mut texturenum: libc::c_int = 0;
    let mut flatpatch: *mut uint8_t = 0 as *mut uint8_t;
    let mut lumplength: size_t = 0;
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numlevelflats {
        if strncasecmp(
            ((*levelflat.offset(i as isize)).name).as_mut_ptr(),
            flatname,
            8 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
        {
            return i as int32_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    if resize != 0 {
        levelflats = Z_ReallocAlign(
            levelflats as *mut libc::c_void,
            numlevelflats
                .wrapping_add(1 as libc::c_int as size_t)
                .wrapping_mul(::core::mem::size_of::<levelflat_t>() as libc::c_ulong),
            PU_LEVEL as libc::c_int,
            0 as *mut libc::c_void,
            ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
        ) as *mut levelflat_t;
        levelflat = levelflats.offset(numlevelflats as isize);
    } else {
        if numlevelflats >= 256 as libc::c_int as size_t {
            I_Error(b"Too many flats in level\n\0" as *const u8 as *const libc::c_char);
        }
        levelflat = levelflat.offset(numlevelflats as isize);
    }
    strlcpy(
        ((*levelflat).name).as_mut_ptr(),
        flatname,
        ::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong,
    );
    strupr(((*levelflat).name).as_mut_ptr());
    let mut current_block_32: u64;
    flatnum = R_GetFlatNumForName(((*levelflat).name).as_mut_ptr());
    if flatnum == 4294967295 as libc::c_uint {
        texturenum = R_CheckTextureNumForName(((*levelflat).name).as_mut_ptr());
        if texturenum == -(1 as libc::c_int) {
            texturenum = R_CheckTextureNumForName(
                b"REDWALL\0" as *const u8 as *const libc::c_char,
            );
            if texturenum != -(1 as libc::c_int) {
                current_block_32 = 8997023796578693695;
            } else {
                flatnum = R_GetFlatNumForName(
                    b"REDFLR\0" as *const u8 as *const libc::c_char,
                );
                if flatnum != 4294967295 as libc::c_uint {
                    current_block_32 = 9562147605943398467;
                } else {
                    (*levelflat).type_0 = LEVELFLAT_NONE as libc::c_int as uint8_t;
                    current_block_32 = 14136749492126903395;
                }
            }
        } else {
            current_block_32 = 8997023796578693695;
        }
        match current_block_32 {
            9562147605943398467 => {}
            14136749492126903395 => {}
            _ => {
                (*levelflat).type_0 = LEVELFLAT_TEXTURE as libc::c_int as uint8_t;
                (*levelflat).u.texture.num = texturenum;
                (*levelflat).u.texture.lastnum = texturenum;
                (*levelflat).u.texture.basenum = -(1 as libc::c_int);
                current_block_32 = 14136749492126903395;
            }
        }
    } else {
        current_block_32 = 9562147605943398467;
    }
    match current_block_32 {
        9562147605943398467 => {
            flatpatch = W_CacheLumpNum(flatnum, PU_CACHE as libc::c_int) as *mut uint8_t;
            lumplength = W_LumpLength(flatnum);
            if Picture_CheckIfDoomPatch(flatpatch as *mut softwarepatch_t, lumplength)
                != 0
            {
                (*levelflat).type_0 = LEVELFLAT_PATCH as libc::c_int as uint8_t;
            } else {
                W_ReadLumpHeader(
                    flatnum,
                    buffer.as_mut_ptr() as *mut libc::c_void,
                    8 as libc::c_int as size_t,
                    0 as libc::c_int as size_t,
                );
                if Picture_IsLumpPNG(buffer.as_mut_ptr(), lumplength) != 0 {
                    (*levelflat).type_0 = LEVELFLAT_PNG as libc::c_int as uint8_t;
                } else {
                    (*levelflat).type_0 = LEVELFLAT_FLAT as libc::c_int as uint8_t;
                }
            }
            if !flatpatch.is_null() {
                Z_Free(flatpatch as *mut libc::c_void);
            }
            (*levelflat).u.flat.lumpnum = flatnum;
            (*levelflat).u.flat.baselumpnum = 4294967295 as libc::c_uint;
        }
        _ => {}
    }
    CONS_Debug(
        0x400 as libc::c_int,
        b"flat #%03d: %s\n\0" as *const u8 as *const libc::c_char,
        atoi(sizeu1(numlevelflats)),
        ((*levelflat).name).as_mut_ptr(),
    );
    let fresh0 = numlevelflats;
    numlevelflats = numlevelflats.wrapping_add(1);
    return fresh0 as int32_t;
}
#[no_mangle]
pub unsafe extern "C" fn P_AddLevelFlat(
    mut flatname: *const libc::c_char,
    mut levelflat: *mut levelflat_t,
) -> int32_t {
    return Ploadflat(levelflat, flatname, false_0 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn P_AddLevelFlatRuntime(
    mut flatname: *const libc::c_char,
) -> int32_t {
    return Ploadflat(levelflats, flatname, true_0 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn P_CheckLevelFlat(mut flatname: *const libc::c_char) -> int32_t {
    let mut i: size_t = 0;
    let mut levelflat: *mut levelflat_t = levelflats;
    i = 0 as libc::c_int as size_t;
    while i < numlevelflats {
        if strncasecmp(
            ((*levelflat).name).as_mut_ptr(),
            flatname,
            8 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
        {
            break;
        }
        i = i.wrapping_add(1);
        i;
        levelflat = levelflat.offset(1);
        levelflat;
    }
    if i == numlevelflats {
        return 0 as libc::c_int;
    }
    return i as int32_t;
}
#[no_mangle]
pub unsafe extern "C" fn P_ReloadRings() {
    let mut mo: *mut mobj_t = 0 as *mut mobj_t;
    let mut th: *mut thinker_t = 0 as *mut thinker_t;
    let mut i: size_t = 0;
    let mut numHoops: size_t = 0 as libc::c_int as size_t;
    let mut hoopsToRespawn: [*mut mapthing_t; 4096] = [0 as *mut mapthing_t; 4096];
    let mut mt: *mut mapthing_t = mapthings;
    th = (*thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)).next;
    while th
        != &mut *thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)
            as *mut thinker_t
    {
        if !((*th).function.acp1
            == ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut thinker_t) -> ()>,
                actionf_p1,
            >(
                Some(
                    P_RemoveThinkerDelayed as unsafe extern "C" fn(*mut thinker_t) -> (),
                ),
            ))
        {
            mo = th as *mut mobj_t;
            if (*mo).type_0 as libc::c_uint
                == MT_HOOPCENTER as libc::c_int as libc::c_uint
            {
                if (*mo).threshold == 4242 as libc::c_int {
                    let fresh1 = numHoops;
                    numHoops = numHoops.wrapping_add(1);
                    hoopsToRespawn[fresh1 as usize] = (*mo).spawnpoint;
                    P_RemoveMobj(mo);
                }
            } else if (*mo).type_0 as libc::c_uint
                == MT_RING as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint == MT_COIN as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_BLUESPHERE as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_BOMBSPHERE as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_NIGHTSCHIP as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_NIGHTSSTAR as libc::c_int as libc::c_uint
            {
                if !((*mo).flags2 & MF2_NIGHTSPULL as libc::c_int as uint32_t != 0) {
                    P_RemoveMobj(mo);
                }
            }
        }
        th = (*th).next;
    }
    i = 0 as libc::c_int as size_t;
    while i < nummapthings {
        if (*mt).type_0 as libc::c_int
            == mobjinfo[MT_RING as libc::c_int as usize].doomednum
            || (*mt).type_0 as libc::c_int
                == mobjinfo[MT_COIN as libc::c_int as usize].doomednum
            || (*mt).type_0 as libc::c_int
                == mobjinfo[MT_REDTEAMRING as libc::c_int as usize].doomednum
            || (*mt).type_0 as libc::c_int
                == mobjinfo[MT_BLUETEAMRING as libc::c_int as usize].doomednum
            || (*mt).type_0 as libc::c_int
                == mobjinfo[MT_BLUESPHERE as libc::c_int as usize].doomednum
            || (*mt).type_0 as libc::c_int
                == mobjinfo[MT_BOMBSPHERE as libc::c_int as usize].doomednum
        {
            (*mt).mobj = 0 as *mut mobj_s;
            P_SetBonusTime(P_SpawnMapThing(mt));
        } else if (*mt).type_0 as libc::c_int >= 600 as libc::c_int
            && (*mt).type_0 as libc::c_int <= 611 as libc::c_int
        {
            (*mt).mobj = 0 as *mut mobj_s;
            P_SpawnItemPattern(mt, true_0 as libc::c_int);
        }
        i = i.wrapping_add(1);
        i;
        mt = mt.offset(1);
        mt;
    }
    i = 0 as libc::c_int as size_t;
    while i < numHoops {
        P_SpawnHoop(hoopsToRespawn[i as usize]);
        i = i.wrapping_add(1);
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_SwitchSpheresBonusMode(mut bonustime: boolean) {
    let mut mo: *mut mobj_t = 0 as *mut mobj_t;
    let mut th: *mut thinker_t = 0 as *mut thinker_t;
    th = (*thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)).next;
    while th
        != &mut *thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)
            as *mut thinker_t
    {
        if !((*th).function.acp1
            == ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut thinker_t) -> ()>,
                actionf_p1,
            >(
                Some(
                    P_RemoveThinkerDelayed as unsafe extern "C" fn(*mut thinker_t) -> (),
                ),
            ))
        {
            mo = th as *mut mobj_t;
            if !((*mo).type_0 as libc::c_uint
                != MT_BLUESPHERE as libc::c_int as libc::c_uint
                && (*mo).type_0 as libc::c_uint
                    != MT_NIGHTSCHIP as libc::c_int as libc::c_uint
                && (*mo).type_0 as libc::c_uint
                    != MT_FLINGBLUESPHERE as libc::c_int as libc::c_uint
                && (*mo).type_0 as libc::c_uint
                    != MT_FLINGNIGHTSCHIP as libc::c_int as libc::c_uint)
            {
                if !((*mo).health == 0) {
                    P_SetMobjState(
                        mo,
                        (if bonustime != 0 {
                            (*(*mo).info).raisestate as libc::c_uint
                        } else {
                            (*(*mo).info).spawnstate as libc::c_uint
                        }) as statenum_t,
                    );
                }
            }
        }
        th = (*th).next;
    }
}
unsafe extern "C" fn P_SpawnEmeraldHunt() {
    let mut emer: [int32_t; 3] = [0; 3];
    let mut num: [int32_t; 64] = [0; 64];
    let mut i: int32_t = 0;
    let mut randomkey: int32_t = 0;
    let mut x: fixed_t = 0;
    let mut y: fixed_t = 0;
    let mut z: fixed_t = 0;
    i = 0 as libc::c_int;
    while i < numhuntemeralds {
        num[i as usize] = i;
        i += 1;
        i;
    }
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        let fresh2 = numhuntemeralds;
        numhuntemeralds = numhuntemeralds - 1;
        randomkey = P_RandomKey(fresh2);
        emer[i as usize] = num[randomkey as usize];
        num[randomkey as usize] = num[numhuntemeralds as usize];
        num[numhuntemeralds as usize] = emer[i as usize];
        x = ((*huntemeralds[emer[i as usize] as usize]).x as libc::c_int)
            << 16 as libc::c_int;
        y = ((*huntemeralds[emer[i as usize] as usize]).y as libc::c_int)
            << 16 as libc::c_int;
        z = P_GetMapThingSpawnHeight(
            MT_EMERHUNT,
            huntemeralds[emer[i as usize] as usize],
            x,
            y,
        );
        P_SetMobjStateNF(
            P_SpawnMobj(x, y, z, MT_EMERHUNT),
            (mobjinfo[MT_EMERHUNT as libc::c_int as usize].spawnstate as libc::c_uint)
                .wrapping_add(i as libc::c_uint) as statenum_t,
        );
        i += 1;
        i;
    }
}
unsafe extern "C" fn P_SpawnMapThings(mut spawnemblems: boolean) {
    let mut i: size_t = 0;
    let mut mt: *mut mapthing_t = 0 as *mut mapthing_t;
    i = 0 as libc::c_int as size_t;
    mt = mapthings;
    while i < nummapthings {
        let mut current_block_2: u64;
        match (*mt).type_0 as libc::c_int {
            1701 => {
                current_block_2 = 2275697770225995386;
            }
            1700 | 1702 => {
                current_block_2 = 2275697770225995386;
            }
            _ => {
                current_block_2 = 2473556513754201174;
            }
        }
        match current_block_2 {
            2275697770225995386 => {
                (*mt).mobj = 0 as *mut mobj_s;
                P_SpawnMapThing(mt);
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        i;
        mt = mt.offset(1);
        mt;
    }
    numhuntemeralds = 0 as libc::c_int;
    i = 0 as libc::c_int as size_t;
    mt = mapthings;
    while i < nummapthings {
        if !((*mt).type_0 as libc::c_int == 1700 as libc::c_int
            || (*mt).type_0 as libc::c_int == 1701 as libc::c_int
            || (*mt).type_0 as libc::c_int == 1702 as libc::c_int)
        {
            if !(spawnemblems == 0
                && (*mt).type_0 as libc::c_int
                    == mobjinfo[MT_EMBLEM as libc::c_int as usize].doomednum)
            {
                (*mt).mobj = 0 as *mut mobj_s;
                if (*mt).type_0 as libc::c_int >= 600 as libc::c_int
                    && (*mt).type_0 as libc::c_int <= 611 as libc::c_int
                {
                    P_SpawnItemPattern(mt, false_0 as libc::c_int);
                } else if (*mt).type_0 as libc::c_int == 1713 as libc::c_int {
                    P_SpawnHoop(mt);
                } else {
                    P_SpawnMapThing(mt);
                }
            }
        }
        i = i.wrapping_add(1);
        i;
        mt = mt.offset(1);
        mt;
    }
    if numhuntemeralds != 0 {
        P_SpawnEmeraldHunt();
    }
}
unsafe extern "C" fn P_LoadVertices(mut data: *mut uint8_t) {
    let mut mv: *mut mapvertex_t = data as *mut mapvertex_t;
    let mut v: *mut vertex_t = vertexes;
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numvertexes {
        (*v).x = ((*mv).x as libc::c_int) << 16 as libc::c_int;
        (*v).y = ((*mv).y as libc::c_int) << 16 as libc::c_int;
        (*v).ceilingzset = false_0 as libc::c_int;
        (*v).floorzset = (*v).ceilingzset;
        (*v).ceilingz = 0 as libc::c_int;
        (*v).floorz = (*v).ceilingz;
        i = i.wrapping_add(1);
        i;
        v = v.offset(1);
        v;
        mv = mv.offset(1);
        mv;
    }
}
unsafe extern "C" fn P_InitializeSector(mut ss: *mut sector_t) {
    memset(
        &mut (*ss).soundorg as *mut degenmobj_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<degenmobj_t>() as libc::c_ulong,
    );
    (*ss).validcount = 0 as libc::c_int as size_t;
    (*ss).thinglist = 0 as *mut mobj_t;
    (*ss).floordata = 0 as *mut libc::c_void;
    (*ss).ceilingdata = 0 as *mut libc::c_void;
    (*ss).lightingdata = 0 as *mut libc::c_void;
    (*ss).fadecolormapdata = 0 as *mut libc::c_void;
    (*ss).heightsec = -(1 as libc::c_int);
    (*ss).camsec = -(1 as libc::c_int);
    (*ss).ceilinglightsec = -(1 as libc::c_int);
    (*ss).floorlightsec = (*ss).ceilinglightsec;
    (*ss).crumblestate = CRUMBLE_NONE as libc::c_int;
    (*ss).touching_thinglist = 0 as *mut msecnode_s;
    (*ss).linecount = 0 as libc::c_int as size_t;
    (*ss).lines = 0 as *mut *mut line_s;
    (*ss).ffloors = 0 as *mut ffloor_t;
    (*ss).attached = 0 as *mut size_t;
    (*ss).attachedsolid = 0 as *mut boolean;
    (*ss).numattached = 0 as libc::c_int as size_t;
    (*ss).maxattached = 1 as libc::c_int as size_t;
    (*ss).lightlist = 0 as *mut lightlist_t;
    (*ss).numlights = 0 as libc::c_int;
    (*ss).moved = true_0 as libc::c_int;
    (*ss).extra_colormap = 0 as *mut extracolormap_t;
    (*ss).gravityptr = 0 as *mut fixed_t;
    (*ss).cullheight = 0 as *mut line_s;
    (*ss).ceilspeed = 0 as libc::c_int;
    (*ss).floorspeed = (*ss).ceilspeed;
    (*ss).preciplist = 0 as *mut precipmobj_t;
    (*ss).touching_preciplist = 0 as *mut mprecipsecnode_s;
    (*ss).f_slope = 0 as *mut pslope_t;
    (*ss).c_slope = 0 as *mut pslope_t;
    (*ss).hasslope = false_0 as libc::c_int;
    (*ss).spawn_lightlevel = (*ss).lightlevel;
    (*ss).spawn_extra_colormap = 0 as *mut extracolormap_t;
}
unsafe extern "C" fn P_LoadSectors(mut data: *mut uint8_t) {
    let mut ms: *mut mapsector_t = data as *mut mapsector_t;
    let mut ss: *mut sector_t = sectors;
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numsectors {
        (*ss).floorheight = ((*ms).floorheight as libc::c_int) << 16 as libc::c_int;
        (*ss).ceilingheight = ((*ms).ceilingheight as libc::c_int) << 16 as libc::c_int;
        (*ss).floorpic = P_AddLevelFlat(((*ms).floorpic).as_mut_ptr(), foundflats);
        (*ss).ceilingpic = P_AddLevelFlat(((*ms).ceilingpic).as_mut_ptr(), foundflats);
        (*ss).lightlevel = (*ms).lightlevel;
        (*ss).special = (*ms).special;
        Tag_FSet(&mut (*ss).tags, (*ms).tag);
        (*ss).flooryoffset = 0 as libc::c_int;
        (*ss).floorxoffset = (*ss).flooryoffset;
        (*ss).ceilingyoffset = 0 as libc::c_int;
        (*ss).ceilingxoffset = (*ss).ceilingyoffset;
        (*ss).ceilingangle = 0 as libc::c_int as angle_t;
        (*ss).floorangle = (*ss).ceilingangle;
        (*ss).ceilinglightlevel = 0 as libc::c_int as int16_t;
        (*ss).floorlightlevel = (*ss).ceilinglightlevel;
        (*ss).ceilinglightabsolute = false_0 as libc::c_int;
        (*ss).floorlightabsolute = (*ss).ceilinglightabsolute;
        (*ss).colormap_protected = false_0 as libc::c_int;
        (*ss).gravity = (1 as libc::c_int) << 16 as libc::c_int;
        (*ss).flags = MSF_FLIPSPECIAL_FLOOR;
        (*ss).specialflags = 0 as sectorspecialflags_t;
        (*ss).damagetype = SD_NONE as libc::c_int as uint8_t;
        (*ss).triggertag = 0 as libc::c_int as mtag_t;
        (*ss).triggerer = TO_PLAYER as libc::c_int as uint8_t;
        (*ss).friction = (0xe8 as libc::c_int) << 16 as libc::c_int - 8 as libc::c_int;
        P_InitializeSector(ss);
        i = i.wrapping_add(1);
        i;
        ss = ss.offset(1);
        ss;
        ms = ms.offset(1);
        ms;
    }
}
unsafe extern "C" fn P_InitializeLinedef(mut ld: *mut line_t) {
    let mut v1: *mut vertex_t = (*ld).v1;
    let mut v2: *mut vertex_t = (*ld).v2;
    let mut j: uint8_t = 0;
    (*ld).dx = (*v2).x - (*v1).x;
    (*ld).dy = (*v2).y - (*v1).y;
    (*ld)
        .angle = R_PointToAngle2(0 as libc::c_int, 0 as libc::c_int, (*ld).dx, (*ld).dy);
    (*ld)
        .bbox[BOXLEFT as libc::c_int
        as usize] = if (*v1).x < (*v2).x { (*v1).x } else { (*v2).x };
    (*ld)
        .bbox[BOXRIGHT as libc::c_int
        as usize] = if (*v1).x > (*v2).x { (*v1).x } else { (*v2).x };
    (*ld)
        .bbox[BOXBOTTOM as libc::c_int
        as usize] = if (*v1).y < (*v2).y { (*v1).y } else { (*v2).y };
    (*ld)
        .bbox[BOXTOP as libc::c_int
        as usize] = if (*v1).y > (*v2).y { (*v1).y } else { (*v2).y };
    if (*ld).dx == 0 {
        (*ld).slopetype = ST_VERTICAL;
    } else if (*ld).dy == 0 {
        (*ld).slopetype = ST_HORIZONTAL;
    } else if ((*ld).dy > 0 as libc::c_int) as libc::c_int
        == ((*ld).dx > 0 as libc::c_int) as libc::c_int
    {
        (*ld).slopetype = ST_POSITIVE;
    } else {
        (*ld).slopetype = ST_NEGATIVE;
    }
    (*ld).backsector = 0 as *mut sector_t;
    (*ld).frontsector = (*ld).backsector;
    (*ld).validcount = 0 as libc::c_int as size_t;
    (*ld).polyobj = 0 as *mut polyobj_t;
    (*ld).callcount = 0 as libc::c_int as int16_t;
    j = 0 as libc::c_int as uint8_t;
    while (j as libc::c_int) < 2 as libc::c_int {
        if (*ld).sidenum[j as usize] as libc::c_int != 0xffff as libc::c_int
            && (*ld).sidenum[j as usize] as libc::c_int
                >= numsides as uint16_t as libc::c_int
        {
            (*ld).sidenum[j as usize] = 0xffff as libc::c_int as uint16_t;
            CONS_Debug(
                0x400 as libc::c_int,
                b"P_InitializeLinedef: Linedef %s has out-of-range sidedef number\n\0"
                    as *const u8 as *const libc::c_char,
                sizeu1(ld.offset_from(lines) as libc::c_long as size_t),
            );
        }
        j = j.wrapping_add(1);
        j;
    }
    if (*ld).sidenum[0 as libc::c_int as usize] as libc::c_int == 0xffff as libc::c_int {
        (*ld).sidenum[0 as libc::c_int as usize] = 0 as libc::c_int as uint16_t;
        CONS_Debug(
            0x400 as libc::c_int,
            b"P_InitializeLinedef: Linedef %s missing first sidedef\n\0" as *const u8
                as *const libc::c_char,
            sizeu1(ld.offset_from(lines) as libc::c_long as size_t),
        );
    }
    if (*ld).sidenum[1 as libc::c_int as usize] as libc::c_int == 0xffff as libc::c_int
        && (*ld).flags as libc::c_int & 4 as libc::c_int != 0
    {
        (*ld).flags = ((*ld).flags as libc::c_int & !(4 as libc::c_int)) as int16_t;
        CONS_Debug(
            0x400 as libc::c_int,
            b"P_InitializeLinedef: Linedef %s has two-sided flag set, but no second sidedef\n\0"
                as *const u8 as *const libc::c_char,
            sizeu1(ld.offset_from(lines) as libc::c_long as size_t),
        );
    }
    if (*ld).sidenum[0 as libc::c_int as usize] as libc::c_int != 0xffff as libc::c_int {
        (*sides.offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
            .special = (*ld).special;
        let ref mut fresh3 = (*sides
            .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
            .line;
        *fresh3 = ld;
    }
    if (*ld).sidenum[1 as libc::c_int as usize] as libc::c_int != 0xffff as libc::c_int {
        (*sides.offset((*ld).sidenum[1 as libc::c_int as usize] as isize))
            .special = (*ld).special;
        let ref mut fresh4 = (*sides
            .offset((*ld).sidenum[1 as libc::c_int as usize] as isize))
            .line;
        *fresh4 = ld;
    }
}
unsafe extern "C" fn P_SetLinedefV1(mut i: size_t, mut vertex_num: uint16_t) {
    if vertex_num as size_t >= numvertexes {
        CONS_Debug(
            0x400 as libc::c_int,
            b"P_SetLinedefV1: linedef %s has out-of-range v1 num %u\n\0" as *const u8
                as *const libc::c_char,
            sizeu1(i),
            vertex_num as libc::c_int,
        );
        vertex_num = 0 as libc::c_int as uint16_t;
    }
    let ref mut fresh5 = (*lines.offset(i as isize)).v1;
    *fresh5 = &mut *vertexes.offset(vertex_num as isize) as *mut vertex_t;
}
unsafe extern "C" fn P_SetLinedefV2(mut i: size_t, mut vertex_num: uint16_t) {
    if vertex_num as size_t >= numvertexes {
        CONS_Debug(
            0x400 as libc::c_int,
            b"P_SetLinedefV2: linedef %s has out-of-range v2 num %u\n\0" as *const u8
                as *const libc::c_char,
            sizeu1(i),
            vertex_num as libc::c_int,
        );
        vertex_num = 0 as libc::c_int as uint16_t;
    }
    let ref mut fresh6 = (*lines.offset(i as isize)).v2;
    *fresh6 = &mut *vertexes.offset(vertex_num as isize) as *mut vertex_t;
}
unsafe extern "C" fn P_LoadLinedefs(mut data: *mut uint8_t) {
    let mut mld: *mut maplinedef_t = data as *mut maplinedef_t;
    let mut ld: *mut line_t = lines;
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numlines {
        (*ld).flags = (*mld).flags;
        (*ld).special = (*mld).special;
        Tag_FSet(&mut (*ld).tags, (*mld).tag);
        memset(
            ((*ld).args).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            (10 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<int32_t>() as libc::c_ulong),
        );
        memset(
            ((*ld).stringargs).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            (2 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ),
        );
        (*ld).alpha = (1 as libc::c_int) << 16 as libc::c_int;
        (*ld).executordelay = 0 as libc::c_int;
        P_SetLinedefV1(i, (*mld).v1 as uint16_t);
        P_SetLinedefV2(i, (*mld).v2 as uint16_t);
        (*ld)
            .sidenum[0 as libc::c_int
            as usize] = (*mld).sidenum[0 as libc::c_int as usize] as int16_t as uint16_t;
        (*ld)
            .sidenum[1 as libc::c_int
            as usize] = (*mld).sidenum[1 as libc::c_int as usize] as int16_t as uint16_t;
        P_InitializeLinedef(ld);
        i = i.wrapping_add(1);
        i;
        mld = mld.offset(1);
        mld;
        ld = ld.offset(1);
        ld;
    }
}
unsafe extern "C" fn P_SetSidedefSector(mut i: size_t, mut sector_num: uint16_t) {
    if sector_num as size_t >= numsectors {
        CONS_Debug(
            0x400 as libc::c_int,
            b"P_SetSidedefSector: sidedef %s has out-of-range sector num %u\n\0"
                as *const u8 as *const libc::c_char,
            sizeu1(i),
            sector_num as libc::c_int,
        );
        sector_num = 0 as libc::c_int as uint16_t;
    }
    let ref mut fresh7 = (*sides.offset(i as isize)).sector;
    *fresh7 = &mut *sectors.offset(sector_num as isize) as *mut sector_t;
}
unsafe extern "C" fn P_InitializeSidedef(mut sd: *mut side_t) {
    if ((*sd).line).is_null() {
        CONS_Debug(
            0x400 as libc::c_int,
            b"P_LoadSidedefs: Sidedef %s is not used by any linedef\n\0" as *const u8
                as *const libc::c_char,
            sizeu1(sd.offset_from(sides) as libc::c_long as size_t),
        );
        (*sd).line = &mut *lines.offset(0 as libc::c_int as isize) as *mut line_t;
        (*sd).special = (*(*sd).line).special;
    }
    (*sd).colormap_data = 0 as *mut extracolormap_t;
}
static mut contextdrift: boolean = false_0 as libc::c_int;
unsafe extern "C" fn P_WriteConstant(
    mut constant: int32_t,
    mut target: *mut *mut libc::c_char,
    mut desc: *const libc::c_char,
    mut id: uint32_t,
) {
    let mut buffer: [libc::c_char; 12] = [0; 12];
    let mut len: size_t = 0;
    CONS_Alert(
        CONS_WARNING,
        b"P_WriteConstant has been called for %s %d, this level is vulnerable to context drift if -writetextmap is used.\n\0"
            as *const u8 as *const libc::c_char,
        desc,
        id,
    );
    contextdrift = true_0 as libc::c_int;
    sprintf(buffer.as_mut_ptr(), b"%d\0" as *const u8 as *const libc::c_char, constant);
    len = (strlen(buffer.as_mut_ptr())).wrapping_add(1 as libc::c_int as libc::c_ulong);
    *target = Z_MallocAlign(
        len,
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut libc::c_char;
    M_Memcpy
        .expect(
            "non-null function pointer",
        )(*target as *mut libc::c_void, buffer.as_mut_ptr() as *const libc::c_void, len);
}
unsafe extern "C" fn P_WriteDuplicateText(
    mut text: *const libc::c_char,
    mut target: *mut *mut libc::c_char,
) {
    if text.is_null()
        || *text.offset(0 as libc::c_int as isize) as libc::c_int == '\0' as i32
    {
        return;
    }
    let mut len: size_t = (strlen(text)).wrapping_add(1 as libc::c_int as libc::c_ulong);
    *target = Z_MallocAlign(
        len,
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut libc::c_char;
    M_Memcpy
        .expect(
            "non-null function pointer",
        )(*target as *mut libc::c_void, text as *const libc::c_void, len);
}
unsafe extern "C" fn P_WriteSkincolor(
    mut constant: int32_t,
    mut target: *mut *mut libc::c_char,
) {
    let mut color_name: *const libc::c_char = 0 as *const libc::c_char;
    if constant <= SKINCOLOR_NONE as libc::c_int || constant >= numskincolors as int32_t
    {
        return;
    }
    if constant >= SKINCOLOR_FIRSTFREESLOT as libc::c_int {
        color_name = FREE_SKINCOLORS[(constant - SKINCOLOR_FIRSTFREESLOT as libc::c_int)
            as usize];
    } else {
        color_name = *COLOR_ENUMS.as_mut_ptr().offset(constant as isize);
    }
    P_WriteDuplicateText(
        va(b"SKINCOLOR_%s\0" as *const u8 as *const libc::c_char, color_name),
        target,
    );
}
unsafe extern "C" fn P_WriteSfx(
    mut constant: int32_t,
    mut target: *mut *mut libc::c_char,
) {
    if constant <= sfx_None as libc::c_int || constant >= sfxfree as int32_t {
        return;
    }
    P_WriteDuplicateText(
        va(
            b"SFX_%s\0" as *const u8 as *const libc::c_char,
            (*S_sfx.as_mut_ptr().offset(constant as isize)).name,
        ),
        target,
    );
}
unsafe extern "C" fn P_WriteTics(mut tics: int32_t, mut target: *mut *mut libc::c_char) {
    if tics == 0 {
        return;
    }
    let mut seconds: int32_t = tics / 35 as libc::c_int;
    tics %= 35 as libc::c_int;
    let mut text: *const libc::c_char = 0 as *const libc::c_char;
    if tics != 0 && seconds == 0 {
        text = va(b"%d\0" as *const u8 as *const libc::c_char, tics);
    } else if seconds != 0 && tics == 0 {
        text = va(b"(%d*TICRATE)\0" as *const u8 as *const libc::c_char, seconds);
    } else {
        text = va(
            b"(%d*TICRATE)%s%d\0" as *const u8 as *const libc::c_char,
            seconds,
            if tics > 0 as libc::c_int {
                b"+\0" as *const u8 as *const libc::c_char
            } else {
                b"\0" as *const u8 as *const libc::c_char
            },
            tics,
        );
    }
    P_WriteDuplicateText(text, target);
}
unsafe extern "C" fn P_LoadSidedefs(mut data: *mut uint8_t) {
    let mut msd: *mut mapsidedef_t = data as *mut mapsidedef_t;
    let mut sd: *mut side_t = sides;
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numsides {
        let mut textureoffset: int16_t = (*msd).textureoffset;
        let mut isfrontside: boolean = 0;
        P_InitializeSidedef(sd);
        isfrontside = ((*(*sd).line).sidenum[0 as libc::c_int as usize] as size_t == i)
            as libc::c_int;
        if (*(*sd).line).flags as libc::c_int & (4 as libc::c_int | 1024 as libc::c_int)
            == 4 as libc::c_int | 1024 as libc::c_int
            && !((*sd).special as libc::c_int >= 300 as libc::c_int
                && ((*sd).special as libc::c_int) < 500 as libc::c_int)
        {
            (*sd)
                .repeatcnt = (textureoffset as uint16_t as libc::c_int
                >> 12 as libc::c_int) as int16_t;
            (*sd)
                .textureoffset = (textureoffset as uint16_t as libc::c_int
                & 2047 as libc::c_int) << 16 as libc::c_int;
        } else {
            (*sd).repeatcnt = 0 as libc::c_int as int16_t;
            (*sd).textureoffset = (textureoffset as libc::c_int) << 16 as libc::c_int;
        }
        (*sd).rowoffset = ((*msd).rowoffset as libc::c_int) << 16 as libc::c_int;
        (*sd).offsetx_bot = 0 as libc::c_int;
        (*sd).offsetx_mid = (*sd).offsetx_bot;
        (*sd).offsetx_top = (*sd).offsetx_mid;
        (*sd).offsety_bot = 0 as libc::c_int;
        (*sd).offsety_mid = (*sd).offsety_bot;
        (*sd).offsety_top = (*sd).offsety_mid;
        P_SetSidedefSector(i, (*msd).sector as uint16_t);
        let mut current_block_65: u64;
        match (*sd).special as libc::c_int {
            447 => {
                current_block_65 = 10296307166806092025;
            }
            606 | 455 => {
                current_block_65 = 10296307166806092025;
            }
            413 => {
                (*sd).bottomtexture = 0 as libc::c_int;
                (*sd).midtexture = (*sd).bottomtexture;
                (*sd).toptexture = (*sd).midtexture;
                if isfrontside == 0 {
                    current_block_65 = 5028470053297453708;
                } else {
                    let mut process: [libc::c_char; 9] = [0; 9];
                    if (*msd).bottomtexture[0 as libc::c_int as usize] as libc::c_int
                        != '-' as i32
                        || (*msd).bottomtexture[1 as libc::c_int as usize] as libc::c_int
                            != '\0' as i32
                    {
                        M_Memcpy
                            .expect(
                                "non-null function pointer",
                            )(
                            process.as_mut_ptr() as *mut libc::c_void,
                            ((*msd).bottomtexture).as_mut_ptr() as *const libc::c_void,
                            8 as libc::c_int as size_t,
                        );
                        process[8 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
                        (*sd).bottomtexture = get_number(process.as_mut_ptr());
                    }
                    if !((*msd).midtexture[0 as libc::c_int as usize] as libc::c_int
                        == '-' as i32
                        && (*msd).midtexture[1 as libc::c_int as usize] as libc::c_int
                            == '\0' as i32)
                        || (*msd).midtexture[1 as libc::c_int as usize] as libc::c_int
                            != '\0' as i32
                    {
                        M_Memcpy
                            .expect(
                                "non-null function pointer",
                            )(
                            process.as_mut_ptr() as *mut libc::c_void,
                            ((*msd).midtexture).as_mut_ptr() as *const libc::c_void,
                            8 as libc::c_int as size_t,
                        );
                        process[8 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
                        (*sd).midtexture = get_number(process.as_mut_ptr());
                    }
                    if (*msd).toptexture[0 as libc::c_int as usize] as libc::c_int
                        != '-' as i32
                        && (*msd).toptexture[1 as libc::c_int as usize] as libc::c_int
                            != '\0' as i32
                    {
                        (*(*sd).line)
                            .stringargs[0 as libc::c_int
                            as usize] = Z_MallocAlign(
                            7 as libc::c_int as size_t,
                            PU_LEVEL as libc::c_int,
                            0 as *mut libc::c_void,
                            ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong
                                as int32_t,
                        ) as *mut libc::c_char;
                        M_Memcpy
                            .expect(
                                "non-null function pointer",
                            )(
                            process.as_mut_ptr() as *mut libc::c_void,
                            ((*msd).toptexture).as_mut_ptr() as *const libc::c_void,
                            8 as libc::c_int as size_t,
                        );
                        process[8 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
                        if (process[0 as libc::c_int as usize] as libc::c_int
                            == 'O' as i32
                            || process[0 as libc::c_int as usize] as libc::c_int
                                == 'D' as i32)
                            && process[7 as libc::c_int as usize] as libc::c_int != 0
                        {
                            M_Memcpy
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*(*sd).line).stringargs[0 as libc::c_int as usize]
                                    as *mut libc::c_void,
                                process.as_mut_ptr().offset(2 as libc::c_int as isize)
                                    as *const libc::c_void,
                                6 as libc::c_int as size_t,
                            );
                        } else {
                            M_Memcpy
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*(*sd).line).stringargs[0 as libc::c_int as usize]
                                    as *mut libc::c_void,
                                process.as_mut_ptr() as *const libc::c_void,
                                6 as libc::c_int as size_t,
                            );
                        }
                        *((*(*sd).line).stringargs[0 as libc::c_int as usize])
                            .offset(
                                6 as libc::c_int as isize,
                            ) = '\0' as i32 as libc::c_char;
                    }
                    current_block_65 = 5028470053297453708;
                }
            }
            4 => {
                current_block_65 = 1538046216550696469;
            }
            414 => {
                current_block_65 = 1538046216550696469;
            }
            9 => {
                current_block_65 = 17874336442984296732;
            }
            14 => {
                current_block_65 = 17874336442984296732;
            }
            15 => {
                current_block_65 = 9007357115414505193;
            }
            331 => {
                current_block_65 = 13528092925535381439;
            }
            332 => {
                current_block_65 = 2360797296277494495;
            }
            333 => {
                current_block_65 = 1368983992090660734;
            }
            334 => {
                current_block_65 = 3055222360059121983;
            }
            335 => {
                current_block_65 = 17304536711106025969;
            }
            336 => {
                current_block_65 = 11637537669464858461;
            }
            425 => {
                current_block_65 = 7315890131247491006;
            }
            434 => {
                current_block_65 = 16546538242513169243;
            }
            442 => {
                current_block_65 = 8516594647644293614;
            }
            443 => {
                current_block_65 = 4655732821400318247;
            }
            459 => {
                current_block_65 = 13872732562189904297;
            }
            461 => {
                current_block_65 = 12729124780691699072;
            }
            463 => {
                current_block_65 = 10758786907990354186;
            }
            259 => {
                if isfrontside == 0 {
                    if (*msd).toptexture[0 as libc::c_int as usize] as libc::c_int
                        >= '0' as i32
                        && (*msd).toptexture[0 as libc::c_int as usize] as libc::c_int
                            <= '9' as i32
                        || (*msd).toptexture[0 as libc::c_int as usize] as libc::c_int
                            >= 'A' as i32
                            && (*msd).toptexture[0 as libc::c_int as usize]
                                as libc::c_int <= 'F' as i32
                    {
                        (*sd).toptexture = axtoi(((*msd).toptexture).as_mut_ptr());
                    } else {
                        I_Error(
                            b"Custom FOF (line id %s) needs a value in the linedef's back side upper texture field.\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(
                                ((*sd).line).offset_from(lines) as libc::c_long as size_t,
                            ),
                        );
                    }
                    (*sd)
                        .midtexture = R_TextureNumForName(
                        ((*msd).midtexture).as_mut_ptr(),
                    );
                    (*sd)
                        .bottomtexture = R_TextureNumForName(
                        ((*msd).bottomtexture).as_mut_ptr(),
                    );
                    current_block_65 = 5028470053297453708;
                } else {
                    current_block_65 = 7671424434072908072;
                }
            }
            _ => {
                current_block_65 = 7671424434072908072;
            }
        }
        match current_block_65 {
            1538046216550696469 => {
                (*sd).bottomtexture = 0 as libc::c_int;
                (*sd).midtexture = (*sd).bottomtexture;
                (*sd).toptexture = (*sd).midtexture;
                if isfrontside == 0 {
                    current_block_65 = 5028470053297453708;
                } else {
                    if (*msd).toptexture[0 as libc::c_int as usize] as libc::c_int
                        != '-' as i32
                        || (*msd).toptexture[1 as libc::c_int as usize] as libc::c_int
                            != '\0' as i32
                    {
                        let mut process_0: [libc::c_char; 9] = [0; 9];
                        M_Memcpy
                            .expect(
                                "non-null function pointer",
                            )(
                            process_0.as_mut_ptr() as *mut libc::c_void,
                            ((*msd).toptexture).as_mut_ptr() as *const libc::c_void,
                            8 as libc::c_int as size_t,
                        );
                        process_0[8 as libc::c_int
                            as usize] = '\0' as i32 as libc::c_char;
                        P_WriteDuplicateText(
                            process_0.as_mut_ptr(),
                            &mut *((*(*sd).line).stringargs)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize),
                        );
                    }
                    current_block_65 = 5028470053297453708;
                }
            }
            10296307166806092025 => {
                (*sd)
                    .colormap_data = R_CreateColormapFromLinedef(
                    ((*msd).toptexture).as_mut_ptr(),
                    ((*msd).midtexture).as_mut_ptr(),
                    ((*msd).bottomtexture).as_mut_ptr(),
                );
                (*sd).bottomtexture = 0 as libc::c_int;
                (*sd).midtexture = (*sd).bottomtexture;
                (*sd).toptexture = (*sd).midtexture;
                current_block_65 = 5028470053297453708;
            }
            17874336442984296732 => {
                current_block_65 = 9007357115414505193;
            }
            7671424434072908072 => {
                if (*msd).toptexture[0 as libc::c_int as usize] as libc::c_int
                    == '#' as i32
                {
                    let mut col: *mut libc::c_char = ((*msd).toptexture).as_mut_ptr();
                    (*sd)
                        .toptexture = (*col.offset(1 as libc::c_int as isize)
                        as libc::c_int - '0' as i32) * 100 as libc::c_int
                        + (*col.offset(2 as libc::c_int as isize) as libc::c_int
                            - '0' as i32) * 10 as libc::c_int
                        + *col.offset(3 as libc::c_int as isize) as libc::c_int
                        - '0' as i32 + 1 as libc::c_int;
                    if *col.offset(4 as libc::c_int as isize) != 0 {
                        (*sd).toptexture
                            += (*col.offset(4 as libc::c_int as isize) as libc::c_int
                                - '0' as i32) * 1000 as libc::c_int;
                    }
                    (*sd).bottomtexture = (*sd).toptexture;
                    (*sd)
                        .midtexture = R_TextureNumForName(
                        ((*msd).midtexture).as_mut_ptr(),
                    );
                } else {
                    (*sd)
                        .midtexture = R_TextureNumForName(
                        ((*msd).midtexture).as_mut_ptr(),
                    );
                    (*sd)
                        .toptexture = R_TextureNumForName(
                        ((*msd).toptexture).as_mut_ptr(),
                    );
                    (*sd)
                        .bottomtexture = R_TextureNumForName(
                        ((*msd).bottomtexture).as_mut_ptr(),
                    );
                }
                current_block_65 = 5028470053297453708;
            }
            _ => {}
        }
        match current_block_65 {
            9007357115414505193 => {
                if (*msd).toptexture[7 as libc::c_int as usize] as libc::c_int
                    == '\0' as i32
                    && strcasecmp(
                        ((*msd).toptexture).as_mut_ptr(),
                        b"MT_NULL\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                {
                    current_block_65 = 5028470053297453708;
                } else {
                    current_block_65 = 13528092925535381439;
                }
            }
            _ => {}
        }
        match current_block_65 {
            13528092925535381439 => {
                current_block_65 = 2360797296277494495;
            }
            _ => {}
        }
        match current_block_65 {
            2360797296277494495 => {
                current_block_65 = 1368983992090660734;
            }
            _ => {}
        }
        match current_block_65 {
            1368983992090660734 => {
                current_block_65 = 3055222360059121983;
            }
            _ => {}
        }
        match current_block_65 {
            3055222360059121983 => {
                current_block_65 = 17304536711106025969;
            }
            _ => {}
        }
        match current_block_65 {
            17304536711106025969 => {
                current_block_65 = 11637537669464858461;
            }
            _ => {}
        }
        match current_block_65 {
            11637537669464858461 => {
                current_block_65 = 7315890131247491006;
            }
            _ => {}
        }
        match current_block_65 {
            7315890131247491006 => {
                current_block_65 = 16546538242513169243;
            }
            _ => {}
        }
        match current_block_65 {
            16546538242513169243 => {
                current_block_65 = 8516594647644293614;
            }
            _ => {}
        }
        match current_block_65 {
            8516594647644293614 => {
                current_block_65 = 4655732821400318247;
            }
            _ => {}
        }
        match current_block_65 {
            4655732821400318247 => {
                current_block_65 = 13872732562189904297;
            }
            _ => {}
        }
        match current_block_65 {
            13872732562189904297 => {
                current_block_65 = 12729124780691699072;
            }
            _ => {}
        }
        match current_block_65 {
            12729124780691699072 => {
                current_block_65 = 10758786907990354186;
            }
            _ => {}
        }
        match current_block_65 {
            10758786907990354186 => {
                let mut process_1: [libc::c_char; 25] = [0; 25];
                memset(
                    process_1.as_mut_ptr() as *mut libc::c_void,
                    0 as libc::c_int,
                    (8 as libc::c_int * 3 as libc::c_int + 1 as libc::c_int)
                        as libc::c_ulong,
                );
                (*sd).bottomtexture = 0 as libc::c_int;
                (*sd).midtexture = (*sd).bottomtexture;
                (*sd).toptexture = (*sd).midtexture;
                if !((*msd).toptexture[0 as libc::c_int as usize] as libc::c_int
                    == '-' as i32
                    && (*msd).toptexture[1 as libc::c_int as usize] as libc::c_int
                        == '\0' as i32)
                {
                    M_Memcpy
                        .expect(
                            "non-null function pointer",
                        )(
                        process_1.as_mut_ptr() as *mut libc::c_void,
                        ((*msd).toptexture).as_mut_ptr() as *const libc::c_void,
                        8 as libc::c_int as size_t,
                    );
                    if (*msd).midtexture[0 as libc::c_int as usize] as libc::c_int
                        != '-' as i32
                        || (*msd).midtexture[1 as libc::c_int as usize] as libc::c_int
                            != '\0' as i32
                    {
                        M_Memcpy
                            .expect(
                                "non-null function pointer",
                            )(
                            process_1
                                .as_mut_ptr()
                                .offset(strlen(process_1.as_mut_ptr()) as isize)
                                as *mut libc::c_void,
                            ((*msd).midtexture).as_mut_ptr() as *const libc::c_void,
                            8 as libc::c_int as size_t,
                        );
                    }
                    if (*msd).bottomtexture[0 as libc::c_int as usize] as libc::c_int
                        != '-' as i32
                        || (*msd).bottomtexture[1 as libc::c_int as usize] as libc::c_int
                            != '\0' as i32
                    {
                        M_Memcpy
                            .expect(
                                "non-null function pointer",
                            )(
                            process_1
                                .as_mut_ptr()
                                .offset(strlen(process_1.as_mut_ptr()) as isize)
                                as *mut libc::c_void,
                            ((*msd).bottomtexture).as_mut_ptr() as *const libc::c_void,
                            8 as libc::c_int as size_t,
                        );
                    }
                    P_WriteDuplicateText(
                        process_1.as_mut_ptr(),
                        &mut *((*(*sd).line).stringargs)
                            .as_mut_ptr()
                            .offset(
                                (if isfrontside != 0 {
                                    0 as libc::c_int
                                } else {
                                    1 as libc::c_int
                                }) as isize,
                            ),
                    );
                }
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        i;
        sd = sd.offset(1);
        sd;
        msd = msd.offset(1);
        msd;
    }
}
unsafe extern "C" fn P_LoadThings(mut data: *mut uint8_t) {
    let mut mt: *mut mapthing_t = 0 as *mut mapthing_t;
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    mt = mapthings;
    while i < nummapthings {
        (*mt)
            .x = ({
            let mut p_tmp: *mut int16_t = data as *mut libc::c_void as *mut int16_t;
            let mut b: int16_t = 0;
            memcpy(
                &mut b as *mut int16_t as *mut libc::c_void,
                data as *const libc::c_void,
                ::core::mem::size_of::<int16_t>() as libc::c_ulong,
            );
            p_tmp = p_tmp.offset(1);
            p_tmp;
            data = p_tmp as *mut libc::c_void as *mut uint8_t;
            b
        });
        (*mt)
            .y = ({
            let mut p_tmp: *mut int16_t = data as *mut libc::c_void as *mut int16_t;
            let mut b: int16_t = 0;
            memcpy(
                &mut b as *mut int16_t as *mut libc::c_void,
                data as *const libc::c_void,
                ::core::mem::size_of::<int16_t>() as libc::c_ulong,
            );
            p_tmp = p_tmp.offset(1);
            p_tmp;
            data = p_tmp as *mut libc::c_void as *mut uint8_t;
            b
        });
        (*mt)
            .angle = ({
            let mut p_tmp: *mut int16_t = data as *mut libc::c_void as *mut int16_t;
            let mut b: int16_t = 0;
            memcpy(
                &mut b as *mut int16_t as *mut libc::c_void,
                data as *const libc::c_void,
                ::core::mem::size_of::<int16_t>() as libc::c_ulong,
            );
            p_tmp = p_tmp.offset(1);
            p_tmp;
            data = p_tmp as *mut libc::c_void as *mut uint8_t;
            b
        });
        (*mt)
            .type_0 = ({
            let mut p_tmp: *mut uint16_t = data as *mut libc::c_void as *mut uint16_t;
            let mut b: uint16_t = 0;
            memcpy(
                &mut b as *mut uint16_t as *mut libc::c_void,
                data as *const libc::c_void,
                ::core::mem::size_of::<uint16_t>() as libc::c_ulong,
            );
            p_tmp = p_tmp.offset(1);
            p_tmp;
            data = p_tmp as *mut libc::c_void as *mut uint8_t;
            b
        });
        (*mt)
            .options = ({
            let mut p_tmp: *mut uint16_t = data as *mut libc::c_void as *mut uint16_t;
            let mut b: uint16_t = 0;
            memcpy(
                &mut b as *mut uint16_t as *mut libc::c_void,
                data as *const libc::c_void,
                ::core::mem::size_of::<uint16_t>() as libc::c_ulong,
            );
            p_tmp = p_tmp.offset(1);
            p_tmp;
            data = p_tmp as *mut libc::c_void as *mut uint8_t;
            b
        });
        (*mt).extrainfo = ((*mt).type_0 as libc::c_int >> 12 as libc::c_int) as uint8_t;
        Tag_FSet(&mut (*mt).tags, 0 as libc::c_int as mtag_t);
        (*mt).scale = (1 as libc::c_int) << 16 as libc::c_int;
        (*mt).spriteyscale = (1 as libc::c_int) << 16 as libc::c_int;
        (*mt).spritexscale = (*mt).spriteyscale;
        memset(
            ((*mt).args).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            (10 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<int32_t>() as libc::c_ulong),
        );
        memset(
            ((*mt).stringargs).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            (2 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ),
        );
        (*mt).roll = 0 as libc::c_int as int16_t;
        (*mt).pitch = (*mt).roll;
        (*mt).type_0 = ((*mt).type_0 as libc::c_int & 4095 as libc::c_int) as uint16_t;
        if (*mt).type_0 as libc::c_int == 1705 as libc::c_int
            || (*mt).type_0 as libc::c_int == 750 as libc::c_int
                && (*mt).extrainfo as libc::c_int != 0
        {
            (*mt).z = (*mt).options as int16_t;
        } else {
            (*mt).z = ((*mt).options as libc::c_int >> 4 as libc::c_int) as int16_t;
        }
        (*mt).mobj = 0 as *mut mobj_s;
        i = i.wrapping_add(1);
        i;
        mt = mt.offset(1);
        mt;
    }
}
#[no_mangle]
pub static mut mapthingsPos: [uint32_t; 65535] = [0; 65535];
#[no_mangle]
pub static mut linesPos: [uint32_t; 65535] = [0; 65535];
#[no_mangle]
pub static mut sidesPos: [uint32_t; 65535] = [0; 65535];
#[no_mangle]
pub static mut vertexesPos: [uint32_t; 65535] = [0; 65535];
#[no_mangle]
pub static mut sectorsPos: [uint32_t; 65535] = [0; 65535];
unsafe extern "C" fn TextmapCount(mut size: size_t) -> boolean {
    let mut tkn: *const libc::c_char = M_TokenizerRead(0 as libc::c_int as uint32_t);
    let mut brackets: uint8_t = 0 as libc::c_int as uint8_t;
    nummapthings = 0 as libc::c_int as size_t;
    numlines = 0 as libc::c_int as size_t;
    numsides = 0 as libc::c_int as size_t;
    numvertexes = 0 as libc::c_int as size_t;
    numsectors = 0 as libc::c_int as size_t;
    if fastcmp(tkn, b"namespace\0" as *const u8 as *const libc::c_char) == 0 {
        CONS_Alert(
            CONS_ERROR,
            b"No namespace at beginning of lump!\n\0" as *const u8 as *const libc::c_char,
        );
        return false_0 as libc::c_int;
    }
    tkn = M_TokenizerRead(0 as libc::c_int as uint32_t);
    if fastcmp(tkn, b"srb2\0" as *const u8 as *const libc::c_char) == 0 {
        CONS_Alert(
            CONS_WARNING,
            b"Invalid namespace '%s', only 'srb2' is supported.\n\0" as *const u8
                as *const libc::c_char,
            tkn,
        );
    }
    loop {
        tkn = M_TokenizerRead(0 as libc::c_int as uint32_t);
        if !(!tkn.is_null() && (M_TokenizerGetEndPos() as size_t) < size) {
            break;
        }
        if brackets != 0 {
            if fastcmp(tkn, b"}\0" as *const u8 as *const libc::c_char) != 0 {
                brackets = brackets.wrapping_sub(1);
                brackets;
            }
        } else if fastcmp(tkn, b"{\0" as *const u8 as *const libc::c_char) != 0 {
            brackets = brackets.wrapping_add(1);
            brackets;
        } else if fastcmp(tkn, b"thing\0" as *const u8 as *const libc::c_char) != 0 {
            let fresh8 = nummapthings;
            nummapthings = nummapthings.wrapping_add(1);
            mapthingsPos[fresh8 as usize] = M_TokenizerGetEndPos();
        } else if fastcmp(tkn, b"linedef\0" as *const u8 as *const libc::c_char) != 0 {
            let fresh9 = numlines;
            numlines = numlines.wrapping_add(1);
            linesPos[fresh9 as usize] = M_TokenizerGetEndPos();
        } else if fastcmp(tkn, b"sidedef\0" as *const u8 as *const libc::c_char) != 0 {
            let fresh10 = numsides;
            numsides = numsides.wrapping_add(1);
            sidesPos[fresh10 as usize] = M_TokenizerGetEndPos();
        } else if fastcmp(tkn, b"vertex\0" as *const u8 as *const libc::c_char) != 0 {
            let fresh11 = numvertexes;
            numvertexes = numvertexes.wrapping_add(1);
            vertexesPos[fresh11 as usize] = M_TokenizerGetEndPos();
        } else if fastcmp(tkn, b"sector\0" as *const u8 as *const libc::c_char) != 0 {
            let fresh12 = numsectors;
            numsectors = numsectors.wrapping_add(1);
            sectorsPos[fresh12 as usize] = M_TokenizerGetEndPos();
        } else {
            CONS_Alert(
                CONS_NOTICE,
                b"Unknown field '%s'.\n\0" as *const u8 as *const libc::c_char,
                tkn,
            );
        }
    }
    if brackets != 0 {
        CONS_Alert(
            CONS_ERROR,
            b"Unclosed brackets detected in textmap lump.\n\0" as *const u8
                as *const libc::c_char,
        );
        return false_0 as libc::c_int;
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn ParseTextmapVertexParameter(
    mut i: uint32_t,
    mut param: *const libc::c_char,
    mut val: *const libc::c_char,
) {
    if fastcmp(param, b"x\0" as *const u8 as *const libc::c_char) != 0 {
        (*vertexes.offset(i as isize)).x = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"y\0" as *const u8 as *const libc::c_char) != 0 {
        (*vertexes.offset(i as isize)).y = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"zfloor\0" as *const u8 as *const libc::c_char) != 0 {
        (*vertexes.offset(i as isize)).floorz = FloatToFixed(atof(val) as libc::c_float);
        (*vertexes.offset(i as isize)).floorzset = true_0 as libc::c_int;
    } else if fastcmp(param, b"zceiling\0" as *const u8 as *const libc::c_char) != 0 {
        (*vertexes.offset(i as isize))
            .ceilingz = FloatToFixed(atof(val) as libc::c_float);
        (*vertexes.offset(i as isize)).ceilingzset = true_0 as libc::c_int;
    }
}
#[no_mangle]
pub static mut textmap_colormap: textmap_colormap_t = {
    let mut init = textmap_colormap_s {
        used: false_0 as libc::c_int,
        lightcolor: 0 as libc::c_int,
        lightalpha: 25 as libc::c_int as uint8_t,
        fadecolor: 0 as libc::c_int,
        fadealpha: 25 as libc::c_int as uint8_t,
        fadestart: 0 as libc::c_int as uint8_t,
        fadeend: 31 as libc::c_int as uint8_t,
        flags: 0 as libc::c_int as uint8_t,
    };
    init
};
#[no_mangle]
pub static mut textmap_planefloor: textmap_plane_t = {
    let mut init = textmap_plane_s {
        defined: 0 as libc::c_int as uint8_t,
        a: 0 as libc::c_int,
        b: 0 as libc::c_int,
        c: 0 as libc::c_int,
        d: 0 as libc::c_int,
    };
    init
};
#[no_mangle]
pub static mut textmap_planeceiling: textmap_plane_t = {
    let mut init = textmap_plane_s {
        defined: 0 as libc::c_int as uint8_t,
        a: 0 as libc::c_int,
        b: 0 as libc::c_int,
        c: 0 as libc::c_int,
        d: 0 as libc::c_int,
    };
    init
};
unsafe extern "C" fn ParseTextmapSectorParameter(
    mut i: uint32_t,
    mut param: *const libc::c_char,
    mut val: *const libc::c_char,
) {
    if fastcmp(param, b"heightfloor\0" as *const u8 as *const libc::c_char) != 0 {
        (*sectors.offset(i as isize))
            .floorheight = (atol(val) << 16 as libc::c_int) as fixed_t;
    } else if fastcmp(param, b"heightceiling\0" as *const u8 as *const libc::c_char) != 0
    {
        (*sectors.offset(i as isize))
            .ceilingheight = (atol(val) << 16 as libc::c_int) as fixed_t;
    }
    if fastcmp(param, b"texturefloor\0" as *const u8 as *const libc::c_char) != 0 {
        (*sectors.offset(i as isize)).floorpic = P_AddLevelFlat(val, foundflats);
    } else if fastcmp(param, b"textureceiling\0" as *const u8 as *const libc::c_char)
        != 0
    {
        (*sectors.offset(i as isize)).ceilingpic = P_AddLevelFlat(val, foundflats);
    } else if fastcmp(param, b"lightlevel\0" as *const u8 as *const libc::c_char) != 0 {
        (*sectors.offset(i as isize)).lightlevel = atol(val) as int16_t;
    } else if fastcmp(param, b"lightfloor\0" as *const u8 as *const libc::c_char) != 0 {
        (*sectors.offset(i as isize)).floorlightlevel = atol(val) as int16_t;
    } else if fastcmp(param, b"lightfloorabsolute\0" as *const u8 as *const libc::c_char)
        != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        (*sectors.offset(i as isize)).floorlightabsolute = true_0 as libc::c_int;
    } else if fastcmp(param, b"lightceiling\0" as *const u8 as *const libc::c_char) != 0
    {
        (*sectors.offset(i as isize)).ceilinglightlevel = atol(val) as int16_t;
    } else if fastcmp(
        param,
        b"lightceilingabsolute\0" as *const u8 as *const libc::c_char,
    ) != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        (*sectors.offset(i as isize)).ceilinglightabsolute = true_0 as libc::c_int;
    } else if fastcmp(param, b"id\0" as *const u8 as *const libc::c_char) != 0 {
        Tag_FSet(&mut (*sectors.offset(i as isize)).tags, atol(val) as mtag_t);
    } else if fastcmp(param, b"moreids\0" as *const u8 as *const libc::c_char) != 0 {
        let mut id: *const libc::c_char = val;
        while !id.is_null() {
            Tag_Add(&mut (*sectors.offset(i as isize)).tags, atol(id) as mtag_t);
            id = strchr(id, ' ' as i32);
            if !id.is_null() {
                id = id.offset(1);
                id;
            }
        }
    } else if fastcmp(param, b"xpanningfloor\0" as *const u8 as *const libc::c_char) != 0
    {
        (*sectors.offset(i as isize))
            .floorxoffset = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"ypanningfloor\0" as *const u8 as *const libc::c_char) != 0
    {
        (*sectors.offset(i as isize))
            .flooryoffset = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"xpanningceiling\0" as *const u8 as *const libc::c_char)
        != 0
    {
        (*sectors.offset(i as isize))
            .ceilingxoffset = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"ypanningceiling\0" as *const u8 as *const libc::c_char)
        != 0
    {
        (*sectors.offset(i as isize))
            .ceilingyoffset = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"rotationfloor\0" as *const u8 as *const libc::c_char) != 0
    {
        (*sectors.offset(i as isize))
            .floorangle = FixedAngle(FloatToFixed(atof(val) as libc::c_float));
    } else if fastcmp(param, b"rotationceiling\0" as *const u8 as *const libc::c_char)
        != 0
    {
        (*sectors.offset(i as isize))
            .ceilingangle = FixedAngle(FloatToFixed(atof(val) as libc::c_float));
    } else if fastcmp(param, b"floorplane_a\0" as *const u8 as *const libc::c_char) != 0
    {
        textmap_planefloor
            .defined = (textmap_planefloor.defined as libc::c_int | PD_A as libc::c_int)
            as uint8_t;
        textmap_planefloor.a = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"floorplane_b\0" as *const u8 as *const libc::c_char) != 0
    {
        textmap_planefloor
            .defined = (textmap_planefloor.defined as libc::c_int | PD_B as libc::c_int)
            as uint8_t;
        textmap_planefloor.b = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"floorplane_c\0" as *const u8 as *const libc::c_char) != 0
    {
        textmap_planefloor
            .defined = (textmap_planefloor.defined as libc::c_int | PD_C as libc::c_int)
            as uint8_t;
        textmap_planefloor.c = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"floorplane_d\0" as *const u8 as *const libc::c_char) != 0
    {
        textmap_planefloor
            .defined = (textmap_planefloor.defined as libc::c_int | PD_D as libc::c_int)
            as uint8_t;
        textmap_planefloor.d = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"ceilingplane_a\0" as *const u8 as *const libc::c_char)
        != 0
    {
        textmap_planeceiling
            .defined = (textmap_planeceiling.defined as libc::c_int
            | PD_A as libc::c_int) as uint8_t;
        textmap_planeceiling.a = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"ceilingplane_b\0" as *const u8 as *const libc::c_char)
        != 0
    {
        textmap_planeceiling
            .defined = (textmap_planeceiling.defined as libc::c_int
            | PD_B as libc::c_int) as uint8_t;
        textmap_planeceiling.b = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"ceilingplane_c\0" as *const u8 as *const libc::c_char)
        != 0
    {
        textmap_planeceiling
            .defined = (textmap_planeceiling.defined as libc::c_int
            | PD_C as libc::c_int) as uint8_t;
        textmap_planeceiling.c = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"ceilingplane_d\0" as *const u8 as *const libc::c_char)
        != 0
    {
        textmap_planeceiling
            .defined = (textmap_planeceiling.defined as libc::c_int
            | PD_D as libc::c_int) as uint8_t;
        textmap_planeceiling.d = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"lightcolor\0" as *const u8 as *const libc::c_char) != 0 {
        textmap_colormap.used = true_0 as libc::c_int;
        textmap_colormap.lightcolor = atol(val) as int32_t;
    } else if fastcmp(param, b"lightalpha\0" as *const u8 as *const libc::c_char) != 0 {
        textmap_colormap.used = true_0 as libc::c_int;
        textmap_colormap.lightalpha = atol(val) as uint8_t;
    } else if fastcmp(param, b"fadecolor\0" as *const u8 as *const libc::c_char) != 0 {
        textmap_colormap.used = true_0 as libc::c_int;
        textmap_colormap.fadecolor = atol(val) as int32_t;
    } else if fastcmp(param, b"fadealpha\0" as *const u8 as *const libc::c_char) != 0 {
        textmap_colormap.used = true_0 as libc::c_int;
        textmap_colormap.fadealpha = atol(val) as uint8_t;
    } else if fastcmp(param, b"fadestart\0" as *const u8 as *const libc::c_char) != 0 {
        textmap_colormap.used = true_0 as libc::c_int;
        textmap_colormap.fadestart = atol(val) as uint8_t;
    } else if fastcmp(param, b"fadeend\0" as *const u8 as *const libc::c_char) != 0 {
        textmap_colormap.used = true_0 as libc::c_int;
        textmap_colormap.fadeend = atol(val) as uint8_t;
    } else if fastcmp(param, b"colormapfog\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        textmap_colormap.used = true_0 as libc::c_int;
        textmap_colormap
            .flags = (textmap_colormap.flags as libc::c_int | 4 as libc::c_int)
            as uint8_t;
    } else if fastcmp(
        param,
        b"colormapfadesprites\0" as *const u8 as *const libc::c_char,
    ) != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        textmap_colormap.used = true_0 as libc::c_int;
        textmap_colormap
            .flags = (textmap_colormap.flags as libc::c_int | 1 as libc::c_int)
            as uint8_t;
    } else if fastcmp(param, b"colormapprotected\0" as *const u8 as *const libc::c_char)
        != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        (*sectors.offset(i as isize)).colormap_protected = true_0 as libc::c_int;
    } else if fastcmp(
        param,
        b"flipspecial_nofloor\0" as *const u8 as *const libc::c_char,
    ) != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh13 = (*sectors.offset(i as isize)).flags;
        *fresh13 = ::core::mem::transmute::<
            libc::c_uint,
            sectorflags_t,
        >(
            *fresh13 as libc::c_uint
                & !(MSF_FLIPSPECIAL_FLOOR as libc::c_int) as libc::c_uint,
        );
    } else if fastcmp(
        param,
        b"flipspecial_ceiling\0" as *const u8 as *const libc::c_char,
    ) != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh14 = (*sectors.offset(i as isize)).flags;
        *fresh14 = ::core::mem::transmute::<
            libc::c_uint,
            sectorflags_t,
        >(
            *fresh14 as libc::c_uint
                | MSF_FLIPSPECIAL_CEILING as libc::c_int as libc::c_uint,
        );
    } else if fastcmp(
        param,
        b"triggerspecial_touch\0" as *const u8 as *const libc::c_char,
    ) != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh15 = (*sectors.offset(i as isize)).flags;
        *fresh15 = ::core::mem::transmute::<
            libc::c_uint,
            sectorflags_t,
        >(
            *fresh15 as libc::c_uint
                | MSF_TRIGGERSPECIAL_TOUCH as libc::c_int as libc::c_uint,
        );
    } else if fastcmp(
        param,
        b"triggerspecial_headbump\0" as *const u8 as *const libc::c_char,
    ) != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh16 = (*sectors.offset(i as isize)).flags;
        *fresh16 = ::core::mem::transmute::<
            libc::c_uint,
            sectorflags_t,
        >(
            *fresh16 as libc::c_uint
                | MSF_TRIGGERSPECIAL_HEADBUMP as libc::c_int as libc::c_uint,
        );
    } else if fastcmp(param, b"triggerline_plane\0" as *const u8 as *const libc::c_char)
        != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh17 = (*sectors.offset(i as isize)).flags;
        *fresh17 = ::core::mem::transmute::<
            libc::c_uint,
            sectorflags_t,
        >(
            *fresh17 as libc::c_uint
                | MSF_TRIGGERLINE_PLANE as libc::c_int as libc::c_uint,
        );
    } else if fastcmp(param, b"triggerline_mobj\0" as *const u8 as *const libc::c_char)
        != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh18 = (*sectors.offset(i as isize)).flags;
        *fresh18 = ::core::mem::transmute::<
            libc::c_uint,
            sectorflags_t,
        >(
            *fresh18 as libc::c_uint
                | MSF_TRIGGERLINE_MOBJ as libc::c_int as libc::c_uint,
        );
    } else if fastcmp(param, b"invertprecip\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh19 = (*sectors.offset(i as isize)).flags;
        *fresh19 = ::core::mem::transmute::<
            libc::c_uint,
            sectorflags_t,
        >(*fresh19 as libc::c_uint | MSF_INVERTPRECIP as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"gravityflip\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh20 = (*sectors.offset(i as isize)).flags;
        *fresh20 = ::core::mem::transmute::<
            libc::c_uint,
            sectorflags_t,
        >(*fresh20 as libc::c_uint | MSF_GRAVITYFLIP as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"heatwave\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh21 = (*sectors.offset(i as isize)).flags;
        *fresh21 = ::core::mem::transmute::<
            libc::c_uint,
            sectorflags_t,
        >(*fresh21 as libc::c_uint | MSF_HEATWAVE as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"noclipcamera\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh22 = (*sectors.offset(i as isize)).flags;
        *fresh22 = ::core::mem::transmute::<
            libc::c_uint,
            sectorflags_t,
        >(*fresh22 as libc::c_uint | MSF_NOCLIPCAMERA as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"outerspace\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh23 = (*sectors.offset(i as isize)).specialflags;
        *fresh23 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh23 as libc::c_uint | SSF_OUTERSPACE as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"doublestepup\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh24 = (*sectors.offset(i as isize)).specialflags;
        *fresh24 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh24 as libc::c_uint | SSF_DOUBLESTEPUP as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"nostepdown\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh25 = (*sectors.offset(i as isize)).specialflags;
        *fresh25 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh25 as libc::c_uint | SSF_NOSTEPDOWN as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"speedpad\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh26 = (*sectors.offset(i as isize)).specialflags;
        *fresh26 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh26 as libc::c_uint | SSF_SPEEDPAD as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"starpostactivator\0" as *const u8 as *const libc::c_char)
        != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh27 = (*sectors.offset(i as isize)).specialflags;
        *fresh27 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(
            *fresh27 as libc::c_uint
                | SSF_STARPOSTACTIVATOR as libc::c_int as libc::c_uint,
        );
    } else if fastcmp(param, b"exit\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh28 = (*sectors.offset(i as isize)).specialflags;
        *fresh28 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh28 as libc::c_uint | SSF_EXIT as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"specialstagepit\0" as *const u8 as *const libc::c_char)
        != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh29 = (*sectors.offset(i as isize)).specialflags;
        *fresh29 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh29 as libc::c_uint | SSF_SPECIALSTAGEPIT as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"returnflag\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh30 = (*sectors.offset(i as isize)).specialflags;
        *fresh30 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh30 as libc::c_uint | SSF_RETURNFLAG as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"redteambase\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh31 = (*sectors.offset(i as isize)).specialflags;
        *fresh31 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh31 as libc::c_uint | SSF_REDTEAMBASE as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"blueteambase\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh32 = (*sectors.offset(i as isize)).specialflags;
        *fresh32 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh32 as libc::c_uint | SSF_BLUETEAMBASE as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"fan\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh33 = (*sectors.offset(i as isize)).specialflags;
        *fresh33 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh33 as libc::c_uint | SSF_FAN as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"supertransform\0" as *const u8 as *const libc::c_char)
        != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh34 = (*sectors.offset(i as isize)).specialflags;
        *fresh34 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh34 as libc::c_uint | SSF_SUPERTRANSFORM as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"forcespin\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh35 = (*sectors.offset(i as isize)).specialflags;
        *fresh35 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh35 as libc::c_uint | SSF_FORCESPIN as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"zoomtubestart\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh36 = (*sectors.offset(i as isize)).specialflags;
        *fresh36 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh36 as libc::c_uint | SSF_ZOOMTUBESTART as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"zoomtubeend\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh37 = (*sectors.offset(i as isize)).specialflags;
        *fresh37 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh37 as libc::c_uint | SSF_ZOOMTUBEEND as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"finishline\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh38 = (*sectors.offset(i as isize)).specialflags;
        *fresh38 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh38 as libc::c_uint | SSF_FINISHLINE as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"ropehang\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh39 = (*sectors.offset(i as isize)).specialflags;
        *fresh39 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh39 as libc::c_uint | SSF_ROPEHANG as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"jumpflip\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh40 = (*sectors.offset(i as isize)).specialflags;
        *fresh40 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh40 as libc::c_uint | SSF_JUMPFLIP as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"gravityoverride\0" as *const u8 as *const libc::c_char)
        != 0 && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh41 = (*sectors.offset(i as isize)).specialflags;
        *fresh41 = ::core::mem::transmute::<
            libc::c_uint,
            sectorspecialflags_t,
        >(*fresh41 as libc::c_uint | SSF_GRAVITYOVERRIDE as libc::c_int as libc::c_uint);
    } else if fastcmp(param, b"friction\0" as *const u8 as *const libc::c_char) != 0 {
        (*sectors.offset(i as isize))
            .friction = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"gravity\0" as *const u8 as *const libc::c_char) != 0 {
        (*sectors.offset(i as isize)).gravity = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"damagetype\0" as *const u8 as *const libc::c_char) != 0 {
        if fastcmp(val, b"Generic\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize))
                .damagetype = SD_GENERIC as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"Water\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize))
                .damagetype = SD_WATER as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"Fire\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize)).damagetype = SD_FIRE as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"Lava\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize)).damagetype = SD_LAVA as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"Electric\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize))
                .damagetype = SD_ELECTRIC as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"Spike\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize))
                .damagetype = SD_SPIKE as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"DeathPitTilt\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize))
                .damagetype = SD_DEATHPITTILT as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"DeathPitNoTilt\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize))
                .damagetype = SD_DEATHPITNOTILT as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"Instakill\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize))
                .damagetype = SD_INSTAKILL as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"SpecialStage\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize))
                .damagetype = SD_SPECIALSTAGE as libc::c_int as uint8_t;
        }
    } else if fastcmp(param, b"triggertag\0" as *const u8 as *const libc::c_char) != 0 {
        (*sectors.offset(i as isize)).triggertag = atol(val) as mtag_t;
    } else if fastcmp(param, b"triggerer\0" as *const u8 as *const libc::c_char) != 0 {
        if fastcmp(val, b"Player\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize))
                .triggerer = TO_PLAYER as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"AllPlayers\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize))
                .triggerer = TO_ALLPLAYERS as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"Mobj\0" as *const u8 as *const libc::c_char) != 0 {
            (*sectors.offset(i as isize)).triggerer = TO_MOBJ as libc::c_int as uint8_t;
        }
    }
}
unsafe extern "C" fn ParseTextmapSidedefParameter(
    mut i: uint32_t,
    mut param: *const libc::c_char,
    mut val: *const libc::c_char,
) {
    if fastcmp(param, b"offsetx\0" as *const u8 as *const libc::c_char) != 0 {
        (*sides.offset(i as isize))
            .textureoffset = (atol(val) << 16 as libc::c_int) as fixed_t;
    } else if fastcmp(param, b"offsety\0" as *const u8 as *const libc::c_char) != 0 {
        (*sides.offset(i as isize))
            .rowoffset = (atol(val) << 16 as libc::c_int) as fixed_t;
    } else if fastcmp(param, b"offsetx_top\0" as *const u8 as *const libc::c_char) != 0 {
        (*sides.offset(i as isize))
            .offsetx_top = (atol(val) << 16 as libc::c_int) as fixed_t;
    } else if fastcmp(param, b"offsetx_mid\0" as *const u8 as *const libc::c_char) != 0 {
        (*sides.offset(i as isize))
            .offsetx_mid = (atol(val) << 16 as libc::c_int) as fixed_t;
    } else if fastcmp(param, b"offsetx_bottom\0" as *const u8 as *const libc::c_char)
        != 0
    {
        (*sides.offset(i as isize))
            .offsetx_bot = (atol(val) << 16 as libc::c_int) as fixed_t;
    } else if fastcmp(param, b"offsety_top\0" as *const u8 as *const libc::c_char) != 0 {
        (*sides.offset(i as isize))
            .offsety_top = (atol(val) << 16 as libc::c_int) as fixed_t;
    } else if fastcmp(param, b"offsety_mid\0" as *const u8 as *const libc::c_char) != 0 {
        (*sides.offset(i as isize))
            .offsety_mid = (atol(val) << 16 as libc::c_int) as fixed_t;
    } else if fastcmp(param, b"offsety_bottom\0" as *const u8 as *const libc::c_char)
        != 0
    {
        (*sides.offset(i as isize))
            .offsety_bot = (atol(val) << 16 as libc::c_int) as fixed_t;
    } else if fastcmp(param, b"texturetop\0" as *const u8 as *const libc::c_char) != 0 {
        (*sides.offset(i as isize)).toptexture = R_TextureNumForName(val);
    } else if fastcmp(param, b"texturebottom\0" as *const u8 as *const libc::c_char) != 0
    {
        (*sides.offset(i as isize)).bottomtexture = R_TextureNumForName(val);
    } else if fastcmp(param, b"texturemiddle\0" as *const u8 as *const libc::c_char) != 0
    {
        (*sides.offset(i as isize)).midtexture = R_TextureNumForName(val);
    } else if fastcmp(param, b"sector\0" as *const u8 as *const libc::c_char) != 0 {
        P_SetSidedefSector(i as size_t, atol(val) as uint16_t);
    } else if fastcmp(param, b"repeatcnt\0" as *const u8 as *const libc::c_char) != 0 {
        (*sides.offset(i as isize)).repeatcnt = atol(val) as int16_t;
    }
}
unsafe extern "C" fn ParseTextmapLinedefParameter(
    mut i: uint32_t,
    mut param: *const libc::c_char,
    mut val: *const libc::c_char,
) {
    if fastcmp(param, b"id\0" as *const u8 as *const libc::c_char) != 0 {
        Tag_FSet(&mut (*lines.offset(i as isize)).tags, atol(val) as mtag_t);
    } else if fastcmp(param, b"moreids\0" as *const u8 as *const libc::c_char) != 0 {
        let mut id: *const libc::c_char = val;
        while !id.is_null() {
            Tag_Add(&mut (*lines.offset(i as isize)).tags, atol(id) as mtag_t);
            id = strchr(id, ' ' as i32);
            if !id.is_null() {
                id = id.offset(1);
                id;
            }
        }
    } else if fastcmp(param, b"special\0" as *const u8 as *const libc::c_char) != 0 {
        (*lines.offset(i as isize)).special = atol(val) as int16_t;
    } else if fastcmp(param, b"v1\0" as *const u8 as *const libc::c_char) != 0 {
        P_SetLinedefV1(i as size_t, atol(val) as uint16_t);
    } else if fastcmp(param, b"v2\0" as *const u8 as *const libc::c_char) != 0 {
        P_SetLinedefV2(i as size_t, atol(val) as uint16_t);
    } else if fastncmp(
        param,
        b"stringarg\0" as *const u8 as *const libc::c_char,
        9 as libc::c_int as uint16_t,
    ) != 0 && strlen(param) > 9 as libc::c_int as libc::c_ulong
    {
        let mut argnum: size_t = atol(param.offset(9 as libc::c_int as isize)) as size_t;
        if argnum >= 2 as libc::c_int as size_t {
            return;
        }
        let ref mut fresh42 = (*lines.offset(i as isize)).stringargs[argnum as usize];
        *fresh42 = Z_MallocAlign(
            (strlen(val)).wrapping_add(1 as libc::c_int as libc::c_ulong),
            PU_LEVEL as libc::c_int,
            0 as *mut libc::c_void,
            ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
        ) as *mut libc::c_char;
        M_Memcpy
            .expect(
                "non-null function pointer",
            )(
            (*lines.offset(i as isize)).stringargs[argnum as usize] as *mut libc::c_void,
            val as *const libc::c_void,
            (strlen(val)).wrapping_add(1 as libc::c_int as libc::c_ulong),
        );
    } else if fastncmp(
        param,
        b"arg\0" as *const u8 as *const libc::c_char,
        3 as libc::c_int as uint16_t,
    ) != 0 && strlen(param) > 3 as libc::c_int as libc::c_ulong
    {
        let mut argnum_0: size_t = atol(param.offset(3 as libc::c_int as isize))
            as size_t;
        if argnum_0 >= 10 as libc::c_int as size_t {
            return;
        }
        (*lines.offset(i as isize)).args[argnum_0 as usize] = atol(val) as int32_t;
    } else if fastcmp(param, b"sidefront\0" as *const u8 as *const libc::c_char) != 0 {
        (*lines.offset(i as isize))
            .sidenum[0 as libc::c_int as usize] = atol(val) as uint16_t;
    } else if fastcmp(param, b"sideback\0" as *const u8 as *const libc::c_char) != 0 {
        (*lines.offset(i as isize))
            .sidenum[1 as libc::c_int as usize] = atol(val) as uint16_t;
    } else if fastcmp(param, b"alpha\0" as *const u8 as *const libc::c_char) != 0 {
        (*lines.offset(i as isize)).alpha = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"blendmode\0" as *const u8 as *const libc::c_char) != 0
        || fastcmp(param, b"renderstyle\0" as *const u8 as *const libc::c_char) != 0
    {
        if fastcmp(val, b"translucent\0" as *const u8 as *const libc::c_char) != 0 {
            (*lines.offset(i as isize)).blendmode = AST_COPY as libc::c_int as uint8_t;
        } else if fastcmp(val, b"add\0" as *const u8 as *const libc::c_char) != 0 {
            (*lines.offset(i as isize)).blendmode = AST_ADD as libc::c_int as uint8_t;
        } else if fastcmp(val, b"subtract\0" as *const u8 as *const libc::c_char) != 0 {
            (*lines.offset(i as isize))
                .blendmode = AST_SUBTRACT as libc::c_int as uint8_t;
        } else if fastcmp(val, b"reversesubtract\0" as *const u8 as *const libc::c_char)
            != 0
        {
            (*lines.offset(i as isize))
                .blendmode = AST_REVERSESUBTRACT as libc::c_int as uint8_t;
        } else if fastcmp(val, b"modulate\0" as *const u8 as *const libc::c_char) != 0 {
            (*lines.offset(i as isize))
                .blendmode = AST_MODULATE as libc::c_int as uint8_t;
        }
        if fastcmp(val, b"fog\0" as *const u8 as *const libc::c_char) != 0 {
            (*lines.offset(i as isize)).blendmode = AST_FOG as libc::c_int as uint8_t;
        }
    } else if fastcmp(param, b"executordelay\0" as *const u8 as *const libc::c_char) != 0
    {
        (*lines.offset(i as isize)).executordelay = atol(val) as int32_t;
    } else if fastcmp(param, b"blocking\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh43 = (*lines.offset(i as isize)).flags;
        *fresh43 = (*fresh43 as libc::c_int | 1 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"blockmonsters\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh44 = (*lines.offset(i as isize)).flags;
        *fresh44 = (*fresh44 as libc::c_int | 2 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"twosided\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh45 = (*lines.offset(i as isize)).flags;
        *fresh45 = (*fresh45 as libc::c_int | 4 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"dontpegtop\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh46 = (*lines.offset(i as isize)).flags;
        *fresh46 = (*fresh46 as libc::c_int | 8 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"dontpegbottom\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh47 = (*lines.offset(i as isize)).flags;
        *fresh47 = (*fresh47 as libc::c_int | 16 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"skewtd\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh48 = (*lines.offset(i as isize)).flags;
        *fresh48 = (*fresh48 as libc::c_int | 32 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"noclimb\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh49 = (*lines.offset(i as isize)).flags;
        *fresh49 = (*fresh49 as libc::c_int | 64 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"noskew\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh50 = (*lines.offset(i as isize)).flags;
        *fresh50 = (*fresh50 as libc::c_int | 128 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"midpeg\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh51 = (*lines.offset(i as isize)).flags;
        *fresh51 = (*fresh51 as libc::c_int | 256 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"midsolid\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh52 = (*lines.offset(i as isize)).flags;
        *fresh52 = (*fresh52 as libc::c_int | 512 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"wrapmidtex\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh53 = (*lines.offset(i as isize)).flags;
        *fresh53 = (*fresh53 as libc::c_int | 1024 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"nonet\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh54 = (*lines.offset(i as isize)).flags;
        *fresh54 = (*fresh54 as libc::c_int | 4096 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"netonly\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh55 = (*lines.offset(i as isize)).flags;
        *fresh55 = (*fresh55 as libc::c_int | 2048 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"bouncy\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh56 = (*lines.offset(i as isize)).flags;
        *fresh56 = (*fresh56 as libc::c_int | 16384 as libc::c_int) as int16_t;
    } else if fastcmp(param, b"transfer\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh57 = (*lines.offset(i as isize)).flags;
        *fresh57 = (*fresh57 as libc::c_int | 32768 as libc::c_int) as int16_t;
    }
}
unsafe extern "C" fn ParseTextmapThingParameter(
    mut i: uint32_t,
    mut param: *const libc::c_char,
    mut val: *const libc::c_char,
) {
    if fastcmp(param, b"id\0" as *const u8 as *const libc::c_char) != 0 {
        Tag_FSet(&mut (*mapthings.offset(i as isize)).tags, atol(val) as mtag_t);
    } else if fastcmp(param, b"moreids\0" as *const u8 as *const libc::c_char) != 0 {
        let mut id: *const libc::c_char = val;
        while !id.is_null() {
            Tag_Add(&mut (*mapthings.offset(i as isize)).tags, atol(id) as mtag_t);
            id = strchr(id, ' ' as i32);
            if !id.is_null() {
                id = id.offset(1);
                id;
            }
        }
    } else if fastcmp(param, b"x\0" as *const u8 as *const libc::c_char) != 0 {
        (*mapthings.offset(i as isize)).x = atol(val) as int16_t;
    } else if fastcmp(param, b"y\0" as *const u8 as *const libc::c_char) != 0 {
        (*mapthings.offset(i as isize)).y = atol(val) as int16_t;
    } else if fastcmp(param, b"height\0" as *const u8 as *const libc::c_char) != 0 {
        (*mapthings.offset(i as isize)).z = atol(val) as int16_t;
    } else if fastcmp(param, b"angle\0" as *const u8 as *const libc::c_char) != 0 {
        (*mapthings.offset(i as isize)).angle = atol(val) as int16_t;
    } else if fastcmp(param, b"pitch\0" as *const u8 as *const libc::c_char) != 0 {
        (*mapthings.offset(i as isize)).pitch = atol(val) as int16_t;
    } else if fastcmp(param, b"roll\0" as *const u8 as *const libc::c_char) != 0 {
        (*mapthings.offset(i as isize)).roll = atol(val) as int16_t;
    } else if fastcmp(param, b"type\0" as *const u8 as *const libc::c_char) != 0 {
        (*mapthings.offset(i as isize)).type_0 = atol(val) as uint16_t;
    } else if fastcmp(param, b"scale\0" as *const u8 as *const libc::c_char) != 0 {
        let ref mut fresh58 = (*mapthings.offset(i as isize)).spriteyscale;
        *fresh58 = FloatToFixed(atof(val) as libc::c_float);
        (*mapthings.offset(i as isize)).spritexscale = *fresh58;
    } else if fastcmp(param, b"scalex\0" as *const u8 as *const libc::c_char) != 0 {
        (*mapthings.offset(i as isize))
            .spritexscale = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"scaley\0" as *const u8 as *const libc::c_char) != 0 {
        (*mapthings.offset(i as isize))
            .spriteyscale = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"mobjscale\0" as *const u8 as *const libc::c_char) != 0 {
        (*mapthings.offset(i as isize)).scale = FloatToFixed(atof(val) as libc::c_float);
    } else if fastcmp(param, b"flip\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh59 = (*mapthings.offset(i as isize)).options;
        *fresh59 = (*fresh59 as libc::c_int | 2 as libc::c_int) as uint16_t;
    } else if fastcmp(param, b"absolutez\0" as *const u8 as *const libc::c_char) != 0
        && fastcmp(b"true\0" as *const u8 as *const libc::c_char, val) != 0
    {
        let ref mut fresh60 = (*mapthings.offset(i as isize)).options;
        *fresh60 = (*fresh60 as libc::c_int | 16 as libc::c_int) as uint16_t;
    } else if fastncmp(
        param,
        b"stringarg\0" as *const u8 as *const libc::c_char,
        9 as libc::c_int as uint16_t,
    ) != 0 && strlen(param) > 9 as libc::c_int as libc::c_ulong
    {
        let mut argnum: size_t = atol(param.offset(9 as libc::c_int as isize)) as size_t;
        if argnum >= 2 as libc::c_int as size_t {
            return;
        }
        let ref mut fresh61 = (*mapthings.offset(i as isize))
            .stringargs[argnum as usize];
        *fresh61 = Z_MallocAlign(
            (strlen(val)).wrapping_add(1 as libc::c_int as libc::c_ulong),
            PU_LEVEL as libc::c_int,
            0 as *mut libc::c_void,
            ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
        ) as *mut libc::c_char;
        M_Memcpy
            .expect(
                "non-null function pointer",
            )(
            (*mapthings.offset(i as isize)).stringargs[argnum as usize]
                as *mut libc::c_void,
            val as *const libc::c_void,
            (strlen(val)).wrapping_add(1 as libc::c_int as libc::c_ulong),
        );
    } else if fastncmp(
        param,
        b"arg\0" as *const u8 as *const libc::c_char,
        3 as libc::c_int as uint16_t,
    ) != 0 && strlen(param) > 3 as libc::c_int as libc::c_ulong
    {
        let mut argnum_0: size_t = atol(param.offset(3 as libc::c_int as isize))
            as size_t;
        if argnum_0 >= 10 as libc::c_int as size_t {
            return;
        }
        (*mapthings.offset(i as isize)).args[argnum_0 as usize] = atol(val) as int32_t;
    }
}
unsafe extern "C" fn TextmapParse(
    mut dataPos: uint32_t,
    mut num: size_t,
    mut parser: Option::<
        unsafe extern "C" fn(uint32_t, *const libc::c_char, *const libc::c_char) -> (),
    >,
) {
    let mut param: *const libc::c_char = 0 as *const libc::c_char;
    let mut val: *const libc::c_char = 0 as *const libc::c_char;
    M_TokenizerSetEndPos(dataPos);
    param = M_TokenizerRead(0 as libc::c_int as uint32_t);
    if fastcmp(param, b"{\0" as *const u8 as *const libc::c_char) == 0 {
        CONS_Alert(
            CONS_WARNING,
            b"Invalid UDMF data capsule!\n\0" as *const u8 as *const libc::c_char,
        );
        return;
    }
    while true_0 as libc::c_int != 0 {
        param = M_TokenizerRead(0 as libc::c_int as uint32_t);
        if fastcmp(param, b"}\0" as *const u8 as *const libc::c_char) != 0 {
            break;
        }
        val = M_TokenizerRead(1 as libc::c_int as uint32_t);
        parser.expect("non-null function pointer")(num as uint32_t, param, val);
    }
}
unsafe extern "C" fn TextmapFixFlatOffsets(mut sec: *mut sector_t) {
    if (*sec).floorangle != 0 {
        let mut pc: fixed_t = *finecosine
            .offset(((*sec).floorangle >> 19 as libc::c_int) as isize)
            >> 16 as libc::c_int - 16 as libc::c_int;
        let mut ps: fixed_t = finesine[((*sec).floorangle >> 19 as libc::c_int) as usize]
            >> 16 as libc::c_int - 16 as libc::c_int;
        let mut xoffs: fixed_t = (*sec).floorxoffset;
        let mut yoffs: fixed_t = (*sec).flooryoffset;
        (*sec)
            .floorxoffset = FixedMul(xoffs, pc)
            % ((2048 as libc::c_int) << 16 as libc::c_int)
            - FixedMul(yoffs, ps) % ((2048 as libc::c_int) << 16 as libc::c_int);
        (*sec)
            .flooryoffset = FixedMul(xoffs, ps)
            % ((2048 as libc::c_int) << 16 as libc::c_int)
            + FixedMul(yoffs, pc) % ((2048 as libc::c_int) << 16 as libc::c_int);
    }
    if (*sec).ceilingangle != 0 {
        let mut pc_0: fixed_t = *finecosine
            .offset(((*sec).ceilingangle >> 19 as libc::c_int) as isize)
            >> 16 as libc::c_int - 16 as libc::c_int;
        let mut ps_0: fixed_t = finesine[((*sec).ceilingangle >> 19 as libc::c_int)
            as usize] >> 16 as libc::c_int - 16 as libc::c_int;
        let mut xoffs_0: fixed_t = (*sec).ceilingxoffset;
        let mut yoffs_0: fixed_t = (*sec).ceilingyoffset;
        (*sec)
            .ceilingxoffset = FixedMul(xoffs_0, pc_0)
            % ((2048 as libc::c_int) << 16 as libc::c_int)
            - FixedMul(yoffs_0, ps_0) % ((2048 as libc::c_int) << 16 as libc::c_int);
        (*sec)
            .ceilingyoffset = FixedMul(xoffs_0, ps_0)
            % ((2048 as libc::c_int) << 16 as libc::c_int)
            + FixedMul(yoffs_0, pc_0) % ((2048 as libc::c_int) << 16 as libc::c_int);
    }
}
unsafe extern "C" fn TextmapUnfixFlatOffsets(mut sec: *mut sector_t) {
    if (*sec).floorangle != 0 {
        let mut pc: fixed_t = *finecosine
            .offset(((*sec).floorangle >> 19 as libc::c_int) as isize)
            >> 16 as libc::c_int - 16 as libc::c_int;
        let mut ps: fixed_t = finesine[((*sec).floorangle >> 19 as libc::c_int) as usize]
            >> 16 as libc::c_int - 16 as libc::c_int;
        let mut xoffs: fixed_t = (*sec).floorxoffset;
        let mut yoffs: fixed_t = (*sec).flooryoffset;
        (*sec)
            .floorxoffset = FixedMul(xoffs, ps)
            % ((2048 as libc::c_int) << 16 as libc::c_int)
            + FixedMul(yoffs, pc) % ((2048 as libc::c_int) << 16 as libc::c_int);
        (*sec)
            .flooryoffset = FixedMul(xoffs, pc)
            % ((2048 as libc::c_int) << 16 as libc::c_int)
            - FixedMul(yoffs, ps) % ((2048 as libc::c_int) << 16 as libc::c_int);
    }
    if (*sec).ceilingangle != 0 {
        let mut pc_0: fixed_t = *finecosine
            .offset(((*sec).ceilingangle >> 19 as libc::c_int) as isize)
            >> 16 as libc::c_int - 16 as libc::c_int;
        let mut ps_0: fixed_t = finesine[((*sec).ceilingangle >> 19 as libc::c_int)
            as usize] >> 16 as libc::c_int - 16 as libc::c_int;
        let mut xoffs_0: fixed_t = (*sec).ceilingxoffset;
        let mut yoffs_0: fixed_t = (*sec).ceilingyoffset;
        (*sec)
            .ceilingxoffset = FixedMul(xoffs_0, ps_0)
            % ((2048 as libc::c_int) << 16 as libc::c_int)
            + FixedMul(yoffs_0, pc_0) % ((2048 as libc::c_int) << 16 as libc::c_int);
        (*sec)
            .ceilingyoffset = FixedMul(xoffs_0, pc_0)
            % ((2048 as libc::c_int) << 16 as libc::c_int)
            - FixedMul(yoffs_0, ps_0) % ((2048 as libc::c_int) << 16 as libc::c_int);
    }
}
unsafe extern "C" fn P_ColorToRGBA(mut color: int32_t, mut alpha: uint8_t) -> int32_t {
    let mut r: uint8_t = (color >> 16 as libc::c_int & 0xff as libc::c_int) as uint8_t;
    let mut g: uint8_t = (color >> 8 as libc::c_int & 0xff as libc::c_int) as uint8_t;
    let mut b: uint8_t = (color & 0xff as libc::c_int) as uint8_t;
    return r as libc::c_int + ((g as libc::c_int) << 8 as libc::c_int)
        + ((b as libc::c_int) << 16 as libc::c_int)
        + ((alpha as libc::c_int) << 24 as libc::c_int);
}
unsafe extern "C" fn P_RGBAToColor(mut rgba: int32_t) -> int32_t {
    let mut r: uint8_t = (rgba & 0xff as libc::c_int) as uint8_t;
    let mut g: uint8_t = (rgba >> 8 as libc::c_int & 0xff as libc::c_int) as uint8_t;
    let mut b: uint8_t = (rgba >> 16 as libc::c_int & 0xff as libc::c_int) as uint8_t;
    return (r as libc::c_int) << 16 as libc::c_int
        | (g as libc::c_int) << 8 as libc::c_int | b as libc::c_int;
}
unsafe extern "C" fn P_WriteTextmap() {
    let mut i: size_t = 0;
    let mut j: size_t = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut filepath: *mut libc::c_char = va(
        pandf,
        srb2home.as_mut_ptr(),
        b"TEXTMAP\0" as *const u8 as *const libc::c_char,
    );
    let mut firsttag: mtag_t = 0;
    let mut wmapthings: *mut mapthing_t = 0 as *mut mapthing_t;
    let mut wvertexes: *mut vertex_t = 0 as *mut vertex_t;
    let mut wsectors: *mut sector_t = 0 as *mut sector_t;
    let mut wlines: *mut line_t = 0 as *mut line_t;
    let mut wsides: *mut side_t = 0 as *mut side_t;
    let mut freetag: mtag_t = 0;
    let mut specialthings: *mut sectorspecialthings_t = 0 as *mut sectorspecialthings_t;
    f = fopen(filepath, b"w\0" as *const u8 as *const libc::c_char);
    if f.is_null() {
        CONS_Alert(
            CONS_ERROR,
            b"Couldn't save map file %s\n\0" as *const u8 as *const libc::c_char,
            filepath,
        );
        return;
    }
    wmapthings = Z_CallocAlign(
        nummapthings.wrapping_mul(::core::mem::size_of::<mapthing_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut mapthing_t;
    wvertexes = Z_CallocAlign(
        numvertexes.wrapping_mul(::core::mem::size_of::<vertex_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut vertex_t;
    wsectors = Z_CallocAlign(
        numsectors.wrapping_mul(::core::mem::size_of::<sector_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut sector_t;
    wlines = Z_CallocAlign(
        numlines.wrapping_mul(::core::mem::size_of::<line_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut line_t;
    wsides = Z_CallocAlign(
        numsides.wrapping_mul(::core::mem::size_of::<side_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut side_t;
    specialthings = Z_CallocAlign(
        numsectors.wrapping_mul(::core::mem::size_of::<sector_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut sectorspecialthings_t;
    memcpy(
        wmapthings as *mut libc::c_void,
        mapthings as *const libc::c_void,
        nummapthings.wrapping_mul(::core::mem::size_of::<mapthing_t>() as libc::c_ulong),
    );
    memcpy(
        wvertexes as *mut libc::c_void,
        vertexes as *const libc::c_void,
        numvertexes.wrapping_mul(::core::mem::size_of::<vertex_t>() as libc::c_ulong),
    );
    memcpy(
        wsectors as *mut libc::c_void,
        sectors as *const libc::c_void,
        numsectors.wrapping_mul(::core::mem::size_of::<sector_t>() as libc::c_ulong),
    );
    memcpy(
        wlines as *mut libc::c_void,
        lines as *const libc::c_void,
        numlines.wrapping_mul(::core::mem::size_of::<line_t>() as libc::c_ulong),
    );
    memcpy(
        wsides as *mut libc::c_void,
        sides as *const libc::c_void,
        numsides.wrapping_mul(::core::mem::size_of::<side_t>() as libc::c_ulong),
    );
    i = 0 as libc::c_int as size_t;
    while i < nummapthings {
        if (*mapthings.offset(i as isize)).tags.count != 0 {
            let ref mut fresh62 = (*wmapthings.offset(i as isize)).tags.tags;
            *fresh62 = memcpy(
                Z_MallocAlign(
                    ((*mapthings.offset(i as isize)).tags.count as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<mtag_t>() as libc::c_ulong),
                    PU_LEVEL as libc::c_int,
                    0 as *mut libc::c_void,
                    ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong
                        as int32_t,
                ),
                (*mapthings.offset(i as isize)).tags.tags as *const libc::c_void,
                ((*mapthings.offset(i as isize)).tags.count as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<mtag_t>() as libc::c_ulong),
            ) as *mut mtag_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < numsectors {
        if (*sectors.offset(i as isize)).tags.count != 0 {
            let ref mut fresh63 = (*wsectors.offset(i as isize)).tags.tags;
            *fresh63 = memcpy(
                Z_MallocAlign(
                    ((*sectors.offset(i as isize)).tags.count as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<mtag_t>() as libc::c_ulong),
                    PU_LEVEL as libc::c_int,
                    0 as *mut libc::c_void,
                    ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong
                        as int32_t,
                ),
                (*sectors.offset(i as isize)).tags.tags as *const libc::c_void,
                ((*sectors.offset(i as isize)).tags.count as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<mtag_t>() as libc::c_ulong),
            ) as *mut mtag_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < numlines {
        if (*lines.offset(i as isize)).tags.count != 0 {
            let ref mut fresh64 = (*wlines.offset(i as isize)).tags.tags;
            *fresh64 = memcpy(
                Z_MallocAlign(
                    ((*lines.offset(i as isize)).tags.count as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<mtag_t>() as libc::c_ulong),
                    PU_LEVEL as libc::c_int,
                    0 as *mut libc::c_void,
                    ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong
                        as int32_t,
                ),
                (*lines.offset(i as isize)).tags.tags as *const libc::c_void,
                ((*lines.offset(i as isize)).tags.count as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<mtag_t>() as libc::c_ulong),
            ) as *mut mtag_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    freetag = Tag_NextUnused(0 as libc::c_int as mtag_t);
    i = 0 as libc::c_int as size_t;
    while i < nummapthings {
        let mut ss: *mut subsector_t = 0 as *mut subsector_t;
        let mut s: int32_t = 0;
        if !((*wmapthings.offset(i as isize)).type_0 as libc::c_int != 751 as libc::c_int
            && (*wmapthings.offset(i as isize)).type_0 as libc::c_int
                != 752 as libc::c_int
            && (*wmapthings.offset(i as isize)).type_0 as libc::c_int
                != 758 as libc::c_int)
        {
            ss = R_PointInSubsector(
                ((*wmapthings.offset(i as isize)).x as libc::c_int) << 16 as libc::c_int,
                ((*wmapthings.offset(i as isize)).y as libc::c_int) << 16 as libc::c_int,
            );
            if !ss.is_null() {
                s = ((*ss).sector).offset_from(sectors) as libc::c_long as int32_t;
                match (*wmapthings.offset(i as isize)).type_0 as libc::c_int {
                    751 => {
                        if ((*specialthings.offset(s as isize)).teleport).is_null() {
                            let ref mut fresh65 = (*specialthings.offset(s as isize))
                                .teleport;
                            *fresh65 = &mut *wmapthings.offset(i as isize)
                                as *mut mapthing_t;
                        }
                    }
                    752 => {
                        if ((*specialthings.offset(s as isize)).altview).is_null() {
                            let ref mut fresh66 = (*specialthings.offset(s as isize))
                                .altview;
                            *fresh66 = &mut *wmapthings.offset(i as isize)
                                as *mut mapthing_t;
                        }
                    }
                    758 => {
                        if ((*specialthings.offset(s as isize)).angleanchor).is_null() {
                            let ref mut fresh67 = (*specialthings.offset(s as isize))
                                .angleanchor;
                            *fresh67 = &mut *wmapthings.offset(i as isize)
                                as *mut mapthing_t;
                        }
                    }
                    _ => {}
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    let mut current_block_91: u64;
    i = 0 as libc::c_int as size_t;
    while i < numlines {
        let mut s_0: int32_t = 0;
        match (*wlines.offset(i as isize)).special as libc::c_int {
            1 => {
                let mut ICNT_2244: size_t = 0 as libc::c_int as size_t;
                loop {
                    s_0 = Tag_Iterate_Sectors(
                        Tag_FGet(&mut (*wlines.offset(i as isize)).tags),
                        ICNT_2244,
                    );
                    if !(s_0 >= 0 as libc::c_int) {
                        break;
                    }
                    CONS_Alert(
                        CONS_WARNING,
                        b"Linedef %s applies custom gravity to sector %d. Changes to this gravity at runtime will not be reflected in the converted map. Use linedef type 469 for this.\n\0"
                            as *const u8 as *const libc::c_char,
                        sizeu1(i),
                        s_0,
                    );
                    (*wsectors.offset(s_0 as isize))
                        .gravity = FixedDiv(
                        (*(*lines.offset(i as isize)).frontsector).floorheight
                            >> 16 as libc::c_int,
                        1000 as libc::c_int,
                    );
                    ICNT_2244 = ICNT_2244.wrapping_add(1);
                    ICNT_2244;
                }
                current_block_91 = 7019009297990327870;
            }
            2 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Custom exit linedef %s detected. Changes to the next map at runtime will not be reflected in the converted map. Use linedef type 468 for this.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                );
                (*wlines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*(*lines.offset(i as isize)).frontsector).floorheight
                    >> 16 as libc::c_int;
                (*wlines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*(*lines.offset(i as isize)).frontsector).ceilingheight
                    >> 16 as libc::c_int;
                current_block_91 = 7019009297990327870;
            }
            5 | 50 | 51 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Linedef %s has type %d, which is not supported in UDMF.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                    (*wlines.offset(i as isize)).special as libc::c_int,
                );
                current_block_91 = 7019009297990327870;
            }
            61 => {
                if (*wlines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    current_block_91 = 15512526488502093901;
                } else if (*wlines.offset(i as isize)).args[1 as libc::c_int as usize]
                    == 0
                {
                    current_block_91 = 15512526488502093901;
                } else {
                    CONS_Alert(
                        CONS_WARNING,
                        b"Linedef %s with crusher type 61 rises twice as fast on spawn. This behavior is not supported in UDMF.\n\0"
                            as *const u8 as *const libc::c_char,
                        sizeu1(i),
                    );
                    current_block_91 = 7019009297990327870;
                }
            }
            76 => {
                if freetag as libc::c_int
                    == 65535 as libc::c_int as mtag_t as libc::c_int
                {
                    CONS_Alert(
                        CONS_WARNING,
                        b"No unused tag found. Linedef %s with type 76 cannot be converted.\n\0"
                            as *const u8 as *const libc::c_char,
                        sizeu1(i),
                    );
                } else {
                    let mut ICNT_2273: size_t = 0 as libc::c_int as size_t;
                    loop {
                        s_0 = Tag_Iterate_Sectors(
                            (*wlines.offset(i as isize)).args[0 as libc::c_int as usize]
                                as mtag_t,
                            ICNT_2273,
                        );
                        if !(s_0 >= 0 as libc::c_int) {
                            break;
                        }
                        j = 0 as libc::c_int as size_t;
                        while (j as libc::c_uint as size_t)
                            < (*wsectors.offset(s_0 as isize)).linecount
                        {
                            let mut line: *mut line_t = wlines
                                .offset(
                                    (*((*wsectors.offset(s_0 as isize)).lines)
                                        .offset(j as isize))
                                        .offset_from(lines) as libc::c_long as isize,
                                );
                            if !(((*line).special as libc::c_int) < 100 as libc::c_int
                                || (*line).special as libc::c_int >= 300 as libc::c_int)
                            {
                                Tag_Add(&mut (*line).tags, freetag);
                            }
                            j = j.wrapping_add(1);
                            j;
                        }
                        ICNT_2273 = ICNT_2273.wrapping_add(1);
                        ICNT_2273;
                    }
                    (*wlines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = freetag as int32_t;
                    freetag = Tag_NextUnused(freetag);
                }
                current_block_91 = 7019009297990327870;
            }
            259 => {
                if (*wlines.offset(i as isize)).args[3 as libc::c_int as usize]
                    & FOF_QUICKSAND as libc::c_int != 0
                {
                    CONS_Alert(
                        CONS_WARNING,
                        b"Quicksand properties of custom FOF on linedef %s cannot be converted. Use linedef type 75 instead.\n\0"
                            as *const u8 as *const libc::c_char,
                        sizeu1(i),
                    );
                }
                if (*wlines.offset(i as isize)).args[3 as libc::c_int as usize]
                    & FOF_BUSTUP as libc::c_int != 0
                {
                    CONS_Alert(
                        CONS_WARNING,
                        b"Bustable properties of custom FOF on linedef %s cannot be converted. Use linedef type 74 instead.\n\0"
                            as *const u8 as *const libc::c_char,
                        sizeu1(i),
                    );
                }
                current_block_91 = 7019009297990327870;
            }
            412 => {
                s_0 = Tag_Iterate_Sectors(
                    (*wlines.offset(i as isize)).args[0 as libc::c_int as usize]
                        as mtag_t,
                    0 as libc::c_int as size_t,
                );
                if s_0 < 0 as libc::c_int {
                    current_block_91 = 7019009297990327870;
                } else if ((*specialthings.offset(s_0 as isize)).teleport).is_null() {
                    current_block_91 = 7019009297990327870;
                } else {
                    if freetag as libc::c_int
                        == 65535 as libc::c_int as mtag_t as libc::c_int
                    {
                        CONS_Alert(
                            CONS_WARNING,
                            b"No unused tag found. Linedef %s with type 412 cannot be converted.\n\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(i),
                        );
                    } else {
                        Tag_Add(
                            &mut (*(*specialthings.offset(s_0 as isize)).teleport).tags,
                            freetag,
                        );
                        (*wlines.offset(i as isize))
                            .args[0 as libc::c_int as usize] = freetag as int32_t;
                        freetag = Tag_NextUnused(freetag);
                    }
                    current_block_91 = 7019009297990327870;
                }
            }
            422 => {
                s_0 = Tag_Iterate_Sectors(
                    (*wlines.offset(i as isize)).args[0 as libc::c_int as usize]
                        as mtag_t,
                    0 as libc::c_int as size_t,
                );
                if s_0 < 0 as libc::c_int {
                    current_block_91 = 7019009297990327870;
                } else if ((*specialthings.offset(s_0 as isize)).altview).is_null() {
                    current_block_91 = 7019009297990327870;
                } else {
                    if freetag as libc::c_int
                        == 65535 as libc::c_int as mtag_t as libc::c_int
                    {
                        CONS_Alert(
                            CONS_WARNING,
                            b"No unused tag found. Linedef %s with type 422 cannot be converted.\n\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(i),
                        );
                    } else {
                        Tag_Add(
                            &mut (*(*specialthings.offset(s_0 as isize)).altview).tags,
                            freetag,
                        );
                        (*wlines.offset(i as isize))
                            .args[0 as libc::c_int as usize] = freetag as int32_t;
                        (*(*specialthings.offset(s_0 as isize)).altview)
                            .pitch = (*wlines.offset(i as isize))
                            .args[2 as libc::c_int as usize] as int16_t;
                        freetag = Tag_NextUnused(freetag);
                    }
                    current_block_91 = 7019009297990327870;
                }
            }
            447 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Linedef %s has change colormap action, which cannot be converted automatically. Tag arg0 to a sector with the desired colormap.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                );
                if (*wlines.offset(i as isize)).flags as libc::c_int
                    & 32768 as libc::c_int != 0
                {
                    CONS_Alert(
                        CONS_WARNING,
                        b"Linedef %s mixes front and back colormaps, which is not supported in UDMF. Copy one colormap to the target sector first, then mix in the second one.\n\0"
                            as *const u8 as *const libc::c_char,
                        sizeu1(i),
                    );
                }
                current_block_91 = 7019009297990327870;
            }
            455 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Linedef %s has fade colormap action, which cannot be converted automatically. Tag arg0 to a sector with the desired colormap.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                );
                if (*wlines.offset(i as isize)).flags as libc::c_int
                    & 32768 as libc::c_int != 0
                {
                    CONS_Alert(
                        CONS_WARNING,
                        b"Linedef %s specifies starting colormap for the fade, which is not supported in UDMF. Change the colormap with linedef type 447 instead.\n\0"
                            as *const u8 as *const libc::c_char,
                        sizeu1(i),
                    );
                }
                current_block_91 = 7019009297990327870;
            }
            457 => {
                s_0 = Tag_Iterate_Sectors(
                    (*wlines.offset(i as isize)).args[0 as libc::c_int as usize]
                        as mtag_t,
                    0 as libc::c_int as size_t,
                );
                if s_0 < 0 as libc::c_int {
                    current_block_91 = 7019009297990327870;
                } else if ((*specialthings.offset(s_0 as isize)).angleanchor).is_null() {
                    current_block_91 = 7019009297990327870;
                } else {
                    if freetag as libc::c_int
                        == 65535 as libc::c_int as mtag_t as libc::c_int
                    {
                        CONS_Alert(
                            CONS_WARNING,
                            b"No unused tag found. Linedef %s with type 457 cannot be converted.\n\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(i),
                        );
                    } else {
                        Tag_Add(
                            &mut (*(*specialthings.offset(s_0 as isize)).angleanchor)
                                .tags,
                            freetag,
                        );
                        (*wlines.offset(i as isize))
                            .args[0 as libc::c_int as usize] = freetag as int32_t;
                        freetag = Tag_NextUnused(freetag);
                    }
                    current_block_91 = 7019009297990327870;
                }
            }
            606 => {
                if (*wlines.offset(i as isize)).args[0 as libc::c_int as usize]
                    == -(1 as libc::c_int)
                {
                    let mut sec: *mut sector_t = wsectors
                        .offset(
                            ((*wlines.offset(i as isize)).frontsector)
                                .offset_from(sectors) as libc::c_long as isize,
                        );
                    (*sec)
                        .extra_colormap = (*wsides
                        .offset(
                            (*wlines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .colormap_data;
                } else {
                    let mut ICNT_2351: size_t = 0 as libc::c_int as size_t;
                    loop {
                        s_0 = Tag_Iterate_Sectors(
                            (*wlines.offset(i as isize)).args[0 as libc::c_int as usize]
                                as mtag_t,
                            ICNT_2351,
                        );
                        if !(s_0 >= 0 as libc::c_int) {
                            break;
                        }
                        if (*wsectors.offset(s_0 as isize)).colormap_protected != 0 {
                            ICNT_2351 = ICNT_2351.wrapping_add(1);
                            ICNT_2351;
                        } else {
                            let ref mut fresh68 = (*wsectors.offset(s_0 as isize))
                                .extra_colormap;
                            *fresh68 = (*wsides
                                .offset(
                                    (*wlines.offset(i as isize))
                                        .sidenum[0 as libc::c_int as usize] as isize,
                                ))
                                .colormap_data;
                            if freetag as libc::c_int
                                == 65535 as libc::c_int as mtag_t as libc::c_int
                            {
                                CONS_Alert(
                                    CONS_WARNING,
                                    b"No unused tag found. Linedef %s with type 606 cannot be converted.\n\0"
                                        as *const u8 as *const libc::c_char,
                                    sizeu1(i),
                                );
                                break;
                            } else {
                                Tag_Add(
                                    &mut (*wsectors.offset(s_0 as isize)).tags,
                                    freetag,
                                );
                                (*wlines.offset(i as isize))
                                    .args[1 as libc::c_int as usize] = freetag as int32_t;
                                freetag = Tag_NextUnused(freetag);
                                break;
                            }
                        }
                    }
                }
                current_block_91 = 7019009297990327870;
            }
            _ => {
                current_block_91 = 7019009297990327870;
            }
        }
        match current_block_91 {
            7019009297990327870 => {
                if (*wlines.offset(i as isize)).special as libc::c_int
                    >= 300 as libc::c_int
                    && ((*wlines.offset(i as isize)).special as libc::c_int)
                        < 400 as libc::c_int
                    && (*wlines.offset(i as isize)).flags as libc::c_int
                        & 1024 as libc::c_int != 0
                {
                    CONS_Alert(
                        CONS_WARNING,
                        b"Linedef executor trigger linedef %s has disregard order flag, which is not supported in UDMF.\n\0"
                            as *const u8 as *const libc::c_char,
                        sizeu1(i),
                    );
                }
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < numsectors {
        if Tag_Find(
            &mut (*wsectors.offset(i as isize)).tags,
            LE_CAPSULE0 as libc::c_int as mtag_t,
        ) != 0
        {
            CONS_Alert(
                CONS_WARNING,
                b"Sector %s has reserved tag %d, which is not supported in UDMF. Use arg3 of the boss mapthing instead.\n\0"
                    as *const u8 as *const libc::c_char,
                sizeu1(i),
                LE_CAPSULE0 as libc::c_int,
            );
        }
        if Tag_Find(
            &mut (*wsectors.offset(i as isize)).tags,
            LE_CAPSULE1 as libc::c_int as mtag_t,
        ) != 0
        {
            CONS_Alert(
                CONS_WARNING,
                b"Sector %s has reserved tag %d, which is not supported in UDMF. Use arg3 of the boss mapthing instead.\n\0"
                    as *const u8 as *const libc::c_char,
                sizeu1(i),
                LE_CAPSULE1 as libc::c_int,
            );
        }
        if Tag_Find(
            &mut (*wsectors.offset(i as isize)).tags,
            LE_CAPSULE2 as libc::c_int as mtag_t,
        ) != 0
        {
            CONS_Alert(
                CONS_WARNING,
                b"Sector %s has reserved tag %d, which is not supported in UDMF. Use arg3 of the boss mapthing instead.\n\0"
                    as *const u8 as *const libc::c_char,
                sizeu1(i),
                LE_CAPSULE2 as libc::c_int,
            );
        }
        match (*wsectors.offset(i as isize)).special as libc::c_int
            >> (1 as libc::c_int - 1 as libc::c_int) * 4 as libc::c_int
            & 15 as libc::c_int
        {
            9 | 10 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Sector %s has ring drainer effect, which is not supported in UDMF. Use linedef type 462 instead.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                );
            }
            15 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Sector %s has bouncy FOF effect, which is not supported in UDMF. Use linedef type 76 instead.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                );
            }
            _ => {}
        }
        match (*wsectors.offset(i as isize)).special as libc::c_int
            >> (2 as libc::c_int - 1 as libc::c_int) * 4 as libc::c_int
            & 15 as libc::c_int
        {
            6 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Sector %s has emerald check trigger type, which is not supported in UDMF. Use linedef types 337-339 instead.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                );
            }
            7 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Sector %s has NiGHTS mare trigger type, which is not supported in UDMF. Use linedef types 340-342 instead.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                );
            }
            9 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Sector %s has Egg Capsule type, which is not supported in UDMF. Use linedef type 464 instead.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                );
            }
            10 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Sector %s has special stage time/spheres requirements effect, which is not supported in UDMF. Use the SpecialStageTime and SpecialStageSpheres level header options instead.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                );
            }
            11 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Sector %s has custom global gravity effect, which is not supported in UDMF. Use the Gravity level header option instead.\n\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                );
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        i;
    }
    fprintf(f, b"namespace = \"srb2\";\n\0" as *const u8 as *const libc::c_char);
    i = 0 as libc::c_int as size_t;
    while i < nummapthings {
        fprintf(f, b"thing // %s\n\0" as *const u8 as *const libc::c_char, sizeu1(i));
        fprintf(f, b"{\n\0" as *const u8 as *const libc::c_char);
        firsttag = Tag_FGet(&mut (*wmapthings.offset(i as isize)).tags);
        if firsttag as libc::c_int != 0 as libc::c_int {
            fprintf(
                f,
                b"id = %d;\n\0" as *const u8 as *const libc::c_char,
                firsttag as libc::c_int,
            );
        }
        if (*wmapthings.offset(i as isize)).tags.count as libc::c_int > 1 as libc::c_int
        {
            fprintf(f, b"moreids = \"\0" as *const u8 as *const libc::c_char);
            j = 1 as libc::c_int as size_t;
            while j < (*wmapthings.offset(i as isize)).tags.count as size_t {
                if j > 1 as libc::c_int as size_t {
                    fprintf(f, b" \0" as *const u8 as *const libc::c_char);
                }
                fprintf(
                    f,
                    b"%d\0" as *const u8 as *const libc::c_char,
                    *((*wmapthings.offset(i as isize)).tags.tags).offset(j as isize)
                        as libc::c_int,
                );
                j = j.wrapping_add(1);
                j;
            }
            fprintf(f, b"\";\n\0" as *const u8 as *const libc::c_char);
        }
        fprintf(
            f,
            b"x = %d;\n\0" as *const u8 as *const libc::c_char,
            (*wmapthings.offset(i as isize)).x as libc::c_int,
        );
        fprintf(
            f,
            b"y = %d;\n\0" as *const u8 as *const libc::c_char,
            (*wmapthings.offset(i as isize)).y as libc::c_int,
        );
        if (*wmapthings.offset(i as isize)).z as libc::c_int != 0 as libc::c_int {
            fprintf(
                f,
                b"height = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wmapthings.offset(i as isize)).z as libc::c_int,
            );
        }
        fprintf(
            f,
            b"angle = %d;\n\0" as *const u8 as *const libc::c_char,
            (*wmapthings.offset(i as isize)).angle as libc::c_int,
        );
        if (*wmapthings.offset(i as isize)).pitch as libc::c_int != 0 as libc::c_int {
            fprintf(
                f,
                b"pitch = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wmapthings.offset(i as isize)).pitch as libc::c_int,
            );
        }
        if (*wmapthings.offset(i as isize)).roll as libc::c_int != 0 as libc::c_int {
            fprintf(
                f,
                b"roll = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wmapthings.offset(i as isize)).roll as libc::c_int,
            );
        }
        if (*wmapthings.offset(i as isize)).type_0 as libc::c_int != 0 as libc::c_int {
            fprintf(
                f,
                b"type = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wmapthings.offset(i as isize)).type_0 as libc::c_int,
            );
        }
        if (*wmapthings.offset(i as isize)).spritexscale
            != (1 as libc::c_int) << 16 as libc::c_int
        {
            fprintf(
                f,
                b"scalex = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat((*wmapthings.offset(i as isize)).spritexscale)
                    as libc::c_double,
            );
        }
        if (*wmapthings.offset(i as isize)).spriteyscale
            != (1 as libc::c_int) << 16 as libc::c_int
        {
            fprintf(
                f,
                b"scaley = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat((*wmapthings.offset(i as isize)).spriteyscale)
                    as libc::c_double,
            );
        }
        if (*wmapthings.offset(i as isize)).scale
            != (1 as libc::c_int) << 16 as libc::c_int
        {
            fprintf(
                f,
                b"mobjscale = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat((*wmapthings.offset(i as isize)).scale) as libc::c_double,
            );
        }
        if (*wmapthings.offset(i as isize)).options as libc::c_int & 2 as libc::c_int
            != 0
        {
            fprintf(f, b"flip = true;\n\0" as *const u8 as *const libc::c_char);
        }
        j = 0 as libc::c_int as size_t;
        while j < 10 as libc::c_int as size_t {
            if (*wmapthings.offset(i as isize)).args[j as usize] != 0 as libc::c_int {
                fprintf(
                    f,
                    b"arg%s = %d;\n\0" as *const u8 as *const libc::c_char,
                    sizeu1(j),
                    (*wmapthings.offset(i as isize)).args[j as usize],
                );
            }
            j = j.wrapping_add(1);
            j;
        }
        j = 0 as libc::c_int as size_t;
        while j < 2 as libc::c_int as size_t {
            if !((*mapthings.offset(i as isize)).stringargs[j as usize]).is_null() {
                fprintf(
                    f,
                    b"stringarg%s = \"%s\";\n\0" as *const u8 as *const libc::c_char,
                    sizeu1(j),
                    (*mapthings.offset(i as isize)).stringargs[j as usize],
                );
            }
            j = j.wrapping_add(1);
            j;
        }
        fprintf(f, b"}\n\0" as *const u8 as *const libc::c_char);
        fprintf(f, b"\n\0" as *const u8 as *const libc::c_char);
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < numvertexes {
        fprintf(f, b"vertex // %s\n\0" as *const u8 as *const libc::c_char, sizeu1(i));
        fprintf(f, b"{\n\0" as *const u8 as *const libc::c_char);
        fprintf(
            f,
            b"x = %f;\n\0" as *const u8 as *const libc::c_char,
            FixedToFloat((*wvertexes.offset(i as isize)).x) as libc::c_double,
        );
        fprintf(
            f,
            b"y = %f;\n\0" as *const u8 as *const libc::c_char,
            FixedToFloat((*wvertexes.offset(i as isize)).y) as libc::c_double,
        );
        if (*wvertexes.offset(i as isize)).floorzset != 0 {
            fprintf(
                f,
                b"zfloor = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat((*wvertexes.offset(i as isize)).floorz) as libc::c_double,
            );
        }
        if (*wvertexes.offset(i as isize)).ceilingzset != 0 {
            fprintf(
                f,
                b"zceiling = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat((*wvertexes.offset(i as isize)).ceilingz) as libc::c_double,
            );
        }
        fprintf(f, b"}\n\0" as *const u8 as *const libc::c_char);
        fprintf(f, b"\n\0" as *const u8 as *const libc::c_char);
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < numlines {
        fprintf(f, b"linedef // %s\n\0" as *const u8 as *const libc::c_char, sizeu1(i));
        fprintf(f, b"{\n\0" as *const u8 as *const libc::c_char);
        fprintf(
            f,
            b"v1 = %s;\n\0" as *const u8 as *const libc::c_char,
            sizeu1(
                ((*wlines.offset(i as isize)).v1).offset_from(vertexes) as libc::c_long
                    as size_t,
            ),
        );
        fprintf(
            f,
            b"v2 = %s;\n\0" as *const u8 as *const libc::c_char,
            sizeu1(
                ((*wlines.offset(i as isize)).v2).offset_from(vertexes) as libc::c_long
                    as size_t,
            ),
        );
        fprintf(
            f,
            b"sidefront = %d;\n\0" as *const u8 as *const libc::c_char,
            (*wlines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                as libc::c_int,
        );
        if (*wlines.offset(i as isize)).sidenum[1 as libc::c_int as usize] as libc::c_int
            != 0xffff as libc::c_int
        {
            fprintf(
                f,
                b"sideback = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wlines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                    as libc::c_int,
            );
        }
        firsttag = Tag_FGet(&mut (*wlines.offset(i as isize)).tags);
        if firsttag as libc::c_int != 0 as libc::c_int {
            fprintf(
                f,
                b"id = %d;\n\0" as *const u8 as *const libc::c_char,
                firsttag as libc::c_int,
            );
        }
        if (*wlines.offset(i as isize)).tags.count as libc::c_int > 1 as libc::c_int {
            fprintf(f, b"moreids = \"\0" as *const u8 as *const libc::c_char);
            j = 1 as libc::c_int as size_t;
            while j < (*wlines.offset(i as isize)).tags.count as size_t {
                if j > 1 as libc::c_int as size_t {
                    fprintf(f, b" \0" as *const u8 as *const libc::c_char);
                }
                fprintf(
                    f,
                    b"%d\0" as *const u8 as *const libc::c_char,
                    *((*wlines.offset(i as isize)).tags.tags).offset(j as isize)
                        as libc::c_int,
                );
                j = j.wrapping_add(1);
                j;
            }
            fprintf(f, b"\";\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).special as libc::c_int != 0 as libc::c_int {
            fprintf(
                f,
                b"special = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wlines.offset(i as isize)).special as libc::c_int,
            );
        }
        j = 0 as libc::c_int as size_t;
        while j < 10 as libc::c_int as size_t {
            if (*wlines.offset(i as isize)).args[j as usize] != 0 as libc::c_int {
                fprintf(
                    f,
                    b"arg%s = %d;\n\0" as *const u8 as *const libc::c_char,
                    sizeu1(j),
                    (*wlines.offset(i as isize)).args[j as usize],
                );
            }
            j = j.wrapping_add(1);
            j;
        }
        j = 0 as libc::c_int as size_t;
        while j < 2 as libc::c_int as size_t {
            if !((*lines.offset(i as isize)).stringargs[j as usize]).is_null() {
                fprintf(
                    f,
                    b"stringarg%s = \"%s\";\n\0" as *const u8 as *const libc::c_char,
                    sizeu1(j),
                    (*lines.offset(i as isize)).stringargs[j as usize],
                );
            }
            j = j.wrapping_add(1);
            j;
        }
        if (*wlines.offset(i as isize)).alpha != (1 as libc::c_int) << 16 as libc::c_int
        {
            fprintf(
                f,
                b"alpha = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat((*wlines.offset(i as isize)).alpha) as libc::c_double,
            );
        }
        if (*wlines.offset(i as isize)).blendmode as libc::c_int
            != AST_COPY as libc::c_int
        {
            match (*wlines.offset(i as isize)).blendmode as libc::c_int {
                2 => {
                    fprintf(
                        f,
                        b"renderstyle = \"add\";\n\0" as *const u8 as *const libc::c_char,
                    );
                }
                3 => {
                    fprintf(
                        f,
                        b"renderstyle = \"subtract\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                4 => {
                    fprintf(
                        f,
                        b"renderstyle = \"reversesubtract\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                5 => {
                    fprintf(
                        f,
                        b"renderstyle = \"modulate\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                7 => {
                    fprintf(
                        f,
                        b"renderstyle = \"fog\";\n\0" as *const u8 as *const libc::c_char,
                    );
                }
                _ => {}
            }
        }
        if (*wlines.offset(i as isize)).executordelay != 0 as libc::c_int
            && !((*wlines.offset(i as isize)).backsector).is_null()
        {
            CONS_Alert(
                CONS_WARNING,
                b"Linedef %s has an executor delay. Changes to the delay at runtime will not be reflected in the converted map. Use linedef type 465 for this.\n\0"
                    as *const u8 as *const libc::c_char,
                sizeu1(i),
            );
            fprintf(
                f,
                b"executordelay = %d;\n\0" as *const u8 as *const libc::c_char,
                ((*(*wlines.offset(i as isize)).backsector).ceilingheight
                    >> 16 as libc::c_int)
                    + ((*(*wlines.offset(i as isize)).backsector).floorheight
                        >> 16 as libc::c_int),
            );
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 1 as libc::c_int != 0 {
            fprintf(f, b"blocking = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 2 as libc::c_int != 0 {
            fprintf(f, b"blockmonsters = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 4 as libc::c_int != 0 {
            fprintf(f, b"twosided = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 8 as libc::c_int != 0 {
            fprintf(f, b"dontpegtop = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 16 as libc::c_int != 0 {
            fprintf(f, b"dontpegbottom = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int != 0 {
            fprintf(f, b"skewtd = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int != 0 {
            fprintf(f, b"noclimb = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 128 as libc::c_int != 0 {
            fprintf(f, b"noskew = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int != 0 {
            fprintf(f, b"midpeg = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int != 0 {
            fprintf(f, b"midsolid = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 1024 as libc::c_int != 0 {
            fprintf(f, b"wrapmidtex = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 4096 as libc::c_int != 0 {
            fprintf(f, b"nonet = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 2048 as libc::c_int != 0 {
            fprintf(f, b"netonly = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 16384 as libc::c_int != 0
        {
            fprintf(f, b"bouncy = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wlines.offset(i as isize)).flags as libc::c_int & 32768 as libc::c_int != 0
        {
            fprintf(f, b"transfer = true;\n\0" as *const u8 as *const libc::c_char);
        }
        fprintf(f, b"}\n\0" as *const u8 as *const libc::c_char);
        fprintf(f, b"\n\0" as *const u8 as *const libc::c_char);
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < numsides {
        fprintf(f, b"sidedef // %s\n\0" as *const u8 as *const libc::c_char, sizeu1(i));
        fprintf(f, b"{\n\0" as *const u8 as *const libc::c_char);
        fprintf(
            f,
            b"sector = %s;\n\0" as *const u8 as *const libc::c_char,
            sizeu1(
                ((*wsides.offset(i as isize)).sector).offset_from(sectors)
                    as libc::c_long as size_t,
            ),
        );
        if (*wsides.offset(i as isize)).textureoffset != 0 as libc::c_int {
            fprintf(
                f,
                b"offsetx = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsides.offset(i as isize)).textureoffset >> 16 as libc::c_int,
            );
        }
        if (*wsides.offset(i as isize)).rowoffset != 0 as libc::c_int {
            fprintf(
                f,
                b"offsety = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsides.offset(i as isize)).rowoffset >> 16 as libc::c_int,
            );
        }
        if (*wsides.offset(i as isize)).offsetx_top != 0 as libc::c_int {
            fprintf(
                f,
                b"offsetx_top = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsides.offset(i as isize)).offsetx_top >> 16 as libc::c_int,
            );
        }
        if (*wsides.offset(i as isize)).offsety_top != 0 as libc::c_int {
            fprintf(
                f,
                b"offsety_top = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsides.offset(i as isize)).offsety_top >> 16 as libc::c_int,
            );
        }
        if (*wsides.offset(i as isize)).offsetx_mid != 0 as libc::c_int {
            fprintf(
                f,
                b"offsetx_mid = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsides.offset(i as isize)).offsetx_mid >> 16 as libc::c_int,
            );
        }
        if (*wsides.offset(i as isize)).offsety_mid != 0 as libc::c_int {
            fprintf(
                f,
                b"offsety_mid = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsides.offset(i as isize)).offsety_mid >> 16 as libc::c_int,
            );
        }
        if (*wsides.offset(i as isize)).offsetx_bot != 0 as libc::c_int {
            fprintf(
                f,
                b"offsetx_bottom = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsides.offset(i as isize)).offsetx_bot >> 16 as libc::c_int,
            );
        }
        if (*wsides.offset(i as isize)).offsety_bot != 0 as libc::c_int {
            fprintf(
                f,
                b"offsety_bottom = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsides.offset(i as isize)).offsety_bot >> 16 as libc::c_int,
            );
        }
        if (*wsides.offset(i as isize)).toptexture > 0 as libc::c_int
            && (*wsides.offset(i as isize)).toptexture < numtextures
        {
            fprintf(
                f,
                b"texturetop = \"%.*s\";\n\0" as *const u8 as *const libc::c_char,
                8 as libc::c_int,
                ((**textures.offset((*wsides.offset(i as isize)).toptexture as isize))
                    .name)
                    .as_mut_ptr(),
            );
        }
        if (*wsides.offset(i as isize)).bottomtexture > 0 as libc::c_int
            && (*wsides.offset(i as isize)).bottomtexture < numtextures
        {
            fprintf(
                f,
                b"texturebottom = \"%.*s\";\n\0" as *const u8 as *const libc::c_char,
                8 as libc::c_int,
                ((**textures.offset((*wsides.offset(i as isize)).bottomtexture as isize))
                    .name)
                    .as_mut_ptr(),
            );
        }
        if (*wsides.offset(i as isize)).midtexture > 0 as libc::c_int
            && (*wsides.offset(i as isize)).midtexture < numtextures
        {
            fprintf(
                f,
                b"texturemiddle = \"%.*s\";\n\0" as *const u8 as *const libc::c_char,
                8 as libc::c_int,
                ((**textures.offset((*wsides.offset(i as isize)).midtexture as isize))
                    .name)
                    .as_mut_ptr(),
            );
        }
        if (*wsides.offset(i as isize)).repeatcnt as libc::c_int != 0 as libc::c_int {
            fprintf(
                f,
                b"repeatcnt = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsides.offset(i as isize)).repeatcnt as libc::c_int,
            );
        }
        fprintf(f, b"}\n\0" as *const u8 as *const libc::c_char);
        fprintf(f, b"\n\0" as *const u8 as *const libc::c_char);
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < numsectors {
        fprintf(f, b"sector // %s\n\0" as *const u8 as *const libc::c_char, sizeu1(i));
        fprintf(f, b"{\n\0" as *const u8 as *const libc::c_char);
        fprintf(
            f,
            b"heightfloor = %d;\n\0" as *const u8 as *const libc::c_char,
            (*wsectors.offset(i as isize)).floorheight >> 16 as libc::c_int,
        );
        fprintf(
            f,
            b"heightceiling = %d;\n\0" as *const u8 as *const libc::c_char,
            (*wsectors.offset(i as isize)).ceilingheight >> 16 as libc::c_int,
        );
        if (*wsectors.offset(i as isize)).floorpic != -(1 as libc::c_int) {
            fprintf(
                f,
                b"texturefloor = \"%s\";\n\0" as *const u8 as *const libc::c_char,
                ((*levelflats.offset((*wsectors.offset(i as isize)).floorpic as isize))
                    .name)
                    .as_mut_ptr(),
            );
        }
        if (*wsectors.offset(i as isize)).ceilingpic != -(1 as libc::c_int) {
            fprintf(
                f,
                b"textureceiling = \"%s\";\n\0" as *const u8 as *const libc::c_char,
                ((*levelflats.offset((*wsectors.offset(i as isize)).ceilingpic as isize))
                    .name)
                    .as_mut_ptr(),
            );
        }
        fprintf(
            f,
            b"lightlevel = %d;\n\0" as *const u8 as *const libc::c_char,
            (*wsectors.offset(i as isize)).lightlevel as libc::c_int,
        );
        if (*wsectors.offset(i as isize)).floorlightlevel as libc::c_int
            != 0 as libc::c_int
        {
            fprintf(
                f,
                b"lightfloor = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsectors.offset(i as isize)).floorlightlevel as libc::c_int,
            );
        }
        if (*wsectors.offset(i as isize)).floorlightabsolute != 0 {
            fprintf(
                f,
                b"lightfloorabsolute = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).ceilinglightlevel as libc::c_int
            != 0 as libc::c_int
        {
            fprintf(
                f,
                b"lightceiling = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsectors.offset(i as isize)).ceilinglightlevel as libc::c_int,
            );
        }
        if (*wsectors.offset(i as isize)).ceilinglightabsolute != 0 {
            fprintf(
                f,
                b"lightceilingabsolute = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        firsttag = Tag_FGet(&mut (*wsectors.offset(i as isize)).tags);
        if firsttag as libc::c_int != 0 as libc::c_int {
            fprintf(
                f,
                b"id = %d;\n\0" as *const u8 as *const libc::c_char,
                firsttag as libc::c_int,
            );
        }
        if (*wsectors.offset(i as isize)).tags.count as libc::c_int > 1 as libc::c_int {
            fprintf(f, b"moreids = \"\0" as *const u8 as *const libc::c_char);
            j = 1 as libc::c_int as size_t;
            while j < (*wsectors.offset(i as isize)).tags.count as size_t {
                if j > 1 as libc::c_int as size_t {
                    fprintf(f, b" \0" as *const u8 as *const libc::c_char);
                }
                fprintf(
                    f,
                    b"%d\0" as *const u8 as *const libc::c_char,
                    *((*wsectors.offset(i as isize)).tags.tags).offset(j as isize)
                        as libc::c_int,
                );
                j = j.wrapping_add(1);
                j;
            }
            fprintf(f, b"\";\n\0" as *const u8 as *const libc::c_char);
        }
        let mut tempsec: sector_t = *wsectors.offset(i as isize);
        TextmapUnfixFlatOffsets(&mut tempsec);
        if tempsec.floorxoffset != 0 as libc::c_int {
            fprintf(
                f,
                b"xpanningfloor = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat(tempsec.floorxoffset) as libc::c_double,
            );
        }
        if tempsec.flooryoffset != 0 as libc::c_int {
            fprintf(
                f,
                b"ypanningfloor = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat(tempsec.flooryoffset) as libc::c_double,
            );
        }
        if tempsec.ceilingxoffset != 0 as libc::c_int {
            fprintf(
                f,
                b"xpanningceiling = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat(tempsec.ceilingxoffset) as libc::c_double,
            );
        }
        if tempsec.ceilingyoffset != 0 as libc::c_int {
            fprintf(
                f,
                b"ypanningceiling = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat(tempsec.ceilingyoffset) as libc::c_double,
            );
        }
        if (*wsectors.offset(i as isize)).floorangle != 0 as libc::c_int as angle_t {
            fprintf(
                f,
                b"rotationfloor = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat(AngleFixed((*wsectors.offset(i as isize)).floorangle))
                    as libc::c_double,
            );
        }
        if (*wsectors.offset(i as isize)).ceilingangle != 0 as libc::c_int as angle_t {
            fprintf(
                f,
                b"rotationceiling = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat(AngleFixed((*wsectors.offset(i as isize)).ceilingangle))
                    as libc::c_double,
            );
        }
        if !((*wsectors.offset(i as isize)).extra_colormap).is_null() {
            let mut lightcolor: int32_t = P_RGBAToColor(
                (*(*wsectors.offset(i as isize)).extra_colormap).rgba,
            );
            let mut lightalpha: uint8_t = ((*(*wsectors.offset(i as isize))
                .extra_colormap)
                .rgba >> 24 as libc::c_int & 0xff as libc::c_int) as uint8_t;
            let mut fadecolor: int32_t = P_RGBAToColor(
                (*(*wsectors.offset(i as isize)).extra_colormap).fadergba,
            );
            let mut fadealpha: uint8_t = ((*(*wsectors.offset(i as isize))
                .extra_colormap)
                .fadergba >> 24 as libc::c_int & 0xff as libc::c_int) as uint8_t;
            if lightcolor != 0 as libc::c_int {
                fprintf(
                    f,
                    b"lightcolor = %d;\n\0" as *const u8 as *const libc::c_char,
                    lightcolor,
                );
            }
            if lightalpha as libc::c_int != 25 as libc::c_int {
                fprintf(
                    f,
                    b"lightalpha = %d;\n\0" as *const u8 as *const libc::c_char,
                    lightalpha as libc::c_int,
                );
            }
            if fadecolor != 0 as libc::c_int {
                fprintf(
                    f,
                    b"fadecolor = %d;\n\0" as *const u8 as *const libc::c_char,
                    fadecolor,
                );
            }
            if fadealpha as libc::c_int != 25 as libc::c_int {
                fprintf(
                    f,
                    b"fadealpha = %d;\n\0" as *const u8 as *const libc::c_char,
                    fadealpha as libc::c_int,
                );
            }
            if (*(*wsectors.offset(i as isize)).extra_colormap).fadestart as libc::c_int
                != 0 as libc::c_int
            {
                fprintf(
                    f,
                    b"fadestart = %d;\n\0" as *const u8 as *const libc::c_char,
                    (*(*wsectors.offset(i as isize)).extra_colormap).fadestart
                        as libc::c_int,
                );
            }
            if (*(*wsectors.offset(i as isize)).extra_colormap).fadeend as libc::c_int
                != 31 as libc::c_int
            {
                fprintf(
                    f,
                    b"fadeend = %d;\n\0" as *const u8 as *const libc::c_char,
                    (*(*wsectors.offset(i as isize)).extra_colormap).fadeend
                        as libc::c_int,
                );
            }
            if (*(*wsectors.offset(i as isize)).extra_colormap).flags as libc::c_int
                & 4 as libc::c_int != 0
            {
                fprintf(
                    f,
                    b"colormapfog = true;\n\0" as *const u8 as *const libc::c_char,
                );
            }
            if (*(*wsectors.offset(i as isize)).extra_colormap).flags as libc::c_int
                & 1 as libc::c_int != 0
            {
                fprintf(
                    f,
                    b"colormapfadesprites = true;\n\0" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        if (*wsectors.offset(i as isize)).colormap_protected != 0 {
            fprintf(
                f,
                b"colormapprotected = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).flags as libc::c_uint
            & MSF_FLIPSPECIAL_FLOOR as libc::c_int as libc::c_uint == 0
        {
            fprintf(
                f,
                b"flipspecial_nofloor = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).flags as libc::c_uint
            & MSF_FLIPSPECIAL_CEILING as libc::c_int as libc::c_uint != 0
        {
            fprintf(
                f,
                b"flipspecial_ceiling = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).flags as libc::c_uint
            & MSF_TRIGGERSPECIAL_TOUCH as libc::c_int as libc::c_uint != 0
        {
            fprintf(
                f,
                b"triggerspecial_touch = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).flags as libc::c_uint
            & MSF_TRIGGERSPECIAL_HEADBUMP as libc::c_int as libc::c_uint != 0
        {
            fprintf(
                f,
                b"triggerspecial_headbump = true;\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).flags as libc::c_uint
            & MSF_TRIGGERLINE_PLANE as libc::c_int as libc::c_uint != 0
        {
            fprintf(
                f,
                b"triggerline_plane = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).flags as libc::c_uint
            & MSF_TRIGGERLINE_MOBJ as libc::c_int as libc::c_uint != 0
        {
            fprintf(
                f,
                b"triggerline_mobj = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).flags as libc::c_uint
            & MSF_INVERTPRECIP as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"invertprecip = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).flags as libc::c_uint
            & MSF_GRAVITYFLIP as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"gravityflip = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).flags as libc::c_uint
            & MSF_HEATWAVE as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"heatwave = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).flags as libc::c_uint
            & MSF_NOCLIPCAMERA as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"noclipcamera = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_OUTERSPACE as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"outerspace = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_DOUBLESTEPUP as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"doublestepup = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_NOSTEPDOWN as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"nostepdown = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_SPEEDPAD as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"speedpad = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_STARPOSTACTIVATOR as libc::c_int as libc::c_uint != 0
        {
            fprintf(
                f,
                b"starpostactivator = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_EXIT as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"exit = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_SPECIALSTAGEPIT as libc::c_int as libc::c_uint != 0
        {
            fprintf(
                f,
                b"specialstagepit = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_RETURNFLAG as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"returnflag = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_REDTEAMBASE as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"redteambase = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_BLUETEAMBASE as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"blueteambase = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_FAN as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"fan = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_SUPERTRANSFORM as libc::c_int as libc::c_uint != 0
        {
            fprintf(
                f,
                b"supertransform = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_FORCESPIN as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"forcespin = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_ZOOMTUBESTART as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"zoomtubestart = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_ZOOMTUBEEND as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"zoomtubeend = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_FINISHLINE as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"finishline = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_ROPEHANG as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"ropehang = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_JUMPFLIP as libc::c_int as libc::c_uint != 0
        {
            fprintf(f, b"jumpflip = true;\n\0" as *const u8 as *const libc::c_char);
        }
        if (*wsectors.offset(i as isize)).specialflags as libc::c_uint
            & SSF_GRAVITYOVERRIDE as libc::c_int as libc::c_uint != 0
        {
            fprintf(
                f,
                b"gravityoverride = true;\n\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*wsectors.offset(i as isize)).friction
            != (0xe8 as libc::c_int) << 16 as libc::c_int - 8 as libc::c_int
        {
            fprintf(
                f,
                b"friction = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat((*wsectors.offset(i as isize)).friction) as libc::c_double,
            );
        }
        if (*wsectors.offset(i as isize)).gravity
            != (1 as libc::c_int) << 16 as libc::c_int
        {
            fprintf(
                f,
                b"gravity = %f;\n\0" as *const u8 as *const libc::c_char,
                FixedToFloat((*wsectors.offset(i as isize)).gravity) as libc::c_double,
            );
        }
        if (*wsectors.offset(i as isize)).damagetype as libc::c_int
            != SD_NONE as libc::c_int
        {
            match (*wsectors.offset(i as isize)).damagetype as libc::c_int {
                1 => {
                    fprintf(
                        f,
                        b"damagetype = \"Generic\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                2 => {
                    fprintf(
                        f,
                        b"damagetype = \"Water\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                3 => {
                    fprintf(
                        f,
                        b"damagetype = \"Fire\";\n\0" as *const u8 as *const libc::c_char,
                    );
                }
                4 => {
                    fprintf(
                        f,
                        b"damagetype = \"Lava\";\n\0" as *const u8 as *const libc::c_char,
                    );
                }
                5 => {
                    fprintf(
                        f,
                        b"damagetype = \"Electric\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                6 => {
                    fprintf(
                        f,
                        b"damagetype = \"Spike\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                7 => {
                    fprintf(
                        f,
                        b"damagetype = \"DeathPitTilt\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                8 => {
                    fprintf(
                        f,
                        b"damagetype = \"DeathPitNoTilt\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                9 => {
                    fprintf(
                        f,
                        b"damagetype = \"Instakill\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                10 => {
                    fprintf(
                        f,
                        b"damagetype = \"SpecialStage\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                _ => {}
            }
        }
        if (*wsectors.offset(i as isize)).triggertag as libc::c_int != 0 as libc::c_int {
            fprintf(
                f,
                b"triggertag = %d;\n\0" as *const u8 as *const libc::c_char,
                (*wsectors.offset(i as isize)).triggertag as libc::c_int,
            );
        }
        if (*wsectors.offset(i as isize)).triggerer as libc::c_int != 0 as libc::c_int {
            match (*wsectors.offset(i as isize)).triggerer as libc::c_int {
                0 => {
                    fprintf(
                        f,
                        b"triggerer = \"Player\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                1 => {
                    fprintf(
                        f,
                        b"triggerer = \"AllPlayers\";\n\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                2 => {
                    fprintf(
                        f,
                        b"triggerer = \"Mobj\";\n\0" as *const u8 as *const libc::c_char,
                    );
                }
                _ => {}
            }
        }
        fprintf(f, b"}\n\0" as *const u8 as *const libc::c_char);
        fprintf(f, b"\n\0" as *const u8 as *const libc::c_char);
        i = i.wrapping_add(1);
        i;
    }
    fclose(f);
    i = 0 as libc::c_int as size_t;
    while i < nummapthings {
        if (*wmapthings.offset(i as isize)).tags.count != 0 {
            Z_Free((*wmapthings.offset(i as isize)).tags.tags as *mut libc::c_void);
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < numsectors {
        if (*wsectors.offset(i as isize)).tags.count != 0 {
            Z_Free((*wsectors.offset(i as isize)).tags.tags as *mut libc::c_void);
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < numlines {
        if (*wlines.offset(i as isize)).tags.count != 0 {
            Z_Free((*wlines.offset(i as isize)).tags.tags as *mut libc::c_void);
        }
        i = i.wrapping_add(1);
        i;
    }
    Z_Free(wmapthings as *mut libc::c_void);
    Z_Free(wvertexes as *mut libc::c_void);
    Z_Free(wsectors as *mut libc::c_void);
    Z_Free(wlines as *mut libc::c_void);
    Z_Free(wsides as *mut libc::c_void);
    Z_Free(specialthings as *mut libc::c_void);
    if contextdrift != 0 {
        CONS_Alert(
            CONS_WARNING,
            b"Some elements of this level are vulnerable to context drift.Please check the console log for more information.\n\0"
                as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn P_LoadTextmap() {
    let mut i: uint32_t = 0;
    let mut vt: *mut vertex_t = 0 as *mut vertex_t;
    let mut sc: *mut sector_t = 0 as *mut sector_t;
    let mut ld: *mut line_t = 0 as *mut line_t;
    let mut sd: *mut side_t = 0 as *mut side_t;
    let mut mt: *mut mapthing_t = 0 as *mut mapthing_t;
    CONS_Alert(
        CONS_NOTICE,
        b"UDMF support is still a work-in-progress; its specs and features are prone to change until it is fully implemented.\n\0"
            as *const u8 as *const libc::c_char,
    );
    i = 0 as libc::c_int as uint32_t;
    vt = vertexes;
    while (i as size_t) < numvertexes {
        (*vt).y = 2147483647 as libc::c_int;
        (*vt).x = (*vt).y;
        (*vt).ceilingzset = false_0 as libc::c_int;
        (*vt).floorzset = (*vt).ceilingzset;
        (*vt).ceilingz = 0 as libc::c_int;
        (*vt).floorz = (*vt).ceilingz;
        TextmapParse(
            vertexesPos[i as usize],
            i as size_t,
            Some(
                ParseTextmapVertexParameter
                    as unsafe extern "C" fn(
                        uint32_t,
                        *const libc::c_char,
                        *const libc::c_char,
                    ) -> (),
            ),
        );
        if (*vt).x == 2147483647 as libc::c_int {
            I_Error(
                b"P_LoadTextmap: vertex %s has no x value set!\n\0" as *const u8
                    as *const libc::c_char,
                sizeu1(i as size_t),
            );
        }
        if (*vt).y == 2147483647 as libc::c_int {
            I_Error(
                b"P_LoadTextmap: vertex %s has no y value set!\n\0" as *const u8
                    as *const libc::c_char,
                sizeu1(i as size_t),
            );
        }
        i = i.wrapping_add(1);
        i;
        vt = vt.offset(1);
        vt;
    }
    i = 0 as libc::c_int as uint32_t;
    sc = sectors;
    while (i as size_t) < numsectors {
        (*sc).floorheight = 0 as libc::c_int;
        (*sc).ceilingheight = 0 as libc::c_int;
        (*sc).floorpic = 0 as libc::c_int;
        (*sc).ceilingpic = 0 as libc::c_int;
        (*sc).lightlevel = 255 as libc::c_int as int16_t;
        (*sc).special = 0 as libc::c_int as int16_t;
        Tag_FSet(&mut (*sc).tags, 0 as libc::c_int as mtag_t);
        (*sc).flooryoffset = 0 as libc::c_int;
        (*sc).floorxoffset = (*sc).flooryoffset;
        (*sc).ceilingyoffset = 0 as libc::c_int;
        (*sc).ceilingxoffset = (*sc).ceilingyoffset;
        (*sc).ceilingangle = 0 as libc::c_int as angle_t;
        (*sc).floorangle = (*sc).ceilingangle;
        (*sc).ceilinglightlevel = 0 as libc::c_int as int16_t;
        (*sc).floorlightlevel = (*sc).ceilinglightlevel;
        (*sc).ceilinglightabsolute = false_0 as libc::c_int;
        (*sc).floorlightabsolute = (*sc).ceilinglightabsolute;
        (*sc).colormap_protected = false_0 as libc::c_int;
        (*sc).gravity = (1 as libc::c_int) << 16 as libc::c_int;
        (*sc).flags = MSF_FLIPSPECIAL_FLOOR;
        (*sc).specialflags = 0 as sectorspecialflags_t;
        (*sc).damagetype = SD_NONE as libc::c_int as uint8_t;
        (*sc).triggertag = 0 as libc::c_int as mtag_t;
        (*sc).triggerer = TO_PLAYER as libc::c_int as uint8_t;
        (*sc).friction = (0xe8 as libc::c_int) << 16 as libc::c_int - 8 as libc::c_int;
        textmap_colormap.used = false_0 as libc::c_int;
        textmap_colormap.lightcolor = 0 as libc::c_int;
        textmap_colormap.lightalpha = 25 as libc::c_int as uint8_t;
        textmap_colormap.fadecolor = 0 as libc::c_int;
        textmap_colormap.fadealpha = 25 as libc::c_int as uint8_t;
        textmap_colormap.fadestart = 0 as libc::c_int as uint8_t;
        textmap_colormap.fadeend = 31 as libc::c_int as uint8_t;
        textmap_colormap.flags = 0 as libc::c_int as uint8_t;
        textmap_planefloor.defined = 0 as libc::c_int as uint8_t;
        textmap_planeceiling.defined = 0 as libc::c_int as uint8_t;
        TextmapParse(
            sectorsPos[i as usize],
            i as size_t,
            Some(
                ParseTextmapSectorParameter
                    as unsafe extern "C" fn(
                        uint32_t,
                        *const libc::c_char,
                        *const libc::c_char,
                    ) -> (),
            ),
        );
        P_InitializeSector(sc);
        if textmap_colormap.used != 0 {
            let mut rgba: int32_t = P_ColorToRGBA(
                textmap_colormap.lightcolor,
                textmap_colormap.lightalpha,
            );
            let mut fadergba: int32_t = P_ColorToRGBA(
                textmap_colormap.fadecolor,
                textmap_colormap.fadealpha,
            );
            (*sc)
                .spawn_extra_colormap = R_CreateColormap(
                rgba,
                fadergba,
                textmap_colormap.fadestart,
                textmap_colormap.fadeend,
                textmap_colormap.flags,
            );
            (*sc).extra_colormap = (*sc).spawn_extra_colormap;
        }
        if textmap_planefloor.defined as libc::c_int
            == PD_A as libc::c_int | PD_B as libc::c_int | PD_C as libc::c_int
                | PD_D as libc::c_int
        {
            (*sc)
                .f_slope = MakeViaEquationConstants(
                textmap_planefloor.a,
                textmap_planefloor.b,
                textmap_planefloor.c,
                textmap_planefloor.d,
            );
            (*sc).hasslope = true_0 as libc::c_int;
        }
        if textmap_planeceiling.defined as libc::c_int
            == PD_A as libc::c_int | PD_B as libc::c_int | PD_C as libc::c_int
                | PD_D as libc::c_int
        {
            (*sc)
                .c_slope = MakeViaEquationConstants(
                textmap_planeceiling.a,
                textmap_planeceiling.b,
                textmap_planeceiling.c,
                textmap_planeceiling.d,
            );
            (*sc).hasslope = true_0 as libc::c_int;
        }
        TextmapFixFlatOffsets(sc);
        i = i.wrapping_add(1);
        i;
        sc = sc.offset(1);
        sc;
    }
    i = 0 as libc::c_int as uint32_t;
    ld = lines;
    while (i as size_t) < numlines {
        (*ld).v2 = 0 as *mut vertex_t;
        (*ld).v1 = (*ld).v2;
        (*ld).flags = 0 as libc::c_int as int16_t;
        (*ld).special = 0 as libc::c_int as int16_t;
        Tag_FSet(&mut (*ld).tags, 0 as libc::c_int as mtag_t);
        memset(
            ((*ld).args).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            (10 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<int32_t>() as libc::c_ulong),
        );
        memset(
            ((*ld).stringargs).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            (2 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ),
        );
        (*ld).alpha = (1 as libc::c_int) << 16 as libc::c_int;
        (*ld).executordelay = 0 as libc::c_int;
        (*ld).sidenum[0 as libc::c_int as usize] = 0xffff as libc::c_int as uint16_t;
        (*ld).sidenum[1 as libc::c_int as usize] = 0xffff as libc::c_int as uint16_t;
        TextmapParse(
            linesPos[i as usize],
            i as size_t,
            Some(
                ParseTextmapLinedefParameter
                    as unsafe extern "C" fn(
                        uint32_t,
                        *const libc::c_char,
                        *const libc::c_char,
                    ) -> (),
            ),
        );
        if ((*ld).v1).is_null() {
            I_Error(
                b"P_LoadTextmap: linedef %s has no v1 value set!\n\0" as *const u8
                    as *const libc::c_char,
                sizeu1(i as size_t),
            );
        }
        if ((*ld).v2).is_null() {
            I_Error(
                b"P_LoadTextmap: linedef %s has no v2 value set!\n\0" as *const u8
                    as *const libc::c_char,
                sizeu1(i as size_t),
            );
        }
        if (*ld).sidenum[0 as libc::c_int as usize] as libc::c_int
            == 0xffff as libc::c_int
        {
            I_Error(
                b"P_LoadTextmap: linedef %s has no sidefront value set!\n\0" as *const u8
                    as *const libc::c_char,
                sizeu1(i as size_t),
            );
        }
        P_InitializeLinedef(ld);
        i = i.wrapping_add(1);
        i;
        ld = ld.offset(1);
        ld;
    }
    i = 0 as libc::c_int as uint32_t;
    sd = sides;
    while (i as size_t) < numsides {
        (*sd).textureoffset = 0 as libc::c_int;
        (*sd).rowoffset = 0 as libc::c_int;
        (*sd).offsetx_bot = 0 as libc::c_int;
        (*sd).offsetx_mid = (*sd).offsetx_bot;
        (*sd).offsetx_top = (*sd).offsetx_mid;
        (*sd).offsety_bot = 0 as libc::c_int;
        (*sd).offsety_mid = (*sd).offsety_bot;
        (*sd).offsety_top = (*sd).offsety_mid;
        (*sd)
            .toptexture = R_TextureNumForName(
            b"-\0" as *const u8 as *const libc::c_char,
        );
        (*sd)
            .midtexture = R_TextureNumForName(
            b"-\0" as *const u8 as *const libc::c_char,
        );
        (*sd)
            .bottomtexture = R_TextureNumForName(
            b"-\0" as *const u8 as *const libc::c_char,
        );
        (*sd).sector = 0 as *mut sector_t;
        (*sd).repeatcnt = 0 as libc::c_int as int16_t;
        TextmapParse(
            sidesPos[i as usize],
            i as size_t,
            Some(
                ParseTextmapSidedefParameter
                    as unsafe extern "C" fn(
                        uint32_t,
                        *const libc::c_char,
                        *const libc::c_char,
                    ) -> (),
            ),
        );
        if ((*sd).sector).is_null() {
            I_Error(
                b"P_LoadTextmap: sidedef %s has no sector value set!\n\0" as *const u8
                    as *const libc::c_char,
                sizeu1(i as size_t),
            );
        }
        P_InitializeSidedef(sd);
        i = i.wrapping_add(1);
        i;
        sd = sd.offset(1);
        sd;
    }
    i = 0 as libc::c_int as uint32_t;
    mt = mapthings;
    while (i as size_t) < nummapthings {
        (*mt).y = 0 as libc::c_int as int16_t;
        (*mt).x = (*mt).y;
        (*mt).roll = 0 as libc::c_int as int16_t;
        (*mt).pitch = (*mt).roll;
        (*mt).angle = (*mt).pitch;
        (*mt).type_0 = 0 as libc::c_int as uint16_t;
        (*mt).options = 0 as libc::c_int as uint16_t;
        (*mt).z = 0 as libc::c_int as int16_t;
        (*mt).extrainfo = 0 as libc::c_int as uint8_t;
        Tag_FSet(&mut (*mt).tags, 0 as libc::c_int as mtag_t);
        (*mt).scale = (1 as libc::c_int) << 16 as libc::c_int;
        (*mt).spriteyscale = (1 as libc::c_int) << 16 as libc::c_int;
        (*mt).spritexscale = (*mt).spriteyscale;
        memset(
            ((*mt).args).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            (10 as libc::c_int as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<int32_t>() as libc::c_ulong),
        );
        memset(
            ((*mt).stringargs).as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            (2 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ),
        );
        (*mt).mobj = 0 as *mut mobj_s;
        TextmapParse(
            mapthingsPos[i as usize],
            i as size_t,
            Some(
                ParseTextmapThingParameter
                    as unsafe extern "C" fn(
                        uint32_t,
                        *const libc::c_char,
                        *const libc::c_char,
                    ) -> (),
            ),
        );
        i = i.wrapping_add(1);
        i;
        mt = mt.offset(1);
        mt;
    }
}
unsafe extern "C" fn P_ProcessLinedefsAfterSidedefs() {
    let mut i: size_t = numlines;
    let mut ld: *mut line_t = lines;
    loop {
        let fresh69 = i;
        i = i.wrapping_sub(1);
        if !(fresh69 != 0) {
            break;
        }
        (*ld)
            .frontsector = (*sides
            .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
            .sector;
        (*ld)
            .backsector = if (*ld).sidenum[1 as libc::c_int as usize] as libc::c_int
            != 0xffff as libc::c_int
        {
            (*sides.offset((*ld).sidenum[1 as libc::c_int as usize] as isize)).sector
        } else {
            0 as *mut sector_t
        };
        if !(udmf != 0) {
            let mut current_block_29: u64;
            match (*ld).special as libc::c_int {
                331 => {
                    current_block_29 = 10949256118388880583;
                }
                332 => {
                    current_block_29 = 10949256118388880583;
                }
                333 => {
                    current_block_29 = 13793631868002881155;
                }
                443 => {
                    current_block_29 = 5627532849278391493;
                }
                447 | 455 => {
                    if (*ld).flags as libc::c_int & 16 as libc::c_int != 0 {
                        let mut exc: *mut extracolormap_t = R_CopyColormap(
                            (*sides
                                .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                                .colormap_data,
                            false_0 as libc::c_int,
                        );
                        let mut alpha: int16_t = (if (if ((*sides
                            .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                            .textureoffset >> 16 as libc::c_int) < 25 as libc::c_int
                        {
                            (*sides
                                .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                                .textureoffset >> 16 as libc::c_int
                        } else {
                            25 as libc::c_int
                        }) > -(25 as libc::c_int)
                        {
                            if ((*sides
                                .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                                .textureoffset >> 16 as libc::c_int) < 25 as libc::c_int
                            {
                                (*sides
                                    .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                                    .textureoffset >> 16 as libc::c_int
                            } else {
                                25 as libc::c_int
                            }
                        } else {
                            -(25 as libc::c_int)
                        }) as int16_t;
                        let mut fadealpha: int16_t = (if (if ((*sides
                            .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                            .rowoffset >> 16 as libc::c_int) < 25 as libc::c_int
                        {
                            (*sides
                                .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                                .rowoffset >> 16 as libc::c_int
                        } else {
                            25 as libc::c_int
                        }) > -(25 as libc::c_int)
                        {
                            if ((*sides
                                .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                                .rowoffset >> 16 as libc::c_int) < 25 as libc::c_int
                            {
                                (*sides
                                    .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                                    .rowoffset >> 16 as libc::c_int
                            } else {
                                25 as libc::c_int
                            }
                        } else {
                            -(25 as libc::c_int)
                        }) as int16_t;
                        if (alpha as libc::c_int) < 0 as libc::c_int {
                            alpha = (alpha as libc::c_int * -(1 as libc::c_int))
                                as int16_t;
                            (*ld).args[2 as libc::c_int as usize]
                                |= TMCF_SUBLIGHTA as libc::c_int;
                        }
                        if (fadealpha as libc::c_int) < 0 as libc::c_int {
                            fadealpha = (fadealpha as libc::c_int * -(1 as libc::c_int))
                                as int16_t;
                            (*ld).args[2 as libc::c_int as usize]
                                |= TMCF_SUBFADEA as libc::c_int;
                        }
                        (*exc)
                            .rgba = ((*exc).rgba & 0xffffff as libc::c_int)
                            + ((alpha as libc::c_int) << 24 as libc::c_int);
                        (*exc)
                            .fadergba = ((*exc).fadergba & 0xffffff as libc::c_int)
                            + ((fadealpha as libc::c_int) << 24 as libc::c_int);
                        let ref mut fresh70 = (*sides
                            .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                            .colormap_data;
                        *fresh70 = R_GetColormapFromList(exc);
                        if (*fresh70).is_null() {
                            (*exc).colormap = R_CreateLightTable(exc);
                            R_AddColormapToList(exc);
                            let ref mut fresh71 = (*sides
                                .offset((*ld).sidenum[0 as libc::c_int as usize] as isize))
                                .colormap_data;
                            *fresh71 = exc;
                        } else {
                            Z_Free(exc as *mut libc::c_void);
                        }
                    }
                    current_block_29 = 11932355480408055363;
                }
                _ => {
                    current_block_29 = 11932355480408055363;
                }
            }
            match current_block_29 {
                10949256118388880583 => {
                    current_block_29 = 13793631868002881155;
                }
                _ => {}
            }
            match current_block_29 {
                13793631868002881155 => {
                    current_block_29 = 5627532849278391493;
                }
                _ => {}
            }
            match current_block_29 {
                5627532849278391493 => {
                    if !((*ld).stringargs[0 as libc::c_int as usize]).is_null()
                        && !((*ld).stringargs[1 as libc::c_int as usize]).is_null()
                    {
                        let mut len: [size_t; 2] = [0; 2];
                        len[0 as libc::c_int
                            as usize] = strlen(
                            (*ld).stringargs[0 as libc::c_int as usize],
                        );
                        len[1 as libc::c_int
                            as usize] = strlen(
                            (*ld).stringargs[1 as libc::c_int as usize],
                        );
                        if len[1 as libc::c_int as usize] != 0 {
                            (*ld)
                                .stringargs[0 as libc::c_int
                                as usize] = Z_ReallocAlign(
                                (*ld).stringargs[0 as libc::c_int as usize]
                                    as *mut libc::c_void,
                                (len[0 as libc::c_int as usize])
                                    .wrapping_add(len[1 as libc::c_int as usize])
                                    .wrapping_add(1 as libc::c_int as size_t),
                                PU_LEVEL as libc::c_int,
                                0 as *mut libc::c_void,
                                ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong
                                    as int32_t,
                            ) as *mut libc::c_char;
                            M_Memcpy
                                .expect(
                                    "non-null function pointer",
                                )(
                                ((*ld).stringargs[0 as libc::c_int as usize])
                                    .offset(len[0 as libc::c_int as usize] as isize)
                                    .offset(1 as libc::c_int as isize) as *mut libc::c_void,
                                (*ld).stringargs[1 as libc::c_int as usize]
                                    as *const libc::c_void,
                                (len[1 as libc::c_int as usize])
                                    .wrapping_add(1 as libc::c_int as size_t),
                            );
                        }
                        Z_Free(
                            (*ld).stringargs[1 as libc::c_int as usize]
                                as *mut libc::c_void,
                        );
                        (*ld)
                            .stringargs[1 as libc::c_int
                            as usize] = 0 as *mut libc::c_char;
                    }
                }
                _ => {}
            }
        }
        ld = ld.offset(1);
        ld;
    };
}
unsafe extern "C" fn P_LoadMapData(mut virt: *const virtres_t) -> boolean {
    let mut virtvertexes: *mut virtlump_t = 0 as *mut virtlump_t;
    let mut virtsectors: *mut virtlump_t = 0 as *mut virtlump_t;
    let mut virtsidedefs: *mut virtlump_t = 0 as *mut virtlump_t;
    let mut virtlinedefs: *mut virtlump_t = 0 as *mut virtlump_t;
    let mut virtthings: *mut virtlump_t = 0 as *mut virtlump_t;
    if udmf != 0 {
        let mut textmap: *mut virtlump_t = vres_Find(
            virt,
            b"TEXTMAP\0" as *const u8 as *const libc::c_char,
        );
        M_TokenizerOpen((*textmap).data as *mut libc::c_char);
        if TextmapCount((*textmap).size) == 0 {
            M_TokenizerClose();
            return false_0 as libc::c_int;
        }
    } else {
        virtthings = vres_Find(virt, b"THINGS\0" as *const u8 as *const libc::c_char);
        virtvertexes = vres_Find(
            virt,
            b"VERTEXES\0" as *const u8 as *const libc::c_char,
        );
        virtsectors = vres_Find(virt, b"SECTORS\0" as *const u8 as *const libc::c_char);
        virtsidedefs = vres_Find(
            virt,
            b"SIDEDEFS\0" as *const u8 as *const libc::c_char,
        );
        virtlinedefs = vres_Find(
            virt,
            b"LINEDEFS\0" as *const u8 as *const libc::c_char,
        );
        if virtthings.is_null() {
            I_Error(b"THINGS lump not found\0" as *const u8 as *const libc::c_char);
        }
        if virtvertexes.is_null() {
            I_Error(b"VERTEXES lump not found\0" as *const u8 as *const libc::c_char);
        }
        if virtsectors.is_null() {
            I_Error(b"SECTORS lump not found\0" as *const u8 as *const libc::c_char);
        }
        if virtsidedefs.is_null() {
            I_Error(b"SIDEDEFS lump not found\0" as *const u8 as *const libc::c_char);
        }
        if virtlinedefs.is_null() {
            I_Error(b"LINEDEFS lump not found\0" as *const u8 as *const libc::c_char);
        }
        numvertexes = ((*virtvertexes).size)
            .wrapping_div(::core::mem::size_of::<mapvertex_t>() as libc::c_ulong);
        numsectors = ((*virtsectors).size)
            .wrapping_div(::core::mem::size_of::<mapsector_t>() as libc::c_ulong);
        numsides = ((*virtsidedefs).size)
            .wrapping_div(::core::mem::size_of::<mapsidedef_t>() as libc::c_ulong);
        numlines = ((*virtlinedefs).size)
            .wrapping_div(::core::mem::size_of::<maplinedef_t>() as libc::c_ulong);
        nummapthings = ((*virtthings).size)
            .wrapping_div(
                (5 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<int16_t>() as libc::c_ulong),
            );
    }
    if numvertexes <= 0 as libc::c_int as size_t {
        I_Error(b"Level has no vertices\0" as *const u8 as *const libc::c_char);
    }
    if numsectors <= 0 as libc::c_int as size_t {
        I_Error(b"Level has no sectors\0" as *const u8 as *const libc::c_char);
    }
    if numsides <= 0 as libc::c_int as size_t {
        I_Error(b"Level has no sidedefs\0" as *const u8 as *const libc::c_char);
    }
    if numlines <= 0 as libc::c_int as size_t {
        I_Error(b"Level has no linedefs\0" as *const u8 as *const libc::c_char);
    }
    vertexes = Z_CallocAlign(
        numvertexes.wrapping_mul(::core::mem::size_of::<vertex_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut vertex_t;
    sectors = Z_CallocAlign(
        numsectors.wrapping_mul(::core::mem::size_of::<sector_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut sector_t;
    sides = Z_CallocAlign(
        numsides.wrapping_mul(::core::mem::size_of::<side_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut side_t;
    lines = Z_CallocAlign(
        numlines.wrapping_mul(::core::mem::size_of::<line_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut line_t;
    mapthings = Z_CallocAlign(
        nummapthings.wrapping_mul(::core::mem::size_of::<mapthing_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut mapthing_t;
    foundflats = calloc(
        256 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<levelflat_t>() as libc::c_ulong,
    ) as *mut levelflat_t;
    if foundflats.is_null() {
        I_Error(
            b"Ran out of memory while loading sectors\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    numlevelflats = 0 as libc::c_int as size_t;
    if udmf != 0 {
        P_LoadTextmap();
        M_TokenizerClose();
    } else {
        P_LoadVertices((*virtvertexes).data);
        P_LoadSectors((*virtsectors).data);
        P_LoadLinedefs((*virtlinedefs).data);
        P_LoadSidedefs((*virtsidedefs).data);
        P_LoadThings((*virtthings).data);
    }
    P_ProcessLinedefsAfterSidedefs();
    R_ClearTextureNumCache(true_0 as libc::c_int);
    skyflatnum = P_AddLevelFlat(
        b"F_SKY1\0" as *const u8 as *const libc::c_char,
        foundflats,
    );
    levelflats = M_Memcpy
        .expect(
            "non-null function pointer",
        )(
        Z_CallocAlign(
            numlevelflats
                .wrapping_mul(::core::mem::size_of::<levelflat_t>() as libc::c_ulong),
            PU_LEVEL as libc::c_int,
            0 as *mut libc::c_void,
            ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
        ),
        foundflats as *const libc::c_void,
        numlevelflats
            .wrapping_mul(::core::mem::size_of::<levelflat_t>() as libc::c_ulong),
    ) as *mut levelflat_t;
    free(foundflats as *mut libc::c_void);
    P_SetupLevelFlatAnims();
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_InitializeSubsector(mut ss: *mut subsector_t) {
    (*ss).sector = 0 as *mut sector_t;
    (*ss).validcount = 0 as libc::c_int as size_t;
}
#[inline]
unsafe extern "C" fn P_LoadSubsectors(mut data: *mut uint8_t) {
    let mut ms: *mut mapsubsector_t = data as *mut mapsubsector_t;
    let mut ss: *mut subsector_t = subsectors;
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numsubsectors {
        (*ss).numlines = (*ms).numsegs as int16_t;
        (*ss).firstline = (*ms).firstseg as int16_t as uint16_t as uint32_t;
        P_InitializeSubsector(ss);
        i = i.wrapping_add(1);
        i;
        ss = ss.offset(1);
        ss;
        ms = ms.offset(1);
        ms;
    }
}
unsafe extern "C" fn P_LoadNodes(mut data: *mut uint8_t) {
    let mut j: uint8_t = 0;
    let mut k: uint8_t = 0;
    let mut mn: *mut mapnode_t = data as *mut mapnode_t;
    let mut no: *mut node_t = nodes;
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numnodes {
        (*no).x = ((*mn).x as libc::c_int) << 16 as libc::c_int;
        (*no).y = ((*mn).y as libc::c_int) << 16 as libc::c_int;
        (*no).dx = ((*mn).dx as libc::c_int) << 16 as libc::c_int;
        (*no).dy = ((*mn).dy as libc::c_int) << 16 as libc::c_int;
        j = 0 as libc::c_int as uint8_t;
        while (j as libc::c_int) < 2 as libc::c_int {
            (*no)
                .children[j
                as usize] = (*mn).children[j as usize] as int16_t as uint16_t;
            k = 0 as libc::c_int as uint8_t;
            while (k as libc::c_int) < 4 as libc::c_int {
                (*no)
                    .bbox[j
                    as usize][k
                    as usize] = ((*mn).bbox[j as usize][k as usize] as libc::c_int)
                    << 16 as libc::c_int;
                k = k.wrapping_add(1);
                k;
            }
            j = j.wrapping_add(1);
            j;
        }
        i = i.wrapping_add(1);
        i;
        no = no.offset(1);
        no;
        mn = mn.offset(1);
        mn;
    }
}
unsafe extern "C" fn P_SegLength(mut seg: *mut seg_t) -> fixed_t {
    let mut dx: int64_t = ((*(*seg).v2).x - (*(*seg).v1).x >> 1 as libc::c_int)
        as int64_t;
    let mut dy: int64_t = ((*(*seg).v2).y - (*(*seg).v1).y >> 1 as libc::c_int)
        as int64_t;
    return FixedHypot(dx as fixed_t, dy as fixed_t) << 1 as libc::c_int;
}
unsafe extern "C" fn P_InitializeSeg(mut seg: *mut seg_t) {
    if !((*seg).linedef).is_null() {
        let mut side: uint16_t = (*(*seg).linedef).sidenum[(*seg).side as usize];
        if side as libc::c_int == 0xffff as libc::c_int {
            I_Error(
                b"P_InitializeSeg: Seg %s refers to side %d of linedef %s, which doesn't exist!\n\0"
                    as *const u8 as *const libc::c_char,
                sizeu1(seg.offset_from(segs) as libc::c_long as size_t),
                (*seg).side,
                sizeu1(((*seg).linedef).offset_from(lines) as libc::c_long as size_t),
            );
        }
        (*seg).sidedef = &mut *sides.offset(side as isize) as *mut side_t;
        (*seg).frontsector = (*(*seg).sidedef).sector;
        (*seg)
            .backsector = if (*(*seg).linedef).flags as libc::c_int & 4 as libc::c_int
            != 0
        {
            (*sides
                .offset(
                    (*(*seg).linedef).sidenum[((*seg).side ^ 1 as libc::c_int) as usize]
                        as isize,
                ))
                .sector
        } else {
            0 as *mut sector_t
        };
    }
    (*seg).numlights = 0 as libc::c_int as size_t;
    (*seg).rlights = 0 as *mut r_lightlist_t;
    (*seg).polyseg = 0 as *mut polyobj_t;
    (*seg).dontrenderme = false_0 as libc::c_int;
}
unsafe extern "C" fn P_LoadSegs(mut data: *mut uint8_t) {
    let mut ms: *mut mapseg_t = data as *mut mapseg_t;
    let mut seg: *mut seg_t = segs;
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numsegs {
        (*seg).v1 = &mut *vertexes.offset((*ms).v1 as isize) as *mut vertex_t;
        (*seg).v2 = &mut *vertexes.offset((*ms).v2 as isize) as *mut vertex_t;
        (*seg).side = (*ms).side as int32_t;
        (*seg).offset = ((*ms).offset as libc::c_int) << 16 as libc::c_int;
        (*seg).angle = (((*ms).angle as libc::c_int) << 16 as libc::c_int) as angle_t;
        (*seg).linedef = &mut *lines.offset((*ms).linedef as isize) as *mut line_t;
        (*seg).length = P_SegLength(seg);
        (*seg).glseg = false_0 as libc::c_int;
        P_InitializeSeg(seg);
        i = i.wrapping_add(1);
        i;
        seg = seg.offset(1);
        seg;
        ms = ms.offset(1);
        ms;
    }
}
unsafe extern "C" fn P_GetNodetype(
    mut virt: *const virtres_t,
    mut nodedata: *mut *mut uint8_t,
) -> nodetype_t {
    let mut supported: [boolean; 10] = [0 as libc::c_int, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let mut nodetype: nodetype_t = NT_UNSUPPORTED;
    let mut signature: [libc::c_char; 5] = [0; 5];
    *nodedata = 0 as *mut uint8_t;
    if udmf != 0 {
        let mut virtznodes: *mut virtlump_t = vres_Find(
            virt,
            b"ZNODES\0" as *const u8 as *const libc::c_char,
        );
        if !virtznodes.is_null() && (*virtznodes).size != 0 {
            *nodedata = (*virtznodes).data;
            supported[NT_XGL3 as libc::c_int as usize] = true_0 as libc::c_int;
            supported[NT_XGLN as libc::c_int
                as usize] = supported[NT_XGL3 as libc::c_int as usize];
        }
    } else {
        let mut virtsegs: *mut virtlump_t = vres_Find(
            virt,
            b"SEGS\0" as *const u8 as *const libc::c_char,
        );
        let mut virtssectors: *mut virtlump_t = 0 as *mut virtlump_t;
        if !virtsegs.is_null() && (*virtsegs).size != 0 {
            let mut virtnodes: *mut virtlump_t = vres_Find(
                virt,
                b"NODES\0" as *const u8 as *const libc::c_char,
            );
            if !virtnodes.is_null() && (*virtnodes).size != 0 {
                *nodedata = (*virtnodes).data;
                return NT_DOOM;
            }
        } else {
            virtssectors = vres_Find(
                virt,
                b"SSECTORS\0" as *const u8 as *const libc::c_char,
            );
            if !virtssectors.is_null() && (*virtssectors).size != 0 {
                *nodedata = (*virtssectors).data;
                supported[NT_XGL3 as libc::c_int as usize] = true_0 as libc::c_int;
                supported[NT_ZGLN as libc::c_int
                    as usize] = supported[NT_XGL3 as libc::c_int as usize];
                supported[NT_XGLN as libc::c_int
                    as usize] = supported[NT_ZGLN as libc::c_int as usize];
            } else {
                let mut virtnodes_0: *mut virtlump_t = vres_Find(
                    virt,
                    b"NODES\0" as *const u8 as *const libc::c_char,
                );
                if !virtnodes_0.is_null() && (*virtnodes_0).size != 0 {
                    *nodedata = (*virtnodes_0).data;
                    supported[NT_ZNOD as libc::c_int as usize] = true_0 as libc::c_int;
                    supported[NT_XNOD as libc::c_int
                        as usize] = supported[NT_ZNOD as libc::c_int as usize];
                }
            }
        }
    }
    if (*nodedata).is_null() {
        I_Error(
            b"Level has no nodes (does your map have at least 2 sectors?)\0" as *const u8
                as *const libc::c_char,
        );
    }
    M_Memcpy
        .expect(
            "non-null function pointer",
        )(
        signature.as_mut_ptr() as *mut libc::c_void,
        *nodedata as *const libc::c_void,
        4 as libc::c_int as size_t,
    );
    signature[4 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    *nodedata = (*nodedata).offset(4 as libc::c_int as isize);
    if strcmp(signature.as_mut_ptr(), b"XNOD\0" as *const u8 as *const libc::c_char) == 0
    {
        nodetype = NT_XNOD;
    } else if strcmp(
        signature.as_mut_ptr(),
        b"ZNOD\0" as *const u8 as *const libc::c_char,
    ) == 0
    {
        nodetype = NT_ZNOD;
    } else if strcmp(
        signature.as_mut_ptr(),
        b"XGLN\0" as *const u8 as *const libc::c_char,
    ) == 0
    {
        nodetype = NT_XGLN;
    } else if strcmp(
        signature.as_mut_ptr(),
        b"ZGLN\0" as *const u8 as *const libc::c_char,
    ) == 0
    {
        nodetype = NT_ZGLN;
    } else if strcmp(
        signature.as_mut_ptr(),
        b"XGL3\0" as *const u8 as *const libc::c_char,
    ) == 0
    {
        nodetype = NT_XGL3;
    }
    return (if supported[nodetype as usize] != 0 {
        nodetype as libc::c_uint
    } else {
        NT_UNSUPPORTED as libc::c_int as libc::c_uint
    }) as nodetype_t;
}
unsafe extern "C" fn P_LoadExtraVertices(mut data: *mut *mut uint8_t) -> boolean {
    let mut origvrtx: uint32_t = ({
        let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void as *mut uint32_t;
        let mut b: uint32_t = 0;
        memcpy(
            &mut b as *mut uint32_t as *mut libc::c_void,
            *data as *const libc::c_void,
            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    });
    let mut xtrvrtx: uint32_t = ({
        let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void as *mut uint32_t;
        let mut b: uint32_t = 0;
        memcpy(
            &mut b as *mut uint32_t as *mut libc::c_void,
            *data as *const libc::c_void,
            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    });
    let mut ld: *mut line_t = lines;
    let mut oldpos: *mut vertex_t = vertexes;
    let mut offset: ssize_t = 0;
    let mut i: size_t = 0;
    if numvertexes != origvrtx as size_t {
        CONS_Alert(
            CONS_WARNING,
            b"Vertex count in map data and nodes differ!\n\0" as *const u8
                as *const libc::c_char,
        );
        return false_0 as libc::c_int;
    }
    if xtrvrtx == 0 {
        return true_0 as libc::c_int;
    }
    numvertexes = numvertexes.wrapping_add(xtrvrtx as size_t);
    vertexes = Z_ReallocAlign(
        vertexes as *mut libc::c_void,
        numvertexes.wrapping_mul(::core::mem::size_of::<vertex_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut vertex_t;
    offset = vertexes.offset_from(oldpos) as libc::c_long as size_t as ssize_t;
    i = 0 as libc::c_int as size_t;
    ld = lines;
    while i < numlines {
        (*ld).v1 = ((*ld).v1).offset(offset as isize);
        (*ld).v2 = ((*ld).v2).offset(offset as isize);
        i = i.wrapping_add(1);
        i;
        ld = ld.offset(1);
        ld;
    }
    i = origvrtx as size_t;
    while i < numvertexes {
        (*vertexes.offset(i as isize))
            .x = ({
            let mut p_tmp: *mut fixed_t = *data as *mut libc::c_void as *mut fixed_t;
            let mut b: fixed_t = 0;
            memcpy(
                &mut b as *mut fixed_t as *mut libc::c_void,
                *data as *const libc::c_void,
                ::core::mem::size_of::<fixed_t>() as libc::c_ulong,
            );
            p_tmp = p_tmp.offset(1);
            p_tmp;
            *data = p_tmp as *mut libc::c_void as *mut uint8_t;
            b
        });
        (*vertexes.offset(i as isize))
            .y = ({
            let mut p_tmp: *mut fixed_t = *data as *mut libc::c_void as *mut fixed_t;
            let mut b: fixed_t = 0;
            memcpy(
                &mut b as *mut fixed_t as *mut libc::c_void,
                *data as *const libc::c_void,
                ::core::mem::size_of::<fixed_t>() as libc::c_ulong,
            );
            p_tmp = p_tmp.offset(1);
            p_tmp;
            *data = p_tmp as *mut libc::c_void as *mut uint8_t;
            b
        });
        i = i.wrapping_add(1);
        i;
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_LoadExtendedSubsectorsAndSegs(
    mut data: *mut *mut uint8_t,
    mut nodetype: nodetype_t,
) -> boolean {
    let mut i: size_t = 0;
    let mut k: size_t = 0;
    let mut m: int16_t = 0;
    let mut seg: *mut seg_t = 0 as *mut seg_t;
    numsubsectors = ({
        let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void as *mut uint32_t;
        let mut b: uint32_t = 0;
        memcpy(
            &mut b as *mut uint32_t as *mut libc::c_void,
            *data as *const libc::c_void,
            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    }) as size_t;
    subsectors = Z_CallocAlign(
        numsubsectors
            .wrapping_mul(::core::mem::size_of::<subsector_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut subsector_t;
    i = 0 as libc::c_int as size_t;
    while i < numsubsectors {
        (*subsectors.offset(i as isize))
            .numlines = ({
            let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void as *mut uint32_t;
            let mut b: uint32_t = 0;
            memcpy(
                &mut b as *mut uint32_t as *mut libc::c_void,
                *data as *const libc::c_void,
                ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
            );
            p_tmp = p_tmp.offset(1);
            p_tmp;
            *data = p_tmp as *mut libc::c_void as *mut uint8_t;
            b
        }) as int16_t;
        i = i.wrapping_add(1);
        i;
    }
    numsegs = ({
        let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void as *mut uint32_t;
        let mut b: uint32_t = 0;
        memcpy(
            &mut b as *mut uint32_t as *mut libc::c_void,
            *data as *const libc::c_void,
            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    }) as size_t;
    segs = Z_CallocAlign(
        numsegs.wrapping_mul(::core::mem::size_of::<seg_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut seg_t;
    i = 0 as libc::c_int as size_t;
    k = 0 as libc::c_int as size_t;
    while i < numsubsectors {
        (*subsectors.offset(i as isize)).firstline = k as uint32_t;
        P_InitializeSubsector(&mut *subsectors.offset(i as isize));
        match nodetype as libc::c_uint {
            3 | 7 => {
                m = 0 as libc::c_int as int16_t;
                while (m as libc::c_int)
                    < (*subsectors.offset(i as isize)).numlines as libc::c_int
                {
                    let mut vertexnum: uint32_t = ({
                        let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void
                            as *mut uint32_t;
                        let mut b: uint32_t = 0;
                        memcpy(
                            &mut b as *mut uint32_t as *mut libc::c_void,
                            *data as *const libc::c_void,
                            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                        );
                        p_tmp = p_tmp.offset(1);
                        p_tmp;
                        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                        b
                    });
                    let mut linenum: uint16_t = 0;
                    if vertexnum as size_t >= numvertexes {
                        I_Error(
                            b"P_LoadExtendedSubsectorsAndSegs: Seg %s in subsector %d has invalid vertex %d!\n\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(k),
                            m as libc::c_int,
                            vertexnum,
                        );
                    }
                    let ref mut fresh72 = (*segs.offset(k as isize)).v1;
                    *fresh72 = &mut *vertexes.offset(vertexnum as isize)
                        as *mut vertex_t;
                    let ref mut fresh73 = (*segs
                        .offset(
                            k
                                .wrapping_sub(1 as libc::c_int as size_t)
                                .wrapping_add(
                                    (if m as libc::c_int == 0 as libc::c_int {
                                        (*subsectors.offset(i as isize)).numlines as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    }) as size_t,
                                ) as isize,
                        ))
                        .v2;
                    *fresh73 = *fresh72;
                    ({
                        let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void
                            as *mut uint32_t;
                        let mut b: uint32_t = 0;
                        memcpy(
                            &mut b as *mut uint32_t as *mut libc::c_void,
                            *data as *const libc::c_void,
                            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                        );
                        p_tmp = p_tmp.offset(1);
                        p_tmp;
                        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                        b
                    });
                    linenum = (if nodetype as libc::c_uint
                        == NT_XGL3 as libc::c_int as libc::c_uint
                    {
                        ({
                            let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void
                                as *mut uint32_t;
                            let mut b: uint32_t = 0;
                            memcpy(
                                &mut b as *mut uint32_t as *mut libc::c_void,
                                *data as *const libc::c_void,
                                ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                            );
                            p_tmp = p_tmp.offset(1);
                            p_tmp;
                            *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                            b
                        })
                    } else {
                        ({
                            let mut p_tmp: *mut uint16_t = *data as *mut libc::c_void
                                as *mut uint16_t;
                            let mut b: uint16_t = 0;
                            memcpy(
                                &mut b as *mut uint16_t as *mut libc::c_void,
                                *data as *const libc::c_void,
                                ::core::mem::size_of::<uint16_t>() as libc::c_ulong,
                            );
                            p_tmp = p_tmp.offset(1);
                            p_tmp;
                            *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                            b
                        }) as uint32_t
                    }) as uint16_t;
                    if linenum as libc::c_int != 0xffff as libc::c_int
                        && linenum as size_t >= numlines
                    {
                        I_Error(
                            b"P_LoadExtendedSubsectorsAndSegs: Seg %s in subsector %s has invalid linedef %d!\n\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(k),
                            sizeu2(i),
                            linenum as libc::c_int,
                        );
                    }
                    (*segs.offset(k as isize))
                        .glseg = (linenum as libc::c_int == 0xffff as libc::c_int)
                        as libc::c_int;
                    let ref mut fresh74 = (*segs.offset(k as isize)).linedef;
                    *fresh74 = if linenum as libc::c_int == 0xffff as libc::c_int {
                        0 as *mut line_t
                    } else {
                        &mut *lines.offset(linenum as isize) as *mut line_t
                    };
                    (*segs.offset(k as isize))
                        .side = ({
                        let mut p_tmp: *mut uint8_t = *data as *mut libc::c_void
                            as *mut uint8_t;
                        let mut b: uint8_t = 0;
                        memcpy(
                            &mut b as *mut uint8_t as *mut libc::c_void,
                            *data as *const libc::c_void,
                            ::core::mem::size_of::<uint8_t>() as libc::c_ulong,
                        );
                        p_tmp = p_tmp.offset(1);
                        p_tmp;
                        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                        b
                    }) as int32_t;
                    m += 1;
                    m;
                    k = k.wrapping_add(1);
                    k;
                }
                while (*segs.offset((*subsectors.offset(i as isize)).firstline as isize))
                    .glseg != 0
                {
                    let ref mut fresh75 = (*subsectors.offset(i as isize)).firstline;
                    *fresh75 = (*fresh75).wrapping_add(1);
                    *fresh75;
                    if (*subsectors.offset(i as isize)).firstline as size_t == k {
                        I_Error(
                            b"P_LoadExtendedSubsectorsAndSegs: Subsector %s does not have any valid segs!\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(i),
                        );
                    }
                }
            }
            1 => {
                m = 0 as libc::c_int as int16_t;
                while (m as libc::c_int)
                    < (*subsectors.offset(i as isize)).numlines as libc::c_int
                {
                    let mut v1num: uint32_t = ({
                        let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void
                            as *mut uint32_t;
                        let mut b: uint32_t = 0;
                        memcpy(
                            &mut b as *mut uint32_t as *mut libc::c_void,
                            *data as *const libc::c_void,
                            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                        );
                        p_tmp = p_tmp.offset(1);
                        p_tmp;
                        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                        b
                    });
                    let mut v2num: uint32_t = ({
                        let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void
                            as *mut uint32_t;
                        let mut b: uint32_t = 0;
                        memcpy(
                            &mut b as *mut uint32_t as *mut libc::c_void,
                            *data as *const libc::c_void,
                            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                        );
                        p_tmp = p_tmp.offset(1);
                        p_tmp;
                        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                        b
                    });
                    let mut linenum_0: uint16_t = ({
                        let mut p_tmp: *mut uint16_t = *data as *mut libc::c_void
                            as *mut uint16_t;
                        let mut b: uint16_t = 0;
                        memcpy(
                            &mut b as *mut uint16_t as *mut libc::c_void,
                            *data as *const libc::c_void,
                            ::core::mem::size_of::<uint16_t>() as libc::c_ulong,
                        );
                        p_tmp = p_tmp.offset(1);
                        p_tmp;
                        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                        b
                    });
                    if v1num as size_t >= numvertexes {
                        I_Error(
                            b"P_LoadExtendedSubsectorsAndSegs: Seg %s in subsector %d has invalid v1 %d!\n\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(k),
                            m as libc::c_int,
                            v1num,
                        );
                    }
                    if v2num as size_t >= numvertexes {
                        I_Error(
                            b"P_LoadExtendedSubsectorsAndSegs: Seg %s in subsector %d has invalid v2 %d!\n\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(k),
                            m as libc::c_int,
                            v2num,
                        );
                    }
                    if linenum_0 as size_t >= numlines {
                        I_Error(
                            b"P_LoadExtendedSubsectorsAndSegs: Seg %s in subsector %d has invalid linedef %d!\n\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(k),
                            m as libc::c_int,
                            linenum_0 as libc::c_int,
                        );
                    }
                    let ref mut fresh76 = (*segs.offset(k as isize)).v1;
                    *fresh76 = &mut *vertexes.offset(v1num as isize) as *mut vertex_t;
                    let ref mut fresh77 = (*segs.offset(k as isize)).v2;
                    *fresh77 = &mut *vertexes.offset(v2num as isize) as *mut vertex_t;
                    let ref mut fresh78 = (*segs.offset(k as isize)).linedef;
                    *fresh78 = &mut *lines.offset(linenum_0 as isize) as *mut line_t;
                    (*segs.offset(k as isize))
                        .side = ({
                        let mut p_tmp: *mut uint8_t = *data as *mut libc::c_void
                            as *mut uint8_t;
                        let mut b: uint8_t = 0;
                        memcpy(
                            &mut b as *mut uint8_t as *mut libc::c_void,
                            *data as *const libc::c_void,
                            ::core::mem::size_of::<uint8_t>() as libc::c_ulong,
                        );
                        p_tmp = p_tmp.offset(1);
                        p_tmp;
                        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                        b
                    }) as int32_t;
                    (*segs.offset(k as isize)).glseg = false_0 as libc::c_int;
                    m += 1;
                    m;
                    k = k.wrapping_add(1);
                    k;
                }
            }
            _ => return false_0 as libc::c_int,
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    seg = segs;
    while i < numsegs {
        let mut v1: *mut vertex_t = (*seg).v1;
        let mut v2: *mut vertex_t = (*seg).v2;
        P_InitializeSeg(seg);
        (*seg).angle = R_PointToAngle2((*v1).x, (*v1).y, (*v2).x, (*v2).y);
        if !((*seg).linedef).is_null() {
            let mut v: *mut vertex_t = if (*seg).side == 1 as libc::c_int {
                (*(*seg).linedef).v2
            } else {
                (*(*seg).linedef).v1
            };
            (*segs.offset(i as isize))
                .offset = FixedHypot((*v1).x - (*v).x, (*v1).y - (*v).y);
        }
        (*seg).length = P_SegLength(seg);
        i = i.wrapping_add(1);
        i;
        seg = seg.offset(1);
        seg;
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn ShrinkNodeID(mut x: uint32_t) -> uint16_t {
    let mut mask: uint16_t = (x >> 16 as libc::c_int & 0xc000 as libc::c_int as uint32_t)
        as uint16_t;
    let mut result: uint16_t = x as uint16_t;
    return (result as libc::c_int | mask as libc::c_int) as uint16_t;
}
unsafe extern "C" fn P_LoadExtendedNodes(
    mut data: *mut *mut uint8_t,
    mut nodetype: nodetype_t,
) {
    let mut mn: *mut node_t = 0 as *mut node_t;
    let mut i: size_t = 0;
    let mut j: size_t = 0;
    let mut k: size_t = 0;
    let mut xgl3: boolean = (nodetype as libc::c_uint
        == NT_XGL3 as libc::c_int as libc::c_uint) as libc::c_int;
    numnodes = ({
        let mut p_tmp: *mut int32_t = *data as *mut libc::c_void as *mut int32_t;
        let mut b: int32_t = 0;
        memcpy(
            &mut b as *mut int32_t as *mut libc::c_void,
            *data as *const libc::c_void,
            ::core::mem::size_of::<int32_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        *data = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    }) as size_t;
    nodes = Z_CallocAlign(
        numnodes.wrapping_mul(::core::mem::size_of::<node_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut node_t;
    i = 0 as libc::c_int as size_t;
    mn = nodes;
    while i < numnodes {
        (*mn)
            .x = if xgl3 != 0 {
            ({
                let mut p_tmp: *mut int32_t = *data as *mut libc::c_void as *mut int32_t;
                let mut b: int32_t = 0;
                memcpy(
                    &mut b as *mut int32_t as *mut libc::c_void,
                    *data as *const libc::c_void,
                    ::core::mem::size_of::<int32_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            })
        } else {
            (({
                let mut p_tmp: *mut int16_t = *data as *mut libc::c_void as *mut int16_t;
                let mut b: int16_t = 0;
                memcpy(
                    &mut b as *mut int16_t as *mut libc::c_void,
                    *data as *const libc::c_void,
                    ::core::mem::size_of::<int16_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            }) as libc::c_int) << 16 as libc::c_int
        };
        (*mn)
            .y = if xgl3 != 0 {
            ({
                let mut p_tmp: *mut int32_t = *data as *mut libc::c_void as *mut int32_t;
                let mut b: int32_t = 0;
                memcpy(
                    &mut b as *mut int32_t as *mut libc::c_void,
                    *data as *const libc::c_void,
                    ::core::mem::size_of::<int32_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            })
        } else {
            (({
                let mut p_tmp: *mut int16_t = *data as *mut libc::c_void as *mut int16_t;
                let mut b: int16_t = 0;
                memcpy(
                    &mut b as *mut int16_t as *mut libc::c_void,
                    *data as *const libc::c_void,
                    ::core::mem::size_of::<int16_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            }) as libc::c_int) << 16 as libc::c_int
        };
        (*mn)
            .dx = if xgl3 != 0 {
            ({
                let mut p_tmp: *mut int32_t = *data as *mut libc::c_void as *mut int32_t;
                let mut b: int32_t = 0;
                memcpy(
                    &mut b as *mut int32_t as *mut libc::c_void,
                    *data as *const libc::c_void,
                    ::core::mem::size_of::<int32_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            })
        } else {
            (({
                let mut p_tmp: *mut int16_t = *data as *mut libc::c_void as *mut int16_t;
                let mut b: int16_t = 0;
                memcpy(
                    &mut b as *mut int16_t as *mut libc::c_void,
                    *data as *const libc::c_void,
                    ::core::mem::size_of::<int16_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            }) as libc::c_int) << 16 as libc::c_int
        };
        (*mn)
            .dy = if xgl3 != 0 {
            ({
                let mut p_tmp: *mut int32_t = *data as *mut libc::c_void as *mut int32_t;
                let mut b: int32_t = 0;
                memcpy(
                    &mut b as *mut int32_t as *mut libc::c_void,
                    *data as *const libc::c_void,
                    ::core::mem::size_of::<int32_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            })
        } else {
            (({
                let mut p_tmp: *mut int16_t = *data as *mut libc::c_void as *mut int16_t;
                let mut b: int16_t = 0;
                memcpy(
                    &mut b as *mut int16_t as *mut libc::c_void,
                    *data as *const libc::c_void,
                    ::core::mem::size_of::<int16_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            }) as libc::c_int) << 16 as libc::c_int
        };
        j = 0 as libc::c_int as size_t;
        while j < 2 as libc::c_int as size_t {
            k = 0 as libc::c_int as size_t;
            while k < 4 as libc::c_int as size_t {
                (*mn)
                    .bbox[j
                    as usize][k
                    as usize] = (({
                    let mut p_tmp: *mut int16_t = *data as *mut libc::c_void
                        as *mut int16_t;
                    let mut b: int16_t = 0;
                    memcpy(
                        &mut b as *mut int16_t as *mut libc::c_void,
                        *data as *const libc::c_void,
                        ::core::mem::size_of::<int16_t>() as libc::c_ulong,
                    );
                    p_tmp = p_tmp.offset(1);
                    p_tmp;
                    *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                    b
                }) as libc::c_int) << 16 as libc::c_int;
                k = k.wrapping_add(1);
                k;
            }
            j = j.wrapping_add(1);
            j;
        }
        (*mn)
            .children[0 as libc::c_int
            as usize] = ShrinkNodeID(
            ({
                let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void
                    as *mut uint32_t;
                let mut b: uint32_t = 0;
                memcpy(
                    &mut b as *mut uint32_t as *mut libc::c_void,
                    *data as *const libc::c_void,
                    ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            }),
        );
        (*mn)
            .children[1 as libc::c_int
            as usize] = ShrinkNodeID(
            ({
                let mut p_tmp: *mut uint32_t = *data as *mut libc::c_void
                    as *mut uint32_t;
                let mut b: uint32_t = 0;
                memcpy(
                    &mut b as *mut uint32_t as *mut libc::c_void,
                    *data as *const libc::c_void,
                    ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                *data = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            }),
        );
        i = i.wrapping_add(1);
        i;
        mn = mn.offset(1);
        mn;
    }
}
unsafe extern "C" fn P_LoadMapBSP(mut virt: *const virtres_t) {
    let mut nodedata: *mut uint8_t = 0 as *mut uint8_t;
    let mut nodetype: nodetype_t = P_GetNodetype(virt, &mut nodedata);
    match nodetype as libc::c_uint {
        0 => {
            let mut virtssectors: *mut virtlump_t = vres_Find(
                virt,
                b"SSECTORS\0" as *const u8 as *const libc::c_char,
            );
            let mut virtnodes: *mut virtlump_t = vres_Find(
                virt,
                b"NODES\0" as *const u8 as *const libc::c_char,
            );
            let mut virtsegs: *mut virtlump_t = vres_Find(
                virt,
                b"SEGS\0" as *const u8 as *const libc::c_char,
            );
            numsubsectors = ((*virtssectors).size)
                .wrapping_div(::core::mem::size_of::<mapsubsector_t>() as libc::c_ulong);
            numnodes = ((*virtnodes).size)
                .wrapping_div(::core::mem::size_of::<mapnode_t>() as libc::c_ulong);
            numsegs = ((*virtsegs).size)
                .wrapping_div(::core::mem::size_of::<mapseg_t>() as libc::c_ulong);
            if numsubsectors <= 0 as libc::c_int as size_t {
                I_Error(
                    b"Level has no subsectors (did you forget to run it through a nodesbuilder?)\0"
                        as *const u8 as *const libc::c_char,
                );
            }
            if numnodes <= 0 as libc::c_int as size_t {
                I_Error(
                    b"Level has no nodes (does your map have at least 2 sectors?)\0"
                        as *const u8 as *const libc::c_char,
                );
            }
            if numsegs <= 0 as libc::c_int as size_t {
                I_Error(b"Level has no segs\0" as *const u8 as *const libc::c_char);
            }
            subsectors = Z_CallocAlign(
                numsubsectors
                    .wrapping_mul(
                        ::core::mem::size_of::<subsector_t>() as libc::c_ulong,
                    ),
                PU_LEVEL as libc::c_int,
                0 as *mut libc::c_void,
                ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
            ) as *mut subsector_t;
            nodes = Z_CallocAlign(
                numnodes.wrapping_mul(::core::mem::size_of::<node_t>() as libc::c_ulong),
                PU_LEVEL as libc::c_int,
                0 as *mut libc::c_void,
                ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
            ) as *mut node_t;
            segs = Z_CallocAlign(
                numsegs.wrapping_mul(::core::mem::size_of::<seg_t>() as libc::c_ulong),
                PU_LEVEL as libc::c_int,
                0 as *mut libc::c_void,
                ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
            ) as *mut seg_t;
            P_LoadSubsectors((*virtssectors).data);
            P_LoadNodes((*virtnodes).data);
            P_LoadSegs((*virtsegs).data);
        }
        1 | 3 | 7 => {
            if P_LoadExtraVertices(&mut nodedata) == 0 {
                return;
            }
            if P_LoadExtendedSubsectorsAndSegs(&mut nodedata, nodetype) == 0 {
                return;
            }
            P_LoadExtendedNodes(&mut nodedata, nodetype);
        }
        _ => {
            CONS_Alert(
                CONS_WARNING,
                b"Unsupported BSP format detected.\n\0" as *const u8
                    as *const libc::c_char,
            );
            return;
        }
    };
}
unsafe extern "C" fn P_ReadBlockMapLump(
    mut wadblockmaplump: *mut int16_t,
    mut count: size_t,
) {
    let mut i: size_t = 0;
    blockmaplump = Z_CallocAlign(
        (::core::mem::size_of::<int32_t>() as libc::c_ulong).wrapping_mul(count),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut int32_t;
    *blockmaplump
        .offset(
            0 as libc::c_int as isize,
        ) = *wadblockmaplump.offset(0 as libc::c_int as isize) as int32_t;
    *blockmaplump
        .offset(
            1 as libc::c_int as isize,
        ) = *wadblockmaplump.offset(1 as libc::c_int as isize) as int32_t;
    *blockmaplump
        .offset(
            2 as libc::c_int as isize,
        ) = *wadblockmaplump.offset(2 as libc::c_int as isize) as int32_t
        & 0xffff as libc::c_int;
    *blockmaplump
        .offset(
            3 as libc::c_int as isize,
        ) = *wadblockmaplump.offset(3 as libc::c_int as isize) as int32_t
        & 0xffff as libc::c_int;
    i = 4 as libc::c_int as size_t;
    while i < count {
        let mut t: int16_t = *wadblockmaplump.offset(i as isize);
        *blockmaplump
            .offset(
                i as isize,
            ) = if t as libc::c_int == -(1 as libc::c_int) {
            -(1 as libc::c_int)
        } else {
            t as int32_t & 0xffff as libc::c_int
        };
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn P_LoadBlockMap(
    mut data: *mut uint8_t,
    mut count: size_t,
) -> boolean {
    if count == 0 || count >= 0x20000 as libc::c_int as size_t {
        return false_0 as libc::c_int;
    }
    count = count / 2 as libc::c_int as size_t;
    P_ReadBlockMapLump(data as *mut int16_t, count);
    bmaporgx = *blockmaplump.offset(0 as libc::c_int as isize) << 16 as libc::c_int;
    bmaporgy = *blockmaplump.offset(1 as libc::c_int as isize) << 16 as libc::c_int;
    bmapwidth = *blockmaplump.offset(2 as libc::c_int as isize);
    bmapheight = *blockmaplump.offset(3 as libc::c_int as isize);
    count = (::core::mem::size_of::<*mut mobj_t>() as libc::c_ulong)
        .wrapping_mul(bmapwidth as libc::c_ulong)
        .wrapping_mul(bmapheight as libc::c_ulong);
    blocklinks = Z_CallocAlign(
        count,
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut *mut mobj_t;
    blockmap = blockmaplump.offset(4 as libc::c_int as isize);
    count = (::core::mem::size_of::<*mut polymaplink_t>() as libc::c_ulong)
        .wrapping_mul(bmapwidth as libc::c_ulong)
        .wrapping_mul(bmapheight as libc::c_ulong);
    polyblocklinks = Z_CallocAlign(
        count,
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut *mut polymaplink_t;
    return true_0 as libc::c_int;
}
unsafe extern "C" fn LineInBlock(
    mut cx1: fixed_t,
    mut cy1: fixed_t,
    mut cx2: fixed_t,
    mut cy2: fixed_t,
    mut bx1: fixed_t,
    mut by1: fixed_t,
) -> boolean {
    let mut bbox: [fixed_t; 4] = [0; 4];
    let mut testline: line_t = line_s {
        v1: 0 as *mut vertex_t,
        v2: 0 as *mut vertex_t,
        dx: 0,
        dy: 0,
        angle: 0,
        flags: 0,
        special: 0,
        tags: taglist_t {
            tags: 0 as *mut mtag_t,
            count: 0,
        },
        args: [0; 10],
        stringargs: [0 as *mut libc::c_char; 2],
        sidenum: [0; 2],
        alpha: 0,
        blendmode: 0,
        executordelay: 0,
        bbox: [0; 4],
        slopetype: ST_HORIZONTAL,
        frontsector: 0 as *mut sector_t,
        backsector: 0 as *mut sector_t,
        validcount: 0,
        polyobj: 0 as *mut polyobj_t,
        callcount: 0,
    };
    let mut vtest: vertex_t = vertex_t {
        x: 0,
        y: 0,
        floorzset: 0,
        ceilingzset: 0,
        floorz: 0,
        ceilingz: 0,
    };
    bbox[BOXRIGHT as libc::c_int as usize] = bx1 + 128 as libc::c_int;
    bbox[BOXTOP as libc::c_int as usize] = by1 + 128 as libc::c_int;
    bbox[BOXLEFT as libc::c_int as usize] = bx1;
    bbox[BOXBOTTOM as libc::c_int as usize] = by1;
    if cx1 < bbox[BOXLEFT as libc::c_int as usize]
        && cx2 < bbox[BOXLEFT as libc::c_int as usize]
    {
        return false_0 as libc::c_int;
    }
    if cx1 > bbox[BOXRIGHT as libc::c_int as usize]
        && cx2 > bbox[BOXRIGHT as libc::c_int as usize]
    {
        return false_0 as libc::c_int;
    }
    if cy1 < bbox[BOXBOTTOM as libc::c_int as usize]
        && cy2 < bbox[BOXBOTTOM as libc::c_int as usize]
    {
        return false_0 as libc::c_int;
    }
    if cy1 > bbox[BOXTOP as libc::c_int as usize]
        && cy2 > bbox[BOXTOP as libc::c_int as usize]
    {
        return false_0 as libc::c_int;
    }
    cx1 <<= 16 as libc::c_int;
    cy1 <<= 16 as libc::c_int;
    cx2 <<= 16 as libc::c_int;
    cy2 <<= 16 as libc::c_int;
    bbox[BOXTOP as libc::c_int as usize] <<= 16 as libc::c_int;
    bbox[BOXBOTTOM as libc::c_int as usize] <<= 16 as libc::c_int;
    bbox[BOXLEFT as libc::c_int as usize] <<= 16 as libc::c_int;
    bbox[BOXRIGHT as libc::c_int as usize] <<= 16 as libc::c_int;
    testline.v1 = &mut vtest;
    (*testline.v1).x = cx1;
    (*testline.v1).y = cy1;
    testline.dx = cx2 - cx1;
    testline.dy = cy2 - cy1;
    if (testline.dx > 0 as libc::c_int) as libc::c_int
        ^ (testline.dy > 0 as libc::c_int) as libc::c_int != 0
    {
        testline.slopetype = ST_NEGATIVE;
    } else {
        testline.slopetype = ST_POSITIVE;
    }
    return (P_BoxOnLineSide(bbox.as_mut_ptr(), &mut testline) == -(1 as libc::c_int))
        as libc::c_int;
}
unsafe extern "C" fn P_CreateBlockMap() {
    let mut i: size_t = 0;
    let mut minx: fixed_t = 2147483647 as libc::c_int;
    let mut miny: fixed_t = 2147483647 as libc::c_int;
    let mut maxx: fixed_t = -(2147483647 as libc::c_int) - 1 as libc::c_int;
    let mut maxy: fixed_t = -(2147483647 as libc::c_int) - 1 as libc::c_int;
    i = 0 as libc::c_int as size_t;
    while i < numvertexes {
        if ((*vertexes.offset(i as isize)).x >> 16 as libc::c_int) < minx {
            minx = (*vertexes.offset(i as isize)).x >> 16 as libc::c_int;
        } else if (*vertexes.offset(i as isize)).x >> 16 as libc::c_int > maxx {
            maxx = (*vertexes.offset(i as isize)).x >> 16 as libc::c_int;
        }
        if ((*vertexes.offset(i as isize)).y >> 16 as libc::c_int) < miny {
            miny = (*vertexes.offset(i as isize)).y >> 16 as libc::c_int;
        } else if (*vertexes.offset(i as isize)).y >> 16 as libc::c_int > maxy {
            maxy = (*vertexes.offset(i as isize)).y >> 16 as libc::c_int;
        }
        i = i.wrapping_add(1);
        i;
    }
    bmaporgx = minx << 16 as libc::c_int;
    bmaporgy = miny << 16 as libc::c_int;
    bmapwidth = (maxx - minx >> 16 as libc::c_int + 7 as libc::c_int - 16 as libc::c_int)
        + 1 as libc::c_int;
    bmapheight = (maxy - miny
        >> 16 as libc::c_int + 7 as libc::c_int - 16 as libc::c_int) + 1 as libc::c_int;
    let mut tot: size_t = (bmapwidth * bmapheight) as size_t;
    let mut bmap: *mut bmap_t = calloc(
        tot,
        ::core::mem::size_of::<bmap_t>() as libc::c_ulong,
    ) as *mut bmap_t;
    let mut straight: boolean = 0;
    if bmap.is_null() {
        I_Error(
            b"%s: Out of memory making blockmap\0" as *const u8 as *const libc::c_char,
            b"P_CreateBlockMap\0" as *const u8 as *const libc::c_char,
        );
    }
    i = 0 as libc::c_int as size_t;
    while i < numlines {
        let mut x: int32_t = ((*(*lines.offset(i as isize)).v1).x >> 16 as libc::c_int)
            - minx;
        let mut y: int32_t = ((*(*lines.offset(i as isize)).v1).y >> 16 as libc::c_int)
            - miny;
        let mut bxstart: int32_t = 0;
        let mut bxend: int32_t = 0;
        let mut bystart: int32_t = 0;
        let mut byend: int32_t = 0;
        let mut v2x: int32_t = 0;
        let mut v2y: int32_t = 0;
        let mut curblockx: int32_t = 0;
        let mut curblocky: int32_t = 0;
        v2x = (*(*lines.offset(i as isize)).v2).x >> 16 as libc::c_int;
        v2y = (*(*lines.offset(i as isize)).v2).y >> 16 as libc::c_int;
        bxstart = x >> 16 as libc::c_int + 7 as libc::c_int - 16 as libc::c_int;
        bystart = y >> 16 as libc::c_int + 7 as libc::c_int - 16 as libc::c_int;
        v2x -= minx;
        v2y -= miny;
        bxend = v2x >> 16 as libc::c_int + 7 as libc::c_int - 16 as libc::c_int;
        byend = v2y >> 16 as libc::c_int + 7 as libc::c_int - 16 as libc::c_int;
        if bxend < bxstart {
            let mut temp: int32_t = bxstart;
            bxstart = bxend;
            bxend = temp;
        }
        if byend < bystart {
            let mut temp_0: int32_t = bystart;
            bystart = byend;
            byend = temp_0;
        }
        if (*(*lines.offset(i as isize)).v1).y == (*(*lines.offset(i as isize)).v2).y {
            straight = true_0 as libc::c_int;
            bystart -= 1;
            bystart;
            byend += 1;
            byend;
        } else if (*(*lines.offset(i as isize)).v1).x
            == (*(*lines.offset(i as isize)).v2).x
        {
            straight = true_0 as libc::c_int;
            bxstart -= 1;
            bxstart;
            bxend += 1;
            bxend;
        } else {
            straight = false_0 as libc::c_int;
        }
        curblockx = bxstart;
        while curblockx <= bxend {
            curblocky = bystart;
            while curblocky <= byend {
                let mut b: size_t = (curblocky * bmapwidth + curblockx) as size_t;
                if !(b >= tot) {
                    if !(straight == 0
                        && LineInBlock(
                            x,
                            y,
                            v2x,
                            v2y,
                            curblockx
                                << 16 as libc::c_int + 7 as libc::c_int - 16 as libc::c_int,
                            curblocky
                                << 16 as libc::c_int + 7 as libc::c_int - 16 as libc::c_int,
                        ) == 0)
                    {
                        if (*bmap.offset(b as isize)).n
                            >= (*bmap.offset(b as isize)).nalloc
                        {
                            if (*bmap.offset(b as isize)).nalloc == 0 as libc::c_int {
                                (*bmap.offset(b as isize)).nalloc = 8 as libc::c_int;
                            } else {
                                let ref mut fresh79 = (*bmap.offset(b as isize)).nalloc;
                                *fresh79 *= 2 as libc::c_int;
                            }
                            let ref mut fresh80 = (*bmap.offset(b as isize)).list;
                            *fresh80 = Z_ReallocAlign(
                                (*bmap.offset(b as isize)).list as *mut libc::c_void,
                                ((*bmap.offset(b as isize)).nalloc as libc::c_ulong)
                                    .wrapping_mul(
                                        ::core::mem::size_of::<int32_t>() as libc::c_ulong,
                                    ),
                                PU_CACHE as libc::c_int,
                                &mut (*bmap.offset(b as isize)).list as *mut *mut int32_t
                                    as *mut libc::c_void,
                                ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong
                                    as int32_t,
                            ) as *mut int32_t;
                            if ((*bmap.offset(b as isize)).list).is_null() {
                                I_Error(
                                    b"Out of Memory in P_CreateBlockMap\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                        }
                        let ref mut fresh81 = (*bmap.offset(b as isize)).n;
                        let fresh82 = *fresh81;
                        *fresh81 = *fresh81 + 1;
                        *((*bmap.offset(b as isize)).list)
                            .offset(fresh82 as isize) = i as int32_t;
                    }
                }
                curblocky += 1;
                curblocky;
            }
            curblockx += 1;
            curblockx;
        }
        i = i.wrapping_add(1);
        i;
    }
    let mut count: size_t = tot.wrapping_add(6 as libc::c_int as size_t);
    i = 0 as libc::c_int as size_t;
    while i < tot {
        if (*bmap.offset(i as isize)).n != 0 {
            count = count
                .wrapping_add(
                    ((*bmap.offset(i as isize)).n + 2 as libc::c_int) as size_t,
                );
        }
        i = i.wrapping_add(1);
        i;
    }
    blockmaplump = Z_CallocAlign(
        (::core::mem::size_of::<int32_t>() as libc::c_ulong).wrapping_mul(count),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut int32_t;
    tot = tot.wrapping_add(4 as libc::c_int as size_t);
    let mut ndx: size_t = tot;
    let mut bp: *mut bmap_t = bmap;
    let fresh83 = ndx;
    ndx = ndx.wrapping_add(1);
    *blockmaplump.offset(fresh83 as isize) = 0 as libc::c_int;
    let fresh84 = ndx;
    ndx = ndx.wrapping_add(1);
    *blockmaplump.offset(fresh84 as isize) = -(1 as libc::c_int);
    i = 4 as libc::c_int as size_t;
    while i < tot {
        if (*bp).n != 0 {
            let fresh85 = ndx;
            ndx = ndx.wrapping_add(1);
            let ref mut fresh86 = *blockmaplump.offset(i as isize);
            *fresh86 = fresh85 as int32_t;
            *blockmaplump.offset(*fresh86 as isize) = 0 as libc::c_int;
            loop {
                (*bp).n -= 1;
                let fresh87 = ndx;
                ndx = ndx.wrapping_add(1);
                *blockmaplump
                    .offset(fresh87 as isize) = *((*bp).list).offset((*bp).n as isize);
                if !((*bp).n != 0) {
                    break;
                }
            }
            let fresh88 = ndx;
            ndx = ndx.wrapping_add(1);
            *blockmaplump.offset(fresh88 as isize) = -(1 as libc::c_int);
            Z_Free((*bp).list as *mut libc::c_void);
        } else {
            *blockmaplump.offset(i as isize) = tot as int32_t;
        }
        i = i.wrapping_add(1);
        i;
        bp = bp.offset(1);
        bp;
    }
    free(bmap as *mut libc::c_void);
    let mut count_0: size_t = (::core::mem::size_of::<*mut mobj_t>() as libc::c_ulong)
        .wrapping_mul(bmapwidth as libc::c_ulong)
        .wrapping_mul(bmapheight as libc::c_ulong);
    blocklinks = Z_CallocAlign(
        count_0,
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut *mut mobj_t;
    blockmap = blockmaplump.offset(4 as libc::c_int as isize);
    count_0 = (::core::mem::size_of::<*mut polymaplink_t>() as libc::c_ulong)
        .wrapping_mul(bmapwidth as libc::c_ulong)
        .wrapping_mul(bmapheight as libc::c_ulong);
    polyblocklinks = Z_CallocAlign(
        count_0,
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut *mut polymaplink_t;
}
unsafe extern "C" fn P_LoadReject(mut data: *mut uint8_t, mut count: size_t) {
    if count == 0 {
        rejectmatrix = 0 as *mut uint8_t;
        CONS_Debug(
            0x400 as libc::c_int,
            b"P_LoadReject: REJECT lump has size 0, will not be loaded\n\0" as *const u8
                as *const libc::c_char,
        );
    } else {
        rejectmatrix = Z_MallocAlign(
            count,
            PU_LEVEL as libc::c_int,
            0 as *mut libc::c_void,
            ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
        ) as *mut uint8_t;
        M_Memcpy
            .expect(
                "non-null function pointer",
            )(rejectmatrix as *mut libc::c_void, data as *const libc::c_void, count);
    };
}
unsafe extern "C" fn P_LoadMapLUT(mut virt: *const virtres_t) {
    let mut virtblockmap: *mut virtlump_t = vres_Find(
        virt,
        b"BLOCKMAP\0" as *const u8 as *const libc::c_char,
    );
    let mut virtreject: *mut virtlump_t = vres_Find(
        virt,
        b"REJECT\0" as *const u8 as *const libc::c_char,
    );
    if !virtreject.is_null() {
        P_LoadReject((*virtreject).data, (*virtreject).size);
    } else {
        rejectmatrix = 0 as *mut uint8_t;
    }
    if !(!virtblockmap.is_null()
        && P_LoadBlockMap((*virtblockmap).data, (*virtblockmap).size) != 0)
    {
        P_CreateBlockMap();
    }
}
unsafe extern "C" fn P_LinkMapData() {
    let mut i: size_t = 0;
    let mut j: size_t = 0;
    let mut li: *mut line_t = 0 as *mut line_t;
    let mut sector: *mut sector_t = 0 as *mut sector_t;
    let mut ss: *mut subsector_t = subsectors;
    let mut sidei: size_t = 0;
    let mut seg: *mut seg_t = 0 as *mut seg_t;
    let mut bbox: [fixed_t; 4] = [0; 4];
    i = 0 as libc::c_int as size_t;
    while i < numsubsectors {
        if (*ss).firstline as size_t >= numsegs {
            CorruptMapError(
                va(
                    b"P_LinkMapData: ss->firstline invalid (subsector %s, firstline refers to %d of %s)\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                    (*ss).firstline,
                    sizeu2(numsegs),
                ),
            );
        }
        seg = &mut *segs.offset((*ss).firstline as isize) as *mut seg_t;
        sidei = ((*seg).sidedef).offset_from(sides) as libc::c_long as size_t;
        if ((*seg).sidedef).is_null() {
            CorruptMapError(
                va(
                    b"P_LinkMapData: seg->sidedef is NULL (subsector %s, firstline is %d)\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                    (*ss).firstline,
                ),
            );
        }
        if (((*seg).sidedef).offset_from(sides) as libc::c_long)
            < 0 as libc::c_int as libc::c_long
            || ((*seg).sidedef).offset_from(sides) as libc::c_long
                > numsides as uint16_t as libc::c_long
        {
            CorruptMapError(
                va(
                    b"P_LinkMapData: seg->sidedef refers to sidedef %s of %s (subsector %s, firstline is %d)\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(sidei),
                    sizeu2(numsides),
                    sizeu3(i),
                    (*ss).firstline,
                ),
            );
        }
        if ((*(*seg).sidedef).sector).is_null() {
            CorruptMapError(
                va(
                    b"P_LinkMapData: seg->sidedef->sector is NULL (subsector %s, firstline is %d, sidedef is %s)\0"
                        as *const u8 as *const libc::c_char,
                    sizeu1(i),
                    (*ss).firstline,
                    sizeu1(sidei),
                ),
            );
        }
        (*ss).sector = (*(*seg).sidedef).sector;
        i = i.wrapping_add(1);
        i;
        ss = ss.offset(1);
        ss;
    }
    i = 0 as libc::c_int as size_t;
    li = lines;
    while i < numlines {
        (*(*li).frontsector)
            .linecount = ((*(*li).frontsector).linecount).wrapping_add(1);
        (*(*li).frontsector).linecount;
        if !((*li).backsector).is_null() && (*li).backsector != (*li).frontsector {
            (*(*li).backsector)
                .linecount = ((*(*li).backsector).linecount).wrapping_add(1);
            (*(*li).backsector).linecount;
        }
        i = i.wrapping_add(1);
        i;
        li = li.offset(1);
        li;
    }
    i = 0 as libc::c_int as size_t;
    sector = sectors;
    while i < numsectors {
        if (*sector).linecount == 0 as libc::c_int as size_t {
            (*sector).lines = 0 as *mut *mut line_s;
            CONS_Debug(
                0x400 as libc::c_int,
                b"P_LinkMapData: sector %s has no lines\n\0" as *const u8
                    as *const libc::c_char,
                sizeu1(i),
            );
        } else {
            (*sector)
                .lines = Z_CallocAlign(
                ((*sector).linecount)
                    .wrapping_mul(
                        ::core::mem::size_of::<*mut line_t>() as libc::c_ulong,
                    ),
                PU_LEVEL as libc::c_int,
                0 as *mut libc::c_void,
                ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
            ) as *mut *mut line_s;
            (*sector).linecount = 0 as libc::c_int as size_t;
        }
        i = i.wrapping_add(1);
        i;
        sector = sector.offset(1);
        sector;
    }
    i = 0 as libc::c_int as size_t;
    li = lines;
    while i < numlines {
        let fresh89 = (*(*li).frontsector).linecount;
        (*(*li).frontsector)
            .linecount = ((*(*li).frontsector).linecount).wrapping_add(1);
        let ref mut fresh90 = *((*(*li).frontsector).lines).offset(fresh89 as isize);
        *fresh90 = li;
        if !((*li).backsector).is_null() && (*li).backsector != (*li).frontsector {
            let fresh91 = (*(*li).backsector).linecount;
            (*(*li).backsector)
                .linecount = ((*(*li).backsector).linecount).wrapping_add(1);
            let ref mut fresh92 = *((*(*li).backsector).lines).offset(fresh91 as isize);
            *fresh92 = li;
        }
        i = i.wrapping_add(1);
        i;
        li = li.offset(1);
        li;
    }
    i = 0 as libc::c_int as size_t;
    sector = sectors;
    while i < numsectors {
        M_ClearBox(bbox.as_mut_ptr());
        if (*sector).linecount != 0 as libc::c_int as size_t {
            j = 0 as libc::c_int as size_t;
            while j < (*sector).linecount {
                li = *((*sector).lines).offset(j as isize);
                M_AddToBox(bbox.as_mut_ptr(), (*(*li).v1).x, (*(*li).v1).y);
                M_AddToBox(bbox.as_mut_ptr(), (*(*li).v2).x, (*(*li).v2).y);
                j = j.wrapping_add(1);
                j;
            }
        }
        (*sector)
            .soundorg
            .x = (((bbox[BOXRIGHT as libc::c_int as usize] >> 16 as libc::c_int)
            + (bbox[BOXLEFT as libc::c_int as usize] >> 16 as libc::c_int))
            / 2 as libc::c_int) << 16 as libc::c_int;
        (*sector)
            .soundorg
            .y = (((bbox[BOXTOP as libc::c_int as usize] >> 16 as libc::c_int)
            + (bbox[BOXBOTTOM as libc::c_int as usize] >> 16 as libc::c_int))
            / 2 as libc::c_int) << 16 as libc::c_int;
        (*sector).soundorg.z = (*sector).floorheight;
        i = i.wrapping_add(1);
        i;
        sector = sector.offset(1);
        sector;
    }
}
unsafe extern "C" fn P_AddBinaryMapTagsFromLine(
    mut sector: *mut sector_t,
    mut line: *mut line_t,
) {
    Tag_Add(&mut (*sector).tags, Tag_FGet(&mut (*line).tags));
    if (*line).flags as libc::c_int & 8192 as libc::c_int != 0 {
        if (*sides.offset((*line).sidenum[0 as libc::c_int as usize] as isize))
            .textureoffset != 0
        {
            Tag_Add(
                &mut (*sector).tags,
                ((*sides.offset((*line).sidenum[0 as libc::c_int as usize] as isize))
                    .textureoffset / ((1 as libc::c_int) << 16 as libc::c_int)) as mtag_t,
            );
        }
        if (*sides.offset((*line).sidenum[0 as libc::c_int as usize] as isize)).rowoffset
            != 0
        {
            Tag_Add(
                &mut (*sector).tags,
                ((*sides.offset((*line).sidenum[0 as libc::c_int as usize] as isize))
                    .rowoffset / ((1 as libc::c_int) << 16 as libc::c_int)) as mtag_t,
            );
        }
    }
    if (*line).flags as libc::c_int & 32768 as libc::c_int != 0 {
        if (*sides.offset((*line).sidenum[1 as libc::c_int as usize] as isize))
            .textureoffset != 0
        {
            Tag_Add(
                &mut (*sector).tags,
                ((*sides.offset((*line).sidenum[1 as libc::c_int as usize] as isize))
                    .textureoffset / ((1 as libc::c_int) << 16 as libc::c_int)) as mtag_t,
            );
        }
        if (*sides.offset((*line).sidenum[1 as libc::c_int as usize] as isize)).rowoffset
            != 0
        {
            Tag_Add(
                &mut (*sector).tags,
                ((*sides.offset((*line).sidenum[1 as libc::c_int as usize] as isize))
                    .rowoffset / ((1 as libc::c_int) << 16 as libc::c_int)) as mtag_t,
            );
        }
    }
}
unsafe extern "C" fn P_AddBinaryMapTags() {
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numlines {
        if (*lines.offset(i as isize)).special as libc::c_int == 97 as libc::c_int
            || (*lines.offset(i as isize)).special as libc::c_int == 99 as libc::c_int
        {
            P_AddBinaryMapTagsFromLine(
                (*lines.offset(i as isize)).frontsector,
                &mut *lines.offset(i as isize),
            );
        }
        if (*lines.offset(i as isize)).special as libc::c_int == 98 as libc::c_int
            || (*lines.offset(i as isize)).special as libc::c_int == 99 as libc::c_int
        {
            P_AddBinaryMapTagsFromLine(
                (*lines.offset(i as isize)).backsector,
                &mut *lines.offset(i as isize),
            );
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < numlines {
        let mut j: size_t = 0;
        let mut tag: mtag_t = 0;
        let mut target_tag: mtag_t = 0;
        let mut offset_tags: [mtag_t; 4] = [0; 4];
        if !((*lines.offset(i as isize)).special as libc::c_int != 96 as libc::c_int) {
            tag = Tag_FGet(&mut (*(*lines.offset(i as isize)).frontsector).tags);
            target_tag = Tag_FGet(&mut (*lines.offset(i as isize)).tags);
            memset(
                offset_tags.as_mut_ptr() as *mut libc::c_void,
                0 as libc::c_int,
                (::core::mem::size_of::<mtag_t>() as libc::c_ulong)
                    .wrapping_mul(4 as libc::c_int as libc::c_ulong),
            );
            if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                != 0
            {
                offset_tags[0 as libc::c_int
                    as usize] = ((*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset / ((1 as libc::c_int) << 16 as libc::c_int))
                    as mtag_t;
                offset_tags[1 as libc::c_int
                    as usize] = ((*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset / ((1 as libc::c_int) << 16 as libc::c_int)) as mtag_t;
            }
            if (*lines.offset(i as isize)).flags as libc::c_int & 32768 as libc::c_int
                != 0
            {
                offset_tags[2 as libc::c_int
                    as usize] = ((*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset / ((1 as libc::c_int) << 16 as libc::c_int))
                    as mtag_t;
                offset_tags[3 as libc::c_int
                    as usize] = ((*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset / ((1 as libc::c_int) << 16 as libc::c_int)) as mtag_t;
            }
            j = 0 as libc::c_int as size_t;
            while j < numsectors {
                let mut matches_target_tag: boolean = (target_tag as libc::c_int != 0
                    && Tag_Find(&mut (*sectors.offset(j as isize)).tags, target_tag)
                        != 0) as libc::c_int;
                let mut k: size_t = 0;
                k = 0 as libc::c_int as size_t;
                while k < 4 as libc::c_int as size_t {
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 1024 as libc::c_int != 0
                    {
                        if matches_target_tag != 0
                            || offset_tags[k as usize] as libc::c_int != 0
                                && Tag_Find(
                                    &mut (*sectors.offset(j as isize)).tags,
                                    offset_tags[k as usize],
                                ) != 0
                        {
                            Tag_Add(&mut (*sectors.offset(j as isize)).tags, tag);
                            break;
                        }
                    } else if matches_target_tag != 0 {
                        if k == 0 as libc::c_int as size_t {
                            Tag_Add(&mut (*sectors.offset(j as isize)).tags, tag);
                        }
                        if offset_tags[k as usize] != 0 {
                            Tag_Add(
                                &mut (*sectors.offset(j as isize)).tags,
                                offset_tags[k as usize],
                            );
                        }
                    }
                    k = k.wrapping_add(1);
                    k;
                }
                j = j.wrapping_add(1);
                j;
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < nummapthings {
        match (*mapthings.offset(i as isize)).type_0 as libc::c_int {
            291 | 322 | 750 | 760 | 761 | 762 => {
                Tag_FSet(
                    &mut (*mapthings.offset(i as isize)).tags,
                    (*mapthings.offset(i as isize)).angle,
                );
            }
            290 | 292 | 294 | 780 => {
                Tag_FSet(
                    &mut (*mapthings.offset(i as isize)).tags,
                    (*mapthings.offset(i as isize)).extrainfo as mtag_t,
                );
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn P_FindPointPushLine(mut list: *mut taglist_t) -> *mut line_t {
    let mut i: int32_t = 0;
    let mut l: int32_t = 0;
    i = 0 as libc::c_int;
    while i < (*list).count as libc::c_int {
        let mut tag: mtag_t = *((*list).tags).offset(i as isize);
        let mut ICNT_4166: size_t = 0 as libc::c_int as size_t;
        loop {
            l = Tag_Iterate_Lines(tag, ICNT_4166);
            if !(l >= 0 as libc::c_int) {
                break;
            }
            if !(Tag_FGet(&mut (*lines.offset(l as isize)).tags) as libc::c_int
                != tag as libc::c_int)
            {
                if !((*lines.offset(l as isize)).special as libc::c_int
                    != 547 as libc::c_int)
                {
                    return &mut *lines.offset(l as isize) as *mut line_t;
                }
            }
            ICNT_4166 = ICNT_4166.wrapping_add(1);
            ICNT_4166;
        }
        i += 1;
        i;
    }
    return 0 as *mut line_t;
}
unsafe extern "C" fn P_SetBinaryFOFAlpha(mut line: *mut line_t) {
    if (*sides.offset((*line).sidenum[0 as libc::c_int as usize] as isize)).toptexture
        > 0 as libc::c_int
    {
        (*line)
            .args[1 as libc::c_int
            as usize] = (*sides
            .offset((*line).sidenum[0 as libc::c_int as usize] as isize))
            .toptexture;
        if (*sides.offset((*line).sidenum[0 as libc::c_int as usize] as isize))
            .toptexture >= 1001 as libc::c_int
        {
            (*line)
                .args[2 as libc::c_int
                as usize] = (*sides
                .offset((*line).sidenum[0 as libc::c_int as usize] as isize))
                .toptexture / 1000 as libc::c_int;
            (*line).args[1 as libc::c_int as usize] %= 1000 as libc::c_int;
        }
    } else {
        (*line).args[1 as libc::c_int as usize] = 128 as libc::c_int;
        (*line).args[2 as libc::c_int as usize] = TMB_TRANSLUCENT as libc::c_int;
    };
}
unsafe extern "C" fn P_GetFOFFlags(mut oldflags: int32_t) -> int32_t {
    let mut result: int32_t = 0 as libc::c_int;
    if oldflags & FF_OLD_EXISTS as libc::c_int != 0 {
        result |= FOF_EXISTS as libc::c_int;
    }
    if oldflags & FF_OLD_BLOCKPLAYER as libc::c_int != 0 {
        result |= FOF_BLOCKPLAYER as libc::c_int;
    }
    if oldflags & FF_OLD_BLOCKOTHERS as libc::c_int != 0 {
        result |= FOF_BLOCKOTHERS as libc::c_int;
    }
    if oldflags & FF_OLD_RENDERSIDES as libc::c_int != 0 {
        result |= FOF_RENDERSIDES as libc::c_int;
    }
    if oldflags & FF_OLD_RENDERPLANES as libc::c_int != 0 {
        result |= FOF_RENDERPLANES as libc::c_int;
    }
    if oldflags & FF_OLD_SWIMMABLE as libc::c_int != 0 {
        result |= FOF_SWIMMABLE as libc::c_int;
    }
    if oldflags & FF_OLD_NOSHADE as libc::c_int != 0 {
        result |= FOF_NOSHADE as libc::c_int;
    }
    if oldflags & FF_OLD_CUTSOLIDS as libc::c_int != 0 {
        result |= FOF_CUTSOLIDS as libc::c_int;
    }
    if oldflags & FF_OLD_CUTEXTRA as libc::c_int != 0 {
        result |= FOF_CUTEXTRA as libc::c_int;
    }
    if oldflags & FF_OLD_CUTSPRITES as libc::c_int != 0 {
        result |= FOF_CUTSPRITES as libc::c_int;
    }
    if oldflags & FF_OLD_BOTHPLANES as libc::c_int != 0 {
        result |= FOF_BOTHPLANES as libc::c_int;
    }
    if oldflags & FF_OLD_EXTRA as libc::c_int != 0 {
        result |= FOF_EXTRA as libc::c_int;
    }
    if oldflags & FF_OLD_TRANSLUCENT as libc::c_int != 0 {
        result |= FOF_TRANSLUCENT as libc::c_int;
    }
    if oldflags & FF_OLD_FOG as libc::c_int != 0 {
        result |= FOF_FOG as libc::c_int;
    }
    if oldflags & FF_OLD_INVERTPLANES as libc::c_int != 0 {
        result |= FOF_INVERTPLANES as libc::c_int;
    }
    if oldflags & FF_OLD_ALLSIDES as libc::c_int != 0 {
        result |= FOF_ALLSIDES as libc::c_int;
    }
    if oldflags & FF_OLD_INVERTSIDES as libc::c_int != 0 {
        result |= FOF_INVERTSIDES as libc::c_int;
    }
    if oldflags & FF_OLD_DOUBLESHADOW as libc::c_int != 0 {
        result |= FOF_DOUBLESHADOW as libc::c_int;
    }
    if oldflags & FF_OLD_FLOATBOB as libc::c_int != 0 {
        result |= FOF_FLOATBOB as libc::c_int;
    }
    if oldflags & FF_OLD_NORETURN as libc::c_int != 0 {
        result |= FOF_NORETURN as libc::c_int;
    }
    if oldflags & FF_OLD_CRUMBLE as libc::c_int != 0 {
        result |= FOF_CRUMBLE as libc::c_int;
    }
    if oldflags & FF_OLD_GOOWATER as libc::c_int != 0 {
        result |= FOF_GOOWATER as libc::c_int;
    }
    if oldflags & FF_OLD_MARIO as libc::c_int != 0 {
        result |= FOF_MARIO as libc::c_int;
    }
    if oldflags & FF_OLD_BUSTUP as libc::c_int != 0 {
        result |= FOF_BUSTUP as libc::c_int;
    }
    if oldflags & FF_OLD_QUICKSAND as libc::c_int != 0 {
        result |= FOF_QUICKSAND as libc::c_int;
    }
    if oldflags & FF_OLD_PLATFORM as libc::c_int != 0 {
        result |= FOF_PLATFORM as libc::c_int;
    }
    if oldflags & FF_OLD_REVERSEPLATFORM as libc::c_int != 0 {
        result |= FOF_REVERSEPLATFORM as libc::c_int;
    }
    if oldflags & FF_OLD_RIPPLE as libc::c_int != 0 {
        result |= FOF_RIPPLE as libc::c_int;
    }
    if oldflags as libc::c_uint & FF_OLD_COLORMAPONLY as libc::c_uint != 0 {
        result |= FOF_COLORMAPONLY as libc::c_int;
    }
    return result;
}
unsafe extern "C" fn P_GetFOFBusttype(mut oldflags: int32_t) -> int32_t {
    if oldflags & FF_OLD_SHATTER as libc::c_int != 0 {
        return TMFB_TOUCH as libc::c_int;
    }
    if oldflags & FF_OLD_SPINBUST as libc::c_int != 0 {
        return TMFB_SPIN as libc::c_int;
    }
    if oldflags & FF_OLD_STRONGBUST as libc::c_int != 0 {
        return TMFB_STRONG as libc::c_int;
    }
    return TMFB_REGULAR as libc::c_int;
}
unsafe extern "C" fn P_ConvertBinaryLinedefTypes() {
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numlines {
        let mut tag: mtag_t = Tag_FGet(&mut (*lines.offset(i as isize)).tags);
        let mut current_block_1002: u64;
        match (*lines.offset(i as isize)).special as libc::c_int {
            2 => {
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh93 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh93 |= TMEF_SKIPTALLY as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 2 as libc::c_int
                    != 0
                {
                    let ref mut fresh94 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh94 |= TMEF_EMERALDCHECK as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            3 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 512 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            4 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    let ref mut fresh95 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh95 |= TMSP_NOTELEPORT as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 1024 as libc::c_int
                    != 0
                {
                    let ref mut fresh96 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh96 |= TMSP_FORCESPIN as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            7 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int
                    & (2048 as libc::c_int | 4096 as libc::c_int)
                    == 2048 as libc::c_int | 4096 as libc::c_int
                {
                    CONS_Alert(
                        CONS_WARNING,
                        b"Flat alignment linedef (tag %d) doesn't have anything to do.\nConsider changing the linedef's flag configuration or removing it entirely.\n\0"
                            as *const u8 as *const libc::c_char,
                        tag as libc::c_int,
                    );
                    (*lines.offset(i as isize)).special = 0 as libc::c_int as int16_t;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 2048 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMP_CEILING as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 4096 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMP_FLOOR as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMP_BOTH as libc::c_int;
                }
                let ref mut fresh97 = (*lines.offset(i as isize)).flags;
                *fresh97 = (*fresh97 as libc::c_int
                    & !(2048 as libc::c_int | 4096 as libc::c_int)) as int16_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                {
                    let mut flatangle: angle_t = InvAngle(
                        R_PointToAngle2(
                            (*(*lines.offset(i as isize)).v1).x,
                            (*(*lines.offset(i as isize)).v1).y,
                            (*(*lines.offset(i as isize)).v2).x,
                            (*(*lines.offset(i as isize)).v2).y,
                        ),
                    );
                    let mut xoffs: fixed_t = (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset;
                    let mut yoffs: fixed_t = (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .rowoffset;
                    if (*lines.offset(i as isize)).args[0 as libc::c_int as usize]
                        == 0 as libc::c_int
                    {
                        P_ApplyFlatAlignment(
                            (*lines.offset(i as isize)).frontsector,
                            flatangle,
                            xoffs,
                            yoffs,
                            ((*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                                != TMP_CEILING as libc::c_int) as libc::c_int,
                            ((*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                                != TMP_FLOOR as libc::c_int) as libc::c_int,
                        );
                    } else {
                        let mut s: int32_t = 0;
                        let mut ICNT_4329: size_t = 0 as libc::c_int as size_t;
                        loop {
                            s = Tag_Iterate_Sectors(
                                (*lines.offset(i as isize)).args[0 as libc::c_int as usize]
                                    as mtag_t,
                                ICNT_4329,
                            );
                            if !(s >= 0 as libc::c_int) {
                                break;
                            }
                            P_ApplyFlatAlignment(
                                sectors.offset(s as isize),
                                flatangle,
                                xoffs,
                                yoffs,
                                ((*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                                    != TMP_CEILING as libc::c_int) as libc::c_int,
                                ((*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                                    != TMP_FLOOR as libc::c_int) as libc::c_int,
                            );
                            ICNT_4329 = ICNT_4329.wrapping_add(1);
                            ICNT_4329;
                        }
                    }
                    (*lines.offset(i as isize)).special = 0 as libc::c_int as int16_t;
                }
                current_block_1002 = 6860640994621533902;
            }
            8 => {
                let mut s_0: int32_t = 0;
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                let mut ICNT_4340: size_t = 0 as libc::c_int as size_t;
                loop {
                    s_0 = Tag_Iterate_Sectors(tag, ICNT_4340);
                    if !(s_0 >= 0 as libc::c_int) {
                        break;
                    }
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 64 as libc::c_int != 0
                    {
                        let ref mut fresh98 = (*sectors.offset(s_0 as isize)).flags;
                        *fresh98 = ::core::mem::transmute::<
                            libc::c_uint,
                            sectorflags_t,
                        >(
                            *fresh98 as libc::c_uint
                                & !(MSF_FLIPSPECIAL_FLOOR as libc::c_int) as libc::c_uint,
                        );
                        let ref mut fresh99 = (*sectors.offset(s_0 as isize)).flags;
                        *fresh99 = ::core::mem::transmute::<
                            libc::c_uint,
                            sectorflags_t,
                        >(
                            *fresh99 as libc::c_uint
                                | MSF_FLIPSPECIAL_CEILING as libc::c_int as libc::c_uint,
                        );
                    } else if (*lines.offset(i as isize)).flags as libc::c_int
                        & 512 as libc::c_int != 0
                    {
                        let ref mut fresh100 = (*sectors.offset(s_0 as isize)).flags;
                        *fresh100 = ::core::mem::transmute::<
                            libc::c_uint,
                            sectorflags_t,
                        >(
                            *fresh100 as libc::c_uint
                                | MSF_FLIPSPECIAL_BOTH as libc::c_int as libc::c_uint,
                        );
                    }
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 256 as libc::c_int != 0
                    {
                        let ref mut fresh101 = (*sectors.offset(s_0 as isize)).flags;
                        *fresh101 = ::core::mem::transmute::<
                            libc::c_uint,
                            sectorflags_t,
                        >(
                            *fresh101 as libc::c_uint
                                | MSF_TRIGGERSPECIAL_TOUCH as libc::c_int as libc::c_uint,
                        );
                    }
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 128 as libc::c_int != 0
                    {
                        let ref mut fresh102 = (*sectors.offset(s_0 as isize)).flags;
                        *fresh102 = ::core::mem::transmute::<
                            libc::c_uint,
                            sectorflags_t,
                        >(
                            *fresh102 as libc::c_uint
                                | MSF_TRIGGERSPECIAL_HEADBUMP as libc::c_int as libc::c_uint,
                        );
                    }
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 32 as libc::c_int != 0
                    {
                        let ref mut fresh103 = (*sectors.offset(s_0 as isize)).flags;
                        *fresh103 = ::core::mem::transmute::<
                            libc::c_uint,
                            sectorflags_t,
                        >(
                            *fresh103 as libc::c_uint
                                | MSF_INVERTPRECIP as libc::c_int as libc::c_uint,
                        );
                    }
                    ICNT_4340 = ICNT_4340.wrapping_add(1);
                    ICNT_4340;
                }
                if (*(*lines.offset(i as isize)).frontsector).special as libc::c_int
                    >> (4 as libc::c_int - 1 as libc::c_int) * 4 as libc::c_int
                    & 15 as libc::c_int != 12 as libc::c_int
                {
                    (*lines.offset(i as isize)).special = 0 as libc::c_int as int16_t;
                }
                current_block_1002 = 6860640994621533902;
            }
            10 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            11 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0
                {
                    0 as libc::c_int
                } else {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 32 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            13 => {
                let mut s_1: int32_t = 0;
                let mut ICNT_4377: size_t = 0 as libc::c_int as size_t;
                loop {
                    s_1 = Tag_Iterate_Sectors(tag, ICNT_4377);
                    if !(s_1 >= 0 as libc::c_int) {
                        break;
                    }
                    let ref mut fresh104 = (*sectors.offset(s_1 as isize)).flags;
                    *fresh104 = ::core::mem::transmute::<
                        libc::c_uint,
                        sectorflags_t,
                    >(
                        *fresh104 as libc::c_uint
                            | MSF_HEATWAVE as libc::c_int as libc::c_uint,
                    );
                    ICNT_4377 = ICNT_4377.wrapping_add(1);
                    ICNT_4377;
                }
                current_block_1002 = 6860640994621533902;
            }
            14 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 32 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            16 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            20 => {
                let mut check: int32_t = -(1 as libc::c_int);
                let mut paramline: int32_t = -(1 as libc::c_int);
                let mut ICNT_4395: size_t = 0 as libc::c_int as size_t;
                loop {
                    check = Tag_Iterate_Lines(tag, ICNT_4395);
                    if !(check >= 0 as libc::c_int) {
                        break;
                    }
                    if (*lines.offset(check as isize)).special as libc::c_int
                        == 22 as libc::c_int
                    {
                        paramline = check;
                        break;
                    } else {
                        ICNT_4395 = ICNT_4395.wrapping_add(1);
                        ICNT_4395;
                    }
                }
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                let ref mut fresh105 = (*lines.offset(i as isize))
                    .args[3 as libc::c_int as usize];
                *fresh105 |= TMPF_INVISIBLEPLANES as libc::c_int;
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = 32000 as libc::c_int
                    + (*lines.offset(i as isize)).args[0 as libc::c_int as usize];
                if paramline == -(1 as libc::c_int) {
                    current_block_1002 = 6860640994621533902;
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = (*(*lines.offset(paramline as isize)).frontsector)
                        .special as int32_t;
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = if (*lines.offset(paramline as isize)).flags
                        as libc::c_int & 8 as libc::c_int != 0
                    {
                        (*sides
                            .offset(
                                (*lines.offset(paramline as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .textureoffset >> 16 as libc::c_int
                    } else {
                        ((*(*lines.offset(paramline as isize)).frontsector).floorheight
                            >> 16 as libc::c_int) / 100 as libc::c_int
                    };
                    if (*lines.offset(paramline as isize)).flags as libc::c_int
                        & 32 as libc::c_int != 0
                    {
                        let ref mut fresh106 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh106 |= TMPF_NOINSIDES as libc::c_int;
                    }
                    if (*lines.offset(paramline as isize)).flags as libc::c_int
                        & 128 as libc::c_int != 0
                    {
                        let ref mut fresh107 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh107 |= TMPF_INTANGIBLE as libc::c_int;
                    }
                    if (*lines.offset(paramline as isize)).flags as libc::c_int
                        & 256 as libc::c_int != 0
                    {
                        let ref mut fresh108 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh108 |= TMPF_PUSHABLESTOP as libc::c_int;
                    }
                    if (*lines.offset(paramline as isize)).flags as libc::c_int
                        & 512 as libc::c_int != 0
                    {
                        let ref mut fresh109 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh109 &= !(TMPF_INVISIBLEPLANES as libc::c_int);
                    }
                    if (*lines.offset(paramline as isize)).flags as libc::c_int
                        & 8192 as libc::c_int != 0
                    {
                        let ref mut fresh110 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh110 |= TMPF_SPLAT as libc::c_int;
                    }
                    if (*lines.offset(paramline as isize)).flags as libc::c_int
                        & 64 as libc::c_int != 0
                    {
                        let ref mut fresh111 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh111 |= TMPF_EXECUTOR as libc::c_int;
                    }
                    current_block_1002 = 6860640994621533902;
                }
            }
            30 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            31 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = R_PointToDist2(
                    (*(*lines.offset(i as isize)).v2).x,
                    (*(*lines.offset(i as isize)).v2).y,
                    (*(*lines.offset(i as isize)).v1).x,
                    (*(*lines.offset(i as isize)).v1).y,
                ) >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            32 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset != 0
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int
                } else {
                    128 as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = if (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset != 0
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .rowoffset >> 16 as libc::c_int
                } else {
                    90 as libc::c_int
                };
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh112 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh112 |= TMPR_DONTROTATEOTHERS as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 512 as libc::c_int != 0
                {
                    let ref mut fresh113 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh113 |= TMPR_ROTATEPLAYERS as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            50 | 51 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                current_block_1002 = 6860640994621533902;
            }
            52 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            53 => {
                current_block_1002 = 2652155047008587766;
            }
            54 | 55 => {
                current_block_1002 = 2652155047008587766;
            }
            56 => {
                current_block_1002 = 660191227468549570;
            }
            57 | 58 => {
                current_block_1002 = 660191227468549570;
            }
            59 | 60 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 60 as libc::c_int
                {
                    P_AproxDistance(
                        (*lines.offset(i as isize)).dx,
                        (*lines.offset(i as isize)).dy,
                    ) >> 16 as libc::c_int
                } else {
                    8 as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0
                {
                    1 as libc::c_int
                } else {
                    0 as libc::c_int
                };
                (*lines.offset(i as isize)).special = 60 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            61 | 62 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*lines.offset(i as isize)).special as libc::c_int
                    - 61 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = abs((*lines.offset(i as isize)).dx)
                        >> 16 as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int
                        as usize] = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                } else {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = R_PointToDist2(
                        (*(*lines.offset(i as isize)).v2).x,
                        (*(*lines.offset(i as isize)).v2).y,
                        (*(*lines.offset(i as isize)).v1).x,
                        (*(*lines.offset(i as isize)).v1).y,
                    ) >> 16 as libc::c_int + 1 as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int
                        as usize] = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] / 4 as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 61 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            63 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                current_block_1002 = 6860640994621533902;
            }
            64 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0
                {
                    0 as libc::c_int
                } else {
                    tag as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0
                {
                    tag as libc::c_int
                } else {
                    Tag_FGet(&mut (*(*lines.offset(i as isize)).frontsector).tags)
                        as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*lines.offset(i as isize)).dx >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = (*lines.offset(i as isize)).dy >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = (*(*lines.offset(i as isize)).frontsector).floorheight
                    >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[5 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            66 => {
                current_block_1002 = 8095681603675559136;
            }
            67 | 68 => {
                current_block_1002 = 8095681603675559136;
            }
            76 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            100 => {
                current_block_1002 = 3176299481022176532;
            }
            101 => {
                current_block_1002 = 3176299481022176532;
            }
            102 => {
                current_block_1002 = 14055165045049786312;
            }
            103 => {
                current_block_1002 = 6938283216177311918;
            }
            104 | 105 => {
                current_block_1002 = 5611371826125380931;
            }
            120 => {
                current_block_1002 = 13891542684839355158;
            }
            121 => {
                current_block_1002 = 13891542684839355158;
            }
            122 => {
                current_block_1002 = 16557744034144139236;
            }
            123 => {
                current_block_1002 = 11052763078889702642;
            }
            124 | 125 => {
                current_block_1002 = 18062067447159258204;
            }
            140 => {
                current_block_1002 = 10213811827501540822;
            }
            141 => {
                current_block_1002 = 10213811827501540822;
            }
            142 => {
                current_block_1002 = 4630481709593923503;
            }
            143 => {
                current_block_1002 = 1737444249807734800;
            }
            144 => {
                current_block_1002 = 4836002175010205657;
            }
            145 | 146 => {
                current_block_1002 = 72044055750383046;
            }
            150 => {
                current_block_1002 = 15901652309940696178;
            }
            151 => {
                current_block_1002 = 15901652309940696178;
            }
            152 | 153 => {
                current_block_1002 = 6376668003191104824;
            }
            160 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                current_block_1002 = 6860640994621533902;
            }
            170 => {
                current_block_1002 = 14755265072784038703;
            }
            171 => {
                current_block_1002 = 14755265072784038703;
            }
            172 => {
                current_block_1002 = 12016556137065168597;
            }
            173 => {
                current_block_1002 = 5254254926722712074;
            }
            174 => {
                current_block_1002 = 86100791935436905;
            }
            175 => {
                current_block_1002 = 1580848837534479582;
            }
            176 => {
                current_block_1002 = 7207399478227962068;
            }
            177 => {
                current_block_1002 = 11876063911488577274;
            }
            178 => {
                current_block_1002 = 2580075828471106669;
            }
            179 | 180 => {
                current_block_1002 = 3223050142715816929;
            }
            190 => {
                current_block_1002 = 614554557968527432;
            }
            191 => {
                current_block_1002 = 614554557968527432;
            }
            192 => {
                current_block_1002 = 16406402859371515597;
            }
            193 => {
                current_block_1002 = 11836790636291352653;
            }
            194 | 195 => {
                current_block_1002 = 5147096127775914812;
            }
            200 | 201 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 201 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 1 as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 200 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            202 | 223 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                current_block_1002 = 6860640994621533902;
            }
            220 => {
                current_block_1002 = 10086740511237005094;
            }
            221 | 222 => {
                current_block_1002 = 10086740511237005094;
            }
            250 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh169 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh169 |= TMFM_BRICK as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh170 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh170 |= TMFM_INVISIBLE as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            251 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 1024 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = (*lines.offset(i as isize)).dy >> 16 as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = (*lines.offset(i as isize)).dx >> 16 as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 80 as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = 16 as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    P_WriteSfx(
                        (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .textureoffset >> 16 as libc::c_int,
                        &mut *((*lines.offset(i as isize)).stringargs)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize),
                    );
                }
                current_block_1002 = 6860640994621533902;
            }
            252 => {
                current_block_1002 = 1552796785379166655;
            }
            253 => {
                current_block_1002 = 1552796785379166655;
            }
            254 => {
                current_block_1002 = 17751681062231209435;
            }
            255 | 256 => {
                current_block_1002 = 8260881556307538170;
            }
            257 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 1024 as libc::c_int
                    == 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 1 as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*lines.offset(i as isize)).dx >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = (*lines.offset(i as isize)).dy >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            258 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                P_SetBinaryFOFAlpha(&mut *lines.offset(i as isize));
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh176 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh176 |= TMFL_NOBOSSES as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                    || (*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                        == 256 as libc::c_int
                {
                    let ref mut fresh177 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh177 |= TMFL_SPLAT as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            259 => {
                if (*lines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                    as libc::c_int == 0xffff as libc::c_int
                {
                    I_Error(
                        b"Custom FOF (tag %d) found without a linedef back side!\0"
                            as *const u8 as *const libc::c_char,
                        tag as libc::c_int,
                    );
                }
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = P_GetFOFFlags(
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[1 as libc::c_int as usize] as isize,
                        ))
                        .toptexture,
                );
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                {
                    let ref mut fresh178 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh178 |= FOF_SPLAT as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = P_GetFOFBusttype(
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[1 as libc::c_int as usize] as isize,
                        ))
                        .toptexture,
                );
                if (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                            as isize,
                    ))
                    .toptexture & FF_OLD_SHATTERBOTTOM as libc::c_int != 0
                {
                    let ref mut fresh179 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh179 |= TMFB_ONLYBOTTOM as libc::c_int;
                }
                if (*lines.offset(i as isize)).args[3 as libc::c_int as usize]
                    & FOF_TRANSLUCENT as libc::c_int != 0
                {
                    P_SetBinaryFOFAlpha(&mut *lines.offset(i as isize));
                    if (*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                        == 256 as libc::c_int
                    {
                        let ref mut fresh180 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh180 |= FOF_SPLAT as libc::c_int;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 255 as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            300 => {
                current_block_1002 = 14979349787004695573;
            }
            301 | 302 => {
                current_block_1002 = 14979349787004695573;
            }
            303 | 304 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 304 as libc::c_int
                {
                    TMT_ONCE as libc::c_int
                } else {
                    TMT_CONTINUOUS as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMC_LTE as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMC_GTE as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMC_EQUAL as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 512 as libc::c_int != 0) as libc::c_int;
                (*lines.offset(i as isize)).special = 303 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            305 => {
                current_block_1002 = 4672609343193835635;
            }
            306 | 307 => {
                current_block_1002 = 4672609343193835635;
            }
            308 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = TMT_ONCE as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int as usize] = GTR_RACE as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int as usize] = TMF_HASANY as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            309 => {
                current_block_1002 = 10776215054357342558;
            }
            310 => {
                current_block_1002 = 10776215054357342558;
            }
            311 | 312 => {
                current_block_1002 = 177286901473062006;
            }
            313 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                current_block_1002 = 6860640994621533902;
            }
            314 | 315 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 315 as libc::c_int
                {
                    TMT_ONCE as libc::c_int
                } else {
                    TMT_CONTINUOUS as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMC_GTE as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 512 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMC_LTE as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMC_EQUAL as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 314 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            317 | 318 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 318 as libc::c_int
                {
                    TMT_ONCE as libc::c_int
                } else {
                    TMT_CONTINUOUS as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize)).special = 317 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            319 | 320 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 320 as libc::c_int
                {
                    TMT_ONCE as libc::c_int
                } else {
                    TMT_CONTINUOUS as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize)).special = 319 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            321 | 322 => {
                if (*lines.offset(i as isize)).special as libc::c_int % 2 as libc::c_int
                    == 0 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        TMXT_EACHTIMEENTERANDEXIT as libc::c_int
                    } else {
                        TMXT_EACHTIMEENTER as libc::c_int
                    };
                } else {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = TMXT_CONTINUOUS as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = 1 as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int
                        as usize] = (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .rowoffset >> 16 as libc::c_int;
                } else {
                    let ref mut fresh181 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh181 = 0 as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = *fresh181;
                }
                (*lines.offset(i as isize)).special = 321 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            323 => {
                current_block_1002 = 1615022513158998073;
            }
            324 => {
                current_block_1002 = 1615022513158998073;
            }
            325 => {
                current_block_1002 = 8545310219052855647;
            }
            326 => {
                current_block_1002 = 14038448619486050115;
            }
            327 => {
                current_block_1002 = 13860011571733000765;
            }
            328 => {
                current_block_1002 = 7698913941061410784;
            }
            329 | 330 => {
                current_block_1002 = 18159330253651456305;
            }
            331 => {
                current_block_1002 = 5529689922675175864;
            }
            332 | 333 => {
                current_block_1002 = 5529689922675175864;
            }
            334 => {
                current_block_1002 = 17350251256590394187;
            }
            335 | 336 => {
                current_block_1002 = 17350251256590394187;
            }
            337 => {
                current_block_1002 = 3490761217750026838;
            }
            338 | 339 => {
                current_block_1002 = 3490761217750026838;
            }
            340 => {
                current_block_1002 = 14081740663943781683;
            }
            341 | 342 => {
                current_block_1002 = 14081740663943781683;
            }
            343 => {
                current_block_1002 = 10842599078927360536;
            }
            344 | 345 => {
                current_block_1002 = 10842599078927360536;
            }
            400 | 401 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*lines.offset(i as isize)).special as libc::c_int
                    - 400 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int == 0) as libc::c_int;
                (*lines.offset(i as isize)).special = 400 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            402 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int as usize] = 0 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            403 | 404 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*lines.offset(i as isize)).special as libc::c_int
                    - 403 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int
                } else {
                    0 as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                (*lines.offset(i as isize)).special = 403 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            405 | 407 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 405 as libc::c_int
                {
                    TMP_FLOOR as libc::c_int
                } else {
                    TMP_CEILING as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                (*lines.offset(i as isize)).special = 405 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            408 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int
                    & (64 as libc::c_int | 512 as libc::c_int)
                    == 64 as libc::c_int | 512 as libc::c_int
                {
                    CONS_Alert(
                        CONS_WARNING,
                        b"Set flats linedef (tag %d) doesn't have anything to do.\nConsider changing the linedef's flag configuration or removing it entirely.\n\0"
                            as *const u8 as *const libc::c_char,
                        tag as libc::c_int,
                    );
                    (*lines.offset(i as isize)).special = 0 as libc::c_int as int16_t;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMP_CEILING as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 512 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMP_FLOOR as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMP_BOTH as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            409 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMT_ADD as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMT_REMOVE as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = TMT_REPLACEFIRST as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            410 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMT_ADD as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMT_REMOVE as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = TMT_REPLACEFIRST as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            411 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                current_block_1002 = 6860640994621533902;
            }
            412 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 2 as libc::c_int
                    != 0
                {
                    let ref mut fresh187 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh187 |= TMT_SILENT as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh188 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh188 |= TMT_KEEPANGLE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    let ref mut fresh189 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh189 |= TMT_KEEPMOMENTUM as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int
                    != 0
                {
                    let ref mut fresh190 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh190 |= TMT_RELATIVE as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = (*(*lines.offset(i as isize)).frontsector).ceilingheight
                    >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            413 => {
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh191 = (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize];
                    *fresh191 |= TMM_ALLPLAYERS as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh192 = (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize];
                    *fresh192 |= TMM_OFFSET as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 128 as libc::c_int
                    != 0
                {
                    let ref mut fresh193 = (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize];
                    *fresh193 |= TMM_FADE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 2 as libc::c_int
                    != 0
                {
                    let ref mut fresh194 = (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize];
                    *fresh194 |= TMM_NORELOAD as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int
                    & 16384 as libc::c_int != 0
                {
                    let ref mut fresh195 = (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize];
                    *fresh195 |= TMM_FORCERESET as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    let ref mut fresh196 = (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize];
                    *fresh196 |= TMM_NOLOOP as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .midtexture;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = if (*lines.offset(i as isize))
                    .sidenum[1 as libc::c_int as usize] as libc::c_int
                    != 0xffff as libc::c_int
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[1 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int
                } else {
                    0 as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[5 as libc::c_int
                    as usize] = if (*lines.offset(i as isize))
                    .sidenum[1 as libc::c_int as usize] as libc::c_int
                    != 0xffff as libc::c_int
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[1 as libc::c_int as usize] as isize,
                        ))
                        .rowoffset >> 16 as libc::c_int
                } else {
                    -(1 as libc::c_int)
                };
                (*lines.offset(i as isize))
                    .args[6 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .bottomtexture;
                current_block_1002 = 6860640994621533902;
            }
            414 => {
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int as usize] = tag as int32_t;
                if tag as libc::c_int != 0 as libc::c_int {
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 1024 as libc::c_int != 0
                    {
                        (*lines.offset(i as isize))
                            .args[0 as libc::c_int
                            as usize] = TMSS_TAGGEDSECTOR as libc::c_int;
                        (*lines.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = TMSL_EVERYONE as libc::c_int;
                    } else {
                        (*lines.offset(i as isize))
                            .args[0 as libc::c_int
                            as usize] = TMSS_NOWHERE as libc::c_int;
                        (*lines.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = TMSL_TAGGEDSECTOR as libc::c_int;
                    }
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMSS_NOWHERE as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMSL_TRIGGERER as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 512 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMSS_NOWHERE as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMSL_EVERYONE as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = TMSS_TRIGGERSECTOR as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMSL_EVERYONE as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = TMSS_TRIGGERMOBJ as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMSL_EVERYONE as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            415 => {
                let mut scrnum: int32_t = 0;
                let ref mut fresh197 = (*lines.offset(i as isize))
                    .stringargs[0 as libc::c_int as usize];
                *fresh197 = Z_MallocAlign(
                    9 as libc::c_int as size_t,
                    PU_LEVEL as libc::c_int,
                    0 as *mut libc::c_void,
                    ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong
                        as int32_t,
                ) as *mut libc::c_char;
                strcpy(
                    (*lines.offset(i as isize)).stringargs[0 as libc::c_int as usize],
                    G_BuildMapName(gamemap as int32_t),
                );
                *((*lines.offset(i as isize)).stringargs[0 as libc::c_int as usize])
                    .offset(0 as libc::c_int as isize) = 'S' as i32 as libc::c_char;
                *((*lines.offset(i as isize)).stringargs[0 as libc::c_int as usize])
                    .offset(1 as libc::c_int as isize) = 'C' as i32 as libc::c_char;
                *((*lines.offset(i as isize)).stringargs[0 as libc::c_int as usize])
                    .offset(2 as libc::c_int as isize) = 'R' as i32 as libc::c_char;
                scrnum = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                if scrnum < 0 as libc::c_int || scrnum > 999 as libc::c_int {
                    scrnum = 0 as libc::c_int;
                    let ref mut fresh198 = *((*lines.offset(i as isize))
                        .stringargs[0 as libc::c_int as usize])
                        .offset(7 as libc::c_int as isize);
                    *fresh198 = '0' as i32 as libc::c_char;
                    let ref mut fresh199 = *((*lines.offset(i as isize))
                        .stringargs[0 as libc::c_int as usize])
                        .offset(6 as libc::c_int as isize);
                    *fresh199 = *fresh198;
                    *((*lines.offset(i as isize)).stringargs[0 as libc::c_int as usize])
                        .offset(5 as libc::c_int as isize) = *fresh199;
                } else {
                    *((*lines.offset(i as isize)).stringargs[0 as libc::c_int as usize])
                        .offset(
                            5 as libc::c_int as isize,
                        ) = ('0' as i32
                        + (scrnum / 100 as libc::c_int) as libc::c_char as libc::c_int)
                        as libc::c_char;
                    *((*lines.offset(i as isize)).stringargs[0 as libc::c_int as usize])
                        .offset(
                            6 as libc::c_int as isize,
                        ) = ('0' as i32
                        + (scrnum % 100 as libc::c_int / 10 as libc::c_int)
                            as libc::c_char as libc::c_int) as libc::c_char;
                    *((*lines.offset(i as isize)).stringargs[0 as libc::c_int as usize])
                        .offset(
                            7 as libc::c_int as isize,
                        ) = ('0' as i32
                        + (scrnum % 10 as libc::c_int) as libc::c_char as libc::c_int)
                        as libc::c_char;
                }
                *((*lines.offset(i as isize)).stringargs[0 as libc::c_int as usize])
                    .offset(8 as libc::c_int as isize) = '\0' as i32 as libc::c_char;
                current_block_1002 = 6860640994621533902;
            }
            416 => {
                current_block_1002 = 7920189851575299454;
            }
            417 => {
                current_block_1002 = 7920189851575299454;
            }
            602 | 603 => {
                current_block_1002 = 3593871541779009335;
            }
            418 => {
                current_block_1002 = 2124591267729336845;
            }
            419 => {
                current_block_1002 = 2124591267729336845;
            }
            604 | 605 => {
                current_block_1002 = 13877740714604000719;
            }
            420 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 16 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = if (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int > 0 as libc::c_int
                    {
                        (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .textureoffset >> 16 as libc::c_int
                    } else {
                        0 as libc::c_int
                    };
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = if (*lines.offset(i as isize))
                        .sidenum[1 as libc::c_int as usize] as libc::c_int
                        != 0xffff as libc::c_int
                        && (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int == 0
                    {
                        if (if ((*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[1 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int) < 255 as libc::c_int
                        {
                            (*sides
                                .offset(
                                    (*lines.offset(i as isize))
                                        .sidenum[1 as libc::c_int as usize] as isize,
                                ))
                                .rowoffset >> 16 as libc::c_int
                        } else {
                            255 as libc::c_int
                        }) > 0 as libc::c_int
                        {
                            if ((*sides
                                .offset(
                                    (*lines.offset(i as isize))
                                        .sidenum[1 as libc::c_int as usize] as isize,
                                ))
                                .rowoffset >> 16 as libc::c_int) < 255 as libc::c_int
                            {
                                (*sides
                                    .offset(
                                        (*lines.offset(i as isize))
                                            .sidenum[1 as libc::c_int as usize] as isize,
                                    ))
                                    .rowoffset >> 16 as libc::c_int
                            } else {
                                255 as libc::c_int
                            }
                        } else {
                            0 as libc::c_int
                        }
                    } else if (if ((*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .rowoffset >> 16 as libc::c_int) < 255 as libc::c_int
                    {
                        (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int
                    } else {
                        255 as libc::c_int
                    }) > 0 as libc::c_int
                    {
                        if ((*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int) < 255 as libc::c_int
                        {
                            (*sides
                                .offset(
                                    (*lines.offset(i as isize))
                                        .sidenum[0 as libc::c_int as usize] as isize,
                                ))
                                .rowoffset >> 16 as libc::c_int
                        } else {
                            255 as libc::c_int
                        }
                    } else {
                        0 as libc::c_int
                    };
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = (*(*lines.offset(i as isize)).frontsector).lightlevel
                        as int32_t;
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = abs(
                        P_AproxDistance(
                            (*lines.offset(i as isize)).dx,
                            (*lines.offset(i as isize)).dy,
                        ),
                    ) >> 16 as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    let ref mut fresh203 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh203 |= TMF_TICBASED as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 1024 as libc::c_int
                    != 0
                {
                    let ref mut fresh204 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh204 |= TMF_OVERRIDE as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            421 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                current_block_1002 = 6860640994621533902;
            }
            422 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int
                } else {
                    0 as libc::c_int
                };
                current_block_1002 = 6860640994621533902;
            }
            423 | 424 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            426 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            427 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            428 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0
                {
                    1 as libc::c_int
                } else {
                    0 as libc::c_int
                };
                current_block_1002 = 6860640994621533902;
            }
            429 => {
                current_block_1002 = 2711446258322330814;
            }
            430 | 431 => {
                current_block_1002 = 2711446258322330814;
            }
            432 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            433 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 32 as libc::c_int != 0) as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            434 => {
                if (*lines.offset(i as isize)).flags as libc::c_int & 2 as libc::c_int
                    == 0 as libc::c_int
                {
                    if !((*lines.offset(i as isize))
                        .stringargs[1 as libc::c_int as usize])
                        .is_null()
                    {
                        Z_Free(
                            (*lines.offset(i as isize))
                                .stringargs[1 as libc::c_int as usize] as *mut libc::c_void,
                        );
                        let ref mut fresh205 = (*lines.offset(i as isize))
                            .stringargs[1 as libc::c_int as usize];
                        *fresh205 = 0 as *mut libc::c_char;
                    }
                    P_WriteTics(
                        if (*lines.offset(i as isize)).flags as libc::c_int
                            & 64 as libc::c_int != 0
                        {
                            -(1 as libc::c_int)
                        } else {
                            (*sides
                                .offset(
                                    (*lines.offset(i as isize))
                                        .sidenum[0 as libc::c_int as usize] as isize,
                                ))
                                .textureoffset >> 16 as libc::c_int
                        },
                        &mut *((*lines.offset(i as isize)).stringargs)
                            .as_mut_ptr()
                            .offset(1 as libc::c_int as isize),
                    );
                }
                current_block_1002 = 6860640994621533902;
            }
            435 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = R_PointToDist2(
                    (*(*lines.offset(i as isize)).v2).x,
                    (*(*lines.offset(i as isize)).v2).y,
                    (*(*lines.offset(i as isize)).v1).x,
                    (*(*lines.offset(i as isize)).v1).y,
                ) >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            436 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            437 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            438 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            439 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int as usize] = TMSD_FRONTBACK as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 8192 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            441 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            442 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize))
                    .sidenum[1 as libc::c_int as usize] as libc::c_int
                    == 0xffff as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    0 as libc::c_int
                };
                current_block_1002 = 6860640994621533902;
            }
            443 => {
                if ((*lines.offset(i as isize)).stringargs[0 as libc::c_int as usize])
                    .is_null()
                {
                    CONS_Alert(
                        CONS_WARNING,
                        b"Linedef %s is missing the hook name of the Lua function to call! (This should be given in the front texture fields)\n\0"
                            as *const u8 as *const libc::c_char,
                        sizeu1(i),
                    );
                }
                current_block_1002 = 6860640994621533902;
            }
            444 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            445 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            446 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh206 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh206 |= TMFR_NORETURN as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 2 as libc::c_int
                    != 0
                {
                    let ref mut fresh207 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh207 |= TMFR_CHECKFLAG as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            447 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int
                    != 0
                {
                    let ref mut fresh208 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh208 |= TMCF_RELATIVE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh209 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh209
                        |= TMCF_SUBLIGHTR as libc::c_int | TMCF_SUBFADER as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh210 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh210
                        |= TMCF_SUBLIGHTG as libc::c_int | TMCF_SUBFADEG as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 128 as libc::c_int
                    != 0
                {
                    let ref mut fresh211 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh211
                        |= TMCF_SUBLIGHTB as libc::c_int | TMCF_SUBFADEB as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            448 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int
                    & (512 as libc::c_int | 2 as libc::c_int) == 512 as libc::c_int
                {
                    CONS_Alert(
                        CONS_WARNING,
                        b"Skybox switch linedef (tag %d) doesn't have anything to do.\nConsider changing the linedef's flag configuration or removing it entirely.\n\0"
                            as *const u8 as *const libc::c_char,
                        tag as libc::c_int,
                    );
                    (*lines.offset(i as isize)).special = 0 as libc::c_int as int16_t;
                } else {
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & (512 as libc::c_int | 2 as libc::c_int)
                        == 512 as libc::c_int | 2 as libc::c_int
                    {
                        (*lines.offset(i as isize))
                            .args[2 as libc::c_int
                            as usize] = TMS_CENTERPOINT as libc::c_int;
                    } else if (*lines.offset(i as isize)).flags as libc::c_int
                        & 2 as libc::c_int != 0
                    {
                        (*lines.offset(i as isize))
                            .args[2 as libc::c_int as usize] = TMS_BOTH as libc::c_int;
                    } else {
                        (*lines.offset(i as isize))
                            .args[2 as libc::c_int
                            as usize] = TMS_VIEWPOINT as libc::c_int;
                    }
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int
                        as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                        & 64 as libc::c_int != 0) as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            449 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            450 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                current_block_1002 = 6860640994621533902;
            }
            451 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            452 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = if (*lines.offset(i as isize))
                    .sidenum[1 as libc::c_int as usize] as libc::c_int
                    != 0xffff as libc::c_int
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[1 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int
                } else {
                    P_AproxDistance(
                        (*lines.offset(i as isize)).dx,
                        (*lines.offset(i as isize)).dy,
                    ) >> 16 as libc::c_int
                };
                if (*lines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int
                    != 0
                {
                    let ref mut fresh212 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh212 |= TMST_RELATIVE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh213 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh213 |= TMST_DONTDOTRANSLUCENT as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            453 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = if (*lines.offset(i as isize))
                    .sidenum[1 as libc::c_int as usize] as libc::c_int
                    != 0xffff as libc::c_int
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[1 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int
                } else {
                    (*lines.offset(i as isize)).dx >> 16 as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = if (*lines.offset(i as isize))
                    .sidenum[1 as libc::c_int as usize] as libc::c_int
                    != 0xffff as libc::c_int
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[1 as libc::c_int as usize] as isize,
                        ))
                        .rowoffset >> 16 as libc::c_int
                } else {
                    abs((*lines.offset(i as isize)).dy) >> 16 as libc::c_int
                };
                if (*lines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int
                    != 0
                {
                    let ref mut fresh214 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh214 |= TMFT_RELATIVE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 1024 as libc::c_int
                    != 0
                {
                    let ref mut fresh215 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh215 |= TMFT_OVERRIDE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    let ref mut fresh216 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh216 |= TMFT_TICBASED as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int
                    & 16384 as libc::c_int != 0
                {
                    let ref mut fresh217 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh217 |= TMFT_IGNORECOLLISION as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh218 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh218 |= TMFT_GHOSTFADE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh219 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh219 |= TMFT_DONTDOTRANSLUCENT as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 2 as libc::c_int
                    != 0
                {
                    let ref mut fresh220 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh220 |= TMFT_DONTDOEXISTS as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 128 as libc::c_int
                    != 0
                {
                    let ref mut fresh221 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh221
                        |= TMFT_DONTDOLIGHTING as libc::c_int
                            | TMFT_DONTDOCOLORMAP as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int
                    & 32768 as libc::c_int != 0
                {
                    let ref mut fresh222 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh222 |= TMFT_USEEXACTALPHA as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            454 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            455 => {
                let mut speed: int32_t = if ((*lines.offset(i as isize)).flags
                    as libc::c_int & 16 as libc::c_int != 0
                    || (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .rowoffset == 0)
                    && (*lines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                        as libc::c_int != 0xffff as libc::c_int
                {
                    abs(
                        (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[1 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int,
                    )
                } else {
                    abs(
                        (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int,
                    )
                };
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize)).args[2 as libc::c_int as usize] = speed;
                } else {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = (256 as libc::c_int + speed - 1 as libc::c_int)
                        / speed;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int
                    != 0
                {
                    let ref mut fresh223 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh223 |= TMCF_RELATIVE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh224 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh224
                        |= TMCF_SUBLIGHTR as libc::c_int | TMCF_SUBFADER as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh225 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh225
                        |= TMCF_SUBLIGHTG as libc::c_int | TMCF_SUBFADEG as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 128 as libc::c_int
                    != 0
                {
                    let ref mut fresh226 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh226
                        |= TMCF_SUBLIGHTB as libc::c_int | TMCF_SUBFADEB as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int
                    & 16384 as libc::c_int != 0
                {
                    let ref mut fresh227 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh227 |= TMCF_FROMBLACK as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 1024 as libc::c_int
                    != 0
                {
                    let ref mut fresh228 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh228 |= TMCF_OVERRIDE as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            456 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                current_block_1002 = 6860640994621533902;
            }
            457 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = if (*lines.offset(i as isize))
                    .sidenum[1 as libc::c_int as usize] as libc::c_int
                    != 0xffff as libc::c_int
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[1 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int
                } else {
                    0 as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 128 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            459 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 2 as libc::c_int
                    != 0
                {
                    let ref mut fresh229 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh229 |= TMP_CLOSE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh230 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh230 |= TMP_RUNPOSTEXEC as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int
                    & 32768 as libc::c_int != 0
                {
                    let ref mut fresh231 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh231 |= TMP_CALLBYNAME as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 128 as libc::c_int
                    != 0
                {
                    let ref mut fresh232 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh232 |= TMP_KEEPCONTROLS as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int
                    != 0
                {
                    let ref mut fresh233 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh233 |= TMP_KEEPREALTIME as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = if (*lines.offset(i as isize))
                    .sidenum[1 as libc::c_int as usize] as libc::c_int
                    != 0xffff as libc::c_int
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[1 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int
                } else {
                    tag as libc::c_int
                };
                current_block_1002 = 6860640994621533902;
            }
            460 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            461 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*(*lines.offset(i as isize)).frontsector).floorheight
                    >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                    & 32 as libc::c_int != 0
                {
                    AngleFixed(
                        R_PointToAngle2(
                            (*(*lines.offset(i as isize)).v1).x,
                            (*(*lines.offset(i as isize)).v1).y,
                            (*(*lines.offset(i as isize)).v2).x,
                            (*(*lines.offset(i as isize)).v2).y,
                        ),
                    ) >> 16 as libc::c_int
                } else {
                    0 as libc::c_int
                };
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    if (*lines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                        as libc::c_int != 0xffff as libc::c_int
                    {
                        (*lines.offset(i as isize))
                            .args[4 as libc::c_int as usize] = 1 as libc::c_int;
                        (*lines.offset(i as isize))
                            .args[5 as libc::c_int
                            as usize] = (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[1 as libc::c_int as usize] as isize,
                            ))
                            .textureoffset >> 16 as libc::c_int;
                        (*lines.offset(i as isize))
                            .args[6 as libc::c_int
                            as usize] = (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[1 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int;
                        (*lines.offset(i as isize))
                            .args[7 as libc::c_int
                            as usize] = (*(*lines.offset(i as isize)).frontsector)
                            .ceilingheight >> 16 as libc::c_int;
                    } else {
                        CONS_Alert(
                            CONS_WARNING,
                            b"Linedef Type %d - Spawn Object: Linedef is set for random range but has no back side.\n\0"
                                as *const u8 as *const libc::c_char,
                            (*lines.offset(i as isize)).special as libc::c_int,
                        );
                        (*lines.offset(i as isize))
                            .args[4 as libc::c_int as usize] = 0 as libc::c_int;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize] = 0 as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            464 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            466 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            467 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int as usize] = TML_SECTOR as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 256 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            480 | 481 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                    as libc::c_int != 0xffff as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int
                        as usize] = (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[1 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            482 | 483 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).special as libc::c_int
                    == 483 as libc::c_int) as libc::c_int;
                (*lines.offset(i as isize)).special = 482 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            484 => {
                current_block_1002 = 11774153162339022650;
            }
            485 => {
                current_block_1002 = 11774153162339022650;
            }
            486 | 487 => {
                current_block_1002 = 15793766273615434088;
            }
            488 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = PWR_WRAP as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 128 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = PWR_COMEBACK as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = PWR_STOP as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh239 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh239 |= PWF_REVERSE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    let ref mut fresh240 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh240 |= PWF_LOOP as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            489 | 490 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = 491 as libc::c_int
                    - (*lines.offset(i as isize)).special as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    == 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                }
                (*lines.offset(i as isize)).special = 489 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            491 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (if (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset != 0
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset
                } else {
                    (*(*lines.offset(i as isize)).frontsector).floorheight
                }) >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 16 as libc::c_int
                    == 0
                {
                    let ref mut fresh241 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh241 /= 100 as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 256 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            492 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (if (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset != 0
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset
                } else {
                    (*(*lines.offset(i as isize)).frontsector).floorheight
                }) >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 16 as libc::c_int
                    == 0
                {
                    let ref mut fresh242 = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    *fresh242 /= 100 as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = if (*lines.offset(i as isize))
                    .sidenum[1 as libc::c_int as usize] as libc::c_int
                    != 0xffff as libc::c_int
                    && (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .rowoffset == 0
                {
                    abs(
                        (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[1 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int,
                    )
                } else {
                    abs(
                        (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int,
                    )
                };
                if (*lines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int
                    != 0
                {
                    let ref mut fresh243 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh243 |= TMPF_RELATIVE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 1024 as libc::c_int
                    != 0
                {
                    let ref mut fresh244 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh244 |= TMPF_OVERRIDE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    let ref mut fresh245 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh245 |= TMPF_TICBASED as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int
                    & 16384 as libc::c_int != 0
                {
                    let ref mut fresh246 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh246 |= TMPF_IGNORECOLLISION as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh247 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh247 |= TMPF_GHOSTFADE as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            500 | 501 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = 0 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 500 as libc::c_int
                {
                    -(1 as libc::c_int)
                } else {
                    1 as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int as usize] = 0 as libc::c_int;
                (*lines.offset(i as isize)).special = 500 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            502 => {
                current_block_1002 = 6191418209739601196;
            }
            503 | 504 => {
                current_block_1002 = 6191418209739601196;
            }
            505 => {
                current_block_1002 = 12709600971544251898;
            }
            506 => {
                current_block_1002 = 12709600971544251898;
            }
            507 | 508 => {
                current_block_1002 = 4424184993827731645;
            }
            510 => {
                current_block_1002 = 11095206836468387730;
            }
            511 => {
                current_block_1002 = 11095206836468387730;
            }
            512 => {
                current_block_1002 = 4915337751243087799;
            }
            513 => {
                current_block_1002 = 7486809501398986074;
            }
            514 => {
                current_block_1002 = 3561365719365783972;
            }
            515 => {
                current_block_1002 = 9202549138398437433;
            }
            516 => {
                current_block_1002 = 17000289985398837327;
            }
            517 => {
                current_block_1002 = 781376077467926937;
            }
            518 => {
                current_block_1002 = 8223248126057502985;
            }
            520 => {
                current_block_1002 = 14890633166657215186;
            }
            521 => {
                current_block_1002 = 11783215275178290717;
            }
            522 => {
                current_block_1002 = 12781316935607599745;
            }
            523 => {
                current_block_1002 = 3242543460668740766;
            }
            524 => {
                current_block_1002 = 10448352471842181315;
            }
            525 => {
                current_block_1002 = 15721569559606651444;
            }
            526 => {
                current_block_1002 = 5471983970216170950;
            }
            527 => {
                current_block_1002 = 3114118470539981388;
            }
            528 => {
                current_block_1002 = 2510268812606746677;
            }
            530 => {
                current_block_1002 = 3661326538650816866;
            }
            531 => {
                current_block_1002 = 13603703177024492576;
            }
            532 => {
                current_block_1002 = 10424734802533018211;
            }
            533 => {
                current_block_1002 = 7839485439258254799;
            }
            534 => {
                current_block_1002 = 3327335973037550489;
            }
            535 => {
                current_block_1002 = 8288947012521031670;
            }
            536 => {
                current_block_1002 = 11554152168876335608;
            }
            537 | 538 => {
                current_block_1002 = 11912628379678300127;
            }
            540 => {
                let mut s_2: int32_t = 0;
                let mut strength: fixed_t = 0;
                let mut friction: fixed_t = 0;
                strength = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                if strength > 0 as libc::c_int {
                    strength = strength * 2 as libc::c_int;
                }
                friction = ((0xe8 as libc::c_int)
                    << 16 as libc::c_int - 8 as libc::c_int)
                    - 0x1eb8 as libc::c_int * strength / 0x80 as libc::c_int;
                let mut ICNT_5878: size_t = 0 as libc::c_int as size_t;
                loop {
                    s_2 = Tag_Iterate_Sectors(tag, ICNT_5878);
                    if !(s_2 >= 0 as libc::c_int) {
                        break;
                    }
                    (*sectors.offset(s_2 as isize)).friction = friction;
                    ICNT_5878 = ICNT_5878.wrapping_add(1);
                    ICNT_5878;
                }
                current_block_1002 = 6860640994621533902;
            }
            541 => {
                current_block_1002 = 6459267918626391987;
            }
            542 => {
                current_block_1002 = 6459267918626391987;
            }
            543 => {
                current_block_1002 = 16541782871923729959;
            }
            544 => {
                current_block_1002 = 17618199399334942386;
            }
            545 => {
                current_block_1002 = 14757670262871053695;
            }
            546 => {
                current_block_1002 = 16332740329180794166;
            }
            600 | 601 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 601 as libc::c_int
                {
                    TMP_CEILING as libc::c_int
                } else {
                    TMP_FLOOR as libc::c_int
                };
                (*lines.offset(i as isize)).special = 600 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            606 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                current_block_1002 = 6860640994621533902;
            }
            700 => {
                current_block_1002 = 12736163629078028857;
            }
            701 => {
                current_block_1002 = 12736163629078028857;
            }
            702 => {
                current_block_1002 = 149172290493413128;
            }
            703 => {
                current_block_1002 = 16145095014185817216;
            }
            710 => {
                current_block_1002 = 15509564538253101067;
            }
            711 => {
                current_block_1002 = 2944053543039949385;
            }
            712 => {
                current_block_1002 = 5876386205689480058;
            }
            713 => {
                current_block_1002 = 10281805988156872726;
            }
            704 => {
                current_block_1002 = 8691338013887144499;
            }
            705 => {
                current_block_1002 = 8691338013887144499;
            }
            714 => {
                current_block_1002 = 8381375092814948376;
            }
            715 => {
                current_block_1002 = 3846743647805669517;
            }
            720 => {
                current_block_1002 = 13242826846503055997;
            }
            721 | 722 => {
                current_block_1002 = 13242826846503055997;
            }
            723 => {
                current_block_1002 = 8910889541698101569;
            }
            724 | 725 => {
                current_block_1002 = 8910889541698101569;
            }
            730 => {
                current_block_1002 = 9991113203896008483;
            }
            731 | 732 => {
                current_block_1002 = 9991113203896008483;
            }
            733 => {
                current_block_1002 = 6694205228417885073;
            }
            734 | 735 => {
                current_block_1002 = 6694205228417885073;
            }
            799 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                current_block_1002 = 6860640994621533902;
            }
            909 => {
                (*lines.offset(i as isize))
                    .blendmode = AST_FOG as libc::c_int as uint8_t;
                current_block_1002 = 6860640994621533902;
            }
            _ => {
                current_block_1002 = 6860640994621533902;
            }
        }
        match current_block_1002 {
            6694205228417885073 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 734 as libc::c_int
                {
                    let ref mut fresh258 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh258 |= TMSC_BACKTOFRONTFLOOR as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 733 as libc::c_int
                {
                    let ref mut fresh259 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh259 |= TMSC_BACKTOFRONTCEILING as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 720 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            9991113203896008483 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 731 as libc::c_int
                {
                    let ref mut fresh256 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh256 |= TMSC_FRONTTOBACKFLOOR as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 730 as libc::c_int
                {
                    let ref mut fresh257 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh257 |= TMSC_FRONTTOBACKCEILING as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 720 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            8910889541698101569 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 724 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = tag as int32_t;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 723 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = tag as int32_t;
                }
                (*lines.offset(i as isize)).special = 720 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            13242826846503055997 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 721 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = tag as int32_t;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 720 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = tag as int32_t;
                }
                (*lines.offset(i as isize)).special = 720 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            6191418209739601196 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int
                    != 0
                {
                    if (*lines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                        as libc::c_int == 0xffff as libc::c_int
                    {
                        CONS_Debug(
                            0x80 as libc::c_int,
                            b"Line special %d (line #%s) missing back side!\n\0"
                                as *const u8 as *const libc::c_char,
                            (*lines.offset(i as isize)).special as libc::c_int,
                            sizeu1(i),
                        );
                        (*lines.offset(i as isize))
                            .special = 0 as libc::c_int as int16_t;
                        current_block_1002 = 6860640994621533902;
                    } else {
                        (*lines.offset(i as isize))
                            .args[1 as libc::c_int as usize] = 1 as libc::c_int;
                        current_block_1002 = 17928413824818536617;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 0 as libc::c_int;
                    current_block_1002 = 17928413824818536617;
                }
                match current_block_1002 {
                    6860640994621533902 => {}
                    _ => {
                        if (*lines.offset(i as isize)).flags as libc::c_int
                            & 128 as libc::c_int != 0
                        {
                            (*lines.offset(i as isize))
                                .args[2 as libc::c_int
                                as usize] = (*sides
                                .offset(
                                    (*lines.offset(i as isize))
                                        .sidenum[0 as libc::c_int as usize] as isize,
                                ))
                                .textureoffset >> 16 as libc::c_int - 5 as libc::c_int;
                            (*lines.offset(i as isize))
                                .args[3 as libc::c_int
                                as usize] = (*sides
                                .offset(
                                    (*lines.offset(i as isize))
                                        .sidenum[0 as libc::c_int as usize] as isize,
                                ))
                                .rowoffset >> 16 as libc::c_int - 5 as libc::c_int;
                        } else {
                            (*lines.offset(i as isize))
                                .args[2 as libc::c_int
                                as usize] = (*lines.offset(i as isize)).dx
                                >> 16 as libc::c_int;
                            (*lines.offset(i as isize))
                                .args[3 as libc::c_int
                                as usize] = (*lines.offset(i as isize)).dy
                                >> 16 as libc::c_int;
                        }
                        (*lines.offset(i as isize))
                            .args[4 as libc::c_int
                            as usize] = (*lines.offset(i as isize)).special
                            as libc::c_int - 502 as libc::c_int;
                        (*lines.offset(i as isize))
                            .special = 502 as libc::c_int as int16_t;
                        current_block_1002 = 6860640994621533902;
                    }
                }
            }
            2711446258322330814 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 429 as libc::c_int
                {
                    TMP_CEILING as libc::c_int
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 430 as libc::c_int
                {
                    TMP_FLOOR as libc::c_int
                } else {
                    TMP_BOTH as libc::c_int
                };
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 430 as libc::c_int
                    || (*lines.offset(i as isize)).flags as libc::c_int
                        & 512 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = abs((*lines.offset(i as isize)).dx)
                        >> 16 as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int
                        as usize] = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                } else {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = R_PointToDist2(
                        (*(*lines.offset(i as isize)).v2).x,
                        (*(*lines.offset(i as isize)).v2).y,
                        (*(*lines.offset(i as isize)).v1).x,
                        (*(*lines.offset(i as isize)).v1).y,
                    ) >> 16 as libc::c_int + 1 as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int
                        as usize] = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] / 4 as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 429 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            10842599078927360536 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 345 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_ONCE as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 344 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        TMT_EACHTIMEENTERANDEXIT as libc::c_int
                    } else {
                        TMT_EACHTIMEENTER as libc::c_int
                    };
                } else {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_CONTINUOUS as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 2 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = TMG_TEMPREVERSE as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = TMG_REVERSE as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 343 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            14081740663943781683 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 342 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_ONCE as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 341 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        TMT_EACHTIMEENTERANDEXIT as libc::c_int
                    } else {
                        TMT_EACHTIMEENTER as libc::c_int
                    };
                } else {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_CONTINUOUS as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMC_LTE as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMC_GTE as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = TMC_EQUAL as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 340 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            3490761217750026838 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 339 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_ONCE as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 338 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        TMT_EACHTIMEENTERANDEXIT as libc::c_int
                    } else {
                        TMT_EACHTIMEENTER as libc::c_int
                    };
                } else {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_CONTINUOUS as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = 1 as libc::c_int | 2 as libc::c_int | 4 as libc::c_int
                    | 8 as libc::c_int | 16 as libc::c_int | 32 as libc::c_int
                    | 64 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int as usize] = TMF_HASALL as libc::c_int;
                (*lines.offset(i as isize)).special = 337 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            17350251256590394187 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 336 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_ONCE as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 335 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        TMT_EACHTIMEENTERANDEXIT as libc::c_int
                    } else {
                        TMT_EACHTIMEENTER as libc::c_int
                    };
                } else {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_CONTINUOUS as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                (*lines.offset(i as isize)).special = 334 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            5529689922675175864 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 333 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_ONCE as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 332 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        TMT_EACHTIMEENTERANDEXIT as libc::c_int
                    } else {
                        TMT_EACHTIMEENTER as libc::c_int
                    };
                } else {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_CONTINUOUS as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0) as libc::c_int;
                (*lines.offset(i as isize)).special = 331 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            4672609343193835635 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 307 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_ONCE as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 306 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        TMT_EACHTIMEENTERANDEXIT as libc::c_int
                    } else {
                        TMT_EACHTIMEENTER as libc::c_int
                    };
                } else {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_CONTINUOUS as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int) / 10 as libc::c_int;
                (*lines.offset(i as isize)).special = 305 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            14979349787004695573 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 302 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_ONCE as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 301 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        TMT_EACHTIMEENTERANDEXIT as libc::c_int
                    } else {
                        TMT_EACHTIMEENTER as libc::c_int
                    };
                } else {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_CONTINUOUS as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 300 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            10086740511237005094 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 221 as libc::c_int
                {
                    P_SetBinaryFOFAlpha(&mut *lines.offset(i as isize));
                    if (*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                        == 256 as libc::c_int
                    {
                        let ref mut fresh164 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh164 |= TMFA_SPLAT as libc::c_int;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 255 as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 222 as libc::c_int
                {
                    let ref mut fresh165 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh165 |= TMFA_NOPLANES as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 221 as libc::c_int
                {
                    let ref mut fresh166 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh166 |= TMFA_INSIDES as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 220 as libc::c_int
                    && (*lines.offset(i as isize)).flags as libc::c_int
                        & 64 as libc::c_int == 0
                {
                    let ref mut fresh167 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh167 |= TMFA_NOSHADE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                {
                    let ref mut fresh168 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh168 |= TMFA_SPLAT as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 220 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            8095681603675559136 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*lines.offset(i as isize)).special as libc::c_int
                    - 66 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh114 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh114 *= -(1 as libc::c_int);
                }
                (*lines.offset(i as isize)).special = 66 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            660191227468549570 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 56 as libc::c_int
                {
                    TMP_BOTH as libc::c_int
                } else {
                    (*lines.offset(i as isize)).special as libc::c_int
                        - 57 as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = abs((*lines.offset(i as isize)).dx) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = abs((*lines.offset(i as isize)).dy) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[5 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize)).special = 56 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            2652155047008587766 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 53 as libc::c_int
                {
                    TMP_BOTH as libc::c_int
                } else {
                    (*lines.offset(i as isize)).special as libc::c_int
                        - 54 as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = (*lines.offset(i as isize))
                    .args[2 as libc::c_int as usize];
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[5 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize)).special = 53 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            3176299481022176532 => {
                current_block_1002 = 14055165045049786312;
            }
            13891542684839355158 => {
                current_block_1002 = 16557744034144139236;
            }
            10213811827501540822 => {
                current_block_1002 = 4630481709593923503;
            }
            15901652309940696178 => {
                current_block_1002 = 6376668003191104824;
            }
            14755265072784038703 => {
                current_block_1002 = 12016556137065168597;
            }
            614554557968527432 => {
                current_block_1002 = 16406402859371515597;
            }
            1552796785379166655 => {
                current_block_1002 = 17751681062231209435;
            }
            10776215054357342558 => {
                current_block_1002 = 177286901473062006;
            }
            1615022513158998073 => {
                current_block_1002 = 8545310219052855647;
            }
            7920189851575299454 => {
                current_block_1002 = 3593871541779009335;
            }
            2124591267729336845 => {
                current_block_1002 = 13877740714604000719;
            }
            11774153162339022650 => {
                current_block_1002 = 15793766273615434088;
            }
            12709600971544251898 => {
                current_block_1002 = 4424184993827731645;
            }
            11095206836468387730 => {
                current_block_1002 = 4915337751243087799;
            }
            6459267918626391987 => {
                current_block_1002 = 16541782871923729959;
            }
            12736163629078028857 => {
                current_block_1002 = 149172290493413128;
            }
            8691338013887144499 => {
                current_block_1002 = 8381375092814948376;
            }
            _ => {}
        }
        match current_block_1002 {
            4424184993827731645 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).special as libc::c_int
                    >= 507 as libc::c_int) as libc::c_int;
                if (*lines.offset(i as isize)).special as libc::c_int % 2 as libc::c_int
                    == 0 as libc::c_int
                {
                    if (*lines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                        as libc::c_int == 0xffff as libc::c_int
                    {
                        CONS_Debug(
                            0x80 as libc::c_int,
                            b"Line special %d (line #%s) missing back side!\n\0"
                                as *const u8 as *const libc::c_char,
                            (*lines.offset(i as isize)).special as libc::c_int,
                            sizeu1(i),
                        );
                        (*lines.offset(i as isize))
                            .special = 0 as libc::c_int as int16_t;
                        current_block_1002 = 6860640994621533902;
                    } else {
                        (*lines.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[1 as libc::c_int as usize] as isize,
                            ))
                            .textureoffset >> 16 as libc::c_int;
                        (*lines.offset(i as isize))
                            .args[2 as libc::c_int
                            as usize] = (*sides
                            .offset(
                                (*lines.offset(i as isize))
                                    .sidenum[1 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int;
                        current_block_1002 = 8091546701475777769;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset >> 16 as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .rowoffset >> 16 as libc::c_int;
                    current_block_1002 = 8091546701475777769;
                }
                match current_block_1002 {
                    6860640994621533902 => {}
                    _ => {
                        (*lines.offset(i as isize))
                            .special = 500 as libc::c_int as int16_t;
                        current_block_1002 = 6860640994621533902;
                    }
                }
            }
            15793766273615434088 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).args[2 as libc::c_int as usize]
                    == 360 as libc::c_int
                {
                    let ref mut fresh234 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh234 |= TMPR_CONTINUOUS as libc::c_int;
                } else if (*lines.offset(i as isize)).args[2 as libc::c_int as usize]
                    == 0 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize] = 360 as libc::c_int;
                }
                if ((*lines.offset(i as isize)).special as libc::c_int)
                    < 486 as libc::c_int
                {
                    let ref mut fresh235 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh235 *= -(1 as libc::c_int);
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh236 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh236 |= TMPR_DONTROTATEOTHERS as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 512 as libc::c_int != 0
                {
                    let ref mut fresh237 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh237 |= TMPR_ROTATEPLAYERS as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int % 2 as libc::c_int
                    == 1 as libc::c_int
                {
                    let ref mut fresh238 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh238 |= TMPR_OVERRIDE as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 484 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            13877740714604000719 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = abs((*lines.offset(i as isize)).dx) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = abs((*lines.offset(i as isize)).dy) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = (*(*lines.offset(i as isize)).frontsector).lightlevel
                    as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0 && !((*lines.offset(i as isize)).backsector).is_null()
                {
                    (*lines.offset(i as isize))
                        .args[5 as libc::c_int
                        as usize] = (*(*lines.offset(i as isize)).backsector).lightlevel
                        as int32_t;
                } else {
                    let ref mut fresh200 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh200 |= TMB_USETARGET as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int % 2 as libc::c_int
                    == 1 as libc::c_int
                {
                    let ref mut fresh201 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh201 |= TMB_SYNC as libc::c_int;
                    let ref mut fresh202 = (*lines.offset(i as isize)).special;
                    *fresh202 -= 1;
                    *fresh202;
                }
                current_block_1002 = 6860640994621533902;
            }
            3593871541779009335 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*(*lines.offset(i as isize)).frontsector).lightlevel
                    as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0 && !((*lines.offset(i as isize)).backsector).is_null()
                {
                    (*lines.offset(i as isize))
                        .args[4 as libc::c_int
                        as usize] = (*(*lines.offset(i as isize)).backsector).lightlevel
                        as int32_t;
                } else {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = 1 as libc::c_int;
                }
                current_block_1002 = 6860640994621533902;
            }
            177286901473062006 => {
                if (*lines.offset(i as isize)).special as libc::c_int % 2 as libc::c_int
                    == 0 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        TMT_EACHTIMEENTERANDEXIT as libc::c_int
                    } else {
                        TMT_EACHTIMEENTER as libc::c_int
                    };
                } else {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMT_CONTINUOUS as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    > 310 as libc::c_int
                {
                    TMT_BLUE as libc::c_int
                } else {
                    TMT_RED as libc::c_int
                };
                (*lines.offset(i as isize)).special = 309 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            6376668003191104824 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    == 150 as libc::c_int
                {
                    16 as libc::c_int
                } else {
                    P_AproxDistance(
                        (*lines.offset(i as isize)).dx,
                        (*lines.offset(i as isize)).dy,
                    ) >> 16 as libc::c_int
                };
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 152 as libc::c_int
                {
                    let ref mut fresh142 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh142 |= TMFB_REVERSE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh143 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh143 |= TMFB_SPINDASH as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 153 as libc::c_int
                {
                    let ref mut fresh144 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh144 |= TMFB_DYNAMIC as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 150 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            14055165045049786312 => {
                current_block_1002 = 6938283216177311918;
            }
            16557744034144139236 => {
                current_block_1002 = 11052763078889702642;
            }
            4630481709593923503 => {
                current_block_1002 = 1737444249807734800;
            }
            12016556137065168597 => {
                current_block_1002 = 5254254926722712074;
            }
            16406402859371515597 => {
                current_block_1002 = 11836790636291352653;
            }
            17751681062231209435 => {
                current_block_1002 = 8260881556307538170;
            }
            8545310219052855647 => {
                current_block_1002 = 14038448619486050115;
            }
            4915337751243087799 => {
                current_block_1002 = 7486809501398986074;
            }
            16541782871923729959 => {
                current_block_1002 = 17618199399334942386;
            }
            149172290493413128 => {
                current_block_1002 = 16145095014185817216;
            }
            8381375092814948376 => {
                current_block_1002 = 3846743647805669517;
            }
            _ => {}
        }
        match current_block_1002 {
            3846743647805669517 => {
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 704 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = TMSP_FRONTFLOOR as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 705 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = TMSP_FRONTCEILING as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 714 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMSP_BACKFLOOR as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 715 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = TMSP_BACKCEILING as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                {
                    let mut side: uint8_t = ((*lines.offset(i as isize)).special
                        as libc::c_int >= 714 as libc::c_int) as libc::c_int as uint8_t;
                    if side as libc::c_int == 1 as libc::c_int
                        && (*lines.offset(i as isize)).sidenum[1 as libc::c_int as usize]
                            as libc::c_int == 0xffff as libc::c_int
                    {
                        CONS_Debug(
                            0x80 as libc::c_int,
                            b"P_ConvertBinaryMap: Line special %d (line #%s) missing 2nd side!\n\0"
                                as *const u8 as *const libc::c_char,
                            (*lines.offset(i as isize)).special as libc::c_int,
                            sizeu1(i),
                        );
                    } else {
                        (*lines.offset(i as isize))
                            .args[2 as libc::c_int
                            as usize] = (*sides
                            .offset(
                                (*lines.offset(i as isize)).sidenum[side as usize] as isize,
                            ))
                            .textureoffset >> 16 as libc::c_int;
                        (*lines.offset(i as isize))
                            .args[3 as libc::c_int
                            as usize] = (*sides
                            .offset(
                                (*lines.offset(i as isize)).sidenum[side as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int
                        as usize] = (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize];
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 2048 as libc::c_int
                    != 0
                {
                    let ref mut fresh254 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh254 |= TMSL_NOPHYSICS as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 4096 as libc::c_int
                    != 0
                {
                    let ref mut fresh255 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh255 |= TMSL_DYNAMIC as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 704 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            8260881556307538170 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 253 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 256 as libc::c_int
                {
                    P_SetBinaryFOFAlpha(&mut *lines.offset(i as isize));
                    if (*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                        == 256 as libc::c_int
                    {
                        let ref mut fresh171 = (*lines.offset(i as isize))
                            .args[4 as libc::c_int as usize];
                        *fresh171 |= TMFB_SPLAT as libc::c_int;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 255 as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    <= 253 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = TMFB_TOUCH as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    >= 255 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = TMFB_SPIN as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 64 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = TMFB_STRONG as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = TMFB_REGULAR as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    let ref mut fresh172 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh172 |= TMFB_PUSHABLES as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 1024 as libc::c_int
                    != 0
                {
                    let ref mut fresh173 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh173 |= TMFB_EXECUTOR as libc::c_int;
                    (*lines.offset(i as isize))
                        .args[5 as libc::c_int
                        as usize] = P_AproxDistance(
                        (*lines.offset(i as isize)).dx,
                        (*lines.offset(i as isize)).dy,
                    ) >> 16 as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 252 as libc::c_int
                    && (*lines.offset(i as isize)).flags as libc::c_int
                        & 64 as libc::c_int != 0
                {
                    let ref mut fresh174 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh174 |= TMFB_ONLYBOTTOM as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                {
                    let ref mut fresh175 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh175 |= TMFB_SPLAT as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 254 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            6938283216177311918 => {
                current_block_1002 = 5611371826125380931;
            }
            11052763078889702642 => {
                current_block_1002 = 18062067447159258204;
            }
            1737444249807734800 => {
                current_block_1002 = 4836002175010205657;
            }
            5254254926722712074 => {
                current_block_1002 = 86100791935436905;
            }
            11836790636291352653 => {
                current_block_1002 = 5147096127775914812;
            }
            14038448619486050115 => {
                current_block_1002 = 13860011571733000765;
            }
            7486809501398986074 => {
                current_block_1002 = 3561365719365783972;
            }
            17618199399334942386 => {
                current_block_1002 = 14757670262871053695;
            }
            16145095014185817216 => {
                current_block_1002 = 15509564538253101067;
            }
            _ => {}
        }
        match current_block_1002 {
            5147096127775914812 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 192 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 195 as libc::c_int
                {
                    P_SetBinaryFOFAlpha(&mut *lines.offset(i as isize));
                    if (*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                        == 256 as libc::c_int
                    {
                        let ref mut fresh154 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh154 |= TMFA_SPLAT as libc::c_int;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 255 as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 193 as libc::c_int
                {
                    let ref mut fresh155 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh155
                        |= TMFA_NOPLANES as libc::c_int | TMFA_NOSIDES as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    >= 194 as libc::c_int
                {
                    let ref mut fresh156 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh156 |= TMFA_INSIDES as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 190 as libc::c_int
                    && ((*lines.offset(i as isize)).special as libc::c_int
                        <= 193 as libc::c_int
                        || (*lines.offset(i as isize)).flags as libc::c_int
                            & 64 as libc::c_int != 0)
                {
                    let ref mut fresh157 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh157 |= TMFA_NOSHADE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                {
                    let ref mut fresh158 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh158 |= TMFA_SPLAT as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh159 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh159 |= TMFT_DONTBLOCKOTHERS as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 128 as libc::c_int
                    != 0
                {
                    let ref mut fresh160 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh160 |= TMFT_DONTBLOCKPLAYER as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    >= 194 as libc::c_int
                {
                    let ref mut fresh161 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh161 |= TMFT_INTANGIBLEBOTTOM as libc::c_int;
                }
                (*lines.offset(i as isize))
                    .args[5 as libc::c_int
                    as usize] = P_AproxDistance(
                    (*lines.offset(i as isize)).dx,
                    (*lines.offset(i as isize)).dy,
                ) >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 2 as libc::c_int
                    != 0
                {
                    let ref mut fresh162 = (*lines.offset(i as isize))
                        .args[6 as libc::c_int as usize];
                    *fresh162 |= TMFR_REVERSE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh163 = (*lines.offset(i as isize))
                        .args[6 as libc::c_int as usize];
                    *fresh163 |= TMFR_SPINDASH as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 190 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            18062067447159258204 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 120 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 122 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 255 as libc::c_int;
                } else {
                    P_SetBinaryFOFAlpha(&mut *lines.offset(i as isize));
                    if (*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                        == 256 as libc::c_int
                    {
                        let ref mut fresh124 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh124 |= TMFW_SPLAT as libc::c_int;
                    }
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 122 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 123 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 125 as libc::c_int
                {
                    let ref mut fresh125 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh125 |= TMFW_NOSIDES as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    let ref mut fresh126 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh126 |= TMFW_DOUBLESHADOW as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    let ref mut fresh127 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh127 |= TMFW_COLORMAPONLY as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 1024 as libc::c_int
                    == 0
                {
                    let ref mut fresh128 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh128 |= TMFW_NORIPPLE as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    >= 124 as libc::c_int
                {
                    let ref mut fresh129 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh129 |= TMFW_GOOWATER as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                {
                    let ref mut fresh130 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh130 |= TMFW_SPLAT as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 120 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            5611371826125380931 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 102 as libc::c_int
                {
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 64 as libc::c_int != 0
                    {
                        let ref mut fresh115 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh115 |= TMFA_INSIDES as libc::c_int;
                    }
                    P_SetBinaryFOFAlpha(&mut *lines.offset(i as isize));
                    if (*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                        == 256 as libc::c_int
                    {
                        let ref mut fresh116 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh116 |= TMFA_SPLAT as libc::c_int;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 255 as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 105 as libc::c_int
                {
                    let ref mut fresh117 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh117
                        |= TMFA_NOPLANES as libc::c_int | TMFA_NOSIDES as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 104 as libc::c_int
                {
                    let ref mut fresh118 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh118 |= TMFA_NOSIDES as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 103 as libc::c_int
                {
                    let ref mut fresh119 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh119 |= TMFA_NOPLANES as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 100 as libc::c_int
                    && ((*lines.offset(i as isize)).special as libc::c_int
                        != 104 as libc::c_int
                        || (*lines.offset(i as isize)).flags as libc::c_int
                            & 64 as libc::c_int == 0)
                {
                    let ref mut fresh120 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh120 |= TMFA_NOSHADE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                {
                    let ref mut fresh121 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh121 |= TMFA_SPLAT as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh122 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh122 |= TMFT_DONTBLOCKOTHERS as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 128 as libc::c_int
                    != 0
                {
                    let ref mut fresh123 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh123 |= TMFT_DONTBLOCKPLAYER as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 100 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            4836002175010205657 => {
                current_block_1002 = 72044055750383046;
            }
            86100791935436905 => {
                current_block_1002 = 1580848837534479582;
            }
            13860011571733000765 => {
                current_block_1002 = 7698913941061410784;
            }
            3561365719365783972 => {
                current_block_1002 = 9202549138398437433;
            }
            14757670262871053695 => {
                current_block_1002 = 16332740329180794166;
            }
            15509564538253101067 => {
                current_block_1002 = 2944053543039949385;
            }
            _ => {}
        }
        match current_block_1002 {
            16332740329180794166 => {
                let mut strength_0: fixed_t = if (*lines.offset(i as isize)).flags
                    as libc::c_int & 8192 as libc::c_int != 0
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset
                } else {
                    R_PointToDist2(
                        (*(*lines.offset(i as isize)).v2).x,
                        (*(*lines.offset(i as isize)).v2).y,
                        (*(*lines.offset(i as isize)).v1).x,
                        (*(*lines.offset(i as isize)).v1).y,
                    )
                };
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                match ((*lines.offset(i as isize)).special as libc::c_int
                    - 541 as libc::c_int) % 3 as libc::c_int
                {
                    0 => {
                        (*lines.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = strength_0 >> 16 as libc::c_int;
                    }
                    1 => {
                        (*lines.offset(i as isize))
                            .args[2 as libc::c_int
                            as usize] = strength_0 >> 16 as libc::c_int;
                    }
                    2 => {
                        (*lines.offset(i as isize))
                            .args[2 as libc::c_int
                            as usize] = -strength_0 >> 16 as libc::c_int;
                    }
                    _ => {}
                }
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = if (*lines.offset(i as isize)).special as libc::c_int
                    >= 544 as libc::c_int
                {
                    p_current as libc::c_int
                } else {
                    p_wind as libc::c_int
                };
                if (*lines.offset(i as isize)).flags as libc::c_int & 512 as libc::c_int
                    != 0
                {
                    let ref mut fresh249 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh249 |= TMPF_SLIDE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    == 0
                {
                    let ref mut fresh250 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh250 |= TMPF_NONEXCLUSIVE as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 541 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            72044055750383046 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 141 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 142 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 144 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 145 as libc::c_int
                {
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 64 as libc::c_int != 0
                    {
                        let ref mut fresh131 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh131 |= TMFA_INSIDES as libc::c_int;
                    }
                    P_SetBinaryFOFAlpha(&mut *lines.offset(i as isize));
                    if (*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                        == 256 as libc::c_int
                    {
                        let ref mut fresh132 = (*lines.offset(i as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh132 |= TMFA_SPLAT as libc::c_int;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 255 as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 142 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 145 as libc::c_int
                {
                    let ref mut fresh133 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh133 |= TMFA_NOSIDES as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 146 as libc::c_int
                {
                    let ref mut fresh134 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh134 |= TMFA_NOPLANES as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    != 146 as libc::c_int
                    && (*lines.offset(i as isize)).flags as libc::c_int
                        & 64 as libc::c_int != 0
                {
                    let ref mut fresh135 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh135 |= TMFA_NOSHADE as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                {
                    let ref mut fresh136 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh136 |= TMFA_SPLAT as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    <= 142 as libc::c_int
                {
                    let ref mut fresh137 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh137 |= TMFT_INTANGIBLEBOTTOM as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    <= 145 as libc::c_int
                {
                    let ref mut fresh138 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh138 |= TMFT_INTANGIBLETOP as libc::c_int;
                } else {
                    let ref mut fresh139 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh139
                        |= TMFT_INTANGIBLEBOTTOM as libc::c_int
                            | TMFT_INTANGIBLETOP as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh140 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh140 |= TMFT_DONTBLOCKOTHERS as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 128 as libc::c_int
                    != 0
                {
                    let ref mut fresh141 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh141 |= TMFT_DONTBLOCKPLAYER as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 100 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            1580848837534479582 => {
                current_block_1002 = 7207399478227962068;
            }
            7698913941061410784 => {
                current_block_1002 = 18159330253651456305;
            }
            9202549138398437433 => {
                current_block_1002 = 17000289985398837327;
            }
            2944053543039949385 => {
                current_block_1002 = 5876386205689480058;
            }
            _ => {}
        }
        match current_block_1002 {
            18159330253651456305 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = ((*lines.offset(i as isize)).special as libc::c_int
                    + 1 as libc::c_int) % 2 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .textureoffset >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*sides
                    .offset(
                        (*lines.offset(i as isize)).sidenum[0 as libc::c_int as usize]
                            as isize,
                    ))
                    .rowoffset >> 16 as libc::c_int;
                if (*lines.offset(i as isize)).flags as libc::c_int & 64 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = TMC_LTE as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 2 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = TMC_GTE as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize] = TMC_EQUAL as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize] = TMC_LTE as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 128 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize] = TMC_GTE as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize] = TMC_EQUAL as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 16 as libc::c_int
                    != 0
                {
                    (*lines.offset(i as isize))
                        .args[5 as libc::c_int as usize] = TMNP_SLOWEST as libc::c_int;
                } else if (*lines.offset(i as isize)).flags as libc::c_int
                    & 512 as libc::c_int != 0
                {
                    (*lines.offset(i as isize))
                        .args[5 as libc::c_int as usize] = TMNP_TRIGGERER as libc::c_int;
                } else {
                    (*lines.offset(i as isize))
                        .args[5 as libc::c_int as usize] = TMNP_FASTEST as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int % 2 as libc::c_int
                    == 0 as libc::c_int
                {
                    let ref mut fresh182 = (*lines.offset(i as isize)).special;
                    *fresh182 -= 1;
                    *fresh182;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 323 as libc::c_int
                {
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 32768 as libc::c_int != 0
                    {
                        (*lines.offset(i as isize))
                            .args[6 as libc::c_int
                            as usize] = TMN_FROMNONIGHTS as libc::c_int;
                    } else if (*lines.offset(i as isize)).flags as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        (*lines.offset(i as isize))
                            .args[6 as libc::c_int
                            as usize] = TMN_FROMNIGHTS as libc::c_int;
                    } else {
                        (*lines.offset(i as isize))
                            .args[6 as libc::c_int as usize] = TMN_ALWAYS as libc::c_int;
                    }
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 256 as libc::c_int != 0
                    {
                        let ref mut fresh183 = (*lines.offset(i as isize))
                            .args[7 as libc::c_int as usize];
                        *fresh183 |= TMN_BONUSLAPS as libc::c_int;
                    }
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        let ref mut fresh184 = (*lines.offset(i as isize))
                            .args[7 as libc::c_int as usize];
                        *fresh184 |= TMN_LEVELCOMPLETION as libc::c_int;
                    }
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 325 as libc::c_int
                {
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 32768 as libc::c_int != 0
                    {
                        (*lines.offset(i as isize))
                            .args[6 as libc::c_int
                            as usize] = TMD_NOBODYNIGHTS as libc::c_int;
                    } else if (*lines.offset(i as isize)).flags as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        (*lines.offset(i as isize))
                            .args[6 as libc::c_int
                            as usize] = TMD_SOMEBODYNIGHTS as libc::c_int;
                    } else {
                        (*lines.offset(i as isize))
                            .args[6 as libc::c_int as usize] = TMD_ALWAYS as libc::c_int;
                    }
                    (*lines.offset(i as isize))
                        .args[7 as libc::c_int
                        as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                        & 256 as libc::c_int != 0) as libc::c_int;
                } else if (*lines.offset(i as isize)).special as libc::c_int
                    == 327 as libc::c_int
                {
                    (*lines.offset(i as isize))
                        .args[6 as libc::c_int
                        as usize] = ((*lines.offset(i as isize)).flags as libc::c_int
                        & 256 as libc::c_int != 0) as libc::c_int;
                } else {
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        (*lines.offset(i as isize))
                            .args[6 as libc::c_int as usize] = TMS_ALWAYS as libc::c_int;
                    } else if (*lines.offset(i as isize)).flags as libc::c_int
                        & 16384 as libc::c_int != 0
                    {
                        (*lines.offset(i as isize))
                            .args[6 as libc::c_int
                            as usize] = TMS_IFNOTENOUGH as libc::c_int;
                    } else {
                        (*lines.offset(i as isize))
                            .args[6 as libc::c_int
                            as usize] = TMS_IFENOUGH as libc::c_int;
                    }
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 256 as libc::c_int != 0
                    {
                        let ref mut fresh185 = (*lines.offset(i as isize))
                            .args[7 as libc::c_int as usize];
                        *fresh185 |= TMI_BONUSLAPS as libc::c_int;
                    }
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 32768 as libc::c_int != 0
                    {
                        let ref mut fresh186 = (*lines.offset(i as isize))
                            .args[7 as libc::c_int as usize];
                        *fresh186 |= TMI_ENTER as libc::c_int;
                    }
                }
                current_block_1002 = 6860640994621533902;
            }
            7207399478227962068 => {
                current_block_1002 = 11876063911488577274;
            }
            17000289985398837327 => {
                current_block_1002 = 781376077467926937;
            }
            5876386205689480058 => {
                current_block_1002 = 10281805988156872726;
            }
            _ => {}
        }
        match current_block_1002 {
            10281805988156872726 => {
                let mut frontfloor: boolean = ((*lines.offset(i as isize)).special
                    as libc::c_int == 700 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 702 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 703 as libc::c_int) as libc::c_int;
                let mut backfloor: boolean = ((*lines.offset(i as isize)).special
                    as libc::c_int == 710 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 712 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 713 as libc::c_int) as libc::c_int;
                let mut frontceil: boolean = ((*lines.offset(i as isize)).special
                    as libc::c_int == 701 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 702 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 713 as libc::c_int) as libc::c_int;
                let mut backceil: boolean = ((*lines.offset(i as isize)).special
                    as libc::c_int == 711 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 712 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 703 as libc::c_int) as libc::c_int;
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = if backfloor != 0 {
                    TMS_BACK as libc::c_int
                } else if frontfloor != 0 {
                    TMS_FRONT as libc::c_int
                } else {
                    TMS_NONE as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if backceil != 0 {
                    TMS_BACK as libc::c_int
                } else if frontceil != 0 {
                    TMS_FRONT as libc::c_int
                } else {
                    TMS_NONE as libc::c_int
                };
                if (*lines.offset(i as isize)).flags as libc::c_int & 2048 as libc::c_int
                    != 0
                {
                    let ref mut fresh251 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh251 |= TMSL_NOPHYSICS as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 4096 as libc::c_int
                    != 0
                {
                    let ref mut fresh252 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh252 |= TMSL_DYNAMIC as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int
                    & 32768 as libc::c_int != 0
                {
                    let ref mut fresh253 = (*lines.offset(i as isize))
                        .args[2 as libc::c_int as usize];
                    *fresh253 |= TMSL_COPY as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 700 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            11876063911488577274 => {
                current_block_1002 = 2580075828471106669;
            }
            781376077467926937 => {
                current_block_1002 = 8223248126057502985;
            }
            _ => {}
        }
        match current_block_1002 {
            2580075828471106669 => {
                current_block_1002 = 3223050142715816929;
            }
            8223248126057502985 => {
                current_block_1002 = 14890633166657215186;
            }
            _ => {}
        }
        match current_block_1002 {
            3223050142715816929 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                if (*lines.offset(i as isize)).special as libc::c_int
                    >= 174 as libc::c_int
                    && (*lines.offset(i as isize)).special as libc::c_int
                        <= 175 as libc::c_int
                {
                    P_SetBinaryFOFAlpha(&mut *lines.offset(i as isize));
                    if (*lines.offset(i as isize)).args[1 as libc::c_int as usize]
                        == 256 as libc::c_int
                    {
                        let ref mut fresh145 = (*lines.offset(i as isize))
                            .args[4 as libc::c_int as usize];
                        *fresh145 |= TMFC_SPLAT as libc::c_int;
                    }
                } else {
                    (*lines.offset(i as isize))
                        .args[1 as libc::c_int as usize] = 255 as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    >= 172 as libc::c_int
                    && (*lines.offset(i as isize)).special as libc::c_int
                        <= 175 as libc::c_int
                {
                    let ref mut fresh146 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh146 |= TMFT_INTANGIBLEBOTTOM as libc::c_int;
                    if (*lines.offset(i as isize)).flags as libc::c_int
                        & 64 as libc::c_int != 0
                    {
                        let ref mut fresh147 = (*lines.offset(i as isize))
                            .args[4 as libc::c_int as usize];
                        *fresh147 |= TMFC_NOSHADE as libc::c_int;
                    }
                }
                if (*lines.offset(i as isize)).special as libc::c_int % 2 as libc::c_int
                    == 1 as libc::c_int
                {
                    let ref mut fresh148 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh148 |= TMFC_NORETURN as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    == 176 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 177 as libc::c_int
                    || (*lines.offset(i as isize)).special as libc::c_int
                        == 180 as libc::c_int
                {
                    let ref mut fresh149 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh149 |= TMFC_AIRBOB as libc::c_int;
                }
                if (*lines.offset(i as isize)).special as libc::c_int
                    >= 176 as libc::c_int
                    && (*lines.offset(i as isize)).special as libc::c_int
                        <= 179 as libc::c_int
                {
                    let ref mut fresh150 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh150 |= TMFC_FLOATBOB as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 8192 as libc::c_int
                    != 0
                {
                    let ref mut fresh151 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh151 |= TMFC_SPLAT as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 32 as libc::c_int
                    != 0
                {
                    let ref mut fresh152 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh152 |= TMFT_DONTBLOCKOTHERS as libc::c_int;
                }
                if (*lines.offset(i as isize)).flags as libc::c_int & 128 as libc::c_int
                    != 0
                {
                    let ref mut fresh153 = (*lines.offset(i as isize))
                        .args[3 as libc::c_int as usize];
                    *fresh153 |= TMFT_DONTBLOCKPLAYER as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 170 as libc::c_int as int16_t;
                current_block_1002 = 6860640994621533902;
            }
            14890633166657215186 => {
                current_block_1002 = 11783215275178290717;
            }
            _ => {}
        }
        match current_block_1002 {
            11783215275178290717 => {
                current_block_1002 = 12781316935607599745;
            }
            _ => {}
        }
        match current_block_1002 {
            12781316935607599745 => {
                current_block_1002 = 3242543460668740766;
            }
            _ => {}
        }
        match current_block_1002 {
            3242543460668740766 => {
                current_block_1002 = 10448352471842181315;
            }
            _ => {}
        }
        match current_block_1002 {
            10448352471842181315 => {
                current_block_1002 = 15721569559606651444;
            }
            _ => {}
        }
        match current_block_1002 {
            15721569559606651444 => {
                current_block_1002 = 5471983970216170950;
            }
            _ => {}
        }
        match current_block_1002 {
            5471983970216170950 => {
                current_block_1002 = 3114118470539981388;
            }
            _ => {}
        }
        match current_block_1002 {
            3114118470539981388 => {
                current_block_1002 = 2510268812606746677;
            }
            _ => {}
        }
        match current_block_1002 {
            2510268812606746677 => {
                current_block_1002 = 3661326538650816866;
            }
            _ => {}
        }
        match current_block_1002 {
            3661326538650816866 => {
                current_block_1002 = 13603703177024492576;
            }
            _ => {}
        }
        match current_block_1002 {
            13603703177024492576 => {
                current_block_1002 = 10424734802533018211;
            }
            _ => {}
        }
        match current_block_1002 {
            10424734802533018211 => {
                current_block_1002 = 7839485439258254799;
            }
            _ => {}
        }
        match current_block_1002 {
            7839485439258254799 => {
                current_block_1002 = 3327335973037550489;
            }
            _ => {}
        }
        match current_block_1002 {
            3327335973037550489 => {
                current_block_1002 = 8288947012521031670;
            }
            _ => {}
        }
        match current_block_1002 {
            8288947012521031670 => {
                current_block_1002 = 11554152168876335608;
            }
            _ => {}
        }
        match current_block_1002 {
            11554152168876335608 => {
                current_block_1002 = 11912628379678300127;
            }
            _ => {}
        }
        match current_block_1002 {
            11912628379678300127 => {
                (*lines.offset(i as isize))
                    .args[0 as libc::c_int as usize] = tag as int32_t;
                (*lines.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = if ((*lines.offset(i as isize)).special as libc::c_int
                    % 10 as libc::c_int) < 6 as libc::c_int
                {
                    if ((*lines.offset(i as isize)).special as libc::c_int
                        % 10 as libc::c_int) < 3 as libc::c_int
                    {
                        TMP_FLOOR as libc::c_int
                    } else {
                        TMP_CEILING as libc::c_int
                    }
                } else {
                    TMP_BOTH as libc::c_int
                };
                (*lines.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (((*lines.offset(i as isize)).special as libc::c_int
                    - 510 as libc::c_int) / 10 as libc::c_int + 1 as libc::c_int)
                    % 3 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = (if (*lines.offset(i as isize)).flags as libc::c_int
                    & 8192 as libc::c_int != 0
                {
                    (*sides
                        .offset(
                            (*lines.offset(i as isize))
                                .sidenum[0 as libc::c_int as usize] as isize,
                        ))
                        .textureoffset
                } else {
                    R_PointToDist2(
                        (*(*lines.offset(i as isize)).v2).x,
                        (*(*lines.offset(i as isize)).v2).y,
                        (*(*lines.offset(i as isize)).v1).x,
                        (*(*lines.offset(i as isize)).v1).y,
                    )
                }) >> 16 as libc::c_int;
                (*lines.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = (*lines.offset(i as isize)).special as libc::c_int
                    % 10 as libc::c_int % 3 as libc::c_int;
                if (*lines.offset(i as isize)).args[2 as libc::c_int as usize]
                    != TMS_SCROLLONLY as libc::c_int
                    && (*lines.offset(i as isize)).flags as libc::c_int
                        & 64 as libc::c_int == 0
                {
                    let ref mut fresh248 = (*lines.offset(i as isize))
                        .args[4 as libc::c_int as usize];
                    *fresh248 |= TMST_NONEXCLUSIVE as libc::c_int;
                }
                (*lines.offset(i as isize)).special = 510 as libc::c_int as int16_t;
            }
            _ => {}
        }
        if (*lines.offset(i as isize)).special as libc::c_int >= 900 as libc::c_int
            && ((*lines.offset(i as isize)).special as libc::c_int) < 909 as libc::c_int
        {
            (*lines.offset(i as isize))
                .alpha = ((909 as libc::c_int
                - (*lines.offset(i as isize)).special as libc::c_int)
                << 16 as libc::c_int) / 10 as libc::c_int;
        }
        if (*lines.offset(i as isize)).special as libc::c_int >= 910 as libc::c_int
            && (*lines.offset(i as isize)).special as libc::c_int <= 939 as libc::c_int
        {
            (*lines.offset(i as isize))
                .alpha = ((10 as libc::c_int
                - (*lines.offset(i as isize)).special as libc::c_int % 10 as libc::c_int)
                << 16 as libc::c_int) / 10 as libc::c_int;
        }
        if (*lines.offset(i as isize)).special as libc::c_int >= 910 as libc::c_int
            && (*lines.offset(i as isize)).special as libc::c_int <= 919 as libc::c_int
        {
            (*lines.offset(i as isize)).blendmode = AST_ADD as libc::c_int as uint8_t;
        }
        if (*lines.offset(i as isize)).special as libc::c_int >= 920 as libc::c_int
            && (*lines.offset(i as isize)).special as libc::c_int <= 929 as libc::c_int
        {
            (*lines.offset(i as isize))
                .blendmode = AST_SUBTRACT as libc::c_int as uint8_t;
        }
        if (*lines.offset(i as isize)).special as libc::c_int >= 930 as libc::c_int
            && (*lines.offset(i as isize)).special as libc::c_int <= 939 as libc::c_int
        {
            (*lines.offset(i as isize))
                .blendmode = AST_REVERSESUBTRACT as libc::c_int as uint8_t;
        }
        if (*lines.offset(i as isize)).special as libc::c_int == 940 as libc::c_int {
            (*lines.offset(i as isize))
                .blendmode = AST_MODULATE as libc::c_int as uint8_t;
        }
        if (*lines.offset(i as isize)).special as libc::c_int >= 400 as libc::c_int
            && ((*lines.offset(i as isize)).special as libc::c_int) < 500 as libc::c_int
        {
            if (*lines.offset(i as isize)).flags as libc::c_int & 8 as libc::c_int != 0 {
                (*lines.offset(i as isize)).executordelay = 1 as libc::c_int;
            }
        }
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn P_ConvertBinarySectorTypes() {
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numsectors {
        let mut tag: mtag_t = Tag_FGet(&mut (*sectors.offset(i as isize)).tags);
        match (*sectors.offset(i as isize)).special as libc::c_int
            >> (1 as libc::c_int - 1 as libc::c_int) * 4 as libc::c_int
            & 15 as libc::c_int
        {
            1 => {
                (*sectors.offset(i as isize))
                    .damagetype = SD_GENERIC as libc::c_int as uint8_t;
            }
            2 => {
                (*sectors.offset(i as isize))
                    .damagetype = SD_WATER as libc::c_int as uint8_t;
            }
            3 => {
                let mut j: size_t = 0;
                let mut isLava: boolean = false_0 as libc::c_int;
                j = 0 as libc::c_int as size_t;
                while j < (*sectors.offset(i as isize)).linecount {
                    let mut line: *mut line_t = *((*sectors.offset(i as isize)).lines)
                        .offset(j as isize);
                    if !((*line).frontsector
                        != &mut *sectors.offset(i as isize) as *mut sector_t)
                    {
                        if !((*line).flags as libc::c_int & 2 as libc::c_int != 0) {
                            if (*line).special as libc::c_int == 120 as libc::c_int
                                || (*line).special as libc::c_int == 259 as libc::c_int
                                    && (*line).args[2 as libc::c_int as usize]
                                        & FOF_SWIMMABLE as libc::c_int != 0
                            {
                                isLava = true_0 as libc::c_int;
                                break;
                            }
                        }
                    }
                    j = j.wrapping_add(1);
                    j;
                }
                (*sectors.offset(i as isize))
                    .damagetype = (if isLava != 0 {
                    SD_LAVA as libc::c_int
                } else {
                    SD_FIRE as libc::c_int
                }) as uint8_t;
            }
            4 => {
                (*sectors.offset(i as isize))
                    .damagetype = SD_ELECTRIC as libc::c_int as uint8_t;
            }
            5 => {
                (*sectors.offset(i as isize))
                    .damagetype = SD_SPIKE as libc::c_int as uint8_t;
            }
            6 => {
                (*sectors.offset(i as isize))
                    .damagetype = SD_DEATHPITTILT as libc::c_int as uint8_t;
            }
            7 => {
                (*sectors.offset(i as isize))
                    .damagetype = SD_DEATHPITNOTILT as libc::c_int as uint8_t;
            }
            8 => {
                (*sectors.offset(i as isize))
                    .damagetype = SD_INSTAKILL as libc::c_int as uint8_t;
            }
            11 => {
                (*sectors.offset(i as isize))
                    .damagetype = SD_SPECIALSTAGE as libc::c_int as uint8_t;
            }
            12 => {
                let ref mut fresh260 = (*sectors.offset(i as isize)).specialflags;
                *fresh260 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh260 as libc::c_uint
                        | SSF_OUTERSPACE as libc::c_int as libc::c_uint,
                );
            }
            13 => {
                let ref mut fresh261 = (*sectors.offset(i as isize)).specialflags;
                *fresh261 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh261 as libc::c_uint
                        | SSF_DOUBLESTEPUP as libc::c_int as libc::c_uint,
                );
            }
            14 => {
                let ref mut fresh262 = (*sectors.offset(i as isize)).specialflags;
                *fresh262 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh262 as libc::c_uint
                        | SSF_NOSTEPDOWN as libc::c_int as libc::c_uint,
                );
            }
            15 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Deprecated bouncy FOF sector type detected. Please use linedef type 76 instead.\n\0"
                        as *const u8 as *const libc::c_char,
                );
            }
            _ => {}
        }
        match (*sectors.offset(i as isize)).special as libc::c_int
            >> (2 as libc::c_int - 1 as libc::c_int) * 4 as libc::c_int
            & 15 as libc::c_int
        {
            1 => {
                (*sectors.offset(i as isize)).triggertag = tag;
                let ref mut fresh263 = (*sectors.offset(i as isize)).flags;
                *fresh263 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorflags_t,
                >(
                    *fresh263 as libc::c_uint
                        | MSF_TRIGGERLINE_PLANE as libc::c_int as libc::c_uint,
                );
                (*sectors.offset(i as isize))
                    .triggerer = TO_MOBJ as libc::c_int as uint8_t;
            }
            2 => {
                (*sectors.offset(i as isize)).triggertag = tag;
                let ref mut fresh264 = (*sectors.offset(i as isize)).flags;
                *fresh264 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorflags_t,
                >(
                    *fresh264 as libc::c_uint
                        & !(MSF_TRIGGERLINE_PLANE as libc::c_int) as libc::c_uint,
                );
                (*sectors.offset(i as isize))
                    .triggerer = TO_ALLPLAYERS as libc::c_int as uint8_t;
            }
            3 => {
                (*sectors.offset(i as isize)).triggertag = tag;
                let ref mut fresh265 = (*sectors.offset(i as isize)).flags;
                *fresh265 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorflags_t,
                >(
                    *fresh265 as libc::c_uint
                        | MSF_TRIGGERLINE_PLANE as libc::c_int as libc::c_uint,
                );
                (*sectors.offset(i as isize))
                    .triggerer = TO_ALLPLAYERS as libc::c_int as uint8_t;
            }
            4 => {
                (*sectors.offset(i as isize)).triggertag = tag;
                let ref mut fresh266 = (*sectors.offset(i as isize)).flags;
                *fresh266 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorflags_t,
                >(
                    *fresh266 as libc::c_uint
                        & !(MSF_TRIGGERLINE_PLANE as libc::c_int) as libc::c_uint,
                );
                (*sectors.offset(i as isize))
                    .triggerer = TO_PLAYER as libc::c_int as uint8_t;
            }
            5 => {
                (*sectors.offset(i as isize)).triggertag = tag;
                let ref mut fresh267 = (*sectors.offset(i as isize)).flags;
                *fresh267 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorflags_t,
                >(
                    *fresh267 as libc::c_uint
                        | MSF_TRIGGERLINE_PLANE as libc::c_int as libc::c_uint,
                );
                (*sectors.offset(i as isize))
                    .triggerer = TO_PLAYER as libc::c_int as uint8_t;
            }
            6 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Deprecated emerald check sector type detected. Please use linedef types 337-339 instead.\n\0"
                        as *const u8 as *const libc::c_char,
                );
                (*sectors.offset(i as isize)).triggertag = tag;
                let ref mut fresh268 = (*sectors.offset(i as isize)).flags;
                *fresh268 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorflags_t,
                >(
                    *fresh268 as libc::c_uint
                        & !(MSF_TRIGGERLINE_PLANE as libc::c_int) as libc::c_uint,
                );
                (*sectors.offset(i as isize))
                    .triggerer = TO_PLAYEREMERALDS as libc::c_int as uint8_t;
            }
            7 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Deprecated NiGHTS mare sector type detected. Please use linedef types 340-342 instead.\n\0"
                        as *const u8 as *const libc::c_char,
                );
                (*sectors.offset(i as isize)).triggertag = tag;
                let ref mut fresh269 = (*sectors.offset(i as isize)).flags;
                *fresh269 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorflags_t,
                >(
                    *fresh269 as libc::c_uint
                        & !(MSF_TRIGGERLINE_PLANE as libc::c_int) as libc::c_uint,
                );
                (*sectors.offset(i as isize))
                    .triggerer = TO_PLAYERNIGHTS as libc::c_int as uint8_t;
            }
            8 => {
                let ref mut fresh270 = (*sectors.offset(i as isize)).flags;
                *fresh270 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorflags_t,
                >(
                    *fresh270 as libc::c_uint
                        | MSF_TRIGGERLINE_MOBJ as libc::c_int as libc::c_uint,
                );
            }
            10 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Deprecated sector type for special stage requirements detected. Please use the SpecialStageTime and SpecialStageSpheres level header options instead.\n\0"
                        as *const u8 as *const libc::c_char,
                );
            }
            11 => {
                CONS_Alert(
                    CONS_WARNING,
                    b"Deprecated sector type for global gravity detected. Please use the Gravity level header option instead.\n\0"
                        as *const u8 as *const libc::c_char,
                );
            }
            _ => {}
        }
        match (*sectors.offset(i as isize)).special as libc::c_int
            >> (3 as libc::c_int - 1 as libc::c_int) * 4 as libc::c_int
            & 15 as libc::c_int
        {
            5 => {
                let ref mut fresh271 = (*sectors.offset(i as isize)).specialflags;
                *fresh271 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh271 as libc::c_uint
                        | SSF_SPEEDPAD as libc::c_int as libc::c_uint,
                );
            }
            6 => {
                let ref mut fresh272 = (*sectors.offset(i as isize)).specialflags;
                *fresh272 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh272 as libc::c_uint
                        | SSF_JUMPFLIP as libc::c_int as libc::c_uint,
                );
            }
            _ => {}
        }
        match (*sectors.offset(i as isize)).special as libc::c_int
            >> (4 as libc::c_int - 1 as libc::c_int) * 4 as libc::c_int
            & 15 as libc::c_int
        {
            1 => {
                let ref mut fresh273 = (*sectors.offset(i as isize)).specialflags;
                *fresh273 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh273 as libc::c_uint
                        | SSF_STARPOSTACTIVATOR as libc::c_int as libc::c_uint,
                );
            }
            2 => {
                let ref mut fresh274 = (*sectors.offset(i as isize)).specialflags;
                *fresh274 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh274 as libc::c_uint
                        | (SSF_EXIT as libc::c_int | SSF_SPECIALSTAGEPIT as libc::c_int
                            | SSF_RETURNFLAG as libc::c_int) as libc::c_uint,
                );
            }
            3 => {
                let ref mut fresh275 = (*sectors.offset(i as isize)).specialflags;
                *fresh275 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh275 as libc::c_uint
                        | SSF_REDTEAMBASE as libc::c_int as libc::c_uint,
                );
            }
            4 => {
                let ref mut fresh276 = (*sectors.offset(i as isize)).specialflags;
                *fresh276 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh276 as libc::c_uint
                        | SSF_BLUETEAMBASE as libc::c_int as libc::c_uint,
                );
            }
            5 => {
                let ref mut fresh277 = (*sectors.offset(i as isize)).specialflags;
                *fresh277 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(*fresh277 as libc::c_uint | SSF_FAN as libc::c_int as libc::c_uint);
            }
            6 => {
                let ref mut fresh278 = (*sectors.offset(i as isize)).specialflags;
                *fresh278 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh278 as libc::c_uint
                        | SSF_SUPERTRANSFORM as libc::c_int as libc::c_uint,
                );
            }
            7 => {
                let ref mut fresh279 = (*sectors.offset(i as isize)).specialflags;
                *fresh279 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh279 as libc::c_uint
                        | SSF_FORCESPIN as libc::c_int as libc::c_uint,
                );
            }
            8 => {
                let ref mut fresh280 = (*sectors.offset(i as isize)).specialflags;
                *fresh280 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh280 as libc::c_uint
                        | SSF_ZOOMTUBESTART as libc::c_int as libc::c_uint,
                );
            }
            9 => {
                let ref mut fresh281 = (*sectors.offset(i as isize)).specialflags;
                *fresh281 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh281 as libc::c_uint
                        | SSF_ZOOMTUBEEND as libc::c_int as libc::c_uint,
                );
            }
            10 => {
                let ref mut fresh282 = (*sectors.offset(i as isize)).specialflags;
                *fresh282 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh282 as libc::c_uint
                        | SSF_FINISHLINE as libc::c_int as libc::c_uint,
                );
            }
            11 => {
                let ref mut fresh283 = (*sectors.offset(i as isize)).specialflags;
                *fresh283 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorspecialflags_t,
                >(
                    *fresh283 as libc::c_uint
                        | SSF_ROPEHANG as libc::c_int as libc::c_uint,
                );
            }
            12 => {
                let ref mut fresh284 = (*sectors.offset(i as isize)).flags;
                *fresh284 = ::core::mem::transmute::<
                    libc::c_uint,
                    sectorflags_t,
                >(
                    *fresh284 as libc::c_uint
                        | MSF_NOCLIPCAMERA as libc::c_int as libc::c_uint,
                );
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn P_ConvertBinaryThingTypes() {
    let mut i: size_t = 0;
    let mut mobjtypeofthing: [mobjtype_t; 4096] = [
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
        MT_NULL,
    ];
    let mut mobjtype: mobjtype_t = MT_NULL;
    i = 0 as libc::c_int as size_t;
    while i < NUMMOBJTYPES as libc::c_int as size_t {
        if !(mobjinfo[i as usize].doomednum < 0 as libc::c_int
            || mobjinfo[i as usize].doomednum >= 4096 as libc::c_int)
        {
            mobjtypeofthing[mobjinfo[i as usize].doomednum as usize] = i as mobjtype_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as size_t;
    while i < nummapthings {
        mobjtype = mobjtypeofthing[(*mapthings.offset(i as isize)).type_0 as usize];
        if mobjtype as u64 != 0 {
            if mobjinfo[mobjtype as usize].flags & MF_BOSS as libc::c_int as uint32_t
                != 0
            {
                let mut paramoffset: int32_t = (*mapthings.offset(i as isize)).extrainfo
                    as libc::c_int * LE_PARAMWIDTH as libc::c_int;
                (*mapthings.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = (*mapthings.offset(i as isize)).extrainfo as int32_t;
                (*mapthings.offset(i as isize))
                    .args[1 as libc::c_int
                    as usize] = ((*mapthings.offset(i as isize)).options as libc::c_int
                    & 4 as libc::c_int != 0) as libc::c_int;
                (*mapthings.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = LE_BOSSDEAD as libc::c_int + paramoffset;
                (*mapthings.offset(i as isize))
                    .args[3 as libc::c_int
                    as usize] = LE_ALLBOSSESDEAD as libc::c_int + paramoffset;
                (*mapthings.offset(i as isize))
                    .args[4 as libc::c_int
                    as usize] = LE_PINCHPHASE as libc::c_int + paramoffset;
            }
            if mobjinfo[mobjtype as usize].flags
                & MF_NIGHTSITEM as libc::c_int as uint32_t != 0
            {
                if (*mapthings.offset(i as isize)).options as libc::c_int
                    & 4 as libc::c_int != 0
                {
                    let ref mut fresh285 = (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize];
                    *fresh285 |= TMNI_BONUSONLY as libc::c_int;
                }
                if (*mapthings.offset(i as isize)).options as libc::c_int
                    & 8 as libc::c_int != 0
                {
                    let ref mut fresh286 = (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize];
                    *fresh286 |= TMNI_REVEAL as libc::c_int;
                }
            }
            if mobjinfo[mobjtype as usize].flags & MF_PUSHABLE as libc::c_int as uint32_t
                != 0
            {
                if (*mapthings.offset(i as isize)).options as libc::c_int
                    & (4 as libc::c_int | 8 as libc::c_int)
                    == 4 as libc::c_int | 8 as libc::c_int
                {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMP_CLASSIC as libc::c_int;
                } else if (*mapthings.offset(i as isize)).options as libc::c_int
                    & 4 as libc::c_int != 0
                {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMP_SLIDE as libc::c_int;
                } else if (*mapthings.offset(i as isize)).options as libc::c_int
                    & 8 as libc::c_int != 0
                {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMP_IMMOVABLE as libc::c_int;
                } else {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = TMP_NORMAL as libc::c_int;
                }
            }
            if mobjinfo[mobjtype as usize].flags & MF_SPRING as libc::c_int as uint32_t
                != 0 && mobjinfo[mobjtype as usize].painchance == 3 as libc::c_int
            {
                (*mapthings.offset(i as isize))
                    .args[0 as libc::c_int
                    as usize] = ((*mapthings.offset(i as isize)).options as libc::c_int
                    & 8 as libc::c_int != 0) as libc::c_int;
            }
            if mobjinfo[mobjtype as usize].flags & MF_MONITOR as libc::c_int as uint32_t
                != 0
            {
                if (*mapthings.offset(i as isize)).options as libc::c_int
                    & 1 as libc::c_int != 0
                    && (*mapthings.offset(i as isize)).angle as libc::c_int
                        & 16384 as libc::c_int != 0
                {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as libc::c_int
                        & 16383 as libc::c_int;
                }
                if mobjinfo[mobjtype as usize].speed != 0 as libc::c_int {
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 4 as libc::c_int != 0
                    {
                        (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = TMMR_STRONG as libc::c_int;
                    } else if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int as usize] = TMMR_WEAK as libc::c_int;
                    } else {
                        (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int as usize] = TMMR_SAME as libc::c_int;
                    }
                }
            }
        }
        if (*mapthings.offset(i as isize)).type_0 as libc::c_int >= 1 as libc::c_int
            && (*mapthings.offset(i as isize)).type_0 as libc::c_int <= 35 as libc::c_int
        {
            (*mapthings.offset(i as isize))
                .args[0 as libc::c_int
                as usize] = ((*mapthings.offset(i as isize)).options as libc::c_int
                & 8 as libc::c_int != 0) as libc::c_int;
        } else if (*mapthings.offset(i as isize)).type_0 as libc::c_int
            >= 2200 as libc::c_int
            && (*mapthings.offset(i as isize)).type_0 as libc::c_int
                <= 2217 as libc::c_int
        {
            (*mapthings.offset(i as isize))
                .args[0 as libc::c_int
                as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
            if (*mapthings.offset(i as isize)).options as libc::c_int & 1 as libc::c_int
                != 0
            {
                let ref mut fresh287 = (*mapthings.offset(i as isize))
                    .args[1 as libc::c_int as usize];
                *fresh287 |= TMFF_AIMLESS as libc::c_int;
            }
            if (*mapthings.offset(i as isize)).options as libc::c_int & 4 as libc::c_int
                != 0
            {
                let ref mut fresh288 = (*mapthings.offset(i as isize))
                    .args[1 as libc::c_int as usize];
                *fresh288 |= TMFF_STATIONARY as libc::c_int;
            }
            if (*mapthings.offset(i as isize)).options as libc::c_int & 8 as libc::c_int
                != 0
            {
                let ref mut fresh289 = (*mapthings.offset(i as isize))
                    .args[1 as libc::c_int as usize];
                *fresh289 |= TMFF_HOP as libc::c_int;
            }
            if (*mapthings.offset(i as isize)).type_0 as libc::c_int
                == 2207 as libc::c_int
            {
                (*mapthings.offset(i as isize))
                    .args[2 as libc::c_int
                    as usize] = (*mapthings.offset(i as isize)).extrainfo as int32_t;
            }
        } else {
            let mut current_block_262: u64;
            match (*mapthings.offset(i as isize)).type_0 as libc::c_int {
                102 | 1805 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                110 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = LE_TURRET as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                111 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                103 => {
                    current_block_262 = 3771118673463790323;
                }
                104 => {
                    current_block_262 = 3771118673463790323;
                }
                105 => {
                    current_block_262 = 11680761402344870323;
                }
                106 => {
                    current_block_262 = 6496058539240282970;
                }
                117 => {
                    current_block_262 = 9725716477909267835;
                }
                126 => {
                    current_block_262 = 18323572960312075136;
                }
                128 => {
                    current_block_262 = 3366966530450955154;
                }
                132 => {
                    current_block_262 = 7827081262013676022;
                }
                138 | 1602 => {
                    current_block_262 = 12913299854706673563;
                }
                119 => {
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & (1 as libc::c_int | 4 as libc::c_int) == 4 as libc::c_int
                    {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int as usize] = TMGD_LEFT as libc::c_int;
                    } else if (*mapthings.offset(i as isize)).options as libc::c_int
                        & (1 as libc::c_int | 4 as libc::c_int) == 1 as libc::c_int
                    {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int as usize] = TMGD_RIGHT as libc::c_int;
                    } else {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int as usize] = TMGD_BACK as libc::c_int;
                    }
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                127 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).extrainfo as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                135 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).extrainfo
                        as libc::c_int + 1 as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                136 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                201 => {
                    (*mapthings.offset(i as isize))
                        .args[5 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int == 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                203 => {
                    (*mapthings.offset(i as isize))
                        .args[5 as libc::c_int
                        as usize] = LE_BOSS4DROP as libc::c_int
                        + (*mapthings.offset(i as isize)).extrainfo as libc::c_int
                            * LE_PARAMWIDTH as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                204 => {
                    (*mapthings.offset(i as isize))
                        .args[4 as libc::c_int
                        as usize] = LE_BOSS4DROP as libc::c_int
                        + (*mapthings.offset(i as isize)).extrainfo as libc::c_int
                            * LE_PARAMWIDTH as libc::c_int;
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 1 as libc::c_int != 0
                    {
                        let ref mut fresh290 = (*mapthings.offset(i as isize))
                            .args[5 as libc::c_int as usize];
                        *fresh290 |= TMF_GRAYSCALE as libc::c_int;
                    }
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        let ref mut fresh291 = (*mapthings.offset(i as isize))
                            .args[5 as libc::c_int as usize];
                        *fresh291 |= TMF_SKIPINTRO as libc::c_int;
                    }
                    current_block_262 = 5684771287319053842;
                }
                206 => {
                    (*mapthings.offset(i as isize))
                        .args[5 as libc::c_int
                        as usize] = LE_BRAKPLATFORM as libc::c_int
                        + (*mapthings.offset(i as isize)).extrainfo as libc::c_int
                            * LE_PARAMWIDTH as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                207 | 2104 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 1 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                208 => {
                    (*mapthings.offset(i as isize))
                        .args[5 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 1 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                209 => {
                    (*mapthings.offset(i as isize))
                        .args[5 as libc::c_int
                        as usize] = LE_BRAKVILEATACK as libc::c_int
                        + (*mapthings.offset(i as isize)).extrainfo as libc::c_int
                            * LE_PARAMWIDTH as libc::c_int;
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 1 as libc::c_int != 0
                    {
                        let ref mut fresh292 = (*mapthings.offset(i as isize))
                            .args[6 as libc::c_int as usize];
                        *fresh292 |= TMB_NODEATHFLING as libc::c_int;
                    }
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        let ref mut fresh293 = (*mapthings.offset(i as isize))
                            .args[6 as libc::c_int as usize];
                        *fresh293 |= TMB_BARRIER as libc::c_int;
                    }
                    current_block_262 = 5684771287319053842;
                }
                292 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).options
                        as libc::c_int & 7 as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                294 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                300 => {
                    current_block_262 = 3796996925409558124;
                }
                301 => {
                    current_block_262 = 3796996925409558124;
                }
                302 => {
                    current_block_262 = 18251665547072454469;
                }
                303 => {
                    current_block_262 = 9319463168692799805;
                }
                304 => {
                    current_block_262 = 8279308735152199837;
                }
                305 => {
                    current_block_262 = 8289800320966035646;
                }
                306 => {
                    current_block_262 = 5338802250226117973;
                }
                307 => {
                    current_block_262 = 18022583794090175981;
                }
                308 => {
                    current_block_262 = 9272111169585103524;
                }
                309 => {
                    current_block_262 = 12486844204549033476;
                }
                312 => {
                    current_block_262 = 3013351444566145493;
                }
                320 => {
                    current_block_262 = 14268641534782834152;
                }
                321 => {
                    current_block_262 = 11479947651033336051;
                }
                330 => {
                    current_block_262 = 3927851556771736049;
                }
                331 => {
                    current_block_262 = 13151914577407923353;
                }
                332 => {
                    current_block_262 = 10977263893217871522;
                }
                333 => {
                    current_block_262 = 7046344642169884998;
                }
                334 => {
                    current_block_262 = 15980586669830306824;
                }
                335 => {
                    current_block_262 = 7571381298829053059;
                }
                520 => {
                    current_block_262 = 7360090934194561406;
                }
                521 => {
                    current_block_262 = 18009581395994504549;
                }
                1706 | 1800 => {
                    current_block_262 = 17987396596742658124;
                }
                322 => {
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int == 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                409 => {
                    (*mapthings.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & (8 as libc::c_int | 4 as libc::c_int) == 0)
                        as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                500 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                502 => {
                    if (*mapthings.offset(i as isize)).extrainfo != 0 {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int
                            as usize] = (*mapthings.offset(i as isize)).extrainfo
                            as libc::c_int
                            + (*mapthings.offset(i as isize)).angle as libc::c_int
                                / 360 as libc::c_int * 15 as libc::c_int;
                    } else {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int
                            as usize] = (*mapthings.offset(i as isize)).angle
                            as libc::c_int / 360 as libc::c_int;
                    }
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 4 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                522 => {
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 4 as libc::c_int != 0
                    {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int
                            as usize] = mobjinfo[MT_WALLSPIKE as libc::c_int as usize]
                            .speed
                            + (*mapthings.offset(i as isize)).angle as libc::c_int
                                / 360 as libc::c_int;
                        (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = (16 as libc::c_int
                            - (*mapthings.offset(i as isize)).extrainfo as libc::c_int)
                            * (*mapthings.offset(i as isize))
                                .args[0 as libc::c_int as usize] / 16 as libc::c_int;
                        if (*mapthings.offset(i as isize)).options as libc::c_int
                            & 1 as libc::c_int != 0
                        {
                            let ref mut fresh294 = (*mapthings.offset(i as isize))
                                .args[2 as libc::c_int as usize];
                            *fresh294 |= TMSF_RETRACTED as libc::c_int;
                        }
                    }
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        let ref mut fresh295 = (*mapthings.offset(i as isize))
                            .args[2 as libc::c_int as usize];
                        *fresh295 |= TMSF_INTANGIBLE as libc::c_int;
                    }
                    current_block_262 = 5684771287319053842;
                }
                523 => {
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 4 as libc::c_int != 0
                    {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int
                            as usize] = mobjinfo[MT_SPIKE as libc::c_int as usize].speed
                            + (*mapthings.offset(i as isize)).angle as libc::c_int;
                        (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = (16 as libc::c_int
                            - (*mapthings.offset(i as isize)).extrainfo as libc::c_int)
                            * (*mapthings.offset(i as isize))
                                .args[0 as libc::c_int as usize] / 16 as libc::c_int;
                        if (*mapthings.offset(i as isize)).options as libc::c_int
                            & 1 as libc::c_int != 0
                        {
                            let ref mut fresh296 = (*mapthings.offset(i as isize))
                                .args[2 as libc::c_int as usize];
                            *fresh296 |= TMSF_RETRACTED as libc::c_int;
                        }
                    }
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        let ref mut fresh297 = (*mapthings.offset(i as isize))
                            .args[2 as libc::c_int as usize];
                        *fresh297 |= TMSF_INTANGIBLE as libc::c_int;
                    }
                    current_block_262 = 5684771287319053842;
                }
                540 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 4 as libc::c_int != 0
                    {
                        let ref mut fresh298 = (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int as usize];
                        *fresh298 |= TMF_INVISIBLE as libc::c_int;
                    }
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        let ref mut fresh299 = (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int as usize];
                        *fresh299 |= TMF_NODISTANCECHECK as libc::c_int;
                    }
                    current_block_262 = 5684771287319053842;
                }
                541 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                543 => {
                    if (*mapthings.offset(i as isize)).angle as libc::c_int
                        > 0 as libc::c_int
                    {
                        P_WriteSkincolor(
                            ((*mapthings.offset(i as isize)).angle as libc::c_int
                                - 1 as libc::c_int)
                                % (numskincolors as libc::c_int - 1 as libc::c_int)
                                + 1 as libc::c_int,
                            &mut *((*mapthings.offset(i as isize)).stringargs)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize),
                        );
                    }
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                555 => {
                    current_block_262 = 17855240650044330644;
                }
                556 | 557 => {
                    current_block_262 = 17855240650044330644;
                }
                558 => {
                    current_block_262 = 2943036041819015608;
                }
                559 | 560 => {
                    current_block_262 = 2943036041819015608;
                }
                700 => {
                    current_block_262 = 6564976367101321445;
                }
                701 => {
                    current_block_262 = 6564976367101321445;
                }
                702 => {
                    current_block_262 = 9859384875985599929;
                }
                703 => {
                    current_block_262 = 16684463338199207412;
                }
                704 => {
                    current_block_262 = 10629041686158768989;
                }
                705 => {
                    current_block_262 = 15872520761627011276;
                }
                706 | 707 => {
                    current_block_262 = 18383098730014678056;
                }
                708 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = 512 as libc::c_int;
                    P_WriteSfx(
                        sfx_ambint as libc::c_int,
                        &mut *((*mapthings.offset(i as isize)).stringargs)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize),
                    );
                    (*mapthings.offset(i as isize))
                        .type_0 = 700 as libc::c_int as uint16_t;
                    current_block_262 = 5684771287319053842;
                }
                709 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = 220 as libc::c_int;
                    P_WriteSfx(
                        sfx_ambin2 as libc::c_int,
                        &mut *((*mapthings.offset(i as isize)).stringargs)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize),
                    );
                    (*mapthings.offset(i as isize))
                        .type_0 = 700 as libc::c_int as uint16_t;
                    current_block_262 = 5684771287319053842;
                }
                710 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = 24 as libc::c_int;
                    P_WriteSfx(
                        sfx_ambmac as libc::c_int,
                        &mut *((*mapthings.offset(i as isize)).stringargs)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize),
                    );
                    (*mapthings.offset(i as isize))
                        .type_0 = 700 as libc::c_int as uint16_t;
                    current_block_262 = 5684771287319053842;
                }
                750 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).extrainfo as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                753 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as libc::c_int
                        >> 8 as libc::c_int;
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as libc::c_int
                        & 255 as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                754 => {
                    current_block_262 = 7468767852762055642;
                }
                755 => {
                    current_block_262 = 7468767852762055642;
                }
                756 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                757 => {
                    let mut j: int32_t = Tag_FindLineSpecial(
                        15 as libc::c_int as int16_t,
                        (*mapthings.offset(i as isize)).angle,
                    );
                    if j == -(1 as libc::c_int) {
                        CONS_Debug(
                            0x80 as libc::c_int,
                            b"Particle generator (mapthing #%s) needs to be tagged to a #15 parameter line (trying to find tag %d).\n\0"
                                as *const u8 as *const libc::c_char,
                            sizeu1(i),
                            (*mapthings.offset(i as isize)).angle as libc::c_int,
                        );
                    } else {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int
                            as usize] = (*mapthings.offset(i as isize)).z as int32_t;
                        (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = R_PointToDist2(
                            (*(*lines.offset(j as isize)).v1).x,
                            (*(*lines.offset(j as isize)).v1).y,
                            (*(*lines.offset(j as isize)).v2).x,
                            (*(*lines.offset(j as isize)).v2).y,
                        ) >> 16 as libc::c_int;
                        (*mapthings.offset(i as isize))
                            .args[2 as libc::c_int
                            as usize] = (*sides
                            .offset(
                                (*lines.offset(j as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .textureoffset >> 16 as libc::c_int;
                        (*mapthings.offset(i as isize))
                            .args[3 as libc::c_int
                            as usize] = (*sides
                            .offset(
                                (*lines.offset(j as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int;
                        (*mapthings.offset(i as isize))
                            .args[4 as libc::c_int
                            as usize] = if !((*lines.offset(j as isize)).backsector)
                            .is_null()
                        {
                            (*sides
                                .offset(
                                    (*lines.offset(j as isize))
                                        .sidenum[1 as libc::c_int as usize] as isize,
                                ))
                                .textureoffset >> 16 as libc::c_int
                        } else {
                            0 as libc::c_int
                        };
                        (*mapthings.offset(i as isize))
                            .args[6 as libc::c_int
                            as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
                        P_WriteDuplicateText(
                            (*lines.offset(j as isize))
                                .stringargs[0 as libc::c_int as usize],
                            &mut *((*mapthings.offset(i as isize)).stringargs)
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize),
                        );
                    }
                    current_block_262 = 5684771287319053842;
                }
                762 => {
                    let mut check: int32_t = -(1 as libc::c_int);
                    let mut firstline: int32_t = -(1 as libc::c_int);
                    let mut tag: mtag_t = Tag_FGet(
                        &mut (*mapthings.offset(i as isize)).tags,
                    );
                    let mut ICNT_6603: size_t = 0 as libc::c_int as size_t;
                    loop {
                        check = Tag_Iterate_Lines(tag, ICNT_6603);
                        if !(check >= 0 as libc::c_int) {
                            break;
                        }
                        if (*lines.offset(check as isize)).special as libc::c_int
                            == 20 as libc::c_int
                        {
                            firstline = check;
                            break;
                        } else {
                            ICNT_6603 = ICNT_6603.wrapping_add(1);
                            ICNT_6603;
                        }
                    }
                    if firstline != -(1 as libc::c_int) {
                        let ref mut fresh306 = (*lines.offset(firstline as isize))
                            .args[3 as libc::c_int as usize];
                        *fresh306 |= TMPF_CRUSH as libc::c_int;
                    }
                    (*mapthings.offset(i as isize))
                        .type_0 = 761 as libc::c_int as uint16_t;
                    current_block_262 = 5684771287319053842;
                }
                780 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 4 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                799 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).extrainfo as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                1002 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                1007 => {
                    current_block_262 = 18062310889839126891;
                }
                1008 | 1011 => {
                    current_block_262 = 18062310889839126891;
                }
                1102 => {
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 1 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                1104 => {
                    current_block_262 = 2165004349265987625;
                }
                1105 => {
                    current_block_262 = 2165004349265987625;
                }
                1106 => {
                    current_block_262 = 10472550501007398166;
                }
                1107 => {
                    current_block_262 = 13708347923757650419;
                }
                1109 => {
                    current_block_262 = 4050722123997633090;
                }
                1110 => {
                    current_block_262 = 12350242817162068077;
                }
                1101 => {
                    current_block_262 = 8904137429359534714;
                }
                1119 | 1120 => {
                    current_block_262 = 8904137429359534714;
                }
                1121 => {
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 4 as libc::c_int != 0
                    {
                        let ref mut fresh315 = (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int as usize];
                        *fresh315 |= TMFH_NOFLAME as libc::c_int;
                    }
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 1 as libc::c_int != 0
                    {
                        let ref mut fresh316 = (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int as usize];
                        *fresh316 |= TMFH_CORONA as libc::c_int;
                    }
                    current_block_262 = 5684771287319053842;
                }
                1127 => {
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int as usize] = TMED_LEFT as libc::c_int;
                    } else if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 4 as libc::c_int != 0
                    {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int as usize] = TMED_RIGHT as libc::c_int;
                    } else {
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int as usize] = TMED_NONE as libc::c_int;
                    }
                    current_block_262 = 5684771287319053842;
                }
                1200 | 1201 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                1202 => {
                    let mut tag_1: mtag_t = (*mapthings.offset(i as isize)).angle;
                    let mut j_1: int32_t = Tag_FindLineSpecial(
                        12 as libc::c_int as int16_t,
                        tag_1,
                    );
                    if j_1 == -(1 as libc::c_int) {
                        CONS_Debug(
                            0x80 as libc::c_int,
                            b"Rock spawner: Unable to find parameter line 12 (tag %d)!\n\0"
                                as *const u8 as *const libc::c_char,
                            tag_1 as libc::c_int,
                        );
                    } else {
                        (*mapthings.offset(i as isize))
                            .angle = (AngleFixed(
                            R_PointToAngle2(
                                (*(*lines.offset(j_1 as isize)).v2).x,
                                (*(*lines.offset(j_1 as isize)).v2).y,
                                (*(*lines.offset(j_1 as isize)).v1).x,
                                (*(*lines.offset(j_1 as isize)).v1).y,
                            ),
                        ) >> 16 as libc::c_int) as int16_t;
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int
                            as usize] = P_AproxDistance(
                            (*lines.offset(j_1 as isize)).dx,
                            (*lines.offset(j_1 as isize)).dy,
                        ) >> 16 as libc::c_int;
                        (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = (*sides
                            .offset(
                                (*lines.offset(j_1 as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .textureoffset >> 16 as libc::c_int;
                        (*mapthings.offset(i as isize))
                            .args[2 as libc::c_int
                            as usize] = ((*lines.offset(j_1 as isize)).flags
                            as libc::c_int & 64 as libc::c_int != 0) as libc::c_int;
                        let mut id: int32_t = (*sides
                            .offset(
                                (*lines.offset(j_1 as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int;
                        if id > 0 as libc::c_int && id < 16 as libc::c_int {
                            P_WriteDuplicateText(
                                va(
                                    b"MT_ROCKCRUMBLE%d\0" as *const u8 as *const libc::c_char,
                                    id + 1 as libc::c_int,
                                ),
                                &mut *((*mapthings.offset(i as isize)).stringargs)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize),
                            );
                        } else {
                            P_WriteConstant(
                                MT_ROCKCRUMBLE1 as libc::c_int + id,
                                &mut *((*mapthings.offset(i as isize)).stringargs)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize),
                                b"Mapthing\0" as *const u8 as *const libc::c_char,
                                i as uint32_t,
                            );
                        }
                    }
                    current_block_262 = 5684771287319053842;
                }
                1221 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                1229 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                1300 | 1301 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).angle as libc::c_int
                        >> 13 as libc::c_int) * 35 as libc::c_int / 2 as libc::c_int;
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).angle as libc::c_int
                        >> 10 as libc::c_int & 7 as libc::c_int) * 35 as libc::c_int
                        / 2 as libc::c_int;
                    (*mapthings.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = 80 as libc::c_int
                        - 5 as libc::c_int
                            * (*mapthings.offset(i as isize)).extrainfo as libc::c_int;
                    (*mapthings.offset(i as isize))
                        .args[3 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                1304 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                1305 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                1500 => {
                    current_block_262 = 15879287738352634666;
                }
                1501 => {
                    current_block_262 = 15879287738352634666;
                }
                1502 | 1503 => {
                    current_block_262 = 2084554895267249172;
                }
                1700 => {
                    (*mapthings.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as libc::c_int
                        & 16383 as libc::c_int;
                    (*mapthings.offset(i as isize))
                        .args[3 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).angle as libc::c_int
                        & 16384 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 1805695623568620006;
                }
                1701 | 1702 => {
                    current_block_262 = 1805695623568620006;
                }
                1703 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as libc::c_int
                        & 0xfff as libc::c_int;
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).extrainfo
                        as libc::c_int * 32 as libc::c_int;
                    (*mapthings.offset(i as isize))
                        .args[2 as libc::c_int
                        as usize] = (((*mapthings.offset(i as isize)).angle
                        as libc::c_int & 0xf000 as libc::c_int) >> 12 as libc::c_int)
                        * 32 as libc::c_int;
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & (4 as libc::c_int | 1 as libc::c_int)
                        == 4 as libc::c_int | 1 as libc::c_int
                    {
                        (*mapthings.offset(i as isize))
                            .args[3 as libc::c_int
                            as usize] = TMDA_BOTTOM as libc::c_int;
                    } else if (*mapthings.offset(i as isize)).options as libc::c_int
                        & (4 as libc::c_int | 1 as libc::c_int) == 4 as libc::c_int
                    {
                        (*mapthings.offset(i as isize))
                            .args[3 as libc::c_int as usize] = TMDA_TOP as libc::c_int;
                    } else if (*mapthings.offset(i as isize)).options as libc::c_int
                        & (4 as libc::c_int | 1 as libc::c_int) == 1 as libc::c_int
                    {
                        (*mapthings.offset(i as isize))
                            .args[3 as libc::c_int
                            as usize] = TMDA_MIDDLE as libc::c_int;
                    } else {
                        (*mapthings.offset(i as isize))
                            .args[3 as libc::c_int
                            as usize] = TMDA_BOTTOMOFFSET as libc::c_int;
                    }
                    (*mapthings.offset(i as isize))
                        .args[4 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                1704 => {
                    (*mapthings.offset(i as isize))
                        .pitch = (30 as libc::c_int
                        * ((((*mapthings.offset(i as isize)).options as libc::c_int
                            & 15 as libc::c_int) + 9 as libc::c_int)
                            % 12 as libc::c_int)) as int16_t;
                    let ref mut fresh317 = (*mapthings.offset(i as isize)).options;
                    *fresh317 = (*fresh317 as libc::c_int & !(0xf as libc::c_int))
                        as uint16_t;
                    current_block_262 = 5684771287319053842;
                }
                1705 => {
                    current_block_262 = 9363960045095058656;
                }
                1713 => {
                    current_block_262 = 9363960045095058656;
                }
                1710 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).extrainfo as int32_t;
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                1714 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).extrainfo as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                1806 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = LE_KOOPA as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                1807 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = LE_AXE as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                2000 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).angle as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                2006 => {
                    current_block_262 = 1551035704321398794;
                }
                2007 | 2008 => {
                    current_block_262 = 1551035704321398794;
                }
                _ => {
                    current_block_262 = 5684771287319053842;
                }
            }
            match current_block_262 {
                9363960045095058656 => {
                    let mut oldangle: uint16_t = (*mapthings.offset(i as isize)).angle
                        as uint16_t;
                    (*mapthings.offset(i as isize))
                        .angle = (if (*mapthings.offset(i as isize)).extrainfo
                        as libc::c_int == 1 as libc::c_int
                    {
                        oldangle as libc::c_int - 90 as libc::c_int
                    } else {
                        (oldangle as libc::c_int >> 8 as libc::c_int)
                            * 360 as libc::c_int / 256 as libc::c_int
                    }) as int16_t;
                    (*mapthings.offset(i as isize))
                        .pitch = (if (*mapthings.offset(i as isize)).extrainfo
                        as libc::c_int == 1 as libc::c_int
                    {
                        oldangle as libc::c_int / 360 as libc::c_int
                    } else {
                        (oldangle as libc::c_int & 255 as libc::c_int)
                            * 360 as libc::c_int / 256 as libc::c_int
                    }) as int16_t;
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = if (*mapthings.offset(i as isize)).type_0
                        as libc::c_int == 1705 as libc::c_int
                    {
                        96 as libc::c_int
                    } else {
                        ((*mapthings.offset(i as isize)).options as libc::c_int
                            & 0xf as libc::c_int) * 16 as libc::c_int + 32 as libc::c_int
                    };
                    let ref mut fresh318 = (*mapthings.offset(i as isize)).options;
                    *fresh318 = (*fresh318 as libc::c_int & !(0xf as libc::c_int))
                        as uint16_t;
                    (*mapthings.offset(i as isize))
                        .type_0 = 1713 as libc::c_int as uint16_t;
                    current_block_262 = 5684771287319053842;
                }
                1805695623568620006 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).extrainfo as int32_t;
                    (*mapthings.offset(i as isize))
                        .args[1 as libc::c_int
                        as usize] = (*mapthings.offset(i as isize)).options as int32_t;
                    current_block_262 = 5684771287319053842;
                }
                7468767852762055642 => {
                    let mut ss: *mut subsector_t = R_PointInSubsector(
                        ((*mapthings.offset(i as isize)).x as libc::c_int)
                            << 16 as libc::c_int,
                        ((*mapthings.offset(i as isize)).y as libc::c_int)
                            << 16 as libc::c_int,
                    );
                    let mut s: *mut sector_t = 0 as *mut sector_t;
                    let mut line: *mut line_t = 0 as *mut line_t;
                    if ss.is_null() {
                        CONS_Debug(
                            0x80 as libc::c_int,
                            b"Push/pull point: Placed outside of map bounds!\n\0"
                                as *const u8 as *const libc::c_char,
                        );
                    } else {
                        s = (*ss).sector;
                        line = P_FindPointPushLine(&mut (*s).tags);
                        if line.is_null() {
                            CONS_Debug(
                                0x80 as libc::c_int,
                                b"Push/pull point: Unable to find line of type 547 tagged to sector %s!\n\0"
                                    as *const u8 as *const libc::c_char,
                                sizeu1(s.offset_from(sectors) as libc::c_long as size_t),
                            );
                        } else {
                            (*mapthings.offset(i as isize))
                                .args[0 as libc::c_int
                                as usize] = (*mapthings.offset(i as isize)).angle
                                as int32_t;
                            (*mapthings.offset(i as isize))
                                .args[1 as libc::c_int
                                as usize] = if (*line).flags as libc::c_int
                                & 8192 as libc::c_int != 0
                            {
                                (*sides
                                    .offset(
                                        (*line).sidenum[0 as libc::c_int as usize] as isize,
                                    ))
                                    .textureoffset >> 16 as libc::c_int
                            } else {
                                P_AproxDistance(
                                    (*line).dx >> 16 as libc::c_int,
                                    (*line).dy >> 16 as libc::c_int,
                                )
                            };
                            if (*mapthings.offset(i as isize)).type_0 as libc::c_int
                                == 755 as libc::c_int
                            {
                                let ref mut fresh302 = (*mapthings.offset(i as isize))
                                    .args[1 as libc::c_int as usize];
                                *fresh302 *= -(1 as libc::c_int);
                            }
                            if (*mapthings.offset(i as isize)).options as libc::c_int
                                & 4 as libc::c_int != 0
                            {
                                let ref mut fresh303 = (*mapthings.offset(i as isize))
                                    .args[2 as libc::c_int as usize];
                                *fresh303 |= TMPP_NOZFADE as libc::c_int;
                            }
                            if (*mapthings.offset(i as isize)).options as libc::c_int
                                & 8 as libc::c_int != 0
                            {
                                let ref mut fresh304 = (*mapthings.offset(i as isize))
                                    .args[2 as libc::c_int as usize];
                                *fresh304 |= TMPP_PUSHZ as libc::c_int;
                            }
                            if (*line).flags as libc::c_int & 64 as libc::c_int == 0 {
                                let ref mut fresh305 = (*mapthings.offset(i as isize))
                                    .args[2 as libc::c_int as usize];
                                *fresh305 |= TMPP_NONEXCLUSIVE as libc::c_int;
                            }
                            (*mapthings.offset(i as isize))
                                .type_0 = 754 as libc::c_int as uint16_t;
                        }
                    }
                    current_block_262 = 5684771287319053842;
                }
                17855240650044330644 => {
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 4 as libc::c_int != 0
                    {
                        let ref mut fresh300 = (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int as usize];
                        *fresh300 |= TMDS_NOGRAVITY as libc::c_int;
                    }
                    if (*mapthings.offset(i as isize)).options as libc::c_int
                        & 8 as libc::c_int != 0
                    {
                        let ref mut fresh301 = (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int as usize];
                        *fresh301 |= TMDS_ROTATEEXTRA as libc::c_int;
                    }
                    current_block_262 = 5684771287319053842;
                }
                3771118673463790323 => {
                    current_block_262 = 11680761402344870323;
                }
                3796996925409558124 => {
                    current_block_262 = 18251665547072454469;
                }
                2943036041819015608 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int == 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                6564976367101321445 => {
                    current_block_262 = 9859384875985599929;
                }
                18062310889839126891 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 4 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                2165004349265987625 => {
                    current_block_262 = 10472550501007398166;
                }
                8904137429359534714 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 1 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                15879287738352634666 => {
                    current_block_262 = 2084554895267249172;
                }
                1551035704321398794 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 1 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                _ => {}
            }
            match current_block_262 {
                11680761402344870323 => {
                    current_block_262 = 6496058539240282970;
                }
                18251665547072454469 => {
                    current_block_262 = 9319463168692799805;
                }
                9859384875985599929 => {
                    current_block_262 = 16684463338199207412;
                }
                10472550501007398166 => {
                    current_block_262 = 13708347923757650419;
                }
                2084554895267249172 => {
                    if (*mapthings.offset(i as isize)).angle as libc::c_int
                        >= 360 as libc::c_int
                    {
                        (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = 7 as libc::c_int
                            * ((*mapthings.offset(i as isize)).angle as libc::c_int
                                / 360 as libc::c_int) + 1 as libc::c_int;
                    }
                    current_block_262 = 5684771287319053842;
                }
                _ => {}
            }
            match current_block_262 {
                6496058539240282970 => {
                    current_block_262 = 9725716477909267835;
                }
                9319463168692799805 => {
                    current_block_262 = 8279308735152199837;
                }
                16684463338199207412 => {
                    current_block_262 = 10629041686158768989;
                }
                13708347923757650419 => {
                    current_block_262 = 4050722123997633090;
                }
                _ => {}
            }
            match current_block_262 {
                9725716477909267835 => {
                    current_block_262 = 18323572960312075136;
                }
                8279308735152199837 => {
                    current_block_262 = 8289800320966035646;
                }
                10629041686158768989 => {
                    current_block_262 = 15872520761627011276;
                }
                4050722123997633090 => {
                    current_block_262 = 12350242817162068077;
                }
                _ => {}
            }
            match current_block_262 {
                12350242817162068077 => {
                    let mut tag_0: mtag_t = (*mapthings.offset(i as isize)).angle;
                    let mut j_0: int32_t = Tag_FindLineSpecial(
                        9 as libc::c_int as int16_t,
                        tag_0,
                    );
                    if j_0 == -(1 as libc::c_int) {
                        CONS_Debug(
                            0x80 as libc::c_int,
                            b"Chain/mace setup: Unable to find parameter line 9 (tag %d)!\n\0"
                                as *const u8 as *const libc::c_char,
                            tag_0 as libc::c_int,
                        );
                    } else {
                        (*mapthings.offset(i as isize))
                            .angle = ((*(*lines.offset(j_0 as isize)).frontsector)
                            .ceilingheight >> 16 as libc::c_int) as int16_t;
                        (*mapthings.offset(i as isize))
                            .pitch = ((*(*lines.offset(j_0 as isize)).frontsector)
                            .floorheight >> 16 as libc::c_int) as int16_t;
                        (*mapthings.offset(i as isize))
                            .args[0 as libc::c_int
                            as usize] = (*lines.offset(j_0 as isize)).dx
                            >> 16 as libc::c_int;
                        (*mapthings.offset(i as isize))
                            .args[1 as libc::c_int
                            as usize] = (*mapthings.offset(i as isize)).extrainfo
                            as int32_t;
                        (*mapthings.offset(i as isize))
                            .args[3 as libc::c_int
                            as usize] = (*lines.offset(j_0 as isize)).dy
                            >> 16 as libc::c_int;
                        (*mapthings.offset(i as isize))
                            .args[4 as libc::c_int
                            as usize] = (*sides
                            .offset(
                                (*lines.offset(j_0 as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .textureoffset >> 16 as libc::c_int;
                        (*mapthings.offset(i as isize))
                            .args[7 as libc::c_int
                            as usize] = -(*sides
                            .offset(
                                (*lines.offset(j_0 as isize))
                                    .sidenum[0 as libc::c_int as usize] as isize,
                            ))
                            .rowoffset >> 16 as libc::c_int;
                        if !((*lines.offset(j_0 as isize)).backsector).is_null() {
                            (*mapthings.offset(i as isize))
                                .roll = ((*(*lines.offset(j_0 as isize)).backsector)
                                .ceilingheight >> 16 as libc::c_int) as int16_t;
                            (*mapthings.offset(i as isize))
                                .args[2 as libc::c_int
                                as usize] = (*sides
                                .offset(
                                    (*lines.offset(j_0 as isize))
                                        .sidenum[1 as libc::c_int as usize] as isize,
                                ))
                                .rowoffset >> 16 as libc::c_int;
                            (*mapthings.offset(i as isize))
                                .args[5 as libc::c_int
                                as usize] = (*(*lines.offset(j_0 as isize)).backsector)
                                .floorheight >> 16 as libc::c_int;
                            (*mapthings.offset(i as isize))
                                .args[6 as libc::c_int
                                as usize] = (*sides
                                .offset(
                                    (*lines.offset(j_0 as isize))
                                        .sidenum[1 as libc::c_int as usize] as isize,
                                ))
                                .textureoffset >> 16 as libc::c_int;
                        }
                        if (*mapthings.offset(i as isize)).options as libc::c_int
                            & 8 as libc::c_int != 0
                        {
                            let ref mut fresh307 = (*mapthings.offset(i as isize))
                                .args[8 as libc::c_int as usize];
                            *fresh307 |= TMM_DOUBLESIZE as libc::c_int;
                        }
                        if (*mapthings.offset(i as isize)).options as libc::c_int
                            & 4 as libc::c_int != 0
                        {
                            let ref mut fresh308 = (*mapthings.offset(i as isize))
                                .args[8 as libc::c_int as usize];
                            *fresh308 |= TMM_SILENT as libc::c_int;
                        }
                        if (*lines.offset(j_0 as isize)).flags as libc::c_int
                            & 64 as libc::c_int != 0
                        {
                            let ref mut fresh309 = (*mapthings.offset(i as isize))
                                .args[8 as libc::c_int as usize];
                            *fresh309 |= TMM_ALLOWYAWCONTROL as libc::c_int;
                        }
                        if (*lines.offset(j_0 as isize)).flags as libc::c_int
                            & 32 as libc::c_int != 0
                        {
                            let ref mut fresh310 = (*mapthings.offset(i as isize))
                                .args[8 as libc::c_int as usize];
                            *fresh310 |= TMM_SWING as libc::c_int;
                        }
                        if (*lines.offset(j_0 as isize)).flags as libc::c_int
                            & 128 as libc::c_int != 0
                        {
                            let ref mut fresh311 = (*mapthings.offset(i as isize))
                                .args[8 as libc::c_int as usize];
                            *fresh311 |= TMM_MACELINKS as libc::c_int;
                        }
                        if (*lines.offset(j_0 as isize)).flags as libc::c_int
                            & 256 as libc::c_int != 0
                        {
                            let ref mut fresh312 = (*mapthings.offset(i as isize))
                                .args[8 as libc::c_int as usize];
                            *fresh312 |= TMM_CENTERLINK as libc::c_int;
                        }
                        if (*lines.offset(j_0 as isize)).flags as libc::c_int
                            & 512 as libc::c_int != 0
                        {
                            let ref mut fresh313 = (*mapthings.offset(i as isize))
                                .args[8 as libc::c_int as usize];
                            *fresh313 |= TMM_CLIP as libc::c_int;
                        }
                        if (*lines.offset(j_0 as isize)).flags as libc::c_int
                            & 1024 as libc::c_int != 0
                        {
                            let ref mut fresh314 = (*mapthings.offset(i as isize))
                                .args[8 as libc::c_int as usize];
                            *fresh314 |= TMM_ALWAYSTHINK as libc::c_int;
                        }
                        if (*mapthings.offset(i as isize)).type_0 as libc::c_int
                            == 1110 as libc::c_int
                        {
                            P_WriteDuplicateText(
                                (*lines.offset(j_0 as isize))
                                    .stringargs[0 as libc::c_int as usize],
                                &mut *((*mapthings.offset(i as isize)).stringargs)
                                    .as_mut_ptr()
                                    .offset(0 as libc::c_int as isize),
                            );
                            P_WriteDuplicateText(
                                (*lines.offset(j_0 as isize))
                                    .stringargs[1 as libc::c_int as usize],
                                &mut *((*mapthings.offset(i as isize)).stringargs)
                                    .as_mut_ptr()
                                    .offset(1 as libc::c_int as isize),
                            );
                        }
                    }
                    current_block_262 = 5684771287319053842;
                }
                18323572960312075136 => {
                    current_block_262 = 3366966530450955154;
                }
                8289800320966035646 => {
                    current_block_262 = 5338802250226117973;
                }
                15872520761627011276 => {
                    current_block_262 = 18383098730014678056;
                }
                _ => {}
            }
            match current_block_262 {
                18383098730014678056 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int as usize] = 35 as libc::c_int;
                    P_WriteSfx(
                        sfx_amwtr1 as libc::c_int
                            + (*mapthings.offset(i as isize)).type_0 as libc::c_int
                            - 700 as libc::c_int,
                        &mut *((*mapthings.offset(i as isize)).stringargs)
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize),
                    );
                    (*mapthings.offset(i as isize))
                        .type_0 = 700 as libc::c_int as uint16_t;
                    current_block_262 = 5684771287319053842;
                }
                3366966530450955154 => {
                    current_block_262 = 7827081262013676022;
                }
                5338802250226117973 => {
                    current_block_262 = 18022583794090175981;
                }
                _ => {}
            }
            match current_block_262 {
                7827081262013676022 => {
                    current_block_262 = 12913299854706673563;
                }
                18022583794090175981 => {
                    current_block_262 = 9272111169585103524;
                }
                _ => {}
            }
            match current_block_262 {
                12913299854706673563 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int != 0) as libc::c_int;
                    current_block_262 = 5684771287319053842;
                }
                9272111169585103524 => {
                    current_block_262 = 12486844204549033476;
                }
                _ => {}
            }
            match current_block_262 {
                12486844204549033476 => {
                    current_block_262 = 3013351444566145493;
                }
                _ => {}
            }
            match current_block_262 {
                3013351444566145493 => {
                    current_block_262 = 14268641534782834152;
                }
                _ => {}
            }
            match current_block_262 {
                14268641534782834152 => {
                    current_block_262 = 11479947651033336051;
                }
                _ => {}
            }
            match current_block_262 {
                11479947651033336051 => {
                    current_block_262 = 3927851556771736049;
                }
                _ => {}
            }
            match current_block_262 {
                3927851556771736049 => {
                    current_block_262 = 13151914577407923353;
                }
                _ => {}
            }
            match current_block_262 {
                13151914577407923353 => {
                    current_block_262 = 10977263893217871522;
                }
                _ => {}
            }
            match current_block_262 {
                10977263893217871522 => {
                    current_block_262 = 7046344642169884998;
                }
                _ => {}
            }
            match current_block_262 {
                7046344642169884998 => {
                    current_block_262 = 15980586669830306824;
                }
                _ => {}
            }
            match current_block_262 {
                15980586669830306824 => {
                    current_block_262 = 7571381298829053059;
                }
                _ => {}
            }
            match current_block_262 {
                7571381298829053059 => {
                    current_block_262 = 7360090934194561406;
                }
                _ => {}
            }
            match current_block_262 {
                7360090934194561406 => {
                    current_block_262 = 18009581395994504549;
                }
                _ => {}
            }
            match current_block_262 {
                18009581395994504549 => {
                    current_block_262 = 17987396596742658124;
                }
                _ => {}
            }
            match current_block_262 {
                17987396596742658124 => {
                    (*mapthings.offset(i as isize))
                        .args[0 as libc::c_int
                        as usize] = ((*mapthings.offset(i as isize)).options
                        as libc::c_int & 8 as libc::c_int == 0) as libc::c_int;
                }
                _ => {}
            }
            let ref mut fresh319 = (*mapthings.offset(i as isize)).options;
            *fresh319 = (*fresh319 as libc::c_int & 0xf as libc::c_int) as uint16_t;
        }
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn P_ConvertBinaryLinedefFlags() {
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < numlines {
        if ((*lines.offset(i as isize)).flags as libc::c_int & 16 as libc::c_int != 0)
            as libc::c_int
            ^ ((*lines.offset(i as isize)).flags as libc::c_int & 256 as libc::c_int
                != 0) as libc::c_int != 0
        {
            let ref mut fresh320 = (*lines.offset(i as isize)).flags;
            *fresh320 = (*fresh320 as libc::c_int | 256 as libc::c_int) as int16_t;
        } else {
            let ref mut fresh321 = (*lines.offset(i as isize)).flags;
            *fresh321 = (*fresh321 as libc::c_int & !(256 as libc::c_int)) as int16_t;
        }
        if (*lines.offset(i as isize)).special as libc::c_int >= 100 as libc::c_int
            && ((*lines.offset(i as isize)).special as libc::c_int) < 300 as libc::c_int
        {
            if (*lines.offset(i as isize)).flags as libc::c_int & 8 as libc::c_int != 0 {
                let ref mut fresh322 = (*lines.offset(i as isize)).flags;
                *fresh322 = (*fresh322 as libc::c_int | 32 as libc::c_int) as int16_t;
            } else {
                let ref mut fresh323 = (*lines.offset(i as isize)).flags;
                *fresh323 = (*fresh323 as libc::c_int & !(32 as libc::c_int)) as int16_t;
            }
            if (*lines.offset(i as isize)).flags as libc::c_int & 32768 as libc::c_int
                != 0 && !((*lines.offset(i as isize)).frontsector).is_null()
            {
                let mut j: size_t = 0;
                j = 0 as libc::c_int as size_t;
                while j < (*(*lines.offset(i as isize)).frontsector).linecount {
                    if (**((*(*lines.offset(i as isize)).frontsector).lines)
                        .offset(j as isize))
                        .flags as libc::c_int & 8 as libc::c_int != 0
                    {
                        let ref mut fresh324 = (**((*(*lines.offset(i as isize))
                            .frontsector)
                            .lines)
                            .offset(j as isize))
                            .flags;
                        *fresh324 = (*fresh324 as libc::c_int | 32 as libc::c_int)
                            as int16_t;
                    } else {
                        let ref mut fresh325 = (**((*(*lines.offset(i as isize))
                            .frontsector)
                            .lines)
                            .offset(j as isize))
                            .flags;
                        *fresh325 = (*fresh325 as libc::c_int & !(32 as libc::c_int))
                            as int16_t;
                    }
                    j = j.wrapping_add(1);
                    j;
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn P_ConvertBinaryMap() {
    contextdrift = false_0 as libc::c_int;
    P_ConvertBinaryLinedefTypes();
    P_ConvertBinarySectorTypes();
    P_ConvertBinaryThingTypes();
    P_ConvertBinaryLinedefFlags();
    if M_CheckParm(b"-writetextmap\0" as *const u8 as *const libc::c_char) != 0 {
        P_WriteTextmap();
    }
}
unsafe extern "C" fn P_MakeBufferMD5(
    mut buffer: *const libc::c_char,
    mut len: size_t,
    mut resblock: *mut libc::c_void,
) -> int32_t {
    let mut t: tic_t = I_GetTime();
    CONS_Debug(
        0x400 as libc::c_int,
        b"Making MD5\n\0" as *const u8 as *const libc::c_char,
    );
    if (md5_buffer(buffer, len, resblock)).is_null() {
        return 1 as libc::c_int;
    }
    CONS_Debug(
        0x400 as libc::c_int,
        b"MD5 calc took %f seconds\n\0" as *const u8 as *const libc::c_char,
        ((I_GetTime()).wrapping_sub(t) as libc::c_float
            / (35 as libc::c_int * 1 as libc::c_int) as libc::c_float) as libc::c_double,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn P_MakeMapMD5(
    mut virt: *mut virtres_t,
    mut dest: *mut libc::c_void,
) {
    let mut resmd5: [libc::c_uchar; 16] = [0; 16];
    if udmf != 0 {
        let mut textmap: *mut virtlump_t = vres_Find(
            virt,
            b"TEXTMAP\0" as *const u8 as *const libc::c_char,
        );
        P_MakeBufferMD5(
            (*textmap).data as *mut libc::c_char,
            (*textmap).size,
            resmd5.as_mut_ptr() as *mut libc::c_void,
        );
    } else {
        let mut linemd5: [libc::c_uchar; 16] = [0; 16];
        let mut sectormd5: [libc::c_uchar; 16] = [0; 16];
        let mut thingmd5: [libc::c_uchar; 16] = [0; 16];
        let mut sidedefmd5: [libc::c_uchar; 16] = [0; 16];
        let mut i: uint8_t = 0;
        let mut virtlines: *mut virtlump_t = vres_Find(
            virt,
            b"LINEDEFS\0" as *const u8 as *const libc::c_char,
        );
        let mut virtsectors: *mut virtlump_t = vres_Find(
            virt,
            b"SECTORS\0" as *const u8 as *const libc::c_char,
        );
        let mut virtmthings: *mut virtlump_t = vres_Find(
            virt,
            b"THINGS\0" as *const u8 as *const libc::c_char,
        );
        let mut virtsides: *mut virtlump_t = vres_Find(
            virt,
            b"SIDEDEFS\0" as *const u8 as *const libc::c_char,
        );
        P_MakeBufferMD5(
            (*virtlines).data as *mut libc::c_char,
            (*virtlines).size,
            linemd5.as_mut_ptr() as *mut libc::c_void,
        );
        P_MakeBufferMD5(
            (*virtsectors).data as *mut libc::c_char,
            (*virtsectors).size,
            sectormd5.as_mut_ptr() as *mut libc::c_void,
        );
        P_MakeBufferMD5(
            (*virtmthings).data as *mut libc::c_char,
            (*virtmthings).size,
            thingmd5.as_mut_ptr() as *mut libc::c_void,
        );
        P_MakeBufferMD5(
            (*virtsides).data as *mut libc::c_char,
            (*virtsides).size,
            sidedefmd5.as_mut_ptr() as *mut libc::c_void,
        );
        i = 0 as libc::c_int as uint8_t;
        while (i as libc::c_int) < 16 as libc::c_int {
            resmd5[i
                as usize] = (linemd5[i as usize] as libc::c_int
                + sectormd5[i as usize] as libc::c_int
                + thingmd5[i as usize] as libc::c_int
                + sidedefmd5[i as usize] as libc::c_int & 0xff as libc::c_int)
                as libc::c_uchar;
            i = i.wrapping_add(1);
            i;
        }
    }
    M_Memcpy
        .expect(
            "non-null function pointer",
        )(
        dest,
        &mut resmd5 as *mut [libc::c_uchar; 16] as *const libc::c_void,
        16 as libc::c_int as size_t,
    );
}
unsafe extern "C" fn P_LoadMapFromFile() -> boolean {
    let mut virt: *mut virtres_t = vres_GetMap(lastloadedmaplumpnum);
    let mut textmap: *mut virtlump_t = vres_Find(
        virt,
        b"TEXTMAP\0" as *const u8 as *const libc::c_char,
    );
    let mut i: size_t = 0;
    udmf = (textmap != 0 as *mut libc::c_void as *mut virtlump_t) as libc::c_int;
    if P_LoadMapData(virt) == 0 {
        return false_0 as libc::c_int;
    }
    P_LoadMapBSP(virt);
    P_LoadMapLUT(virt);
    P_LinkMapData();
    if udmf == 0 {
        P_AddBinaryMapTags();
    }
    Taglist_InitGlobalTables();
    if udmf == 0 {
        P_ConvertBinaryMap();
    }
    spawnsectors = Z_CallocAlign(
        numsectors.wrapping_mul(::core::mem::size_of::<sector_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut sector_t;
    spawnlines = Z_CallocAlign(
        numlines.wrapping_mul(::core::mem::size_of::<line_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut line_t;
    spawnsides = Z_CallocAlign(
        numsides.wrapping_mul(::core::mem::size_of::<side_t>() as libc::c_ulong),
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut side_t;
    memcpy(
        spawnsectors as *mut libc::c_void,
        sectors as *const libc::c_void,
        numsectors.wrapping_mul(::core::mem::size_of::<sector_t>() as libc::c_ulong),
    );
    memcpy(
        spawnlines as *mut libc::c_void,
        lines as *const libc::c_void,
        numlines.wrapping_mul(::core::mem::size_of::<line_t>() as libc::c_ulong),
    );
    memcpy(
        spawnsides as *mut libc::c_void,
        sides as *const libc::c_void,
        numsides.wrapping_mul(::core::mem::size_of::<side_t>() as libc::c_ulong),
    );
    i = 0 as libc::c_int as size_t;
    while i < numsectors {
        if (*sectors.offset(i as isize)).tags.count != 0 {
            let ref mut fresh326 = (*spawnsectors.offset(i as isize)).tags.tags;
            *fresh326 = memcpy(
                Z_MallocAlign(
                    ((*sectors.offset(i as isize)).tags.count as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<mtag_t>() as libc::c_ulong),
                    PU_LEVEL as libc::c_int,
                    0 as *mut libc::c_void,
                    ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong
                        as int32_t,
                ),
                (*sectors.offset(i as isize)).tags.tags as *const libc::c_void,
                ((*sectors.offset(i as isize)).tags.count as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<mtag_t>() as libc::c_ulong),
            ) as *mut mtag_t;
        }
        i = i.wrapping_add(1);
        i;
    }
    P_MakeMapMD5(virt, &mut mapmd5 as *mut [libc::c_uchar; 16] as *mut libc::c_void);
    vres_Free(virt);
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_SetupLevelSky(mut skynum: int32_t, mut global: boolean) {
    let mut skytexname: [libc::c_char; 12] = [0; 12];
    sprintf(
        skytexname.as_mut_ptr(),
        b"SKY%d\0" as *const u8 as *const libc::c_char,
        skynum,
    );
    skytexture = R_TextureNumForName(skytexname.as_mut_ptr());
    levelskynum = skynum;
    if global != 0 {
        globallevelskynum = levelskynum;
    }
    if dedicated != 0 {
        return;
    }
    R_SetupSkyDraw();
}
static mut maplumpname: *const libc::c_char = 0 as *const libc::c_char;
#[no_mangle]
pub static mut lastloadedmaplumpnum: lumpnum_t = 0;
unsafe extern "C" fn P_InitLevelSettings() {
    let mut i: int32_t = 0;
    let mut canresetlives: boolean = true_0 as libc::c_int;
    leveltime = 0 as libc::c_int as tic_t;
    modulothing = 0 as libc::c_int;
    tokenbits = 0 as libc::c_int;
    runemeraldmanager = false_0 as libc::c_int;
    emeraldspawndelay = (60 as libc::c_int * 35 as libc::c_int) as uint16_t;
    if (netgame != 0 || multiplayer != 0) && G_IsSpecialStage(gamemap as int32_t) == 0 {
        nummaprings = -(1 as libc::c_int);
    } else {
        nummaprings = (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int)
            as usize])
            .startrings as int32_t;
    }
    hunt3 = 0 as *mut mobj_t;
    hunt2 = hunt3;
    hunt1 = hunt2;
    if (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize]).countdown
        != 0
    {
        let mut maxtime: tic_t = 0 as libc::c_int as tic_t;
        countdowntimer = ((*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int)
            as usize])
            .countdown as libc::c_int * 35 as libc::c_int) as tic_t;
        i = 0 as libc::c_int;
        while i < 32 as libc::c_int {
            if !(playeringame[i as usize] == 0) {
                if players[i as usize].starposttime > maxtime {
                    maxtime = players[i as usize].starposttime;
                }
            }
            i += 1;
            i;
        }
        countdowntimer = countdowntimer.wrapping_sub(maxtime);
    } else {
        countdowntimer = 0 as libc::c_int as tic_t;
    }
    countdowntimeup = false_0 as libc::c_int;
    blueflag = 0 as *mut mobj_t;
    redflag = blueflag;
    bflagpoint = 0 as *mut mapthing_t;
    rflagpoint = bflagpoint;
    circuitmap = false_0 as libc::c_int;
    numstarposts = 0 as libc::c_int;
    timeinmap = 0 as libc::c_int as tic_t;
    ssspheres = timeinmap;
    stagefailed = G_IsSpecialStage(gamemap as int32_t);
    memset(
        &mut ntemprecords as *mut [nightsdata_t; 32] as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[nightsdata_t; 32]>() as libc::c_ulong,
    );
    memset(
        &mut quake as *mut quake as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<quake>() as libc::c_ulong,
    );
    if (netgame != 0 || multiplayer != 0) && G_GametypeUsesCoopStarposts() != 0
        && cv_coopstarposts.value == 2 as libc::c_int
    {
        i = 0 as libc::c_int;
        while i < 32 as libc::c_int {
            if playeringame[i as usize] != 0
                && players[i as usize].lives as libc::c_int > 0 as libc::c_int
            {
                canresetlives = false_0 as libc::c_int;
                break;
            } else {
                i += 1;
                i;
            }
        }
    }
    exitfadestarted = 0 as libc::c_int;
    countdown2 = exitfadestarted as uint32_t;
    countdown = countdown2;
    i = 0 as libc::c_int;
    while i < 32 as libc::c_int {
        G_PlayerReborn(i, true_0 as libc::c_int);
        if canresetlives != 0 && (netgame != 0 || multiplayer != 0)
            && playeringame[i as usize] != 0
            && (G_CompetitionGametype() != 0
                || players[i as usize].lives as libc::c_int <= 0 as libc::c_int)
        {
            players[i as usize].lives = cv_startinglives.value as int8_t;
        }
        players[i as usize].exiting = 0 as libc::c_int as tic_t;
        players[i as usize].mare = players[i as usize].exiting as uint8_t;
        players[i as usize].lastmarescore = players[i as usize].mare as uint32_t;
        players[i as usize].marescore = players[i as usize].lastmarescore;
        players[i as usize].laps = players[i as usize].marescore as uint8_t;
        players[i as usize].totalring = players[i as usize].laps as int16_t;
        players[i as usize].numboxes = players[i as usize].totalring;
        players[i as usize].drillmeter = 40 as libc::c_int * 20 as libc::c_int;
        players[i as usize]
            .pflags = ::core::mem::transmute::<
            libc::c_uint,
            pflags_t,
        >(
            players[i as usize].pflags as libc::c_uint
                & !(PF_GAMETYPEOVER as libc::c_int) as libc::c_uint,
        );
        i += 1;
        i;
    }
    if botingame != 0 {
        CV_SetValue(
            &mut *cv_analog.as_mut_ptr().offset(1 as libc::c_int as isize),
            true_0 as libc::c_int,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_RespawnThings() {
    let mut think: *mut thinker_t = 0 as *mut thinker_t;
    let mut i: int32_t = 0;
    let mut viewid: int32_t = -(1 as libc::c_int);
    let mut centerid: int32_t = -(1 as libc::c_int);
    if !(skyboxmo[0 as libc::c_int as usize]).is_null()
        || !(skyboxmo[1 as libc::c_int as usize]).is_null()
    {
        i = 0 as libc::c_int;
        while i < 16 as libc::c_int {
            if !(skyboxmo[0 as libc::c_int as usize]).is_null()
                && skyboxmo[0 as libc::c_int as usize] == skyboxviewpnts[i as usize]
            {
                viewid = i;
            }
            if !(skyboxmo[1 as libc::c_int as usize]).is_null()
                && skyboxmo[1 as libc::c_int as usize] == skyboxcenterpnts[i as usize]
            {
                centerid = i;
            }
            i += 1;
            i;
        }
    }
    think = (*thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)).next;
    while think
        != &mut *thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)
            as *mut thinker_t
    {
        if !((*think).function.acp1
            == ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut thinker_t) -> ()>,
                actionf_p1,
            >(
                Some(
                    P_RemoveThinkerDelayed as unsafe extern "C" fn(*mut thinker_t) -> (),
                ),
            ))
        {
            P_RemoveMobj(think as *mut mobj_t);
        }
        think = (*think).next;
    }
    P_InitLevelSettings();
    localaiming = 0 as libc::c_int;
    localaiming2 = 0 as libc::c_int;
    P_SpawnMapThings(true_0 as libc::c_int);
    skyboxmo[0 as libc::c_int
        as usize] = skyboxviewpnts[(if viewid >= 0 as libc::c_int {
        viewid
    } else {
        0 as libc::c_int
    }) as usize];
    skyboxmo[1 as libc::c_int
        as usize] = skyboxcenterpnts[(if centerid >= 0 as libc::c_int {
        centerid
    } else {
        0 as libc::c_int
    }) as usize];
}
unsafe extern "C" fn P_RunLevelScript(mut scriptname: *const libc::c_char) {
    if (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize]).levelflags
        as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int == 0
    {
        let mut lumpnum: lumpnum_t = 0;
        let mut newname: [libc::c_char; 9] = [0; 9];
        strncpy(newname.as_mut_ptr(), scriptname, 8 as libc::c_int as libc::c_ulong);
        newname[8 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
        lumpnum = W_CheckNumForName(newname.as_mut_ptr());
        if lumpnum == 4294967295 as libc::c_uint
            || W_LumpLength(lumpnum) == 0 as libc::c_int as size_t
        {
            CONS_Debug(
                0x400 as libc::c_int,
                b"SOC Error: script lump %s not found/not valid.\n\0" as *const u8
                    as *const libc::c_char,
                newname.as_mut_ptr(),
            );
            return;
        }
        COM_BufInsertTextEx(
            W_CacheLumpNum(lumpnum, PU_CACHE as libc::c_int) as *const libc::c_char,
            0 as com_flags_t,
        );
    } else {
        COM_BufAddTextEx(
            va(b"exec %s\n\0" as *const u8 as *const libc::c_char, scriptname),
            0 as com_flags_t,
        );
    }
    COM_BufExecute();
}
unsafe extern "C" fn P_ForceCharacter(mut forcecharskin: *const libc::c_char) {
    if netgame != 0 {
        let mut skincmd: [libc::c_char; 33] = [0; 33];
        if splitscreen != 0 {
            sprintf(
                skincmd.as_mut_ptr(),
                b"skin2 %s\n\0" as *const u8 as *const libc::c_char,
                forcecharskin,
            );
            CV_Set(&mut cv_skin2, forcecharskin);
        }
        sprintf(
            skincmd.as_mut_ptr(),
            b"skin %s\n\0" as *const u8 as *const libc::c_char,
            forcecharskin,
        );
        COM_BufAddTextEx(skincmd.as_mut_ptr(), 0 as com_flags_t);
    } else {
        if splitscreen != 0 {
            SetPlayerSkin(secondarydisplayplayer, forcecharskin);
            if cv_playercolor2.value as libc::c_uint
                != skins[players[secondarydisplayplayer as usize].skin as usize]
                    .prefcolor as libc::c_uint
            {
                CV_StealthSetValue(
                    &mut cv_playercolor2,
                    skins[players[secondarydisplayplayer as usize].skin as usize]
                        .prefcolor as int32_t,
                );
                players[secondarydisplayplayer as usize]
                    .skincolor = skins[players[secondarydisplayplayer as usize].skin
                        as usize]
                    .prefcolor;
            }
        }
        SetPlayerSkin(consoleplayer, forcecharskin);
        if cv_playercolor.value as libc::c_uint
            != skins[players[consoleplayer as usize].skin as usize].prefcolor
                as libc::c_uint
        {
            CV_StealthSetValue(
                &mut cv_playercolor,
                skins[players[consoleplayer as usize].skin as usize].prefcolor as int32_t,
            );
            players[consoleplayer as usize]
                .skincolor = skins[players[consoleplayer as usize].skin as usize]
                .prefcolor;
        }
    };
}
unsafe extern "C" fn P_ResetSpawnpoints() {
    let mut i: uint8_t = 0;
    numbluectfstarts = 0 as libc::c_int;
    numredctfstarts = numbluectfstarts;
    numdmstarts = numredctfstarts;
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 32 as libc::c_int {
        redctfstarts[i as usize] = 0 as *mut mapthing_t;
        bluectfstarts[i as usize] = redctfstarts[i as usize];
        playerstarts[i as usize] = bluectfstarts[i as usize];
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 64 as libc::c_int {
        deathmatchstarts[i as usize] = 0 as *mut mapthing_t;
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 2 as libc::c_int {
        skyboxmo[i as usize] = 0 as *mut mobj_t;
        i = i.wrapping_add(1);
        i;
    }
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 16 as libc::c_int {
        skyboxcenterpnts[i as usize] = 0 as *mut mobj_t;
        skyboxviewpnts[i as usize] = skyboxcenterpnts[i as usize];
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn P_LoadRecordGhosts() {
    let glen: size_t = (strlen(srb2home.as_mut_ptr()))
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(strlen(b"replay\0" as *const u8 as *const libc::c_char))
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(strlen(timeattackfolder.as_mut_ptr()))
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(strlen(b"MAPXX\0" as *const u8 as *const libc::c_char))
        .wrapping_add(1 as libc::c_int as libc::c_ulong);
    let mut gpath: *mut libc::c_char = malloc(glen) as *mut libc::c_char;
    let mut i: int32_t = 0;
    if gpath.is_null() {
        return;
    }
    sprintf(
        gpath,
        b"%s/replay/%s/%s\0" as *const u8 as *const libc::c_char,
        srb2home.as_mut_ptr(),
        timeattackfolder.as_mut_ptr(),
        G_BuildMapName(gamemap as int32_t),
    );
    if cv_ghost_bestscore.value != 0 {
        i = 0 as libc::c_int;
        while i < numskins {
            if !(cv_ghost_bestscore.value == 1 as libc::c_int
                && players[consoleplayer as usize].skin != i)
            {
                if FIL_FileExists(
                    va(
                        b"%s-%s-score-best.lmp\0" as *const u8 as *const libc::c_char,
                        gpath,
                        (skins[i as usize].name).as_mut_ptr(),
                    ),
                ) != 0
                {
                    G_AddGhost(
                        va(
                            b"%s-%s-score-best.lmp\0" as *const u8
                                as *const libc::c_char,
                            gpath,
                            (skins[i as usize].name).as_mut_ptr(),
                        ),
                    );
                }
            }
            i += 1;
            i;
        }
    }
    if cv_ghost_besttime.value != 0 {
        i = 0 as libc::c_int;
        while i < numskins {
            if !(cv_ghost_besttime.value == 1 as libc::c_int
                && players[consoleplayer as usize].skin != i)
            {
                if FIL_FileExists(
                    va(
                        b"%s-%s-time-best.lmp\0" as *const u8 as *const libc::c_char,
                        gpath,
                        (skins[i as usize].name).as_mut_ptr(),
                    ),
                ) != 0
                {
                    G_AddGhost(
                        va(
                            b"%s-%s-time-best.lmp\0" as *const u8 as *const libc::c_char,
                            gpath,
                            (skins[i as usize].name).as_mut_ptr(),
                        ),
                    );
                }
            }
            i += 1;
            i;
        }
    }
    if cv_ghost_bestrings.value != 0 {
        i = 0 as libc::c_int;
        while i < numskins {
            if !(cv_ghost_bestrings.value == 1 as libc::c_int
                && players[consoleplayer as usize].skin != i)
            {
                if FIL_FileExists(
                    va(
                        b"%s-%s-rings-best.lmp\0" as *const u8 as *const libc::c_char,
                        gpath,
                        (skins[i as usize].name).as_mut_ptr(),
                    ),
                ) != 0
                {
                    G_AddGhost(
                        va(
                            b"%s-%s-rings-best.lmp\0" as *const u8
                                as *const libc::c_char,
                            gpath,
                            (skins[i as usize].name).as_mut_ptr(),
                        ),
                    );
                }
            }
            i += 1;
            i;
        }
    }
    if cv_ghost_last.value != 0 {
        i = 0 as libc::c_int;
        while i < numskins {
            if !(cv_ghost_last.value == 1 as libc::c_int
                && players[consoleplayer as usize].skin != i)
            {
                if FIL_FileExists(
                    va(
                        b"%s-%s-last.lmp\0" as *const u8 as *const libc::c_char,
                        gpath,
                        (skins[i as usize].name).as_mut_ptr(),
                    ),
                ) != 0
                {
                    G_AddGhost(
                        va(
                            b"%s-%s-last.lmp\0" as *const u8 as *const libc::c_char,
                            gpath,
                            (skins[i as usize].name).as_mut_ptr(),
                        ),
                    );
                }
            }
            i += 1;
            i;
        }
    }
    if cv_ghost_guest.value != 0
        && FIL_FileExists(
            va(b"%s-guest.lmp\0" as *const u8 as *const libc::c_char, gpath),
        ) != 0
    {
        G_AddGhost(va(b"%s-guest.lmp\0" as *const u8 as *const libc::c_char, gpath));
    }
    free(gpath as *mut libc::c_void);
}
unsafe extern "C" fn P_LoadNightsGhosts() {
    let glen: size_t = (strlen(srb2home.as_mut_ptr()))
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(strlen(b"replay\0" as *const u8 as *const libc::c_char))
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(strlen(timeattackfolder.as_mut_ptr()))
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(strlen(b"MAPXX\0" as *const u8 as *const libc::c_char))
        .wrapping_add(1 as libc::c_int as libc::c_ulong);
    let mut gpath: *mut libc::c_char = malloc(glen) as *mut libc::c_char;
    let mut i: int32_t = 0;
    if gpath.is_null() {
        return;
    }
    sprintf(
        gpath,
        b"%s/replay/%s/%s\0" as *const u8 as *const libc::c_char,
        srb2home.as_mut_ptr(),
        timeattackfolder.as_mut_ptr(),
        G_BuildMapName(gamemap as int32_t),
    );
    if cv_ghost_bestscore.value != 0 {
        i = 0 as libc::c_int;
        while i < numskins {
            if !(cv_ghost_bestscore.value == 1 as libc::c_int
                && players[consoleplayer as usize].skin != i)
            {
                if FIL_FileExists(
                    va(
                        b"%s-%s-score-best.lmp\0" as *const u8 as *const libc::c_char,
                        gpath,
                        (skins[i as usize].name).as_mut_ptr(),
                    ),
                ) != 0
                {
                    G_AddGhost(
                        va(
                            b"%s-%s-score-best.lmp\0" as *const u8
                                as *const libc::c_char,
                            gpath,
                            (skins[i as usize].name).as_mut_ptr(),
                        ),
                    );
                }
            }
            i += 1;
            i;
        }
    }
    if cv_ghost_besttime.value != 0 {
        i = 0 as libc::c_int;
        while i < numskins {
            if !(cv_ghost_besttime.value == 1 as libc::c_int
                && players[consoleplayer as usize].skin != i)
            {
                if FIL_FileExists(
                    va(
                        b"%s-%s-time-best.lmp\0" as *const u8 as *const libc::c_char,
                        gpath,
                        (skins[i as usize].name).as_mut_ptr(),
                    ),
                ) != 0
                {
                    G_AddGhost(
                        va(
                            b"%s-%s-time-best.lmp\0" as *const u8 as *const libc::c_char,
                            gpath,
                            (skins[i as usize].name).as_mut_ptr(),
                        ),
                    );
                }
            }
            i += 1;
            i;
        }
    }
    if cv_ghost_last.value != 0 {
        i = 0 as libc::c_int;
        while i < numskins {
            if !(cv_ghost_last.value == 1 as libc::c_int
                && players[consoleplayer as usize].skin != i)
            {
                if FIL_FileExists(
                    va(
                        b"%s-%s-last.lmp\0" as *const u8 as *const libc::c_char,
                        gpath,
                        (skins[i as usize].name).as_mut_ptr(),
                    ),
                ) != 0
                {
                    G_AddGhost(
                        va(
                            b"%s-%s-last.lmp\0" as *const u8 as *const libc::c_char,
                            gpath,
                            (skins[i as usize].name).as_mut_ptr(),
                        ),
                    );
                }
            }
            i += 1;
            i;
        }
    }
    if cv_ghost_guest.value != 0
        && FIL_FileExists(
            va(b"%s-guest.lmp\0" as *const u8 as *const libc::c_char, gpath),
        ) != 0
    {
        G_AddGhost(va(b"%s-guest.lmp\0" as *const u8 as *const libc::c_char, gpath));
    }
    free(gpath as *mut libc::c_void);
}
unsafe extern "C" fn P_InitTagGametype() {
    let mut i: uint8_t = 0;
    let mut realnumplayers: int32_t = 0 as libc::c_int;
    let mut playersactive: [int32_t; 32] = [0; 32];
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 32 as libc::c_int {
        if playeringame[i as usize] != 0
            && !(players[i as usize].spectator != 0 || players[i as usize].quittime != 0)
        {
            playersactive[realnumplayers as usize] = i as int32_t;
            realnumplayers += 1;
            realnumplayers;
        }
        i = i.wrapping_add(1);
        i;
    }
    if realnumplayers == 0 {
        CONS_Printf(
            b"No player currently available to become IT. Awaiting available players.\n\0"
                as *const u8 as *const libc::c_char,
        );
        return;
    }
    i = P_RandomKey(realnumplayers) as uint8_t;
    players[playersactive[i as usize] as usize]
        .pflags = ::core::mem::transmute::<
        libc::c_uint,
        pflags_t,
    >(
        players[playersactive[i as usize] as usize].pflags as libc::c_uint
            | PF_TAGIT as libc::c_int as libc::c_uint,
    );
    if !(players[playersactive[i as usize] as usize].mo).is_null() {
        P_RemoveMobj(players[playersactive[i as usize] as usize].mo);
    }
    G_SpawnPlayer(playersactive[i as usize]);
}
unsafe extern "C" fn P_SetupCamera() {
    if !(players[displayplayer as usize].mo).is_null()
        && (server != 0 || addedtogame != 0)
    {
        camera.x = (*players[displayplayer as usize].mo).x;
        camera.y = (*players[displayplayer as usize].mo).y;
        camera.z = (*players[displayplayer as usize].mo).z;
        camera.angle = (*players[displayplayer as usize].mo).angle;
        camera.subsector = R_PointInSubsector(camera.x, camera.y);
    } else {
        let mut thing: *mut mapthing_t = 0 as *mut mapthing_t;
        if gametyperules & GTR_DEATHMATCHSTARTS as libc::c_int as uint32_t != 0 {
            thing = deathmatchstarts[0 as libc::c_int as usize];
        } else {
            thing = playerstarts[0 as libc::c_int as usize];
        }
        if !thing.is_null() {
            camera.x = (*thing).x as fixed_t;
            camera.y = (*thing).y as fixed_t;
            camera.z = (*thing).z as fixed_t;
            camera.angle = FixedAngle(((*thing).angle as fixed_t) << 16 as libc::c_int);
            camera.subsector = R_PointInSubsector(camera.x, camera.y);
        }
    };
}
unsafe extern "C" fn P_InitCamera() {
    if dedicated == 0 {
        P_SetupCamera();
        if cv_cam_rotate.changed == 0 {
            CV_Set(&mut cv_cam_rotate, cv_cam_rotate.defaultvalue);
        }
        if cv_cam2_rotate.changed == 0 {
            CV_Set(&mut cv_cam2_rotate, cv_cam2_rotate.defaultvalue);
        }
        if cv_analog[0 as libc::c_int as usize].changed == 0 {
            CV_SetValue(
                &mut *cv_analog.as_mut_ptr().offset(0 as libc::c_int as isize),
                0 as libc::c_int,
            );
        }
        if cv_analog[1 as libc::c_int as usize].changed == 0 {
            CV_SetValue(
                &mut *cv_analog.as_mut_ptr().offset(1 as libc::c_int as isize),
                0 as libc::c_int,
            );
        }
        displayplayer = consoleplayer;
    }
    if maptol & TOL_2D as libc::c_int as uint32_t != 0 {
        CV_SetValue(
            &mut *cv_analog.as_mut_ptr().offset(0 as libc::c_int as isize),
            false_0 as libc::c_int,
        );
        CV_SetValue(
            &mut *cv_analog.as_mut_ptr().offset(1 as libc::c_int as isize),
            false_0 as libc::c_int,
        );
    } else {
        if cv_useranalog[0 as libc::c_int as usize].value != 0 {
            CV_SetValue(
                &mut *cv_analog.as_mut_ptr().offset(0 as libc::c_int as isize),
                true_0 as libc::c_int,
            );
        }
        if splitscreen != 0 && cv_useranalog[1 as libc::c_int as usize].value != 0
            || botingame != 0
        {
            CV_SetValue(
                &mut *cv_analog.as_mut_ptr().offset(1 as libc::c_int as isize),
                true_0 as libc::c_int,
            );
        }
    };
}
unsafe extern "C" fn P_RunSpecialStageWipe() {
    let mut starttime: tic_t = I_GetTime();
    let mut endtime: tic_t = starttime
        .wrapping_add(
            (3 as libc::c_int * 35 as libc::c_int / 2 as libc::c_int) as tic_t,
        );
    let mut nowtime: tic_t = 0;
    S_StartSound(0 as *const libc::c_void, sfx_s3kaf);
    if modeattacking == 0
        && (if cv_resetmusicbyheader.value != 0 {
            (if (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                .musforcereset as libc::c_int != -(1 as libc::c_int)
            {
                (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                    .musforcereset as libc::c_int
            } else {
                cv_resetmusic.value
            })
        } else {
            cv_resetmusic.value
        }) != 0
        || strncasecmp(
            S_MusicName(),
            (if mapmusflags as libc::c_int & 0x8000 as libc::c_int != 0 {
                ((*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                    .musname)
                    .as_mut_ptr()
            } else {
                mapmusname.as_mut_ptr()
            }),
            7 as libc::c_int as libc::c_ulong,
        ) != 0
    {
        S_FadeOutStopMusic((1000 as libc::c_int / 4 as libc::c_int) as uint32_t);
    }
    F_WipeStartScreen();
    wipestyleflags = ::core::mem::transmute::<
        libc::c_uint,
        wipestyleflags_t,
    >(
        wipestyleflags as libc::c_uint
            | (WSF_FADEOUT as libc::c_int | WSF_TOWHITE as libc::c_int) as libc::c_uint,
    );
    F_WipeEndScreen();
    F_RunWipe(
        wipedefs[wipe_speclevel_towhite as libc::c_int as usize],
        false_0 as libc::c_int,
    );
    I_OsPolling();
    I_FinishUpdate();
    if moviemode as u64 != 0 {
        M_SaveFrame();
    }
    nowtime = lastwipetic as tic_t;
    while nowtime < endtime {
        loop {
            nowtime = I_GetTime();
            if !(nowtime.wrapping_sub(lastwipetic as tic_t) == 0) {
                break;
            }
            I_Sleep(cv_sleep.value as uint32_t);
            I_UpdateTime(cv_timescale.value);
        }
        lastwipetic = nowtime as int32_t;
        if moviemode as u64 != 0 {
            M_SaveFrame();
        }
        NetKeepAlive();
    }
}
unsafe extern "C" fn P_RunLevelWipe() {
    F_WipeStartScreen();
    wipestyleflags = ::core::mem::transmute::<
        libc::c_uint,
        wipestyleflags_t,
    >(wipestyleflags as libc::c_uint | WSF_FADEOUT as libc::c_int as libc::c_uint);
    F_WipeEndScreen();
    if wipetypepre as libc::c_int != 32767 as libc::c_int {
        F_RunWipe(
            (if wipetypepre as libc::c_int >= 0 as libc::c_int
                && F_WipeExists(wipetypepre as uint8_t) != 0
            {
                wipetypepre as libc::c_int
            } else {
                wipedefs[wipe_level_toblack as libc::c_int as usize] as libc::c_int
            }) as uint8_t,
            false_0 as libc::c_int,
        );
    }
    wipetypepre = -(1 as libc::c_int) as int16_t;
}
unsafe extern "C" fn P_InitPlayers() {
    let mut i: uint8_t = 0;
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 32 as libc::c_int {
        if !(playeringame[i as usize] == 0) {
            players[i as usize].pity = -(1 as libc::c_int) as int8_t;
            players[i as usize].mo = 0 as *mut mobj_t;
            if G_PlatformGametype() == 0 {
                G_DoReborn(i as int32_t);
            } else {
                G_SpawnPlayer(i as int32_t);
                if players[i as usize].starposttime != 0 {
                    P_ClearStarPost(players[i as usize].starpostnum);
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn P_WriteLetter() {
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut b: *mut libc::c_char = 0 as *mut libc::c_char;
    if (*serverGamedata).unlocked[28 as libc::c_int as usize] == 0 {
        return;
    }
    if modeattacking != 0 {
        return;
    }
    if modifiedgame != 0 {
        return;
    }
    if netgame != 0 || multiplayer != 0 {
        return;
    }
    if gamemap as libc::c_int != 0x1d35 as libc::c_int - 0o16464 as libc::c_int {
        return;
    }
    (*P_SpawnMobj(
        0o640370000 as libc::c_int,
        0x11000000 as libc::c_int,
        0x3180000 as libc::c_int,
        MT_LETTER,
    ))
        .angle = 0x40000000 as libc::c_int as angle_t;
    if (*textprompts[199 as libc::c_int as usize])
        .page[1 as libc::c_int as usize]
        .backcolor == 259 as libc::c_int
    {
        return;
    }
    buf = W_CacheLumpName(
        b"WATERMAP\0" as *const u8 as *const libc::c_char,
        PU_STATIC as libc::c_int,
    ) as *mut libc::c_char;
    b = buf;
    while *b as libc::c_int != 65 as libc::c_int
        && (b.offset_from(buf) as libc::c_long) < 256 as libc::c_int as libc::c_long
    {
        *b = (*b as libc::c_int - 65 as libc::c_int & 255 as libc::c_int)
            as libc::c_char;
        b = b.offset(1);
        b;
    }
    *b = '\0' as i32 as libc::c_char;
    Z_Free(
        (*textprompts[199 as libc::c_int as usize]).page[1 as libc::c_int as usize].text
            as *mut libc::c_void,
    );
    (*textprompts[199 as libc::c_int as usize])
        .page[1 as libc::c_int as usize]
        .text = Z_StrDup(buf);
    (*textprompts[199 as libc::c_int as usize])
        .page[1 as libc::c_int as usize]
        .lines = 4 as libc::c_int as uint8_t;
    (*textprompts[199 as libc::c_int as usize])
        .page[1 as libc::c_int as usize]
        .backcolor = 259 as libc::c_int;
    Z_Free(buf as *mut libc::c_void);
}
unsafe extern "C" fn P_InitGametype() {
    let mut i: uint8_t = 0;
    P_InitPlayers();
    if (netgame != 0 || multiplayer != 0) && G_GametypeUsesCoopStarposts() != 0
        && cv_coopstarposts.value == 2 as libc::c_int
    {
        let mut maxstarposttime: tic_t = 0 as libc::c_int as tic_t;
        i = 0 as libc::c_int as uint8_t;
        while (i as libc::c_int) < 32 as libc::c_int {
            if playeringame[i as usize] != 0
                && players[i as usize].starposttime > maxstarposttime
            {
                maxstarposttime = players[i as usize].starposttime;
            }
            i = i.wrapping_add(1);
            i;
        }
        leveltime = maxstarposttime;
    }
    P_WriteLetter();
    if modeattacking as libc::c_int == 1 as libc::c_int && demoplayback == 0 {
        P_LoadRecordGhosts();
    } else if modeattacking as libc::c_int == 2 as libc::c_int && demoplayback == 0 {
        P_LoadNightsGhosts();
    }
    if G_TagGametype() != 0 {
        P_InitTagGametype();
    } else if gametyperules
        & (GTR_RACE as libc::c_int | GTR_LIVES as libc::c_int) as uint32_t
        == GTR_RACE as libc::c_int as uint32_t && server != 0
    {
        CV_StealthSetValue(
            &mut cv_numlaps,
            if cv_basenumlaps.value != 0 {
                cv_basenumlaps.value
            } else {
                (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                    .numlaps as libc::c_int
            },
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_LoadLevel(
    mut fromnetsave: boolean,
    mut reloadinggamestate: boolean,
) -> boolean {
    let mut i: int32_t = 0;
    let mut ranspecialwipe: int32_t = 0 as libc::c_int;
    let mut ss: *mut sector_t = 0 as *mut sector_t;
    levelloading = true_0 as libc::c_int;
    maptol = (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
        .typeoflevel;
    gametyperules = gametypedefaultrules[gametype as usize];
    CON_Drawer();
    I_FinishUpdate();
    if rendermode as libc::c_uint != render_none as libc::c_int as libc::c_uint {
        V_SetPaletteLump(b"PLAYPAL\0" as *const u8 as *const libc::c_char);
    }
    P_Initsecnode();
    if netgame != 0 || multiplayer != 0 {
        botskin = 0 as libc::c_int as uint8_t;
        cv_debug = botskin as int32_t;
    }
    if !metalplayback.is_null() {
        G_StopMetalDemo();
    }
    HU_ClearCEcho();
    if (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
        .runsoc[0 as libc::c_int as usize] as libc::c_int != '#' as i32
    {
        P_RunSOC(
            ((*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                .runsoc)
                .as_mut_ptr(),
        );
    }
    if cv_runscripts.value != 0
        && (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
            .scriptname[0 as libc::c_int as usize] as libc::c_int != '#' as i32
    {
        P_RunLevelScript(
            ((*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                .scriptname)
                .as_mut_ptr(),
        );
    }
    P_InitLevelSettings();
    postimgtype2 = postimg_none;
    postimgtype = postimgtype2;
    if (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
        .forcecharacter[0 as libc::c_int as usize] as libc::c_int != '\0' as i32
    {
        P_ForceCharacter(
            ((*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                .forcecharacter)
                .as_mut_ptr(),
        );
    }
    if dedicated == 0 {
        let mut chase: boolean = (gametyperules
            & GTR_FIRSTPERSON as libc::c_int as uint32_t == 0
            || maptol & TOL_2D as libc::c_int as uint32_t != 0) as libc::c_int;
        CV_UpdateCamDist();
        CV_UpdateCam2Dist();
        if cv_chasecam.changed == 0 {
            CV_SetValue(&mut cv_chasecam, chase);
        }
        if cv_chasecam2.changed == 0 {
            CV_SetValue(&mut cv_chasecam2, chase);
        }
    }
    players[consoleplayer as usize].viewz = 1 as libc::c_int;
    if reloadinggamestate != 0 {
        wipegamestate = gamestate;
    } else {
        wipegamestate = 4294967294 as gamestate_t;
    }
    wipestyleflags = 0 as wipestyleflags_t;
    if G_GetModeAttackRetryFlag() != 0 {
        if modeattacking as libc::c_int != 0 && demoplayback == 0 {
            ranspecialwipe = 2 as libc::c_int;
            wipestyleflags = ::core::mem::transmute::<
                libc::c_uint,
                wipestyleflags_t,
            >(
                wipestyleflags as libc::c_uint
                    | (WSF_FADEOUT as libc::c_int | WSF_TOWHITE as libc::c_int)
                        as libc::c_uint,
            );
        }
        G_ClearModeAttackRetryFlag();
    } else if rendermode as libc::c_uint != render_none as libc::c_int as libc::c_uint
        && G_IsSpecialStage(gamemap as int32_t) != 0
    {
        P_RunSpecialStageWipe();
        ranspecialwipe = 1 as libc::c_int;
    }
    S_StopSounds();
    S_ClearSfx();
    if !(reloadinggamestate != 0 || titlemapinaction as libc::c_int != 0)
        && (modeattacking == 0
            && (if cv_resetmusicbyheader.value != 0 {
                (if (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int)
                    as usize])
                    .musforcereset as libc::c_int != -(1 as libc::c_int)
                {
                    (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int)
                        as usize])
                        .musforcereset as libc::c_int
                } else {
                    cv_resetmusic.value
                })
            } else {
                cv_resetmusic.value
            }) != 0
            || strncasecmp(
                S_MusicName(),
                (if mapmusflags as libc::c_int & 0x8000 as libc::c_int != 0 {
                    ((*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int)
                        as usize])
                        .musname)
                        .as_mut_ptr()
                } else {
                    mapmusname.as_mut_ptr()
                }),
                7 as libc::c_int as libc::c_ulong,
            ) != 0)
    {
        S_FadeMusicFromVolume(
            0 as libc::c_int as uint8_t,
            -(1 as libc::c_int) as int16_t,
            FixedMul(
                FixedDiv(
                    ((F_GetWipeLength(
                        wipedefs[wipe_level_toblack as libc::c_int as usize],
                    ))
                        .wrapping_sub(2 as libc::c_int as tic_t)
                        * 1 as libc::c_int as tic_t) as fixed_t,
                    35 as libc::c_int * 1 as libc::c_int,
                ),
                1000 as libc::c_int,
            ) as uint32_t,
        );
    }
    if rendermode as libc::c_uint != render_none as libc::c_int as libc::c_uint
        && !(ranspecialwipe != 0 || reloadinggamestate != 0)
    {
        P_RunLevelWipe();
    }
    if !(reloadinggamestate != 0 || titlemapinaction as libc::c_int != 0) {
        if ranspecialwipe == 2 as libc::c_int {
            pausedelay = -(3 as libc::c_int);
            S_StartSound(0 as *const libc::c_void, sfx_s3k73);
        }
        if rendermode as libc::c_uint != render_none as libc::c_int as libc::c_uint {
            let mut tx: [libc::c_char; 64] = [0; 64];
            V_DrawSmallString(
                1 as libc::c_int,
                191 as libc::c_int,
                0x800000 as libc::c_int | 0x50000 as libc::c_int
                    | 0x4000000 as libc::c_int | 0x2000000 as libc::c_int,
                b"Speeding off to...\0" as *const u8 as *const libc::c_char,
            );
            snprintf(
                tx.as_mut_ptr(),
                63 as libc::c_int as libc::c_ulong,
                b"%s%s%s\0" as *const u8 as *const libc::c_char,
                ((*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                    .lvlttl)
                    .as_mut_ptr(),
                if (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                    .levelflags as libc::c_int & (1 as libc::c_int) << 4 as libc::c_int
                    != 0
                {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    b" Zone\0" as *const u8 as *const libc::c_char
                },
                if (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                    .actnum as libc::c_int > 0 as libc::c_int
                {
                    va(
                        b" %d\0" as *const u8 as *const libc::c_char,
                        (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int)
                            as usize])
                            .actnum as libc::c_int,
                    ) as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
            V_DrawSmallString(
                1 as libc::c_int,
                195 as libc::c_int,
                0x800000 as libc::c_int | 0x50000 as libc::c_int
                    | 0x4000000 as libc::c_int | 0x2000000 as libc::c_int,
                tx.as_mut_ptr(),
            );
            I_UpdateNoVsync();
        }
        S_StartEx(false_0 as libc::c_int);
    }
    levelfadecol = (if ranspecialwipe != 0 {
        0 as libc::c_int
    } else {
        31 as libc::c_int
    }) as uint8_t;
    F_EndTextPrompt(false_0 as libc::c_int, true_0 as libc::c_int);
    LUA_InvalidateLevel();
    ss = sectors;
    while sectors.offset(numsectors as isize) != ss {
        Z_Free((*ss).attached as *mut libc::c_void);
        Z_Free((*ss).attachedsolid as *mut libc::c_void);
        ss = ss.offset(1);
        ss;
    }
    R_FlushTranslationColormapCache();
    Patch_FreeTags(
        PU_PATCH_LOWPRIORITY as libc::c_int,
        PU_PATCH_LOWPRIORITY as libc::c_int,
    );
    Patch_FreeTags(PU_PATCH_ROTATED as libc::c_int, PU_PATCH_ROTATED as libc::c_int);
    Z_FreeTags(PU_LEVEL as libc::c_int, PU_PURGELEVEL as libc::c_int - 1 as libc::c_int);
    R_InitializeLevelInterpolators();
    P_InitThinkers();
    R_InitMobjInterpolators();
    P_InitCachedActions();
    maplumpname = G_BuildMapName(gamemap as int32_t);
    lastloadedmaplumpnum = W_CheckNumForMap(maplumpname);
    if lastloadedmaplumpnum == 4294967295 as libc::c_uint {
        I_Error(
            b"Map %s not found.\n\0" as *const u8 as *const libc::c_char,
            maplumpname,
        );
    }
    R_ReInitColormaps(
        (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize]).palette,
    );
    CON_SetupBackColormap();
    P_SetupLevelSky(
        (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize]).skynum
            as int32_t,
        true_0 as libc::c_int,
    );
    P_ResetSpawnpoints();
    P_ResetWaypoints();
    P_MapStart();
    P_InitSlopes();
    if P_LoadMapFromFile() == 0 {
        return false_0 as libc::c_int;
    }
    P_InitSpecials();
    P_SpawnSlopes(fromnetsave);
    P_SpawnMapThings((fromnetsave == 0) as libc::c_int);
    skyboxmo[0 as libc::c_int as usize] = skyboxviewpnts[0 as libc::c_int as usize];
    skyboxmo[1 as libc::c_int as usize] = skyboxcenterpnts[0 as libc::c_int as usize];
    numcoopstarts = 0 as libc::c_int;
    while numcoopstarts < 32 as libc::c_int {
        if (playerstarts[numcoopstarts as usize]).is_null() {
            break;
        }
        numcoopstarts += 1;
        numcoopstarts;
    }
    P_SpawnSpecials(fromnetsave);
    if fromnetsave == 0 {
        P_SpawnPrecipitation();
    }
    if fromnetsave == 0 {
        P_InitGametype();
    }
    if reloadinggamestate == 0 {
        P_InitCamera();
        localaiming = 0 as libc::c_int;
        localaiming2 = 0 as libc::c_int;
    }
    iquetail = 0 as libc::c_int as size_t;
    iquehead = iquetail;
    if rendermode as libc::c_uint != render_none as libc::c_int as libc::c_uint
        && !(titlemapinaction as libc::c_int != 0 || reloadinggamestate != 0)
    {
        V_DrawFill(
            0 as libc::c_int,
            0 as libc::c_int,
            320 as libc::c_int,
            200 as libc::c_int,
            levelfadecol as int32_t,
        );
    }
    if precache != 0 || dedicated != 0 {
        R_PrecacheLevel();
    }
    nextmapoverride = 0 as libc::c_int as int16_t;
    skipstats = 0 as libc::c_int as uint8_t;
    if demoplayback == 0 {
        (*clientGamedata)
            .mapvisited[(gamemap as libc::c_int - 1 as libc::c_int)
            as usize] = ((*clientGamedata)
            .mapvisited[(gamemap as libc::c_int - 1 as libc::c_int) as usize]
            as libc::c_int | 1 as libc::c_int) as uint8_t;
        (*serverGamedata)
            .mapvisited[(gamemap as libc::c_int - 1 as libc::c_int)
            as usize] = ((*serverGamedata)
            .mapvisited[(gamemap as libc::c_int - 1 as libc::c_int) as usize]
            as libc::c_int | 1 as libc::c_int) as uint8_t;
    }
    levelloading = false_0 as libc::c_int;
    P_RunCachedActions();
    P_MapEnd();
    if titlemapinaction == 0 {
        if lastmaploaded == 0 {
            if !(ultimatemode as libc::c_int != 0 || netgame != 0 || multiplayer != 0
                || demoplayback != 0 || demorecording != 0 || metalrecording != 0
                || modeattacking as libc::c_int != 0
                || marathonmode as libc::c_uint != 0) && usedCheats == 0
                && cursaveslot > 0 as libc::c_int
            {
                G_SaveGame(cursaveslot as uint32_t, gamemap);
            }
        }
        lastmaploaded = gamemap;
    }
    if fromnetsave == 0 {
        let mut buf: int32_t = (gametic % 1024 as libc::c_int as tic_t) as int32_t;
        i = 0 as libc::c_int;
        while i < 32 as libc::c_int {
            if playeringame[i as usize] != 0 {
                G_CopyTiccmd(
                    &mut (*players.as_mut_ptr().offset(i as isize)).cmd,
                    &mut *(*netcmds.as_mut_ptr().offset(buf as isize))
                        .as_mut_ptr()
                        .offset(i as isize),
                    1 as libc::c_int as size_t,
                );
            }
            i += 1;
            i;
        }
        P_PreTicker(2 as libc::c_int);
        P_MapStart();
        LUA_HookInt(gamemap as int32_t, hook_MapLoad as libc::c_int);
        P_MapEnd();
    }
    if rendermode as libc::c_uint == render_none as libc::c_int as libc::c_uint
        || reloadinggamestate != 0
    {
        return true_0 as libc::c_int;
    }
    R_ResetViewInterpolation(0 as libc::c_int as uint8_t);
    R_ResetViewInterpolation(0 as libc::c_int as uint8_t);
    R_UpdateMobjInterpolators();
    G_StartTitleCard();
    if WipeStageTitle == 0 {
        return true_0 as libc::c_int;
    }
    if ranspecialwipe == 2 as libc::c_int {
        return true_0 as libc::c_int;
    }
    G_PreLevelTitleCard();
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_RunSOC(mut socfilename: *const libc::c_char) -> boolean {
    let mut lump: lumpnum_t = 0;
    if !(strstr(socfilename, b".soc\0" as *const u8 as *const libc::c_char)).is_null() {
        return P_AddWadFile(socfilename);
    }
    lump = W_CheckNumForName(socfilename);
    if lump == 4294967295 as libc::c_uint {
        return false_0 as libc::c_int;
    }
    CONS_Printf(
        b"Loading SOC lump: %s\n\0" as *const u8 as *const libc::c_char,
        socfilename,
    );
    DEH_LoadDehackedLump(lump);
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_LoadSoundsRange(
    mut wadnum: uint16_t,
    mut first: uint16_t,
    mut num: uint16_t,
) {
    let mut j: size_t = 0;
    let mut lumpinfo: *mut lumpinfo_t = ((**wadfiles.offset(wadnum as isize)).lumpinfo)
        .offset(first as libc::c_int as isize);
    while num as libc::c_int > 0 as libc::c_int {
        j = 1 as libc::c_int as size_t;
        while j < NUMSFX as libc::c_int as size_t {
            if !((*S_sfx.as_mut_ptr().offset(j as isize)).name).is_null()
                && strncasecmp(
                    (*S_sfx.as_mut_ptr().offset(j as isize)).name,
                    ((*lumpinfo).name).as_mut_ptr().offset(2 as libc::c_int as isize),
                    6 as libc::c_int as libc::c_ulong,
                ) == 0
            {
                CONS_Debug(
                    0x400 as libc::c_int,
                    b"Sound %.8s replaced\n\0" as *const u8 as *const libc::c_char,
                    ((*lumpinfo).name).as_mut_ptr(),
                );
                I_FreeSfx(&mut *S_sfx.as_mut_ptr().offset(j as isize));
                break;
            } else {
                j = j.wrapping_add(1);
                j;
            }
        }
        num = num.wrapping_sub(1);
        num;
        lumpinfo = lumpinfo.offset(1);
        lumpinfo;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_LoadMusicsRange(
    mut wadnum: uint16_t,
    mut first: uint16_t,
    mut num: uint16_t,
) {
    let mut lumpinfo: *mut lumpinfo_t = ((**wadfiles.offset(wadnum as isize)).lumpinfo)
        .offset(first as libc::c_int as isize);
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    while num as libc::c_int > 0 as libc::c_int {
        name = ((*lumpinfo).name).as_mut_ptr();
        if *name.offset(0 as libc::c_int as isize) as libc::c_int == 'O' as i32
            && *name.offset(1 as libc::c_int as isize) as libc::c_int == '_' as i32
        {
            CONS_Debug(
                0x400 as libc::c_int,
                b"Music %.8s replaced\n\0" as *const u8 as *const libc::c_char,
                name,
            );
        } else if *name.offset(0 as libc::c_int as isize) as libc::c_int == 'D' as i32
            && *name.offset(1 as libc::c_int as isize) as libc::c_int == '_' as i32
        {
            CONS_Debug(
                0x400 as libc::c_int,
                b"Music %.8s replaced\n\0" as *const u8 as *const libc::c_char,
                name,
            );
        }
        num = num.wrapping_sub(1);
        num;
        lumpinfo = lumpinfo.offset(1);
        lumpinfo;
    }
}
unsafe extern "C" fn FindFolder(
    mut folName: *const libc::c_char,
    mut start: *mut uint16_t,
    mut end: *mut uint16_t,
    mut lumpinfo: *mut lumpinfo_t,
    mut pnumlumps: *mut uint16_t,
    mut pi: *mut size_t,
) -> *mut lumpinfo_t {
    let mut numlumps: uint16_t = *pnumlumps;
    let mut i: size_t = *pi;
    if strcasecmp((*lumpinfo).fullname, folName) == 0 {
        lumpinfo = lumpinfo.offset(1);
        lumpinfo;
        i = i.wrapping_add(1);
        *start = i as uint16_t;
        while i < numlumps as size_t {
            if strncasecmp((*lumpinfo).fullname, folName, strlen(folName)) != 0 {
                break;
            }
            i = i.wrapping_add(1);
            i;
            lumpinfo = lumpinfo.offset(1);
            lumpinfo;
        }
        lumpinfo = lumpinfo.offset(-1);
        lumpinfo;
        let fresh327 = i;
        i = i.wrapping_sub(1);
        *end = fresh327.wrapping_sub(*start as size_t) as uint16_t;
        *pi = i;
        *pnumlumps = numlumps;
        return lumpinfo;
    }
    return lumpinfo;
}
unsafe extern "C" fn P_LoadAddon(mut numlumps: uint16_t) -> boolean {
    let wadnum: uint16_t = (numwadfiles as libc::c_int - 1 as libc::c_int) as uint16_t;
    let mut i: size_t = 0;
    let mut j: size_t = 0;
    let mut sreplaces: size_t = 0 as libc::c_int as size_t;
    let mut mreplaces: size_t = 0 as libc::c_int as size_t;
    let mut digmreplaces: size_t = 0 as libc::c_int as size_t;
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut lumpinfo: *mut lumpinfo_t = 0 as *mut lumpinfo_t;
    let mut mapsadded: boolean = false_0 as libc::c_int;
    let mut replacedcurrentmap: boolean = false_0 as libc::c_int;
    let mut sfxPos: uint16_t = 0 as libc::c_int as uint16_t;
    let mut sfxNum: uint16_t = 0 as libc::c_int as uint16_t;
    let mut musPos: uint16_t = 0 as libc::c_int as uint16_t;
    let mut musNum: uint16_t = 0 as libc::c_int as uint16_t;
    let mut texPos: uint16_t = 0 as libc::c_int as uint16_t;
    let mut texNum: uint16_t = 0 as libc::c_int as uint16_t;
    if numlumps as libc::c_int == 32767 as libc::c_int {
        refreshdirmenu = (refreshdirmenu as libc::c_int
            | REFRESHDIR_NOTLOADED as libc::c_int) as uint8_t;
        return false_0 as libc::c_int;
    }
    match (**wadfiles.offset(wadnum as isize)).type_0 as libc::c_uint {
        3 | 4 => {
            lumpinfo = (**wadfiles.offset(wadnum as isize)).lumpinfo;
            i = 0 as libc::c_int as size_t;
            while i < numlumps as size_t {
                lumpinfo = FindFolder(
                    b"Sounds/\0" as *const u8 as *const libc::c_char,
                    &mut sfxPos,
                    &mut sfxNum,
                    lumpinfo,
                    &mut numlumps,
                    &mut i,
                );
                lumpinfo = FindFolder(
                    b"Music/\0" as *const u8 as *const libc::c_char,
                    &mut musPos,
                    &mut musNum,
                    lumpinfo,
                    &mut numlumps,
                    &mut i,
                );
                lumpinfo = FindFolder(
                    b"Textures/\0" as *const u8 as *const libc::c_char,
                    &mut texPos,
                    &mut texNum,
                    lumpinfo,
                    &mut numlumps,
                    &mut i,
                );
                i = i.wrapping_add(1);
                i;
                lumpinfo = lumpinfo.offset(1);
                lumpinfo;
            }
            if sfxNum != 0 {
                P_LoadSoundsRange(wadnum, sfxPos, sfxNum);
            }
            if musNum != 0 {
                P_LoadMusicsRange(wadnum, musPos, musNum);
            }
        }
        _ => {
            lumpinfo = (**wadfiles.offset(wadnum as isize)).lumpinfo;
            i = 0 as libc::c_int as size_t;
            while i < numlumps as size_t {
                name = ((*lumpinfo).name).as_mut_ptr();
                if *name.offset(0 as libc::c_int as isize) as libc::c_int == 'D' as i32 {
                    if *name.offset(1 as libc::c_int as isize) as libc::c_int
                        == 'S' as i32
                    {
                        j = 1 as libc::c_int as size_t;
                        while j < NUMSFX as libc::c_int as size_t {
                            if !((*S_sfx.as_mut_ptr().offset(j as isize)).name).is_null()
                                && strncasecmp(
                                    (*S_sfx.as_mut_ptr().offset(j as isize)).name,
                                    name.offset(2 as libc::c_int as isize),
                                    6 as libc::c_int as libc::c_ulong,
                                ) == 0
                            {
                                CONS_Debug(
                                    0x400 as libc::c_int,
                                    b"Sound %.8s replaced\n\0" as *const u8
                                        as *const libc::c_char,
                                    name,
                                );
                                I_FreeSfx(&mut *S_sfx.as_mut_ptr().offset(j as isize));
                                sreplaces = sreplaces.wrapping_add(1);
                                sreplaces;
                                break;
                            } else {
                                j = j.wrapping_add(1);
                                j;
                            }
                        }
                    } else if *name.offset(1 as libc::c_int as isize) as libc::c_int
                        == '_' as i32
                    {
                        CONS_Debug(
                            0x400 as libc::c_int,
                            b"Music %.8s replaced\n\0" as *const u8
                                as *const libc::c_char,
                            name,
                        );
                        mreplaces = mreplaces.wrapping_add(1);
                        mreplaces;
                    }
                } else if *name.offset(0 as libc::c_int as isize) as libc::c_int
                    == 'O' as i32
                    && *name.offset(1 as libc::c_int as isize) as libc::c_int
                        == '_' as i32
                {
                    CONS_Debug(
                        0x400 as libc::c_int,
                        b"Music %.8s replaced\n\0" as *const u8 as *const libc::c_char,
                        name,
                    );
                    digmreplaces = digmreplaces.wrapping_add(1);
                    digmreplaces;
                }
                i = i.wrapping_add(1);
                i;
                lumpinfo = lumpinfo.offset(1);
                lumpinfo;
            }
        }
    }
    if devparm == 0 && sreplaces != 0 {
        CONS_Printf(
            b"%s sounds replaced\n\0" as *const u8 as *const libc::c_char,
            sizeu1(sreplaces),
        );
    }
    if devparm == 0 && mreplaces != 0 {
        CONS_Printf(
            b"%s midi musics replaced\n\0" as *const u8 as *const libc::c_char,
            sizeu1(mreplaces),
        );
    }
    if devparm == 0 && digmreplaces != 0 {
        CONS_Printf(
            b"%s digital musics replaced\n\0" as *const u8 as *const libc::c_char,
            sizeu1(digmreplaces),
        );
    }
    Patch_FreeTags(PU_SPRITE as libc::c_int, PU_SPRITE as libc::c_int);
    Patch_FreeTags(PU_PATCH_ROTATED as libc::c_int, PU_PATCH_ROTATED as libc::c_int);
    R_AddSpriteDefs(wadnum);
    R_LoadTexturesPwad(wadnum);
    P_InitPicAnims();
    ST_UnloadGraphics();
    HU_LoadGraphics();
    ST_LoadGraphics();
    R_AddSkins(wadnum, false_0 as libc::c_int);
    R_PatchSkins(wadnum, false_0 as libc::c_int);
    ST_ReloadSkinFaceGraphics();
    S_LoadMusicDefs(wadnum);
    lumpinfo = (**wadfiles.offset(wadnum as isize)).lumpinfo;
    i = 0 as libc::c_int as size_t;
    while i < numlumps as size_t {
        name = ((*lumpinfo).name).as_mut_ptr();
        if *name.offset(0 as libc::c_int as isize) as libc::c_int == 'M' as i32
            && *name.offset(1 as libc::c_int as isize) as libc::c_int == 'A' as i32
            && *name.offset(2 as libc::c_int as isize) as libc::c_int == 'P' as i32
        {
            let mut num: int16_t = 0;
            if !(*name.offset(5 as libc::c_int as isize) as libc::c_int != '\0' as i32) {
                num = M_MapNumber(
                    *name.offset(3 as libc::c_int as isize),
                    *name.offset(4 as libc::c_int as isize),
                ) as int16_t;
                if num as libc::c_int == gamemap as libc::c_int {
                    replacedcurrentmap = true_0 as libc::c_int;
                }
                CONS_Printf(b"%s\n\0" as *const u8 as *const libc::c_char, name);
                mapsadded = true_0 as libc::c_int;
            }
        }
        i = i.wrapping_add(1);
        i;
        lumpinfo = lumpinfo.offset(1);
        lumpinfo;
    }
    if mapsadded == 0 {
        CONS_Printf(b"No maps added\n\0" as *const u8 as *const libc::c_char);
    }
    R_LoadSpriteInfoLumps(wadnum, numlumps);
    if gamestate as libc::c_uint == GS_LEVEL as libc::c_int as libc::c_uint {
        ST_Start();
    }
    if modifiedgame != 0 && cursaveslot > 0 as libc::c_int {
        cursaveslot = 0 as libc::c_int;
    }
    if replacedcurrentmap != 0
        && gamestate as libc::c_uint == GS_LEVEL as libc::c_int as libc::c_uint
        && (netgame != 0 || multiplayer != 0)
    {
        CONS_Printf(
            b"Current map %d replaced by added file, ending the level to ensure consistency.\n\0"
                as *const u8 as *const libc::c_char,
            gamemap as libc::c_int,
        );
        if server != 0 {
            D_SendExitLevel(false_0 as libc::c_int);
        }
    }
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_AddWadFile(mut wadfilename: *const libc::c_char) -> boolean {
    return (D_CheckPathAllowed(
        wadfilename,
        b"tried to add file\0" as *const u8 as *const libc::c_char,
    ) != 0
        && P_LoadAddon(
            W_InitFile(wadfilename, false_0 as libc::c_int, false_0 as libc::c_int),
        ) != 0) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_AddFolder(mut folderpath: *const libc::c_char) -> boolean {
    return (D_CheckPathAllowed(
        folderpath,
        b"tried to add folder\0" as *const u8 as *const libc::c_char,
    ) != 0
        && P_LoadAddon(
            W_InitFolder(folderpath, false_0 as libc::c_int, false_0 as libc::c_int),
        ) != 0) as libc::c_int;
}
