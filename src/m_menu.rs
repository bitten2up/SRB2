use ::libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    static mut camera: camera_t;
    static mut camera2: camera_t;
    static mut cv_cam_speed: consvar_t;
    static mut cv_cam_turnmultiplier: consvar_t;
    static mut cv_cam_orbit: consvar_t;
    static mut cv_cam_adjust: consvar_t;
    static mut cv_cam2_speed: consvar_t;
    static mut cv_cam2_turnmultiplier: consvar_t;
    static mut cv_cam2_orbit: consvar_t;
    static mut cv_cam2_adjust: consvar_t;
    static mut cv_cam_savedist: [[consvar_t; 2]; 2];
    static mut cv_cam_saveheight: [[consvar_t; 2]; 2];
    fn CV_UpdateCamDist();
    fn CV_UpdateCam2Dist();
    fn remove(__filename: *const libc::c_char) -> libc::c_int;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
    fn abs(_: libc::c_int) -> libc::c_int;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strncat(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strcasecmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strlcpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_ulong;
    static mut menucolorhead: *mut menucolor_t;
    static mut menucolortail: *mut menucolor_t;
    fn P_GetSkinSprite2(
        skin: *mut skin_t,
        spr2: uint8_t,
        player: *mut player_t,
    ) -> uint8_t;
    fn R_SkinAvailable(name: *const libc::c_char) -> int32_t;
    fn R_SkinUsable(playernum: int32_t, skinnum: int32_t) -> boolean;
    static mut skins: [skin_t; 32];
    static mut numskins: int32_t;
    static mut numskincolors: uint16_t;
    static mut skincolors: [skincolor_t; 1182];
    static mut gamestate: gamestate_t;
    static mut titlemapinaction: uint8_t;
    static mut ultimatemode: uint8_t;
    static mut botingame: boolean;
    static mut botskin: uint8_t;
    static mut botcolor: uint16_t;
    fn I_Error(error: *const libc::c_char, _: ...) -> !;
    fn CONS_Printf(fmt: *const libc::c_char, _: ...);
    fn CONS_Alert(level: alerttype_t, fmt: *const libc::c_char, _: ...);
    static mut savegamename: [libc::c_char; 256];
    static mut liveeventbackup: [libc::c_char; 256];
    static mut M_Memcpy: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_void,
            size_t,
        ) -> *mut libc::c_void,
    >;
    fn va(format: *const libc::c_char, _: ...) -> *mut libc::c_char;
    static mut VERSION: libc::c_int;
    static mut cv_debug: int32_t;
    static mut shiftdown: uint8_t;
    static mut ctrldown: uint8_t;
    static mut finesine: [fixed_t; 10240];
    static mut finecosine: *mut fixed_t;
    fn FixedAngle(fa: fixed_t) -> angle_t;
    static mut S_sfx: [sfxinfo_t; 0];
    fn P_DestroyRobots();
    static mut gamemap: int16_t;
    static mut maptol: uint32_t;
    static mut cursaveslot: int32_t;
    static mut gamecomplete: uint8_t;
    static mut marathonmode: marathonmode_t;
    static mut marathontime: tic_t;
    static mut modifiedgame: boolean;
    static mut savemoddata: boolean;
    static mut usedCheats: boolean;
    static mut metalrecording: boolean;
    static mut modeattacking: uint8_t;
    static mut netgame: boolean;
    static mut multiplayer: boolean;
    static mut gametypecount: int16_t;
    static mut splitscreen: boolean;
    static mut paused: uint8_t;
    static mut window_notinfocus: uint8_t;
    static mut consoleplayer: int32_t;
    static mut displayplayer: int32_t;
    static mut secondarydisplayplayer: int32_t;
    static mut spstage_start: int16_t;
    static mut spmarathon_start: int16_t;
    static mut hidetitlepics: boolean;
    static mut tutorialmap: int16_t;
    static mut tutorialmode: boolean;
    static mut tutorialgcs: int32_t;
    static mut tutorialusemouse: int32_t;
    static mut tutorialfreelook: int32_t;
    static mut tutorialmousemove: int32_t;
    static mut tutorialanalog: int32_t;
    static mut mapheaderinfo: [*mut mapheader_t; 1035];
    static mut emeralds: uint16_t;
    static mut luabanks: [int32_t; 16];
    static mut useBlackRock: uint8_t;
    static mut useContinues: uint8_t;
    static mut gametic: tic_t;
    static mut debugfile: *mut FILE;
    static mut wipegamestate: gamestate_t;
    static mut wipetypepre: int16_t;
    static mut wipetypepost: int16_t;
    fn D_CloseConnection();
    fn COM_AddCommand(name: *const libc::c_char, func: com_func_t, flags: com_flags_t);
    fn COM_BufAddTextEx(btext: *const libc::c_char, flags: com_flags_t);
    fn COM_ImmedExecute(ptext: *const libc::c_char);
    static mut CV_OnOff: [CV_PossibleValue_t; 0];
    static mut CV_YesNo: [CV_PossibleValue_t; 0];
    fn CV_RegisterVar(variable: *mut consvar_t);
    fn CV_Set(var: *mut consvar_t, value: *const libc::c_char);
    fn CV_SetValue(var: *mut consvar_t, value: int32_t);
    fn CV_StealthSetValue(var: *mut consvar_t, value: int32_t);
    fn CV_StealthSet(var: *mut consvar_t, value: *const libc::c_char);
    fn CV_AddValue(var: *mut consvar_t, increment: int32_t);
    fn CV_IsSetToDefault(v: *mut consvar_t) -> boolean;
    static mut cv_playername: consvar_t;
    static mut cv_playercolor: consvar_t;
    static mut cv_skin: consvar_t;
    static mut cv_playername2: consvar_t;
    static mut cv_playercolor2: consvar_t;
    static mut cv_skin2: consvar_t;
    static mut cv_defaultplayercolor: consvar_t;
    static mut cv_defaultskin: consvar_t;
    static mut cv_defaultplayercolor2: consvar_t;
    static mut cv_defaultskin2: consvar_t;
    static mut cv_seenames: consvar_t;
    static mut cv_usemouse: consvar_t;
    static mut cv_usejoystick: consvar_t;
    static mut cv_usejoystick2: consvar_t;
    static mut cv_mouse2port: consvar_t;
    static mut cv_usemouse2: consvar_t;
    static mut cv_itemrespawntime: consvar_t;
    static mut cv_flagtime: consvar_t;
    static mut cv_hidetime: consvar_t;
    static mut cv_pointlimit: consvar_t;
    static mut cv_timelimit: consvar_t;
    static mut cv_autobalance: consvar_t;
    static mut cv_scrambleonchange: consvar_t;
    static mut cv_countdowntime: consvar_t;
    static mut cv_restrictskinchange: consvar_t;
    static mut cv_allowteamchange: consvar_t;
    static mut cv_respawntime: consvar_t;
    static mut cv_teleporters: consvar_t;
    static mut cv_superring: consvar_t;
    static mut cv_supersneakers: consvar_t;
    static mut cv_invincibility: consvar_t;
    static mut cv_jumpshield: consvar_t;
    static mut cv_watershield: consvar_t;
    static mut cv_ringshield: consvar_t;
    static mut cv_forceshield: consvar_t;
    static mut cv_bombshield: consvar_t;
    static mut cv_1up: consvar_t;
    static mut cv_eggmanbox: consvar_t;
    static mut cv_recycler: consvar_t;
    static mut cv_itemfinder: consvar_t;
    static mut cv_inttime: consvar_t;
    static mut cv_coopstarposts: consvar_t;
    static mut cv_cooplives: consvar_t;
    static mut cv_advancemap: consvar_t;
    static mut cv_playersforexit: consvar_t;
    static mut cv_exitmove: consvar_t;
    static mut cv_overtime: consvar_t;
    static mut cv_ringslinger: consvar_t;
    static mut cv_soundtest: consvar_t;
    static mut cv_specialrings: consvar_t;
    static mut cv_powerstones: consvar_t;
    static mut cv_matchboxes: consvar_t;
    static mut cv_competitionboxes: consvar_t;
    static mut cv_showping: consvar_t;
    static mut cv_sleep: consvar_t;
    fn Command_ExitGame_f();
    fn D_MapChange(
        pmapnum: int32_t,
        pgametype: int32_t,
        pultmode: boolean,
        presetplayers: boolean,
        pdelay: int32_t,
        pskipprecutscene: boolean,
        pfromlevelselect: boolean,
    );
    fn IsPlayerAdmin(playernum: int32_t) -> boolean;
    fn CanChangeSkin(playernum: int32_t) -> uint8_t;
    static mut cv_masterserver: consvar_t;
    static mut cv_servername: consvar_t;
    static mut ms_RoomId: int16_t;
    fn GetRoomsList(hosting: boolean, id: libc::c_int) -> int32_t;
    fn GetMODVersion(id: libc::c_int) -> *mut libc::c_char;
    static mut room_list: [msg_rooms_t; 17];
    static mut serverlist: [serverelem_t; 126];
    static mut serverlistcount: uint32_t;
    static mut cv_showjoinaddress: consvar_t;
    static mut server: boolean;
    static mut dedicated: boolean;
    static mut cv_allownewplayer: consvar_t;
    static mut cv_maxplayers: consvar_t;
    static mut cv_joindelay: consvar_t;
    static mut cv_rejointimeout: consvar_t;
    static mut cv_resynchattempts: consvar_t;
    fn SV_StartSinglePlayerServer();
    fn CL_UpdateServerList(internetsearch: boolean, room: int32_t);
    fn Playing() -> boolean;
    static mut cv_timetic: consvar_t;
    static mut cv_powerupdisplay: consvar_t;
    static mut cv_forceskin: consvar_t;
    static mut cv_downloading: consvar_t;
    fn F_SkyScroll(patchname: *const libc::c_char);
    fn F_StartIntro();
    fn F_StartCredits();
    static mut finalecount: int32_t;
    static mut titlescrollxspeed: int32_t;
    static mut titlescrollyspeed: int32_t;
    static mut ttmode: ttmode_enum;
    static mut ttscale: uint8_t;
    static mut ttname: [libc::c_char; 9];
    static mut ttx: int16_t;
    static mut tty: int16_t;
    static mut ttloop: int16_t;
    static mut tttics: uint16_t;
    static mut curbgname: [libc::c_char; 9];
    static mut curfadevalue: int8_t;
    static mut curbgcolor: int32_t;
    static mut curbgxspeed: int32_t;
    static mut curbgyspeed: int32_t;
    static mut curbghide: boolean;
    static mut hidetitlemap: boolean;
    static mut curhidepics: boolean;
    static mut curttmode: ttmode_enum;
    static mut curttscale: uint8_t;
    static mut curttname: [libc::c_char; 9];
    static mut curttx: int16_t;
    static mut curtty: int16_t;
    static mut curttloop: int16_t;
    static mut curtttics: uint16_t;
    static mut WipeInAction: boolean;
    static mut vid: viddef_t;
    static mut setmodeneeded: int32_t;
    static mut cv_scr_width: consvar_t;
    static mut cv_scr_height: consvar_t;
    static mut cv_scr_width_w: consvar_t;
    static mut cv_scr_height_w: consvar_t;
    static mut cv_fullscreen: consvar_t;
    static mut cv_renderer: consvar_t;
    static mut cv_vidwait: consvar_t;
    static mut cv_timescale: consvar_t;
    fn SCR_SetDefaultMode();
    fn SCR_IsAspectCorrect(width: int32_t, height: int32_t) -> boolean;
    static mut sprites: *mut spritedef_t;
    fn P_AllocMapHeader(i: int16_t);
    fn P_HasGrades(map: int16_t, mare: uint8_t) -> uint8_t;
    fn P_GetScoreForGrade(map: int16_t, mare: uint8_t, grade: uint8_t) -> uint32_t;
    fn strlwr(n: *mut libc::c_char) -> libc::c_int;
    fn P_MoveChaseCamera(
        player: *mut player_t,
        thiscam: *mut camera_t,
        resetcalled: boolean,
    ) -> boolean;
    fn P_AutoPause() -> boolean;
    static mut cv_gravity: consvar_t;
    fn P_LinedefExecute(tag: int16_t, actor: *mut mobj_t, caller: *mut sector_t);
    fn W_CheckNumForName(name: *const libc::c_char) -> lumpnum_t;
    fn W_GetNumForName(name: *const libc::c_char) -> lumpnum_t;
    fn W_CacheLumpName(name: *const libc::c_char, tag: int32_t) -> *mut libc::c_void;
    fn W_CachePatchName(name: *const libc::c_char, tag: int32_t) -> *mut libc::c_void;
    fn W_CachePatchNum(lumpnum: lumpnum_t, tag: int32_t) -> *mut libc::c_void;
    fn D_StartTitle();
    static mut srb2home: [libc::c_char; 256];
    fn W_UnlockCachedPatch(patch: *mut libc::c_void);
    static mut usehome: boolean;
    static mut srb2path: [libc::c_char; 256];
    fn CON_Responder(ev: *mut event_t) -> boolean;
    static mut cons_backcolor: consvar_t;
    static mut yellowmap: *mut uint8_t;
    static mut graymap: *mut uint8_t;
    fn CON_ToggleOff();
    fn CON_Ready() -> boolean;
    static mut cv_homremoval: consvar_t;
    static mut cv_drawdist_nights: consvar_t;
    static mut renderisnewtic: boolean;
    static mut cv_drawdist_precip: consvar_t;
    static mut cv_drawdist: consvar_t;
    static mut cv_translucenthud: consvar_t;
    static mut cv_showhud: consvar_t;
    fn SplitScreen_OnChange();
    static mut cv_flipcam2: consvar_t;
    static mut cv_chasecam2: consvar_t;
    static mut cv_flipcam: consvar_t;
    static mut cv_chasecam: consvar_t;
    static mut renderdeltatics: fixed_t;
    fn R_GetTranslationColormap(
        skinnum: int32_t,
        color: skincolornum_t,
        flags: uint8_t,
    ) -> *mut uint8_t;
    static mut shiftxform: *mut libc::c_char;
    static mut chat_on: boolean;
    static mut hu_font: [*mut patch_t; 105];
    static mut emeraldpics: [[*mut patch_t; 8]; 3];
    fn HU_clearChatChars();
    static mut timeattackfolder: [libc::c_char; 64];
    static mut customversionstring: [libc::c_char; 32];
    static mut players: [player_t; 32];
    static mut cv_chatwidth: consvar_t;
    static mut cv_chatnotifications: consvar_t;
    static mut cv_chatheight: consvar_t;
    static mut cv_chattime: consvar_t;
    static mut cv_consolechat: consvar_t;
    static mut cv_chatbacktint: consvar_t;
    static mut cv_chatspamprotection: consvar_t;
    static mut cv_crosshair: consvar_t;
    static mut cv_crosshair2: consvar_t;
    static mut cv_invertmouse: consvar_t;
    static mut cv_alwaysfreelook: consvar_t;
    static mut cv_chasefreelook: consvar_t;
    static mut cv_mousemove: consvar_t;
    static mut cv_invertmouse2: consvar_t;
    static mut cv_alwaysfreelook2: consvar_t;
    static mut cv_chasefreelook2: consvar_t;
    static mut cv_mousemove2: consvar_t;
    static mut cv_useranalog: [consvar_t; 2];
    static mut cv_analog: [consvar_t; 2];
    static mut cv_directionchar: [consvar_t; 2];
    static mut cv_autobrake: consvar_t;
    static mut cv_autobrake2: consvar_t;
    static mut cv_sideaxis: consvar_t;
    static mut cv_turnaxis: consvar_t;
    static mut cv_moveaxis: consvar_t;
    static mut cv_lookaxis: consvar_t;
    static mut cv_jumpaxis: consvar_t;
    static mut cv_spinaxis: consvar_t;
    static mut cv_fireaxis: consvar_t;
    static mut cv_firenaxis: consvar_t;
    static mut cv_deadzone: consvar_t;
    static mut cv_digitaldeadzone: consvar_t;
    static mut cv_sideaxis2: consvar_t;
    static mut cv_turnaxis2: consvar_t;
    static mut cv_moveaxis2: consvar_t;
    static mut cv_lookaxis2: consvar_t;
    static mut cv_jumpaxis2: consvar_t;
    static mut cv_spinaxis2: consvar_t;
    fn G_GetBestNightsScore(
        map: int16_t,
        mare: uint8_t,
        data: *mut gamedata_t,
    ) -> uint32_t;
    fn G_GetBestRings(map: int16_t, data: *mut gamedata_t) -> uint16_t;
    fn G_GetBestTime(map: int16_t, data: *mut gamedata_t) -> tic_t;
    fn G_GetBestScore(map: int16_t, data: *mut gamedata_t) -> uint32_t;
    fn G_SetExitGameFlag();
    static mut demorecording: boolean;
    static mut demoplayback: boolean;
    fn M_ClearSecrets(data: *mut gamedata_t);
    fn G_ClearRecords(data: *mut gamedata_t);
    fn G_GetBestNightsGrade(
        map: int16_t,
        mare: uint8_t,
        data: *mut gamedata_t,
    ) -> uint8_t;
    fn G_StopDemo();
    fn G_GetBestNightsTime(map: int16_t, mare: uint8_t, data: *mut gamedata_t) -> tic_t;
    static mut serverGamedata: *mut gamedata_t;
    fn M_MapLocked(mapnum: int32_t, data: *mut gamedata_t) -> uint8_t;
    fn M_SecretUnlocked(type_1: int32_t, data: *mut gamedata_t) -> uint8_t;
    static mut gametypetol: [uint32_t; 136];
    fn G_IsSpecialStage(mapnum: int32_t) -> boolean;
    fn G_BuildMapName(map: int32_t) -> *const libc::c_char;
    fn G_DeferedInitNew(
        pultmode: boolean,
        mapname: *const libc::c_char,
        pickedchar: int32_t,
        SSSG: boolean,
        FLS: boolean,
    );
    fn G_RecordDemo(name: *const libc::c_char);
    fn G_StopMetalDemo();
    fn G_DoPlayDemo(defdemoname: *mut libc::c_char);
    static mut demofileoverride: demo_file_override_e;
    fn G_CheckDemoForError(defdemoname: *mut libc::c_char) -> uint8_t;
    fn M_GetLevelEmblems(mapnum: int32_t) -> *mut emblem_t;
    fn G_TicsToMinutes(tics: tic_t, full: boolean) -> int32_t;
    fn G_TicsToSeconds(tics: tic_t) -> int32_t;
    fn G_TicsToCentiseconds(tics: tic_t) -> int32_t;
    fn G_GametypeHasTeams() -> boolean;
    static mut clientGamedata: *mut gamedata_t;
    static mut emblemlocations: [emblem_t; 512];
    fn M_GetEmblemPatch(em: *mut emblem_t, big: boolean) -> *const libc::c_char;
    fn M_GetEmblemColor(em: *mut emblem_t) -> skincolornum_t;
    static mut cv_cam_lockonboss: [consvar_t; 2];
    static mut cv_cam_lockedinput: [consvar_t; 2];
    static mut cv_cam_centertoggle: [consvar_t; 2];
    static mut cv_cam_turnfacinginput: [consvar_t; 2];
    static mut cv_cam_turnfacingspindash: [consvar_t; 2];
    static mut cv_cam_turnfacingability: [consvar_t; 2];
    static mut cv_cam_turnfacing: [consvar_t; 2];
    static mut cv_cam_shiftfacing: [consvar_t; 2];
    static mut cv_digitaldeadzone2: consvar_t;
    static mut cv_deadzone2: consvar_t;
    static mut cv_firenaxis2: consvar_t;
    static mut cv_fireaxis2: consvar_t;
    fn G_LoadGame(slot: uint32_t, mapoverride: int16_t);
    fn G_CheckDemoStatus() -> boolean;
    static mut conditionSets: [conditionset_t; 128];
    fn G_GametypeHasSpectators() -> boolean;
    fn G_SetRetryFlag();
    fn G_BuildMapTitle(mapnum: int32_t) -> *mut libc::c_char;
    fn M_GetExtraEmblemColor(em: *mut extraemblem_t) -> skincolornum_t;
    fn M_GetExtraEmblemPatch(
        em: *mut extraemblem_t,
        big: boolean,
    ) -> *const libc::c_char;
    static mut numextraemblems: int32_t;
    fn G_TicsToHours(tics: tic_t) -> int32_t;
    static mut numemblems: int32_t;
    fn M_CountEmblems(data: *mut gamedata_t) -> int32_t;
    fn G_SetUsedCheats(silent: boolean);
    fn G_SetGamestate(newstate: gamestate_t);
    static mut extraemblems: [extraemblem_t; 48];
    fn G_ClearModeAttackRetryFlag();
    static mut titledemo: boolean;
    static mut unlockables: [unlockable_t; 80];
    fn M_AnySecretUnlocked(data: *mut gamedata_t) -> uint8_t;
    fn G_CoopGametype() -> boolean;
    static mut cv_mousesens: consvar_t;
    static mut cv_mouseysens: consvar_t;
    static mut cv_mousesens2: consvar_t;
    static mut cv_mouseysens2: consvar_t;
    static mut cv_controlperkey: consvar_t;
    static mut gamecontrol: [[int32_t; 2]; 43];
    static mut gamecontrolbis: [[int32_t; 2]; 43];
    static mut gamecontroldefault: [[[int32_t; 2]; 43]; 3];
    static gcl_tutorial_check: [int32_t; 6];
    static gcl_tutorial_full: [int32_t; 13];
    fn G_KeyNumToName(keynum: int32_t) -> *const libc::c_char;
    fn G_ClearControlKeys(setupcontrols_0: *mut [int32_t; 2], control: int32_t);
    fn G_CheckDoubleUsage(keynum: int32_t, modify: boolean) -> int32_t;
    fn G_CopyControls(
        setupcontrols_0: *mut [int32_t; 2],
        fromcontrols: *mut [int32_t; 2],
        gclist: *const int32_t,
        gclen: int32_t,
    );
    fn G_GetControlScheme(
        fromcontrols: *mut [int32_t; 2],
        gclist: *const int32_t,
        gclen: int32_t,
    ) -> int32_t;
    fn S_ResetCaptions();
    static mut cv_gamesounds: consvar_t;
    static mut cv_soundvolume: consvar_t;
    static mut cv_gamedigimusic: consvar_t;
    static mut cv_digmusicvolume: consvar_t;
    static mut cv_gamemidimusic: consvar_t;
    static mut cv_midimusicvolume: consvar_t;
    static mut cv_musicpref: consvar_t;
    static mut cv_resetmusic: consvar_t;
    static mut cv_1upsound: consvar_t;
    static mut cv_modfilter: consvar_t;
    static mut cv_playsoundsifunfocused: consvar_t;
    static mut cv_playmusicifunfocused: consvar_t;
    static mut cv_resetmusicbyheader: consvar_t;
    static mut soundtestpage: uint8_t;
    fn S_PrepareSoundTest() -> boolean;
    fn S_StopSounds();
    static mut cv_closedcaptioning: consvar_t;
    static mut numsoundtestdefs: int32_t;
    static mut soundtestsfx: musicdef_t;
    static mut soundtestdefs: *mut *mut musicdef_t;
    fn S_StartSound(origin: *const libc::c_void, sound_id: sfxenum_t);
    fn S_StopMusic();
    fn S_ChangeMusicEx(
        mmusic: *const libc::c_char,
        mflags: uint16_t,
        looping: boolean,
        position: uint32_t,
        prefadems: uint32_t,
        fadeinms: uint32_t,
    );
    fn I_GetTime() -> tic_t;
    fn I_UpdateTime(timescale: fixed_t);
    fn I_Sleep(ms: uint32_t);
    fn I_OsPolling();
    fn I_Quit() -> !;
    fn I_NumJoys() -> int32_t;
    fn I_GetJoyName(joyindex: int32_t) -> *const libc::c_char;
    fn I_mkdir(dirname: *const libc::c_char, unixright: int32_t) -> int32_t;
    fn I_UpdateMouseGrab();
    fn I_ClipboardCopy(data: *const libc::c_char, size: size_t) -> int32_t;
    fn I_ClipboardPaste() -> *const libc::c_char;
    static mut cv_addons_option: consvar_t;
    static mut cv_addons_folder: consvar_t;
    static mut cv_addons_md5: consvar_t;
    static mut cv_addons_showall: consvar_t;
    static mut cv_addons_search_case: consvar_t;
    static mut cv_addons_search_type: consvar_t;
    static mut menupath: [libc::c_char; 1024];
    static mut menupathindex: [size_t; 20];
    static mut menudepthleft: size_t;
    static mut menusearch: [libc::c_char; 33];
    static mut dir_on: [size_t; 20];
    static mut dirmenu: *mut *mut libc::c_char;
    static mut sizedirmenu: size_t;
    static mut refreshdirname: *mut libc::c_char;
    static mut refreshdirmenu: uint8_t;
    fn preparefilemenu(samedepth: boolean) -> boolean;
    fn closefilemenu(validsize: boolean);
    fn searchfilemenu(tempname: *mut libc::c_char);
    static mut cv_ticrate: consvar_t;
    static mut cv_constextsize: consvar_t;
    static mut cv_globalgamma: consvar_t;
    static mut cv_globalsaturation: consvar_t;
    static mut cv_rhue: consvar_t;
    static mut cv_yhue: consvar_t;
    static mut cv_ghue: consvar_t;
    static mut cv_chue: consvar_t;
    static mut cv_bhue: consvar_t;
    static mut cv_mhue: consvar_t;
    static mut cv_rgamma: consvar_t;
    static mut cv_ygamma: consvar_t;
    static mut cv_ggamma: consvar_t;
    static mut cv_cgamma: consvar_t;
    static mut cv_bgamma: consvar_t;
    static mut cv_mgamma: consvar_t;
    static mut cv_rsaturation: consvar_t;
    static mut cv_ysaturation: consvar_t;
    static mut cv_gsaturation: consvar_t;
    static mut cv_csaturation: consvar_t;
    static mut cv_bsaturation: consvar_t;
    static mut cv_msaturation: consvar_t;
    fn V_DrawStretchyFixedPatch(
        x: fixed_t,
        y: fixed_t,
        pscale: fixed_t,
        vscale: fixed_t,
        scrn: int32_t,
        patch: *mut patch_t,
        colormap: *const uint8_t,
    );
    fn V_DrawCroppedPatch(
        x: fixed_t,
        y: fixed_t,
        pscale: fixed_t,
        vscale: fixed_t,
        scrn: int32_t,
        patch: *mut patch_t,
        colormap: *const uint8_t,
        sx: fixed_t,
        sy: fixed_t,
        w: fixed_t,
        h: fixed_t,
    );
    fn V_DrawScaledPic(px1: int32_t, py1: int32_t, scrn: int32_t, lumpnum: int32_t);
    fn V_DrawFill(x: int32_t, y: int32_t, w: int32_t, h: int32_t, c: int32_t);
    fn V_DrawFadeScreen(color: uint16_t, strength: uint8_t);
    fn V_DrawCharacter(x: int32_t, y: int32_t, c: int32_t, lowercaseallowed: boolean);
    fn V_GetStringColormap(colorflags: int32_t) -> *mut uint8_t;
    fn V_DrawLevelTitle(
        x: int32_t,
        y: int32_t,
        option: int32_t,
        string: *const libc::c_char,
    );
    fn V_WordWrap(
        x: int32_t,
        w: int32_t,
        option: int32_t,
        string: *const libc::c_char,
    ) -> *mut libc::c_char;
    fn V_DrawString(
        x: int32_t,
        y: int32_t,
        option: int32_t,
        string: *const libc::c_char,
    );
    fn V_DrawCenteredString(
        x: int32_t,
        y: int32_t,
        option: int32_t,
        string: *const libc::c_char,
    );
    fn V_DrawRightAlignedString(
        x: int32_t,
        y: int32_t,
        option: int32_t,
        string: *const libc::c_char,
    );
    fn V_DrawSmallString(
        x: int32_t,
        y: int32_t,
        option: int32_t,
        string: *const libc::c_char,
    );
    fn V_DrawThinString(
        x: int32_t,
        y: int32_t,
        option: int32_t,
        string: *const libc::c_char,
    );
    fn V_DrawCenteredThinString(
        x: int32_t,
        y: int32_t,
        option: int32_t,
        string: *const libc::c_char,
    );
    fn V_DrawRightAlignedThinString(
        x: int32_t,
        y: int32_t,
        option: int32_t,
        string: *const libc::c_char,
    );
    fn V_LevelNameWidth(string: *const libc::c_char) -> int32_t;
    fn V_DrawNameTag(
        x: int32_t,
        y: int32_t,
        option: int32_t,
        scale: fixed_t,
        basecolormap: *mut uint8_t,
        outlinecolormap: *mut uint8_t,
        string: *const libc::c_char,
    );
    fn V_StringWidth(string: *const libc::c_char, option: int32_t) -> int32_t;
    fn V_ThinStringWidth(string: *const libc::c_char, option: int32_t) -> int32_t;
    static mut rendermode: rendermode_t;
    fn VID_NumModes() -> int32_t;
    fn VID_GetModeForSize(w: int32_t, h: int32_t) -> int32_t;
    fn VID_GetModeName(modenum: int32_t) -> *const libc::c_char;
    fn VID_PrepareModeList();
    fn I_UpdateNoBlit();
    fn I_FinishUpdate();
    fn Z_Free(ptr: *mut libc::c_void);
    fn Z_ReallocAlign(
        ptr: *mut libc::c_void,
        size: size_t,
        tag: int32_t,
        user: *mut libc::c_void,
        alignbits: int32_t,
    ) -> *mut libc::c_void;
    fn Z_StrDup(in_0: *const libc::c_char) -> *mut libc::c_char;
    fn LUA_HookBool(value: boolean, hook: libc::c_int);
    static mut cv_screenshot_option: consvar_t;
    static mut cv_screenshot_folder: consvar_t;
    static mut cv_screenshot_colorprofile: consvar_t;
    static mut cv_moviemode: consvar_t;
    static mut cv_movie_folder: consvar_t;
    static mut cv_movie_option: consvar_t;
    static mut cv_zlib_memory: consvar_t;
    static mut cv_zlib_level: consvar_t;
    static mut cv_zlib_strategy: consvar_t;
    static mut cv_zlib_window_bits: consvar_t;
    static mut cv_zlib_memorya: consvar_t;
    static mut cv_zlib_levela: consvar_t;
    static mut cv_zlib_strategya: consvar_t;
    static mut cv_zlib_window_bitsa: consvar_t;
    static mut cv_apng_downscale: consvar_t;
    fn FIL_WriteFile(
        name: *const libc::c_char,
        source: *const libc::c_void,
        length: size_t,
    ) -> boolean;
    fn FIL_ReadFileTag(
        name: *const libc::c_char,
        buffer: *mut *mut uint8_t,
        tag: int32_t,
    ) -> size_t;
    fn FIL_FileExists(name: *const libc::c_char) -> boolean;
    fn FIL_ReadFileOK(name: *const libc::c_char) -> boolean;
    fn M_Ftrim(_: libc::c_double) -> *const libc::c_char;
    static mut configfile: [libc::c_char; 512];
    static mut cv_gif_optimize: consvar_t;
    static mut cv_gif_downscale: consvar_t;
    static mut cv_gif_localcolortable: consvar_t;
    static mut ngradeletters: [*mut patch_t; 7];
    static mut Joystick: JoyType_t;
    fn M_RandomKey(a: int32_t) -> int32_t;
}
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type size_t = libc::c_ulong;
pub type int8_t = __int8_t;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type int64_t = __int64_t;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type boolean = int32_t;
pub type C2RustUnnamed = libc::c_uint;
pub const true_0: C2RustUnnamed = 1;
pub const false_0: C2RustUnnamed = 0;
pub type lumpnum_t = uint32_t;
pub type tic_t = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type __compar_fn_t = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct skincolor_s {
    pub name: [libc::c_char; 33],
    pub ramp: [uint8_t; 16],
    pub invcolor: uint16_t,
    pub invshade: uint8_t,
    pub chatcolor: uint16_t,
    pub accessible: boolean,
}
pub type skincolor_t = skincolor_s;
pub type skincolornum_t = libc::c_uint;
pub const NUMSUPERCOLORS: skincolornum_t = 9;
pub const MAXSKINCOLORS: skincolornum_t = 1182;
pub const SKINCOLOR_LASTFREESLOT: skincolornum_t = 1181;
pub const SKINCOLOR_FIRSTFREESLOT: skincolornum_t = 158;
pub const SKINCOLOR_SUPERTAN5: skincolornum_t = 157;
pub const SKINCOLOR_SUPERTAN4: skincolornum_t = 156;
pub const SKINCOLOR_SUPERTAN3: skincolornum_t = 155;
pub const SKINCOLOR_SUPERTAN2: skincolornum_t = 154;
pub const SKINCOLOR_SUPERTAN1: skincolornum_t = 153;
pub const SKINCOLOR_SUPERRUST5: skincolornum_t = 152;
pub const SKINCOLOR_SUPERRUST4: skincolornum_t = 151;
pub const SKINCOLOR_SUPERRUST3: skincolornum_t = 150;
pub const SKINCOLOR_SUPERRUST2: skincolornum_t = 149;
pub const SKINCOLOR_SUPERRUST1: skincolornum_t = 148;
pub const SKINCOLOR_SUPERPURPLE5: skincolornum_t = 147;
pub const SKINCOLOR_SUPERPURPLE4: skincolornum_t = 146;
pub const SKINCOLOR_SUPERPURPLE3: skincolornum_t = 145;
pub const SKINCOLOR_SUPERPURPLE2: skincolornum_t = 144;
pub const SKINCOLOR_SUPERPURPLE1: skincolornum_t = 143;
pub const SKINCOLOR_SUPERSKY5: skincolornum_t = 142;
pub const SKINCOLOR_SUPERSKY4: skincolornum_t = 141;
pub const SKINCOLOR_SUPERSKY3: skincolornum_t = 140;
pub const SKINCOLOR_SUPERSKY2: skincolornum_t = 139;
pub const SKINCOLOR_SUPERSKY1: skincolornum_t = 138;
pub const SKINCOLOR_SUPERPERIDOT5: skincolornum_t = 137;
pub const SKINCOLOR_SUPERPERIDOT4: skincolornum_t = 136;
pub const SKINCOLOR_SUPERPERIDOT3: skincolornum_t = 135;
pub const SKINCOLOR_SUPERPERIDOT2: skincolornum_t = 134;
pub const SKINCOLOR_SUPERPERIDOT1: skincolornum_t = 133;
pub const SKINCOLOR_SUPERGOLD5: skincolornum_t = 132;
pub const SKINCOLOR_SUPERGOLD4: skincolornum_t = 131;
pub const SKINCOLOR_SUPERGOLD3: skincolornum_t = 130;
pub const SKINCOLOR_SUPERGOLD2: skincolornum_t = 129;
pub const SKINCOLOR_SUPERGOLD1: skincolornum_t = 128;
pub const SKINCOLOR_SUPERORANGE5: skincolornum_t = 127;
pub const SKINCOLOR_SUPERORANGE4: skincolornum_t = 126;
pub const SKINCOLOR_SUPERORANGE3: skincolornum_t = 125;
pub const SKINCOLOR_SUPERORANGE2: skincolornum_t = 124;
pub const SKINCOLOR_SUPERORANGE1: skincolornum_t = 123;
pub const SKINCOLOR_SUPERRED5: skincolornum_t = 122;
pub const SKINCOLOR_SUPERRED4: skincolornum_t = 121;
pub const SKINCOLOR_SUPERRED3: skincolornum_t = 120;
pub const SKINCOLOR_SUPERRED2: skincolornum_t = 119;
pub const SKINCOLOR_SUPERRED1: skincolornum_t = 118;
pub const SKINCOLOR_SUPERSILVER5: skincolornum_t = 117;
pub const SKINCOLOR_SUPERSILVER4: skincolornum_t = 116;
pub const SKINCOLOR_SUPERSILVER3: skincolornum_t = 115;
pub const SKINCOLOR_SUPERSILVER2: skincolornum_t = 114;
pub const SKINCOLOR_SUPERSILVER1: skincolornum_t = 113;
pub const FIRSTSUPERCOLOR: skincolornum_t = 113;
pub const SKINCOLOR_VOLCANIC: skincolornum_t = 112;
pub const SKINCOLOR_SANGRIA: skincolornum_t = 111;
pub const SKINCOLOR_FANCY: skincolornum_t = 110;
pub const SKINCOLOR_ROSY: skincolornum_t = 109;
pub const SKINCOLOR_TAFFY: skincolornum_t = 108;
pub const SKINCOLOR_RASPBERRY: skincolornum_t = 107;
pub const SKINCOLOR_PLUM: skincolornum_t = 106;
pub const SKINCOLOR_EVENTIDE: skincolornum_t = 105;
pub const SKINCOLOR_MAUVE: skincolornum_t = 104;
pub const SKINCOLOR_LILAC: skincolornum_t = 103;
pub const SKINCOLOR_ROYAL: skincolornum_t = 102;
pub const SKINCOLOR_VIOLET: skincolornum_t = 101;
pub const SKINCOLOR_NEON: skincolornum_t = 100;
pub const SKINCOLOR_MAGENTA: skincolornum_t = 99;
pub const SKINCOLOR_SIBERITE: skincolornum_t = 98;
pub const SKINCOLOR_BUBBLEGUM: skincolornum_t = 97;
pub const SKINCOLOR_FUCHSIA: skincolornum_t = 96;
pub const SKINCOLOR_NOBLE: skincolornum_t = 95;
pub const SKINCOLOR_PURPLE: skincolornum_t = 94;
pub const SKINCOLOR_PASTEL: skincolornum_t = 93;
pub const SKINCOLOR_MAJESTY: skincolornum_t = 92;
pub const SKINCOLOR_DUSK: skincolornum_t = 91;
pub const SKINCOLOR_VAPOR: skincolornum_t = 90;
pub const SKINCOLOR_GALAXY: skincolornum_t = 89;
pub const SKINCOLOR_MIDNIGHT: skincolornum_t = 88;
pub const SKINCOLOR_COBALT: skincolornum_t = 87;
pub const SKINCOLOR_BLUE: skincolornum_t = 86;
pub const SKINCOLOR_CORNFLOWER: skincolornum_t = 85;
pub const SKINCOLOR_ARCTIC: skincolornum_t = 84;
pub const SKINCOLOR_SAPPHIRE: skincolornum_t = 83;
pub const SKINCOLOR_DAYBREAK: skincolornum_t = 82;
pub const SKINCOLOR_ICY: skincolornum_t = 81;
pub const SKINCOLOR_DREAM: skincolornum_t = 80;
pub const SKINCOLOR_CERULEAN: skincolornum_t = 79;
pub const SKINCOLOR_MARINE: skincolornum_t = 78;
pub const SKINCOLOR_SKY: skincolornum_t = 77;
pub const SKINCOLOR_AQUAMARINE: skincolornum_t = 76;
pub const SKINCOLOR_TURQUOISE: skincolornum_t = 75;
pub const SKINCOLOR_CYAN: skincolornum_t = 74;
pub const SKINCOLOR_WAVE: skincolornum_t = 73;
pub const SKINCOLOR_OCEAN: skincolornum_t = 72;
pub const SKINCOLOR_TEAL: skincolornum_t = 71;
pub const SKINCOLOR_AQUA: skincolornum_t = 70;
pub const SKINCOLOR_BOTTLE: skincolornum_t = 69;
pub const SKINCOLOR_ISLAND: skincolornum_t = 68;
pub const SKINCOLOR_SEAFOAM: skincolornum_t = 67;
pub const SKINCOLOR_EMERALD: skincolornum_t = 66;
pub const SKINCOLOR_MASTER: skincolornum_t = 65;
pub const SKINCOLOR_MINT: skincolornum_t = 64;
pub const SKINCOLOR_JADE: skincolornum_t = 63;
pub const SKINCOLOR_SHAMROCK: skincolornum_t = 62;
pub const SKINCOLOR_FOREST: skincolornum_t = 61;
pub const SKINCOLOR_GREEN: skincolornum_t = 60;
pub const SKINCOLOR_CHARTREUSE: skincolornum_t = 59;
pub const SKINCOLOR_HEADLIGHT: skincolornum_t = 58;
pub const SKINCOLOR_APPLE: skincolornum_t = 57;
pub const SKINCOLOR_PERIDOT: skincolornum_t = 56;
pub const SKINCOLOR_LIME: skincolornum_t = 55;
pub const SKINCOLOR_LEMON: skincolornum_t = 54;
pub const SKINCOLOR_PEAR: skincolornum_t = 53;
pub const SKINCOLOR_OLIVE: skincolornum_t = 52;
pub const SKINCOLOR_YELLOW: skincolornum_t = 51;
pub const SKINCOLOR_GOLDENROD: skincolornum_t = 50;
pub const SKINCOLOR_SANDY: skincolornum_t = 49;
pub const SKINCOLOR_GOLD: skincolornum_t = 48;
pub const SKINCOLOR_TOPAZ: skincolornum_t = 47;
pub const SKINCOLOR_TANGERINE: skincolornum_t = 46;
pub const SKINCOLOR_RUST: skincolornum_t = 45;
pub const SKINCOLOR_ORANGE: skincolornum_t = 44;
pub const SKINCOLOR_APRICOT: skincolornum_t = 43;
pub const SKINCOLOR_COPPER: skincolornum_t = 42;
pub const SKINCOLOR_SUNSET: skincolornum_t = 41;
pub const SKINCOLOR_FOUNDATION: skincolornum_t = 40;
pub const SKINCOLOR_QUAIL: skincolornum_t = 39;
pub const SKINCOLOR_PEACHY: skincolornum_t = 38;
pub const SKINCOLOR_KETCHUP: skincolornum_t = 37;
pub const SKINCOLOR_GARNET: skincolornum_t = 36;
pub const SKINCOLOR_FLAME: skincolornum_t = 35;
pub const SKINCOLOR_CRIMSON: skincolornum_t = 34;
pub const SKINCOLOR_RED: skincolornum_t = 33;
pub const SKINCOLOR_PEPPER: skincolornum_t = 32;
pub const SKINCOLOR_SALMON: skincolornum_t = 31;
pub const SKINCOLOR_CHERRY: skincolornum_t = 30;
pub const SKINCOLOR_RUBY: skincolornum_t = 29;
pub const SKINCOLOR_LAVENDER: skincolornum_t = 28;
pub const SKINCOLOR_EGGPLANT: skincolornum_t = 27;
pub const SKINCOLOR_AZURE: skincolornum_t = 26;
pub const SKINCOLOR_MOSS: skincolornum_t = 25;
pub const SKINCOLOR_ROSEBUSH: skincolornum_t = 24;
pub const SKINCOLOR_BEIGE: skincolornum_t = 23;
pub const SKINCOLOR_TAN: skincolornum_t = 22;
pub const SKINCOLOR_ECRU: skincolornum_t = 21;
pub const SKINCOLOR_SEPIA: skincolornum_t = 20;
pub const SKINCOLOR_BRONZE: skincolornum_t = 19;
pub const SKINCOLOR_BOULDER: skincolornum_t = 18;
pub const SKINCOLOR_BROWN: skincolornum_t = 17;
pub const SKINCOLOR_LATTE: skincolornum_t = 16;
pub const SKINCOLOR_YOGURT: skincolornum_t = 15;
pub const SKINCOLOR_ROSEWOOD: skincolornum_t = 14;
pub const SKINCOLOR_PINK: skincolornum_t = 13;
pub const SKINCOLOR_BLUEBELL: skincolornum_t = 12;
pub const SKINCOLOR_MOONSTONE: skincolornum_t = 11;
pub const SKINCOLOR_SLATE: skincolornum_t = 10;
pub const SKINCOLOR_AETHER: skincolornum_t = 9;
pub const SKINCOLOR_BLACK: skincolornum_t = 8;
pub const SKINCOLOR_JET: skincolornum_t = 7;
pub const SKINCOLOR_CARBON: skincolornum_t = 6;
pub const SKINCOLOR_SILVER: skincolornum_t = 5;
pub const SKINCOLOR_GREY: skincolornum_t = 4;
pub const SKINCOLOR_CLOUDY: skincolornum_t = 3;
pub const SKINCOLOR_BONE: skincolornum_t = 2;
pub const SKINCOLOR_WHITE: skincolornum_t = 1;
pub const SKINCOLOR_NONE: skincolornum_t = 0;
pub type gamestate_t = libc::c_uint;
pub const GS_WAITINGPLAYERS: gamestate_t = 13;
pub const GS_DEDICATEDSERVER: gamestate_t = 12;
pub const GS_CUTSCENE: gamestate_t = 11;
pub const GS_ENDING: gamestate_t = 10;
pub const GS_INTRO: gamestate_t = 9;
pub const GS_GAMEEND: gamestate_t = 8;
pub const GS_EVALUATION: gamestate_t = 7;
pub const GS_CREDITS: gamestate_t = 6;
pub const GS_TIMEATTACK: gamestate_t = 5;
pub const GS_TITLESCREEN: gamestate_t = 4;
pub const GS_CONTINUING: gamestate_t = 3;
pub const GS_INTERMISSION: gamestate_t = 2;
pub const GS_LEVEL: gamestate_t = 1;
pub const GS_NULL: gamestate_t = 0;
pub type alerttype_t = libc::c_uint;
pub const CONS_ERROR: alerttype_t = 2;
pub const CONS_WARNING: alerttype_t = 1;
pub const CONS_NOTICE: alerttype_t = 0;
pub type mtag_t = int16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct taglist_t {
    pub tags: *mut mtag_t,
    pub count: uint16_t,
}
pub type fixed_t = int32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vector2_t {
    pub x: fixed_t,
    pub y: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vector3_t {
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mapthing_t {
    pub x: int16_t,
    pub y: int16_t,
    pub angle: int16_t,
    pub pitch: int16_t,
    pub roll: int16_t,
    pub type_0: uint16_t,
    pub options: uint16_t,
    pub z: int16_t,
    pub extrainfo: uint8_t,
    pub tags: taglist_t,
    pub scale: fixed_t,
    pub spritexscale: fixed_t,
    pub spriteyscale: fixed_t,
    pub args: [int32_t; 10],
    pub stringargs: [*mut libc::c_char; 2],
    pub mobj: *mut mobj_s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mobj_s {
    pub thinker: thinker_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub old_x: fixed_t,
    pub old_y: fixed_t,
    pub old_z: fixed_t,
    pub old_x2: fixed_t,
    pub old_y2: fixed_t,
    pub old_z2: fixed_t,
    pub snext: *mut mobj_s,
    pub sprev: *mut *mut mobj_s,
    pub angle: angle_t,
    pub pitch: angle_t,
    pub roll: angle_t,
    pub old_angle: angle_t,
    pub old_pitch: angle_t,
    pub old_roll: angle_t,
    pub old_angle2: angle_t,
    pub old_pitch2: angle_t,
    pub old_roll2: angle_t,
    pub spriteroll: angle_t,
    pub old_spriteroll: angle_t,
    pub old_spriteroll2: angle_t,
    pub sprite: spritenum_t,
    pub frame: uint32_t,
    pub sprite2: uint8_t,
    pub anim_duration: uint16_t,
    pub renderflags: uint32_t,
    pub blendmode: int32_t,
    pub spritexscale: fixed_t,
    pub spriteyscale: fixed_t,
    pub spritexoffset: fixed_t,
    pub spriteyoffset: fixed_t,
    pub old_spritexscale: fixed_t,
    pub old_spriteyscale: fixed_t,
    pub old_spritexoffset: fixed_t,
    pub old_spriteyoffset: fixed_t,
    pub floorspriteslope: *mut pslope_s,
    pub touching_sectorlist: *mut msecnode_s,
    pub subsector: *mut subsector_s,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
    pub floorrover: *mut ffloor_s,
    pub ceilingrover: *mut ffloor_s,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub momx: fixed_t,
    pub momy: fixed_t,
    pub momz: fixed_t,
    pub pmomz: fixed_t,
    pub tics: int32_t,
    pub state: *mut state_t,
    pub flags: uint32_t,
    pub flags2: uint32_t,
    pub eflags: uint16_t,
    pub skin: *mut libc::c_void,
    pub color: uint16_t,
    pub drawonlyforplayer: *mut player_s,
    pub dontdrawforviewmobj: *mut mobj_s,
    pub bnext: *mut mobj_s,
    pub bprev: *mut *mut mobj_s,
    pub hnext: *mut mobj_s,
    pub hprev: *mut mobj_s,
    pub type_0: mobjtype_t,
    pub info: *const mobjinfo_t,
    pub health: int32_t,
    pub movedir: angle_t,
    pub movecount: int32_t,
    pub target: *mut mobj_s,
    pub reactiontime: int32_t,
    pub threshold: int32_t,
    pub player: *mut player_s,
    pub lastlook: int32_t,
    pub spawnpoint: *mut mapthing_t,
    pub tracer: *mut mobj_s,
    pub friction: fixed_t,
    pub movefactor: fixed_t,
    pub fuse: int32_t,
    pub watertop: fixed_t,
    pub waterbottom: fixed_t,
    pub mobjnum: uint32_t,
    pub scale: fixed_t,
    pub old_scale: fixed_t,
    pub old_scale2: fixed_t,
    pub destscale: fixed_t,
    pub scalespeed: fixed_t,
    pub extravalue1: int32_t,
    pub extravalue2: int32_t,
    pub cusval: int32_t,
    pub cvmem: int32_t,
    pub standingslope: *mut pslope_s,
    pub resetinterp: boolean,
    pub colorized: boolean,
    pub mirrored: boolean,
    pub shadowscale: fixed_t,
    pub dispoffset: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pslope_s {
    pub id: uint16_t,
    pub next: *mut pslope_s,
    pub o: vector3_t,
    pub normal: vector3_t,
    pub d: vector2_t,
    pub zdelta: fixed_t,
    pub zangle: angle_t,
    pub xydirection: angle_t,
    pub flags: uint8_t,
}
pub type angle_t = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct player_s {
    pub mo: *mut mobj_t,
    pub cmd: ticcmd_t,
    pub playerstate: playerstate_t,
    pub camerascale: fixed_t,
    pub shieldscale: fixed_t,
    pub viewz: fixed_t,
    pub viewheight: fixed_t,
    pub deltaviewheight: fixed_t,
    pub bob: fixed_t,
    pub viewrollangle: angle_t,
    pub angleturn: int16_t,
    pub oldrelangleturn: int16_t,
    pub aiming: angle_t,
    pub drawangle: angle_t,
    pub old_drawangle: angle_t,
    pub old_drawangle2: angle_t,
    pub rings: int16_t,
    pub spheres: int16_t,
    pub pity: int8_t,
    pub currentweapon: int32_t,
    pub ringweapons: int32_t,
    pub ammoremoval: uint16_t,
    pub ammoremovaltimer: tic_t,
    pub ammoremovalweapon: int32_t,
    pub powers: [uint16_t; 30],
    pub pflags: pflags_t,
    pub panim: panim_t,
    pub stronganim: uint8_t,
    pub flashcount: uint16_t,
    pub flashpal: uint16_t,
    pub skincolor: uint16_t,
    pub skin: int32_t,
    pub availabilities: uint32_t,
    pub score: uint32_t,
    pub recordscore: uint32_t,
    pub dashspeed: fixed_t,
    pub normalspeed: fixed_t,
    pub runspeed: fixed_t,
    pub thrustfactor: uint8_t,
    pub accelstart: uint8_t,
    pub acceleration: uint8_t,
    pub charability: uint8_t,
    pub charability2: uint8_t,
    pub charflags: uint32_t,
    pub thokitem: mobjtype_t,
    pub spinitem: mobjtype_t,
    pub revitem: mobjtype_t,
    pub followitem: mobjtype_t,
    pub followmobj: *mut mobj_t,
    pub actionspd: fixed_t,
    pub mindash: fixed_t,
    pub maxdash: fixed_t,
    pub jumpfactor: fixed_t,
    pub height: fixed_t,
    pub spinheight: fixed_t,
    pub lives: int8_t,
    pub continues: int8_t,
    pub xtralife: int8_t,
    pub gotcontinue: uint8_t,
    pub speed: fixed_t,
    pub secondjump: uint8_t,
    pub fly1: uint8_t,
    pub scoreadd: uint8_t,
    pub glidetime: tic_t,
    pub climbing: uint8_t,
    pub deadtimer: int32_t,
    pub exiting: tic_t,
    pub homing: uint8_t,
    pub dashmode: tic_t,
    pub skidtime: tic_t,
    pub cmomx: fixed_t,
    pub cmomy: fixed_t,
    pub rmomx: fixed_t,
    pub rmomy: fixed_t,
    pub numboxes: int16_t,
    pub totalring: int16_t,
    pub realtime: tic_t,
    pub laps: uint8_t,
    pub ctfteam: int32_t,
    pub gotflag: uint16_t,
    pub weapondelay: int32_t,
    pub tossdelay: int32_t,
    pub starpostx: int16_t,
    pub starposty: int16_t,
    pub starpostz: int16_t,
    pub starpostnum: int32_t,
    pub starposttime: tic_t,
    pub starpostangle: angle_t,
    pub starpostscale: fixed_t,
    pub angle_pos: angle_t,
    pub old_angle_pos: angle_t,
    pub axis1: *mut mobj_t,
    pub axis2: *mut mobj_t,
    pub bumpertime: tic_t,
    pub flyangle: int32_t,
    pub drilltimer: tic_t,
    pub linkcount: int32_t,
    pub linktimer: tic_t,
    pub anotherflyangle: int32_t,
    pub nightstime: tic_t,
    pub drillmeter: int32_t,
    pub drilldelay: uint8_t,
    pub bonustime: boolean,
    pub capsule: *mut mobj_t,
    pub drone: *mut mobj_t,
    pub oldscale: fixed_t,
    pub mare: uint8_t,
    pub marelap: uint8_t,
    pub marebonuslap: uint8_t,
    pub marebegunat: tic_t,
    pub startedtime: tic_t,
    pub finishedtime: tic_t,
    pub lapbegunat: tic_t,
    pub lapstartedtime: tic_t,
    pub finishedspheres: int16_t,
    pub finishedrings: int16_t,
    pub marescore: uint32_t,
    pub lastmarescore: uint32_t,
    pub totalmarescore: uint32_t,
    pub lastmare: uint8_t,
    pub lastmarelap: uint8_t,
    pub lastmarebonuslap: uint8_t,
    pub totalmarelap: uint8_t,
    pub totalmarebonuslap: uint8_t,
    pub maxlink: int32_t,
    pub texttimer: uint8_t,
    pub textvar: uint8_t,
    pub lastsidehit: int16_t,
    pub lastlinehit: int16_t,
    pub losstime: tic_t,
    pub timeshit: uint8_t,
    pub onconveyor: int32_t,
    pub awayviewmobj: *mut mobj_t,
    pub awayviewtics: int32_t,
    pub awayviewaiming: angle_t,
    pub spectator: boolean,
    pub outofcoop: boolean,
    pub removing: boolean,
    pub bot: uint8_t,
    pub botleader: *mut player_s,
    pub lastbuttons: uint16_t,
    pub botmem: botmem_t,
    pub blocked: boolean,
    pub jointime: tic_t,
    pub quittime: tic_t,
}
pub type botmem_t = botmem_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct botmem_s {
    pub lastForward: boolean,
    pub lastBlocked: boolean,
    pub blocked: boolean,
    pub catchup_tics: uint8_t,
    pub thinkstate: uint8_t,
}
pub type mobj_t = mobj_s;
pub type mobjtype_t = mobj_type;
pub type mobj_type = libc::c_uint;
pub const NUMMOBJTYPES: mobj_type = 1163;
pub const MT_LASTFREESLOT: mobj_type = 1162;
pub const MT_FIRSTFREESLOT: mobj_type = 651;
pub const MT_RAY: mobj_type = 650;
pub const MT_NAMECHECK: mobj_type = 649;
pub const MT_YELLOWBRICKDEBRIS: mobj_type = 648;
pub const MT_BLUEBRICKDEBRIS: mobj_type = 647;
pub const MT_REDBRICKDEBRIS: mobj_type = 646;
pub const MT_WOODDEBRIS: mobj_type = 645;
pub const MT_BRICKDEBRIS: mobj_type = 644;
pub const MT_GFZDEBRIS: mobj_type = 643;
pub const MT_ROCKCRUMBLE16: mobj_type = 642;
pub const MT_ROCKCRUMBLE15: mobj_type = 641;
pub const MT_ROCKCRUMBLE14: mobj_type = 640;
pub const MT_ROCKCRUMBLE13: mobj_type = 639;
pub const MT_ROCKCRUMBLE12: mobj_type = 638;
pub const MT_ROCKCRUMBLE11: mobj_type = 637;
pub const MT_ROCKCRUMBLE10: mobj_type = 636;
pub const MT_ROCKCRUMBLE9: mobj_type = 635;
pub const MT_ROCKCRUMBLE8: mobj_type = 634;
pub const MT_ROCKCRUMBLE7: mobj_type = 633;
pub const MT_ROCKCRUMBLE6: mobj_type = 632;
pub const MT_ROCKCRUMBLE5: mobj_type = 631;
pub const MT_ROCKCRUMBLE4: mobj_type = 630;
pub const MT_ROCKCRUMBLE3: mobj_type = 629;
pub const MT_ROCKCRUMBLE2: mobj_type = 628;
pub const MT_ROCKCRUMBLE1: mobj_type = 627;
pub const MT_FALLINGROCK: mobj_type = 626;
pub const MT_ROCKSPAWNER: mobj_type = 625;
pub const MT_DUST: mobj_type = 624;
pub const MT_UWEXPLODE: mobj_type = 623;
pub const MT_EXPLODE: mobj_type = 622;
pub const MT_SPARK: mobj_type = 621;
pub const MT_SKYBOX: mobj_type = 620;
pub const MT_POLYSPAWN: mobj_type = 619;
pub const MT_POLYANCHOR: mobj_type = 618;
pub const MT_ANGLEMAN: mobj_type = 617;
pub const MT_OVERLAY: mobj_type = 616;
pub const MT_GHOST: mobj_type = 615;
pub const MT_PUSH: mobj_type = 614;
pub const MT_TUBEWAYPOINT: mobj_type = 613;
pub const MT_CRUMBLEOBJ: mobj_type = 612;
pub const MT_ALTVIEWMAN: mobj_type = 611;
pub const MT_TELEPORTMAN: mobj_type = 610;
pub const MT_HANGSTER: mobj_type = 609;
pub const MT_SPINBOBERT_FIRE2: mobj_type = 608;
pub const MT_SPINBOBERT_FIRE1: mobj_type = 607;
pub const MT_SPINBOBERT: mobj_type = 606;
pub const MT_CACOFIRE: mobj_type = 605;
pub const MT_CACOSHARD: mobj_type = 604;
pub const MT_CACOLANTERN: mobj_type = 603;
pub const MT_SMASHINGSPIKEBALL: mobj_type = 602;
pub const MT_BUGGLE: mobj_type = 601;
pub const MT_BUMBLEBORE: mobj_type = 600;
pub const MT_HIVEELEMENTAL: mobj_type = 599;
pub const MT_POPSHOT_TRAIL: mobj_type = 598;
pub const MT_POPSHOT: mobj_type = 597;
pub const MT_POPHAT: mobj_type = 596;
pub const MT_PENGUINATOR: mobj_type = 595;
pub const MT_SHLEEP: mobj_type = 594;
pub const MT_PIAN: mobj_type = 593;
pub const MT_NIGHTOPIANHELPER: mobj_type = 592;
pub const MT_IDEYAANCHOR: mobj_type = 591;
pub const MT_EGGCAPSULE: mobj_type = 590;
pub const MT_NIGHTSLINKFREEZE: mobj_type = 589;
pub const MT_NIGHTSEXTRATIME: mobj_type = 588;
pub const MT_NIGHTSHELPER: mobj_type = 587;
pub const MT_NIGHTSDRILLREFILL: mobj_type = 586;
pub const MT_NIGHTSSUPERLOOP: mobj_type = 585;
pub const MT_FLINGNIGHTSSTAR: mobj_type = 584;
pub const MT_NIGHTSSTAR: mobj_type = 583;
pub const MT_FLINGNIGHTSCHIP: mobj_type = 582;
pub const MT_NIGHTSCHIP: mobj_type = 581;
pub const MT_NIGHTSCORE: mobj_type = 580;
pub const MT_HOOPCENTER: mobj_type = 579;
pub const MT_HOOPCOLLIDE: mobj_type = 578;
pub const MT_HOOP: mobj_type = 577;
pub const MT_NIGHTSBUMPER: mobj_type = 576;
pub const MT_NIGHTSLOOPHELPER: mobj_type = 575;
pub const MT_NIGHTSPARKLE: mobj_type = 574;
pub const MT_NIGHTSDRONE_GOAL: mobj_type = 573;
pub const MT_NIGHTSDRONE_SPARKLING: mobj_type = 572;
pub const MT_NIGHTSDRONE_MAN: mobj_type = 571;
pub const MT_NIGHTSDRONE: mobj_type = 570;
pub const MT_AXISTRANSFERLINE: mobj_type = 569;
pub const MT_AXISTRANSFER: mobj_type = 568;
pub const MT_AXIS: mobj_type = 567;
pub const MT_TOAD: mobj_type = 566;
pub const MT_MARIOBUSH2: mobj_type = 565;
pub const MT_MARIOBUSH1: mobj_type = 564;
pub const MT_AXE: mobj_type = 563;
pub const MT_KOOPAFLAME: mobj_type = 562;
pub const MT_KOOPA: mobj_type = 561;
pub const MT_HAMMER: mobj_type = 560;
pub const MT_PUMATRAIL: mobj_type = 559;
pub const MT_PUMA: mobj_type = 558;
pub const MT_SHELL: mobj_type = 557;
pub const MT_FIREBALLTRAIL: mobj_type = 556;
pub const MT_FIREBALL: mobj_type = 555;
pub const MT_FIREFLOWER: mobj_type = 554;
pub const MT_BLUEGOOMBA: mobj_type = 553;
pub const MT_GOOMBA: mobj_type = 552;
pub const MT_FLINGCOIN: mobj_type = 551;
pub const MT_COIN: mobj_type = 550;
pub const MT_THROWNGRENADE: mobj_type = 549;
pub const MT_THROWNEXPLOSION: mobj_type = 548;
pub const MT_THROWNSCATTER: mobj_type = 547;
pub const MT_THROWNAUTOMATIC: mobj_type = 546;
pub const MT_THROWNINFINITY: mobj_type = 545;
pub const MT_THROWNBOUNCE: mobj_type = 544;
pub const MT_GRENADEPICKUP: mobj_type = 543;
pub const MT_SCATTERPICKUP: mobj_type = 542;
pub const MT_EXPLODEPICKUP: mobj_type = 541;
pub const MT_AUTOPICKUP: mobj_type = 540;
pub const MT_RAILPICKUP: mobj_type = 539;
pub const MT_BOUNCEPICKUP: mobj_type = 538;
pub const MT_GRENADERING: mobj_type = 537;
pub const MT_SCATTERRING: mobj_type = 536;
pub const MT_EXPLOSIONRING: mobj_type = 535;
pub const MT_AUTOMATICRING: mobj_type = 534;
pub const MT_INFINITYRING: mobj_type = 533;
pub const MT_RAILRING: mobj_type = 532;
pub const MT_BOUNCERING: mobj_type = 531;
pub const MT_REDRING: mobj_type = 530;
pub const MT_LHRT: mobj_type = 529;
pub const MT_CORK: mobj_type = 528;
pub const MT_AMBIENT: mobj_type = 527;
pub const MT_FINISHFLAG: mobj_type = 526;
pub const MT_GOTFLAG: mobj_type = 525;
pub const MT_TAG: mobj_type = 524;
pub const MT_LOCKONINF: mobj_type = 523;
pub const MT_LOCKON: mobj_type = 522;
pub const MT_GOTEMERALD: mobj_type = 521;
pub const MT_DROWNNUMBERS: mobj_type = 520;
pub const MT_SCORE: mobj_type = 519;
pub const MT_PARTICLEGEN: mobj_type = 518;
pub const MT_PARTICLE: mobj_type = 517;
pub const MT_TFOG: mobj_type = 516;
pub const MT_SPINDUST: mobj_type = 515;
pub const MT_WATERZAP: mobj_type = 514;
pub const MT_EXTRALARGEBUBBLE: mobj_type = 513;
pub const MT_MEDIUMBUBBLE: mobj_type = 512;
pub const MT_SMALLBUBBLE: mobj_type = 511;
pub const MT_SMOKE: mobj_type = 510;
pub const MT_LAVASPLISH: mobj_type = 509;
pub const MT_SPLISH: mobj_type = 508;
pub const MT_SNOWFLAKE: mobj_type = 507;
pub const MT_RAIN: mobj_type = 506;
pub const MT_SEED: mobj_type = 505;
pub const MT_SECRETFLICKY_02_CENTER: mobj_type = 504;
pub const MT_SECRETFLICKY_02: mobj_type = 503;
pub const MT_SECRETFLICKY_01_CENTER: mobj_type = 502;
pub const MT_SECRETFLICKY_01: mobj_type = 501;
pub const MT_FLICKY_16_CENTER: mobj_type = 500;
pub const MT_FLICKY_16: mobj_type = 499;
pub const MT_FLICKY_15_CENTER: mobj_type = 498;
pub const MT_FLICKY_15: mobj_type = 497;
pub const MT_FLICKY_14_CENTER: mobj_type = 496;
pub const MT_FLICKY_14: mobj_type = 495;
pub const MT_FLICKY_13_CENTER: mobj_type = 494;
pub const MT_FLICKY_13: mobj_type = 493;
pub const MT_FLICKY_12_CENTER: mobj_type = 492;
pub const MT_FLICKY_12: mobj_type = 491;
pub const MT_FLICKY_11_CENTER: mobj_type = 490;
pub const MT_FLICKY_11: mobj_type = 489;
pub const MT_FLICKY_10_CENTER: mobj_type = 488;
pub const MT_FLICKY_10: mobj_type = 487;
pub const MT_FLICKY_09_CENTER: mobj_type = 486;
pub const MT_FLICKY_09: mobj_type = 485;
pub const MT_FLICKY_08_CENTER: mobj_type = 484;
pub const MT_FLICKY_08: mobj_type = 483;
pub const MT_FLICKY_07_CENTER: mobj_type = 482;
pub const MT_FLICKY_07: mobj_type = 481;
pub const MT_FLICKY_06_CENTER: mobj_type = 480;
pub const MT_FLICKY_06: mobj_type = 479;
pub const MT_FLICKY_05_CENTER: mobj_type = 478;
pub const MT_FLICKY_05: mobj_type = 477;
pub const MT_FLICKY_04_CENTER: mobj_type = 476;
pub const MT_FLICKY_04: mobj_type = 475;
pub const MT_FLICKY_03_CENTER: mobj_type = 474;
pub const MT_FLICKY_03: mobj_type = 473;
pub const MT_FLICKY_02_CENTER: mobj_type = 472;
pub const MT_FLICKY_02: mobj_type = 471;
pub const MT_FLICKY_01_CENTER: mobj_type = 470;
pub const MT_FLICKY_01: mobj_type = 469;
pub const MT_SUPERSPARK: mobj_type = 468;
pub const MT_IVSP: mobj_type = 467;
pub const MT_THUNDERCOIN_SPARK: mobj_type = 466;
pub const MT_THUNDERCOIN_ORB: mobj_type = 465;
pub const MT_BUBBLEWRAP_ORB: mobj_type = 464;
pub const MT_FLAMEAURA_ORB: mobj_type = 463;
pub const MT_PITY_ORB: mobj_type = 462;
pub const MT_WHIRLWIND_ORB: mobj_type = 461;
pub const MT_ARMAGEDDON_ORB: mobj_type = 460;
pub const MT_FORCE_ORB: mobj_type = 459;
pub const MT_ATTRACT_ORB: mobj_type = 458;
pub const MT_ELEMENTAL_ORB: mobj_type = 457;
pub const MT_EGGSTATUE2: mobj_type = 456;
pub const MT_DBALL: mobj_type = 455;
pub const MT_PALMTREE_TOP: mobj_type = 454;
pub const MT_PALMTREE_TRUNK: mobj_type = 453;
pub const MT_BIG_PALMTREE_TOP: mobj_type = 452;
pub const MT_BIG_PALMTREE_TRUNK: mobj_type = 451;
pub const MT_BSZCLOVER: mobj_type = 450;
pub const MT_BSZSHRUB: mobj_type = 449;
pub const MT_BSZVINE_ORANGE: mobj_type = 448;
pub const MT_BSZVINE_YELLOW: mobj_type = 447;
pub const MT_BSZVINE_CYAN: mobj_type = 446;
pub const MT_BSZVINE_BLUE: mobj_type = 445;
pub const MT_BSZVINE_PURPLE: mobj_type = 444;
pub const MT_BSZVINE_RED: mobj_type = 443;
pub const MT_BSZBUSH_ORANGE: mobj_type = 442;
pub const MT_BSZBUSH_YELLOW: mobj_type = 441;
pub const MT_BSZBUSH_CYAN: mobj_type = 440;
pub const MT_BSZBUSH_BLUE: mobj_type = 439;
pub const MT_BSZBUSH_PURPLE: mobj_type = 438;
pub const MT_BSZBUSH_RED: mobj_type = 437;
pub const MT_BSZCLUSTER_ORANGE: mobj_type = 436;
pub const MT_BSZCLUSTER_YELLOW: mobj_type = 435;
pub const MT_BSZCLUSTER_CYAN: mobj_type = 434;
pub const MT_BSZCLUSTER_BLUE: mobj_type = 433;
pub const MT_BSZCLUSTER_PURPLE: mobj_type = 432;
pub const MT_BSZCLUSTER_RED: mobj_type = 431;
pub const MT_BSZTULIP_ORANGE: mobj_type = 430;
pub const MT_BSZTULIP_YELLOW: mobj_type = 429;
pub const MT_BSZTULIP_CYAN: mobj_type = 428;
pub const MT_BSZTULIP_BLUE: mobj_type = 427;
pub const MT_BSZTULIP_PURPLE: mobj_type = 426;
pub const MT_BSZTULIP_RED: mobj_type = 425;
pub const MT_BSZSHORTFLOWER_ORANGE: mobj_type = 424;
pub const MT_BSZSHORTFLOWER_YELLOW: mobj_type = 423;
pub const MT_BSZSHORTFLOWER_CYAN: mobj_type = 422;
pub const MT_BSZSHORTFLOWER_BLUE: mobj_type = 421;
pub const MT_BSZSHORTFLOWER_PURPLE: mobj_type = 420;
pub const MT_BSZSHORTFLOWER_RED: mobj_type = 419;
pub const MT_BSZFLOWER_ORANGE: mobj_type = 418;
pub const MT_BSZFLOWER_YELLOW: mobj_type = 417;
pub const MT_BSZFLOWER_CYAN: mobj_type = 416;
pub const MT_BSZFLOWER_BLUE: mobj_type = 415;
pub const MT_BSZFLOWER_PURPLE: mobj_type = 414;
pub const MT_BSZFLOWER_RED: mobj_type = 413;
pub const MT_BSZTALLFLOWER_ORANGE: mobj_type = 412;
pub const MT_BSZTALLFLOWER_YELLOW: mobj_type = 411;
pub const MT_BSZTALLFLOWER_CYAN: mobj_type = 410;
pub const MT_BSZTALLFLOWER_BLUE: mobj_type = 409;
pub const MT_BSZTALLFLOWER_PURPLE: mobj_type = 408;
pub const MT_BSZTALLFLOWER_RED: mobj_type = 407;
pub const MT_HHZSTALAGMITE_SHORT: mobj_type = 406;
pub const MT_HHZSTALAGMITE_TALL: mobj_type = 405;
pub const MT_HHZTENTACLE2: mobj_type = 404;
pub const MT_HHZTENTACLE1: mobj_type = 403;
pub const MT_HHZGRASS: mobj_type = 402;
pub const MT_HHZSHROOM: mobj_type = 401;
pub const MT_HHZTREE_PART: mobj_type = 400;
pub const MT_HHZTREE_TOP: mobj_type = 399;
pub const MT_JACKO3: mobj_type = 398;
pub const MT_JACKO2: mobj_type = 397;
pub const MT_JACKO1: mobj_type = 396;
pub const MT_CDLHRT: mobj_type = 395;
pub const MT_ROSY: mobj_type = 394;
pub const MT_FHZICE2: mobj_type = 393;
pub const MT_FHZICE1: mobj_type = 392;
pub const MT_XMASBUSH: mobj_type = 391;
pub const MT_XMASBERRYBUSH: mobj_type = 390;
pub const MT_XMASBLUEBERRYBUSH: mobj_type = 389;
pub const MT_MISTLETOE: mobj_type = 388;
pub const MT_HANGSTAR: mobj_type = 387;
pub const MT_LAMPPOST2: mobj_type = 386;
pub const MT_LAMPPOST1: mobj_type = 385;
pub const MT_SNOWMANHAT: mobj_type = 384;
pub const MT_SNOWMAN: mobj_type = 383;
pub const MT_CANDYCANE: mobj_type = 382;
pub const MT_XMASPOLE: mobj_type = 381;
pub const MT_STALAGMITE9: mobj_type = 380;
pub const MT_STALAGMITE8: mobj_type = 379;
pub const MT_STALAGMITE7: mobj_type = 378;
pub const MT_STALAGMITE6: mobj_type = 377;
pub const MT_STALAGMITE5: mobj_type = 376;
pub const MT_STALAGMITE4: mobj_type = 375;
pub const MT_STALAGMITE3: mobj_type = 374;
pub const MT_STALAGMITE2: mobj_type = 373;
pub const MT_STALAGMITE1: mobj_type = 372;
pub const MT_STALAGMITE0: mobj_type = 371;
pub const MT_BLUEGARGOYLE: mobj_type = 370;
pub const MT_GREENFLAME: mobj_type = 369;
pub const MT_TARGET: mobj_type = 368;
pub const MT_GLAREGOYLELONG: mobj_type = 367;
pub const MT_GLAREGOYLEDOWN: mobj_type = 366;
pub const MT_GLAREGOYLEUP: mobj_type = 365;
pub const MT_GLAREGOYLE: mobj_type = 364;
pub const MT_WALLVINE_SHORT: mobj_type = 363;
pub const MT_WALLVINE_LONG: mobj_type = 362;
pub const MT_TORCHFLOWER: mobj_type = 361;
pub const MT_JUNGLEPALM: mobj_type = 360;
pub const MT_BIGFERN: mobj_type = 359;
pub const MT_BIGFERNLEAF: mobj_type = 358;
pub const MT_ROLLOUTROCK: mobj_type = 357;
pub const MT_ROLLOUTSPAWN: mobj_type = 356;
pub const MT_LAVAFALLROCK: mobj_type = 355;
pub const MT_LAVAFALL_LAVA: mobj_type = 354;
pub const MT_LAVAFALL: mobj_type = 353;
pub const MT_FLAMEJETFLAMEB: mobj_type = 352;
pub const MT_FJSPINAXISB: mobj_type = 351;
pub const MT_FJSPINAXISA: mobj_type = 350;
pub const MT_FLAMEJETFLAME: mobj_type = 349;
pub const MT_VERTICALFLAMEJET: mobj_type = 348;
pub const MT_FLAMEJET: mobj_type = 347;
pub const MT_MINECARTSWITCHPOINT: mobj_type = 346;
pub const MT_TRAINSTEAMSPAWNER: mobj_type = 345;
pub const MT_TRAINDUSTSPAWNER: mobj_type = 344;
pub const MT_TRAINSEG: mobj_type = 343;
pub const MT_TRAINCAMEOSPAWNER: mobj_type = 342;
pub const MT_SALOONDOORCENTER: mobj_type = 341;
pub const MT_SALOONDOOR: mobj_type = 340;
pub const MT_MINECARTSPARK: mobj_type = 339;
pub const MT_MINECARTSIDEMARK: mobj_type = 338;
pub const MT_MINECARTENDSOLID: mobj_type = 337;
pub const MT_MINECARTEND: mobj_type = 336;
pub const MT_MINECARTSPAWNER: mobj_type = 335;
pub const MT_MINECARTSEG: mobj_type = 334;
pub const MT_MINECART: mobj_type = 333;
pub const MT_ARIDDUST: mobj_type = 332;
pub const MT_DUSTLAYER: mobj_type = 331;
pub const MT_DUSTDEVIL: mobj_type = 330;
pub const MT_PROXIMITYTNT: mobj_type = 329;
pub const MT_TNTBARREL: mobj_type = 328;
pub const MT_OILLAMP: mobj_type = 327;
pub const MT_ARIDSIGN_SHARPTURN: mobj_type = 326;
pub const MT_ARIDSIGN_CACTI: mobj_type = 325;
pub const MT_ARIDSIGN_CAUTION: mobj_type = 324;
pub const MT_CACTISMALLSEG: mobj_type = 323;
pub const MT_CACTITINYSEG: mobj_type = 322;
pub const MT_CACTI11: mobj_type = 321;
pub const MT_CACTI10: mobj_type = 320;
pub const MT_CACTI9: mobj_type = 319;
pub const MT_CACTI8: mobj_type = 318;
pub const MT_CACTI7: mobj_type = 317;
pub const MT_CACTI6: mobj_type = 316;
pub const MT_CACTI5: mobj_type = 315;
pub const MT_CACTI4: mobj_type = 314;
pub const MT_CACTI3: mobj_type = 313;
pub const MT_CACTI2: mobj_type = 312;
pub const MT_CACTI1: mobj_type = 311;
pub const MT_LITTLETUMBLEWEED: mobj_type = 310;
pub const MT_BIGTUMBLEWEED: mobj_type = 309;
pub const MT_BRAMBLES: mobj_type = 308;
pub const MT_SUSPICIOUSFACESTABBERSTATUE: mobj_type = 307;
pub const MT_FACESTABBERSTATUE: mobj_type = 306;
pub const MT_CRAWLASTATUE: mobj_type = 305;
pub const MT_WAVINGFLAGSEG2: mobj_type = 304;
pub const MT_WAVINGFLAGSEG1: mobj_type = 303;
pub const MT_WAVINGFLAG2: mobj_type = 302;
pub const MT_WAVINGFLAG1: mobj_type = 301;
pub const MT_FIRETORCH: mobj_type = 300;
pub const MT_FLAMEHOLDER: mobj_type = 299;
pub const MT_CANDLEPRICKET: mobj_type = 298;
pub const MT_CANDLE: mobj_type = 297;
pub const MT_CEZBUSH2: mobj_type = 296;
pub const MT_CEZBUSH1: mobj_type = 295;
pub const MT_PINETREE: mobj_type = 294;
pub const MT_CEZBANNER2: mobj_type = 293;
pub const MT_CEZBANNER1: mobj_type = 292;
pub const MT_CEZPOLE2: mobj_type = 291;
pub const MT_CEZPOLE1: mobj_type = 290;
pub const MT_CEZFLOWER: mobj_type = 289;
pub const MT_BIGFIREBAR: mobj_type = 288;
pub const MT_SMALLFIREBAR: mobj_type = 287;
pub const MT_REDSPRINGBALL: mobj_type = 286;
pub const MT_YELLOWSPRINGBALL: mobj_type = 285;
pub const MT_BIGGRABCHAIN: mobj_type = 284;
pub const MT_SMALLGRABCHAIN: mobj_type = 283;
pub const MT_BIGMACE: mobj_type = 282;
pub const MT_SMALLMACE: mobj_type = 281;
pub const MT_BIGMACECHAIN: mobj_type = 280;
pub const MT_SMALLMACECHAIN: mobj_type = 279;
pub const MT_CUSTOMMACEPOINT: mobj_type = 278;
pub const MT_FIREBARPOINT: mobj_type = 277;
pub const MT_HIDDEN_SLING: mobj_type = 276;
pub const MT_CHAINPOINT: mobj_type = 275;
pub const MT_SPRINGBALLPOINT: mobj_type = 274;
pub const MT_CHAINMACEPOINT: mobj_type = 273;
pub const MT_MACEPOINT: mobj_type = 272;
pub const MT_EGGSTATUE: mobj_type = 271;
pub const MT_FLAMEPARTICLE: mobj_type = 270;
pub const MT_FLAME: mobj_type = 269;
pub const MT_CHAIN: mobj_type = 268;
pub const MT_LIGHTBEAM: mobj_type = 267;
pub const MT_DSZ2STALAGMITE: mobj_type = 266;
pub const MT_DSZSTALAGMITE: mobj_type = 265;
pub const MT_ANIMALGAESEG: mobj_type = 264;
pub const MT_ANIMALGAETOP: mobj_type = 263;
pub const MT_KELP: mobj_type = 262;
pub const MT_BLUECRYSTAL: mobj_type = 261;
pub const MT_CORAL5: mobj_type = 260;
pub const MT_CORAL4: mobj_type = 259;
pub const MT_CORAL3: mobj_type = 258;
pub const MT_CORAL2: mobj_type = 257;
pub const MT_CORAL1: mobj_type = 256;
pub const MT_WATERDROP: mobj_type = 255;
pub const MT_WATERDRIP: mobj_type = 254;
pub const MT_SEAWEED: mobj_type = 253;
pub const MT_BIGGARGOYLE: mobj_type = 252;
pub const MT_GARGOYLE: mobj_type = 251;
pub const MT_ALARM: mobj_type = 250;
pub const MT_THZTREEBRANCH: mobj_type = 249;
pub const MT_THZTREE: mobj_type = 248;
pub const MT_THZFLOWER3: mobj_type = 247;
pub const MT_THZFLOWER2: mobj_type = 246;
pub const MT_THZFLOWER1: mobj_type = 245;
pub const MT_SPRINGTREE: mobj_type = 244;
pub const MT_BUSHREDTREE: mobj_type = 243;
pub const MT_BUSHTREE: mobj_type = 242;
pub const MT_POLYGONTREE: mobj_type = 241;
pub const MT_FHZPINKTREE: mobj_type = 240;
pub const MT_FHZTREE: mobj_type = 239;
pub const MT_CHECKERSUNSETTREE: mobj_type = 238;
pub const MT_CHECKERTREE: mobj_type = 237;
pub const MT_GFZCHERRYTREE: mobj_type = 236;
pub const MT_GFZBERRYTREE: mobj_type = 235;
pub const MT_GFZTREE: mobj_type = 234;
pub const MT_BUSH: mobj_type = 233;
pub const MT_BERRYBUSH: mobj_type = 232;
pub const MT_BLUEBERRYBUSH: mobj_type = 231;
pub const MT_GFZFLOWER3: mobj_type = 230;
pub const MT_GFZFLOWER2: mobj_type = 229;
pub const MT_GFZFLOWER1: mobj_type = 228;
pub const MT_TUTORIALFLOWERF: mobj_type = 227;
pub const MT_TUTORIALFLOWER: mobj_type = 226;
pub const MT_TUTORIALLEAF: mobj_type = 225;
pub const MT_TUTORIALPLANT: mobj_type = 224;
pub const MT_LETTER: mobj_type = 223;
pub const MT_DEMONFIRE: mobj_type = 222;
pub const MT_ARROW: mobj_type = 221;
pub const MT_CANNONBALLDECOR: mobj_type = 220;
pub const MT_CANNONBALL: mobj_type = 219;
pub const MT_TURRETLASER: mobj_type = 218;
pub const MT_JETTBULLET: mobj_type = 217;
pub const MT_MINE: mobj_type = 216;
pub const MT_ENERGYBALL: mobj_type = 215;
pub const MT_TORPEDO2: mobj_type = 214;
pub const MT_TORPEDO: mobj_type = 213;
pub const MT_LASER: mobj_type = 212;
pub const MT_ROCKET: mobj_type = 211;
pub const MT_THUNDERCOIN_ICON: mobj_type = 210;
pub const MT_BUBBLEWRAP_ICON: mobj_type = 209;
pub const MT_FLAMEAURA_ICON: mobj_type = 208;
pub const MT_SCORE10K_ICON: mobj_type = 207;
pub const MT_SCORE1K_ICON: mobj_type = 206;
pub const MT_RECYCLER_ICON: mobj_type = 205;
pub const MT_GRAVITY_ICON: mobj_type = 204;
pub const MT_MIXUP_ICON: mobj_type = 203;
pub const MT_EGGMAN_ICON: mobj_type = 202;
pub const MT_1UP_ICON: mobj_type = 201;
pub const MT_INVULN_ICON: mobj_type = 200;
pub const MT_SNEAKERS_ICON: mobj_type = 199;
pub const MT_ELEMENTAL_ICON: mobj_type = 198;
pub const MT_WHIRLWIND_ICON: mobj_type = 197;
pub const MT_ARMAGEDDON_ICON: mobj_type = 196;
pub const MT_FORCE_ICON: mobj_type = 195;
pub const MT_ATTRACT_ICON: mobj_type = 194;
pub const MT_PITY_ICON: mobj_type = 193;
pub const MT_RING_ICON: mobj_type = 192;
pub const MT_RING_BLUEBOX: mobj_type = 191;
pub const MT_RING_REDBOX: mobj_type = 190;
pub const MT_THUNDERCOIN_GOLDBOX: mobj_type = 189;
pub const MT_BUBBLEWRAP_GOLDBOX: mobj_type = 188;
pub const MT_FLAMEAURA_GOLDBOX: mobj_type = 187;
pub const MT_GRAVITY_GOLDBOX: mobj_type = 186;
pub const MT_EGGMAN_GOLDBOX: mobj_type = 185;
pub const MT_INVULN_GOLDBOX: mobj_type = 184;
pub const MT_SNEAKERS_GOLDBOX: mobj_type = 183;
pub const MT_ELEMENTAL_GOLDBOX: mobj_type = 182;
pub const MT_WHIRLWIND_GOLDBOX: mobj_type = 181;
pub const MT_ARMAGEDDON_GOLDBOX: mobj_type = 180;
pub const MT_FORCE_GOLDBOX: mobj_type = 179;
pub const MT_ATTRACT_GOLDBOX: mobj_type = 178;
pub const MT_PITY_GOLDBOX: mobj_type = 177;
pub const MT_THUNDERCOIN_BOX: mobj_type = 176;
pub const MT_BUBBLEWRAP_BOX: mobj_type = 175;
pub const MT_FLAMEAURA_BOX: mobj_type = 174;
pub const MT_SCORE10K_BOX: mobj_type = 173;
pub const MT_SCORE1K_BOX: mobj_type = 172;
pub const MT_RECYCLER_BOX: mobj_type = 171;
pub const MT_GRAVITY_BOX: mobj_type = 170;
pub const MT_MYSTERY_BOX: mobj_type = 169;
pub const MT_MIXUP_BOX: mobj_type = 168;
pub const MT_EGGMAN_BOX: mobj_type = 167;
pub const MT_1UP_BOX: mobj_type = 166;
pub const MT_INVULN_BOX: mobj_type = 165;
pub const MT_SNEAKERS_BOX: mobj_type = 164;
pub const MT_ELEMENTAL_BOX: mobj_type = 163;
pub const MT_WHIRLWIND_BOX: mobj_type = 162;
pub const MT_ARMAGEDDON_BOX: mobj_type = 161;
pub const MT_FORCE_BOX: mobj_type = 160;
pub const MT_ATTRACT_BOX: mobj_type = 159;
pub const MT_PITY_BOX: mobj_type = 158;
pub const MT_RING_BOX: mobj_type = 157;
pub const MT_BOXSPARKLE: mobj_type = 156;
pub const MT_CANNONLAUNCHER: mobj_type = 155;
pub const MT_BLASTEXECUTOR: mobj_type = 154;
pub const MT_BIGMINE: mobj_type = 153;
pub const MT_STARPOST: mobj_type = 152;
pub const MT_WALLSPIKEBASE: mobj_type = 151;
pub const MT_WALLSPIKE: mobj_type = 150;
pub const MT_SPIKE: mobj_type = 149;
pub const MT_SPINFIRE: mobj_type = 148;
pub const MT_SPIKEBALL: mobj_type = 147;
pub const MT_SIGN: mobj_type = 146;
pub const MT_BUBBLES: mobj_type = 145;
pub const MT_REDBOOSTER: mobj_type = 144;
pub const MT_YELLOWBOOSTER: mobj_type = 143;
pub const MT_BOOSTERROLLER: mobj_type = 142;
pub const MT_BOOSTERSEG: mobj_type = 141;
pub const MT_BLUEHORIZ: mobj_type = 140;
pub const MT_REDHORIZ: mobj_type = 139;
pub const MT_YELLOWHORIZ: mobj_type = 138;
pub const MT_BLUEDIAG: mobj_type = 137;
pub const MT_REDDIAG: mobj_type = 136;
pub const MT_YELLOWDIAG: mobj_type = 135;
pub const MT_BLUESPRING: mobj_type = 134;
pub const MT_REDSPRING: mobj_type = 133;
pub const MT_YELLOWSPRING: mobj_type = 132;
pub const MT_BALLOON: mobj_type = 131;
pub const MT_BUMPER: mobj_type = 130;
pub const MT_STEAM: mobj_type = 129;
pub const MT_FAN: mobj_type = 128;
pub const MT_FLINGEMERALD: mobj_type = 127;
pub const MT_EMERALDSPAWN: mobj_type = 126;
pub const MT_EMERHUNT: mobj_type = 125;
pub const MT_EMERALD7: mobj_type = 124;
pub const MT_EMERALD6: mobj_type = 123;
pub const MT_EMERALD5: mobj_type = 122;
pub const MT_EMERALD4: mobj_type = 121;
pub const MT_EMERALD3: mobj_type = 120;
pub const MT_EMERALD2: mobj_type = 119;
pub const MT_EMERALD1: mobj_type = 118;
pub const MT_EMBLEM: mobj_type = 117;
pub const MT_BLUEFLAG: mobj_type = 116;
pub const MT_REDFLAG: mobj_type = 115;
pub const MT_TOKEN: mobj_type = 114;
pub const MT_BLUETEAMRING: mobj_type = 113;
pub const MT_REDTEAMRING: mobj_type = 112;
pub const MT_BOMBSPHERE: mobj_type = 111;
pub const MT_FLINGBLUESPHERE: mobj_type = 110;
pub const MT_BLUESPHERE: mobj_type = 109;
pub const MT_FLINGRING: mobj_type = 108;
pub const MT_RING: mobj_type = 107;
pub const MT_MSGATHER: mobj_type = 106;
pub const MT_MSSHIELD_FRONT: mobj_type = 105;
pub const MT_METALSONIC_BATTLE: mobj_type = 104;
pub const MT_METALSONIC_RACE: mobj_type = 103;
pub const MT_CYBRAKDEMON_VILE_EXPLOSION: mobj_type = 102;
pub const MT_CYBRAKDEMON_NAPALM_FLAMES: mobj_type = 101;
pub const MT_CYBRAKDEMON_NAPALM_BOMB_SMALL: mobj_type = 100;
pub const MT_CYBRAKDEMON_NAPALM_BOMB_LARGE: mobj_type = 99;
pub const MT_CYBRAKDEMON_TARGET_DOT: mobj_type = 98;
pub const MT_CYBRAKDEMON_TARGET_RETICULE: mobj_type = 97;
pub const MT_CYBRAKDEMON_FLAMEREST: mobj_type = 96;
pub const MT_CYBRAKDEMON_FLAMESHOT: mobj_type = 95;
pub const MT_CYBRAKDEMON_MISSILE: mobj_type = 94;
pub const MT_CYBRAKDEMON_ELECTRIC_BARRIER: mobj_type = 93;
pub const MT_CYBRAKDEMON: mobj_type = 92;
pub const MT_BLACKEGGMAN_MISSILE: mobj_type = 91;
pub const MT_BLACKEGGMAN_GOOPFIRE: mobj_type = 90;
pub const MT_BLACKEGGMAN_HELPER: mobj_type = 89;
pub const MT_BLACKEGGMAN: mobj_type = 88;
pub const MT_FANGWAYPOINT: mobj_type = 87;
pub const MT_FSGNB: mobj_type = 86;
pub const MT_FSGNA: mobj_type = 85;
pub const MT_TNTDUST: mobj_type = 84;
pub const MT_FBOMB: mobj_type = 83;
pub const MT_PROJECTORLIGHT: mobj_type = 82;
pub const MT_VWREB: mobj_type = 81;
pub const MT_VWREF: mobj_type = 80;
pub const MT_BROKENROBOT: mobj_type = 79;
pub const MT_FANG: mobj_type = 78;
pub const MT_EGGROBO1JET: mobj_type = 77;
pub const MT_EGGROBO1: mobj_type = 76;
pub const MT_JETFLAME: mobj_type = 75;
pub const MT_EGGMOBILE4_MACE: mobj_type = 74;
pub const MT_EGGMOBILE4: mobj_type = 73;
pub const MT_SHOCKWAVE: mobj_type = 72;
pub const MT_FAKEMOBILE: mobj_type = 71;
pub const MT_EGGMOBILE3: mobj_type = 70;
pub const MT_GOOPTRAIL: mobj_type = 69;
pub const MT_GOOP: mobj_type = 68;
pub const MT_EGGMOBILE2_POGO: mobj_type = 67;
pub const MT_EGGMOBILE2: mobj_type = 66;
pub const MT_EGGMOBILE_FIRE: mobj_type = 65;
pub const MT_EGGMOBILE_TARGET: mobj_type = 64;
pub const MT_EGGMOBILE_BALL: mobj_type = 63;
pub const MT_JETFUME1: mobj_type = 62;
pub const MT_EGGMOBILE: mobj_type = 61;
pub const MT_BOSSJUNK: mobj_type = 60;
pub const MT_BOSS9GATHERPOINT: mobj_type = 59;
pub const MT_BOSS3WAYPOINT: mobj_type = 58;
pub const MT_EGGTRAP: mobj_type = 57;
pub const MT_BOSSFLYPOINT: mobj_type = 56;
pub const MT_SONIC3KBOSSEXPLODE: mobj_type = 55;
pub const MT_BOSSEXPLODE: mobj_type = 54;
pub const MT_DRAGONMINE: mobj_type = 53;
pub const MT_DRAGONTAIL: mobj_type = 52;
pub const MT_DRAGONWING: mobj_type = 51;
pub const MT_DRAGONBOMBER: mobj_type = 50;
pub const MT_PTERABYTE: mobj_type = 49;
pub const MT_PTERABYTEWAYPOINT: mobj_type = 48;
pub const MT_PTERABYTESPAWNER: mobj_type = 47;
pub const MT_PYREFLY_FIRE: mobj_type = 46;
pub const MT_PYREFLY: mobj_type = 45;
pub const MT_CANARIVORE_GAS: mobj_type = 44;
pub const MT_CANARIVORE: mobj_type = 43;
pub const MT_UNIBALL: mobj_type = 42;
pub const MT_UNIDUS: mobj_type = 41;
pub const MT_YELLOWSHELL: mobj_type = 40;
pub const MT_SPRINGSHELL: mobj_type = 39;
pub const MT_MINUSDIRT: mobj_type = 38;
pub const MT_MINUS: mobj_type = 37;
pub const MT_SNAPPER_HEAD: mobj_type = 36;
pub const MT_SNAPPER_LEG: mobj_type = 35;
pub const MT_GSNAPPER: mobj_type = 34;
pub const MT_EGGSHIELD: mobj_type = 33;
pub const MT_EGGGUARD: mobj_type = 32;
pub const MT_FACESTABBERSPEAR: mobj_type = 31;
pub const MT_FACESTABBER: mobj_type = 30;
pub const MT_ROBOHOOD: mobj_type = 29;
pub const MT_POINTYBALL: mobj_type = 28;
pub const MT_POINTY: mobj_type = 27;
pub const MT_VULTURE: mobj_type = 26;
pub const MT_SNAILER: mobj_type = 25;
pub const MT_JETJAW: mobj_type = 24;
pub const MT_BANPSPRING: mobj_type = 23;
pub const MT_BANPYURA: mobj_type = 22;
pub const MT_CRUSHCHAIN: mobj_type = 21;
pub const MT_CRUSHCLAW: mobj_type = 20;
pub const MT_CRUSHSTACEAN: mobj_type = 19;
pub const MT_SPINCUSHION: mobj_type = 18;
pub const MT_POPUPTURRET: mobj_type = 17;
pub const MT_TURRET: mobj_type = 16;
pub const MT_SKIM: mobj_type = 15;
pub const MT_DETON: mobj_type = 14;
pub const MT_CRAWLACOMMANDER: mobj_type = 13;
pub const MT_JETTGUNNER: mobj_type = 12;
pub const MT_JETTBOMBER: mobj_type = 11;
pub const MT_REDBUZZ: mobj_type = 10;
pub const MT_GOLDBUZZ: mobj_type = 9;
pub const MT_GFZFISH: mobj_type = 8;
pub const MT_REDCRAWLA: mobj_type = 7;
pub const MT_BLUECRAWLA: mobj_type = 6;
pub const MT_METALJETFUME: mobj_type = 5;
pub const MT_TAILSOVERLAY: mobj_type = 4;
pub const MT_PLAYER: mobj_type = 3;
pub const MT_THOK: mobj_type = 2;
pub const MT_UNKNOWN: mobj_type = 1;
pub const MT_NULL: mobj_type = 0;
pub type panim_t = libc::c_uint;
pub const PA_RIDE: panim_t = 13;
pub const PA_ABILITY2: panim_t = 12;
pub const PA_ABILITY: panim_t = 11;
pub const PA_FALL: panim_t = 10;
pub const PA_SPRING: panim_t = 9;
pub const PA_JUMP: panim_t = 8;
pub const PA_ROLL: panim_t = 7;
pub const PA_PAIN: panim_t = 6;
pub const PA_DASH: panim_t = 5;
pub const PA_RUN: panim_t = 4;
pub const PA_WALK: panim_t = 3;
pub const PA_EDGE: panim_t = 2;
pub const PA_IDLE: panim_t = 1;
pub const PA_ETC: panim_t = 0;
pub type pflags_t = libc::c_uint;
pub const PF_FINISHED: pflags_t = 1073741824;
pub const PF_CANCARRY: pflags_t = 536870912;
pub const PF_FORCESTRAFE: pflags_t = 268435456;
pub const PF_TAGIT: pflags_t = 134217728;
pub const PF_GAMETYPEOVER: pflags_t = 67108864;
pub const PF_DRILLING: pflags_t = 33554432;
pub const PF_TRANSFERTOCLOSEST: pflags_t = 16777216;
pub const PF_SLIDING: pflags_t = 8388608;
pub const PF_BOUNCING: pflags_t = 4194304;
pub const PF_GLIDING: pflags_t = 2097152;
pub const PF_SHIELDABILITY: pflags_t = 1048576;
pub const PF_THOKKED: pflags_t = 524288;
pub const PF_STARTDASH: pflags_t = 262144;
pub const PF_SPINNING: pflags_t = 131072;
pub const PF_NOJUMPDAMAGE: pflags_t = 65536;
pub const PF_JUMPED: pflags_t = 32768;
pub const PF_STARTJUMP: pflags_t = 16384;
pub const PF_APPLYAUTOBRAKE: pflags_t = 8192;
pub const PF_FULLSTASIS: pflags_t = 6144;
pub const PF_JUMPSTASIS: pflags_t = 4096;
pub const PF_STASIS: pflags_t = 2048;
pub const PF_WPNDOWN: pflags_t = 1024;
pub const PF_JUMPDOWN: pflags_t = 512;
pub const PF_SPINDOWN: pflags_t = 256;
pub const PF_ATTACKDOWN: pflags_t = 128;
pub const PF_INVIS: pflags_t = 64;
pub const PF_NOCLIP: pflags_t = 32;
pub const PF_GODMODE: pflags_t = 16;
pub const PF_AUTOBRAKE: pflags_t = 8;
pub const PF_DIRECTIONCHAR: pflags_t = 4;
pub const PF_ANALOGMODE: pflags_t = 2;
pub const PF_FLIPCAM: pflags_t = 1;
pub type playerstate_t = libc::c_uint;
pub const PST_REBORN: playerstate_t = 2;
pub const PST_DEAD: playerstate_t = 1;
pub const PST_LIVE: playerstate_t = 0;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct ticcmd_t {
    pub forwardmove: int8_t,
    pub sidemove: int8_t,
    pub angleturn: int16_t,
    pub aiming: int16_t,
    pub buttons: uint16_t,
    pub latency: uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mobjinfo_t {
    pub doomednum: int32_t,
    pub spawnstate: statenum_t,
    pub spawnhealth: int32_t,
    pub seestate: statenum_t,
    pub seesound: sfxenum_t,
    pub reactiontime: int32_t,
    pub attacksound: sfxenum_t,
    pub painstate: statenum_t,
    pub painchance: int32_t,
    pub painsound: sfxenum_t,
    pub meleestate: statenum_t,
    pub missilestate: statenum_t,
    pub deathstate: statenum_t,
    pub xdeathstate: statenum_t,
    pub deathsound: sfxenum_t,
    pub speed: fixed_t,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub dispoffset: int32_t,
    pub mass: int32_t,
    pub damage: int32_t,
    pub activesound: sfxenum_t,
    pub flags: uint32_t,
    pub raisestate: statenum_t,
}
pub type statenum_t = state;
pub type state = libc::c_uint;
pub const NUMSTATES: state = 6735;
pub const S_LASTFREESLOT: state = 6734;
pub const S_FIRSTFREESLOT: state = 2639;
pub const S_NAMECHECK: state = 2638;
pub const S_YELLOWBRICKDEBRIS: state = 2637;
pub const S_BLUEBRICKDEBRIS: state = 2636;
pub const S_REDBRICKDEBRIS: state = 2635;
pub const S_WOODDEBRIS: state = 2634;
pub const S_BRICKDEBRIS: state = 2633;
pub const S_GFZDEBRIS: state = 2632;
pub const S_ROCKCRUMBLEP: state = 2631;
pub const S_ROCKCRUMBLEO: state = 2630;
pub const S_ROCKCRUMBLEN: state = 2629;
pub const S_ROCKCRUMBLEM: state = 2628;
pub const S_ROCKCRUMBLEL: state = 2627;
pub const S_ROCKCRUMBLEK: state = 2626;
pub const S_ROCKCRUMBLEJ: state = 2625;
pub const S_ROCKCRUMBLEI: state = 2624;
pub const S_ROCKCRUMBLEH: state = 2623;
pub const S_ROCKCRUMBLEG: state = 2622;
pub const S_ROCKCRUMBLEF: state = 2621;
pub const S_ROCKCRUMBLEE: state = 2620;
pub const S_ROCKCRUMBLED: state = 2619;
pub const S_ROCKCRUMBLEC: state = 2618;
pub const S_ROCKCRUMBLEB: state = 2617;
pub const S_ROCKCRUMBLEA: state = 2616;
pub const S_ROCKSPAWN: state = 2615;
pub const S_DUST4: state = 2614;
pub const S_DUST3: state = 2613;
pub const S_DUST2: state = 2612;
pub const S_DUST1: state = 2611;
pub const S_WPLD6: state = 2610;
pub const S_WPLD5: state = 2609;
pub const S_WPLD4: state = 2608;
pub const S_WPLD3: state = 2607;
pub const S_WPLD2: state = 2606;
pub const S_WPLD1: state = 2605;
pub const S_XPLD_EGGTRAP: state = 2604;
pub const S_XPLD6: state = 2603;
pub const S_XPLD5: state = 2602;
pub const S_XPLD4: state = 2601;
pub const S_XPLD3: state = 2600;
pub const S_XPLD2: state = 2599;
pub const S_XPLD1: state = 2598;
pub const S_XPLD_FLICKY: state = 2597;
pub const S_SPRK3: state = 2596;
pub const S_SPRK2: state = 2595;
pub const S_SPRK1: state = 2594;
pub const S_CRUMBLE2: state = 2593;
pub const S_CRUMBLE1: state = 2592;
pub const S_HANGSTER_RETURN3: state = 2591;
pub const S_HANGSTER_RETURN2: state = 2590;
pub const S_HANGSTER_RETURN1: state = 2589;
pub const S_HANGSTER_ARCUP3: state = 2588;
pub const S_HANGSTER_ARCUP2: state = 2587;
pub const S_HANGSTER_ARCUP1: state = 2586;
pub const S_HANGSTER_FLYREPEAT: state = 2585;
pub const S_HANGSTER_FLY4: state = 2584;
pub const S_HANGSTER_FLY3: state = 2583;
pub const S_HANGSTER_FLY2: state = 2582;
pub const S_HANGSTER_FLY1: state = 2581;
pub const S_HANGSTER_ARC3: state = 2580;
pub const S_HANGSTER_ARC2: state = 2579;
pub const S_HANGSTER_ARC1: state = 2578;
pub const S_HANGSTER_SWOOP2: state = 2577;
pub const S_HANGSTER_SWOOP1: state = 2576;
pub const S_HANGSTER_LOOK: state = 2575;
pub const S_SPINBOBERT_FIRE_TRAIL3: state = 2574;
pub const S_SPINBOBERT_FIRE_TRAIL2: state = 2573;
pub const S_SPINBOBERT_FIRE_TRAIL1: state = 2572;
pub const S_SPINBOBERT_FIRE_GHOST: state = 2571;
pub const S_SPINBOBERT_FIRE_MOVE: state = 2570;
pub const S_SPINBOBERT_MOVE_DOWN: state = 2569;
pub const S_SPINBOBERT_MOVE_FLIPDOWN: state = 2568;
pub const S_SPINBOBERT_MOVE_UP: state = 2567;
pub const S_SPINBOBERT_MOVE_FLIPUP: state = 2566;
pub const S_CACOFIRE_EXPLODE4: state = 2565;
pub const S_CACOFIRE_EXPLODE3: state = 2564;
pub const S_CACOFIRE_EXPLODE2: state = 2563;
pub const S_CACOFIRE_EXPLODE1: state = 2562;
pub const S_CACOFIRE3: state = 2561;
pub const S_CACOFIRE2: state = 2560;
pub const S_CACOFIRE1: state = 2559;
pub const S_CACOSHARD2_2: state = 2558;
pub const S_CACOSHARD2_1: state = 2557;
pub const S_CACOSHARD1_2: state = 2556;
pub const S_CACOSHARD1_1: state = 2555;
pub const S_CACOSHARD_RANDOMIZE: state = 2554;
pub const S_CACO_DIE_FALL: state = 2553;
pub const S_CACO_DIE_SHATTER: state = 2552;
pub const S_CACO_DIE_SCREAM: state = 2551;
pub const S_CACO_DIE_GIB2: state = 2550;
pub const S_CACO_DIE_GIB1: state = 2549;
pub const S_CACO_DIE_FLAGS: state = 2548;
pub const S_CACO_CLOSE: state = 2547;
pub const S_CACO_SHOOT2: state = 2546;
pub const S_CACO_SHOOT1: state = 2545;
pub const S_CACO_SHOOT_SOUND: state = 2544;
pub const S_CACO_PREPARE3: state = 2543;
pub const S_CACO_PREPARE2: state = 2542;
pub const S_CACO_PREPARE1: state = 2541;
pub const S_CACO_PREPARE_SOUND: state = 2540;
pub const S_CACO_RANDOM: state = 2539;
pub const S_CACO_CHASE_REPEAT: state = 2538;
pub const S_CACO_CHASE: state = 2537;
pub const S_CACO_ROAR: state = 2536;
pub const S_CACO_WAKE4: state = 2535;
pub const S_CACO_WAKE3: state = 2534;
pub const S_CACO_WAKE2: state = 2533;
pub const S_CACO_WAKE1: state = 2532;
pub const S_CACO_LOOK: state = 2531;
pub const S_SMASHSPIKE_RISE2: state = 2530;
pub const S_SMASHSPIKE_RISE1: state = 2529;
pub const S_SMASHSPIKE_STOMP2: state = 2528;
pub const S_SMASHSPIKE_STOMP1: state = 2527;
pub const S_SMASHSPIKE_FALL: state = 2526;
pub const S_SMASHSPIKE_EASE2: state = 2525;
pub const S_SMASHSPIKE_EASE1: state = 2524;
pub const S_SMASHSPIKE_FLOAT: state = 2523;
pub const S_BUGGLEFLY: state = 2522;
pub const S_BUGGLEIDLE: state = 2521;
pub const S_BUMBLEBORE_DIE: state = 2520;
pub const S_BUMBLEBORE_STUCK2: state = 2519;
pub const S_BUMBLEBORE_STUCK1: state = 2518;
pub const S_BUMBLEBORE_FALL2: state = 2517;
pub const S_BUMBLEBORE_FALL1: state = 2516;
pub const S_BUMBLEBORE_RAISE: state = 2515;
pub const S_BUMBLEBORE_FLY2: state = 2514;
pub const S_BUMBLEBORE_FLY1: state = 2513;
pub const S_BUMBLEBORE_LOOK2: state = 2512;
pub const S_BUMBLEBORE_LOOK1: state = 2511;
pub const S_BUMBLEBORE_SPAWN: state = 2510;
pub const S_HIVEELEMENTAL_DIE3: state = 2509;
pub const S_HIVEELEMENTAL_DIE2: state = 2508;
pub const S_HIVEELEMENTAL_DIE1: state = 2507;
pub const S_HIVEELEMENTAL_PAIN: state = 2506;
pub const S_HIVEELEMENTAL_DORMANT: state = 2505;
pub const S_HIVEELEMENTAL_SHOOT2: state = 2504;
pub const S_HIVEELEMENTAL_SHOOT1: state = 2503;
pub const S_HIVEELEMENTAL_PREPARE2: state = 2502;
pub const S_HIVEELEMENTAL_PREPARE1: state = 2501;
pub const S_HIVEELEMENTAL_LOOK: state = 2500;
pub const S_POPSHOT_TRAIL: state = 2499;
pub const S_POPSHOT: state = 2498;
pub const S_POPHAT_SHOOT4: state = 2497;
pub const S_POPHAT_SHOOT3: state = 2496;
pub const S_POPHAT_SHOOT2: state = 2495;
pub const S_POPHAT_SHOOT1: state = 2494;
pub const S_POPHAT_LOOK: state = 2493;
pub const S_PENGUINATOR_SLIDE5: state = 2492;
pub const S_PENGUINATOR_SLIDE4: state = 2491;
pub const S_PENGUINATOR_SLIDE3: state = 2490;
pub const S_PENGUINATOR_SLIDE2: state = 2489;
pub const S_PENGUINATOR_SLIDE1: state = 2488;
pub const S_PENGUINATOR_WADDLE4: state = 2487;
pub const S_PENGUINATOR_WADDLE3: state = 2486;
pub const S_PENGUINATOR_WADDLE2: state = 2485;
pub const S_PENGUINATOR_WADDLE1: state = 2484;
pub const S_PENGUINATOR_LOOK: state = 2483;
pub const S_SHLEEPBOUNCE3: state = 2482;
pub const S_SHLEEPBOUNCE2: state = 2481;
pub const S_SHLEEPBOUNCE1: state = 2480;
pub const S_SHLEEP4: state = 2479;
pub const S_SHLEEP3: state = 2478;
pub const S_SHLEEP2: state = 2477;
pub const S_SHLEEP1: state = 2476;
pub const S_PIAN_SING: state = 2475;
pub const S_PIAN_FLY3: state = 2474;
pub const S_PIAN_FLY2: state = 2473;
pub const S_PIAN_FLY1: state = 2472;
pub const S_PIAN_LOOK3: state = 2471;
pub const S_PIAN_LOOK2: state = 2470;
pub const S_PIAN_LOOK1: state = 2469;
pub const S_NIGHTOPIANHELPER9: state = 2468;
pub const S_NIGHTOPIANHELPER8: state = 2467;
pub const S_NIGHTOPIANHELPER7: state = 2466;
pub const S_NIGHTOPIANHELPER6: state = 2465;
pub const S_NIGHTOPIANHELPER5: state = 2464;
pub const S_NIGHTOPIANHELPER4: state = 2463;
pub const S_NIGHTOPIANHELPER3: state = 2462;
pub const S_NIGHTOPIANHELPER2: state = 2461;
pub const S_NIGHTOPIANHELPER1: state = 2460;
pub const S_ORBIDYA5: state = 2459;
pub const S_ORBIDYA4: state = 2458;
pub const S_ORBIDYA3: state = 2457;
pub const S_ORBIDYA2: state = 2456;
pub const S_ORBIDYA1: state = 2455;
pub const S_ORBITEM8: state = 2454;
pub const S_ORBITEM7: state = 2453;
pub const S_ORBITEM6: state = 2452;
pub const S_ORBITEM5: state = 2451;
pub const S_ORBITEM4: state = 2450;
pub const S_ORBITEM3: state = 2449;
pub const S_ORBITEM2: state = 2448;
pub const S_ORBITEM1: state = 2447;
pub const S_EGGCAPSULE: state = 2446;
pub const S_NIGHTSLINKFREEZE: state = 2445;
pub const S_NIGHTSEXTRATIME: state = 2444;
pub const S_NIGHTSHELPER: state = 2443;
pub const S_NIGHTSDRILLREFILL: state = 2442;
pub const S_NIGHTSSUPERLOOP: state = 2441;
pub const S_NIGHTSCORE100_2: state = 2440;
pub const S_NIGHTSCORE90_2: state = 2439;
pub const S_NIGHTSCORE80_2: state = 2438;
pub const S_NIGHTSCORE70_2: state = 2437;
pub const S_NIGHTSCORE60_2: state = 2436;
pub const S_NIGHTSCORE50_2: state = 2435;
pub const S_NIGHTSCORE40_2: state = 2434;
pub const S_NIGHTSCORE30_2: state = 2433;
pub const S_NIGHTSCORE20_2: state = 2432;
pub const S_NIGHTSCORE10_2: state = 2431;
pub const S_NIGHTSCORE100: state = 2430;
pub const S_NIGHTSCORE90: state = 2429;
pub const S_NIGHTSCORE80: state = 2428;
pub const S_NIGHTSCORE70: state = 2427;
pub const S_NIGHTSCORE60: state = 2426;
pub const S_NIGHTSCORE50: state = 2425;
pub const S_NIGHTSCORE40: state = 2424;
pub const S_NIGHTSCORE30: state = 2423;
pub const S_NIGHTSCORE20: state = 2422;
pub const S_NIGHTSCORE10: state = 2421;
pub const S_HOOP_XMASB: state = 2420;
pub const S_HOOP_XMASA: state = 2419;
pub const S_HOOP: state = 2418;
pub const S_NIGHTSBUMPER12: state = 2417;
pub const S_NIGHTSBUMPER11: state = 2416;
pub const S_NIGHTSBUMPER10: state = 2415;
pub const S_NIGHTSBUMPER9: state = 2414;
pub const S_NIGHTSBUMPER8: state = 2413;
pub const S_NIGHTSBUMPER7: state = 2412;
pub const S_NIGHTSBUMPER6: state = 2411;
pub const S_NIGHTSBUMPER5: state = 2410;
pub const S_NIGHTSBUMPER4: state = 2409;
pub const S_NIGHTSBUMPER3: state = 2408;
pub const S_NIGHTSBUMPER2: state = 2407;
pub const S_NIGHTSBUMPER1: state = 2406;
pub const S_NIGHTSLOOPHELPER: state = 2405;
pub const S_NIGHTSPARKLESUPER4: state = 2404;
pub const S_NIGHTSPARKLESUPER3: state = 2403;
pub const S_NIGHTSPARKLESUPER2: state = 2402;
pub const S_NIGHTSPARKLESUPER1: state = 2401;
pub const S_NIGHTSPARKLE4: state = 2400;
pub const S_NIGHTSPARKLE3: state = 2399;
pub const S_NIGHTSPARKLE2: state = 2398;
pub const S_NIGHTSPARKLE1: state = 2397;
pub const S_NIGHTSDRONE_GOAL4: state = 2396;
pub const S_NIGHTSDRONE_GOAL3: state = 2395;
pub const S_NIGHTSDRONE_GOAL2: state = 2394;
pub const S_NIGHTSDRONE_GOAL1: state = 2393;
pub const S_NIGHTSDRONE_SPARKLING16: state = 2392;
pub const S_NIGHTSDRONE_SPARKLING15: state = 2391;
pub const S_NIGHTSDRONE_SPARKLING14: state = 2390;
pub const S_NIGHTSDRONE_SPARKLING13: state = 2389;
pub const S_NIGHTSDRONE_SPARKLING12: state = 2388;
pub const S_NIGHTSDRONE_SPARKLING11: state = 2387;
pub const S_NIGHTSDRONE_SPARKLING10: state = 2386;
pub const S_NIGHTSDRONE_SPARKLING9: state = 2385;
pub const S_NIGHTSDRONE_SPARKLING8: state = 2384;
pub const S_NIGHTSDRONE_SPARKLING7: state = 2383;
pub const S_NIGHTSDRONE_SPARKLING6: state = 2382;
pub const S_NIGHTSDRONE_SPARKLING5: state = 2381;
pub const S_NIGHTSDRONE_SPARKLING4: state = 2380;
pub const S_NIGHTSDRONE_SPARKLING3: state = 2379;
pub const S_NIGHTSDRONE_SPARKLING2: state = 2378;
pub const S_NIGHTSDRONE_SPARKLING1: state = 2377;
pub const S_NIGHTSDRONE_MAN2: state = 2376;
pub const S_NIGHTSDRONE_MAN1: state = 2375;
pub const S_TOAD: state = 2374;
pub const S_MARIOBUSH2: state = 2373;
pub const S_MARIOBUSH1: state = 2372;
pub const S_AXE3: state = 2371;
pub const S_AXE2: state = 2370;
pub const S_AXE1: state = 2369;
pub const S_KOOPAFLAME3: state = 2368;
pub const S_KOOPAFLAME2: state = 2367;
pub const S_KOOPAFLAME1: state = 2366;
pub const S_KOOPA2: state = 2365;
pub const S_KOOPA1: state = 2364;
pub const S_HAMMER: state = 2363;
pub const S_PUMATRAIL4: state = 2362;
pub const S_PUMATRAIL3: state = 2361;
pub const S_PUMATRAIL2: state = 2360;
pub const S_PUMATRAIL1: state = 2359;
pub const S_PUMA_DOWN3: state = 2358;
pub const S_PUMA_DOWN2: state = 2357;
pub const S_PUMA_DOWN1: state = 2356;
pub const S_PUMA_UP3: state = 2355;
pub const S_PUMA_UP2: state = 2354;
pub const S_PUMA_UP1: state = 2353;
pub const S_PUMA_START2: state = 2352;
pub const S_PUMA_START1: state = 2351;
pub const S_SHELL: state = 2350;
pub const S_FIREBALLTRAIL2: state = 2349;
pub const S_FIREBALLTRAIL1: state = 2348;
pub const S_FIREBALL: state = 2347;
pub const S_FIREFLOWER4: state = 2346;
pub const S_FIREFLOWER3: state = 2345;
pub const S_FIREFLOWER2: state = 2344;
pub const S_FIREFLOWER1: state = 2343;
pub const S_BLUEGOOMBA_DEAD: state = 2342;
pub const S_BLUEGOOMBA9: state = 2341;
pub const S_BLUEGOOMBA8: state = 2340;
pub const S_BLUEGOOMBA7: state = 2339;
pub const S_BLUEGOOMBA6: state = 2338;
pub const S_BLUEGOOMBA5: state = 2337;
pub const S_BLUEGOOMBA4: state = 2336;
pub const S_BLUEGOOMBA3: state = 2335;
pub const S_BLUEGOOMBA2: state = 2334;
pub const S_BLUEGOOMBA1B: state = 2333;
pub const S_BLUEGOOMBA1: state = 2332;
pub const S_GOOMBA_DEAD: state = 2331;
pub const S_GOOMBA9: state = 2330;
pub const S_GOOMBA8: state = 2329;
pub const S_GOOMBA7: state = 2328;
pub const S_GOOMBA6: state = 2327;
pub const S_GOOMBA5: state = 2326;
pub const S_GOOMBA4: state = 2325;
pub const S_GOOMBA3: state = 2324;
pub const S_GOOMBA2: state = 2323;
pub const S_GOOMBA1B: state = 2322;
pub const S_GOOMBA1: state = 2321;
pub const S_COINSPARKLE4: state = 2320;
pub const S_COINSPARKLE3: state = 2319;
pub const S_COINSPARKLE2: state = 2318;
pub const S_COINSPARKLE1: state = 2317;
pub const S_COIN3: state = 2316;
pub const S_COIN2: state = 2315;
pub const S_COIN1: state = 2314;
pub const S_RINGEXPLODE: state = 2313;
pub const S_THROWNSCATTER: state = 2312;
pub const S_THROWNGRENADE18: state = 2311;
pub const S_THROWNGRENADE17: state = 2310;
pub const S_THROWNGRENADE16: state = 2309;
pub const S_THROWNGRENADE15: state = 2308;
pub const S_THROWNGRENADE14: state = 2307;
pub const S_THROWNGRENADE13: state = 2306;
pub const S_THROWNGRENADE12: state = 2305;
pub const S_THROWNGRENADE11: state = 2304;
pub const S_THROWNGRENADE10: state = 2303;
pub const S_THROWNGRENADE9: state = 2302;
pub const S_THROWNGRENADE8: state = 2301;
pub const S_THROWNGRENADE7: state = 2300;
pub const S_THROWNGRENADE6: state = 2299;
pub const S_THROWNGRENADE5: state = 2298;
pub const S_THROWNGRENADE4: state = 2297;
pub const S_THROWNGRENADE3: state = 2296;
pub const S_THROWNGRENADE2: state = 2295;
pub const S_THROWNGRENADE1: state = 2294;
pub const S_THROWNEXPLOSION7: state = 2293;
pub const S_THROWNEXPLOSION6: state = 2292;
pub const S_THROWNEXPLOSION5: state = 2291;
pub const S_THROWNEXPLOSION4: state = 2290;
pub const S_THROWNEXPLOSION3: state = 2289;
pub const S_THROWNEXPLOSION2: state = 2288;
pub const S_THROWNEXPLOSION1: state = 2287;
pub const S_THROWNAUTOMATIC7: state = 2286;
pub const S_THROWNAUTOMATIC6: state = 2285;
pub const S_THROWNAUTOMATIC5: state = 2284;
pub const S_THROWNAUTOMATIC4: state = 2283;
pub const S_THROWNAUTOMATIC3: state = 2282;
pub const S_THROWNAUTOMATIC2: state = 2281;
pub const S_THROWNAUTOMATIC1: state = 2280;
pub const S_THROWNINFINITY7: state = 2279;
pub const S_THROWNINFINITY6: state = 2278;
pub const S_THROWNINFINITY5: state = 2277;
pub const S_THROWNINFINITY4: state = 2276;
pub const S_THROWNINFINITY3: state = 2275;
pub const S_THROWNINFINITY2: state = 2274;
pub const S_THROWNINFINITY1: state = 2273;
pub const S_THROWNBOUNCE7: state = 2272;
pub const S_THROWNBOUNCE6: state = 2271;
pub const S_THROWNBOUNCE5: state = 2270;
pub const S_THROWNBOUNCE4: state = 2269;
pub const S_THROWNBOUNCE3: state = 2268;
pub const S_THROWNBOUNCE2: state = 2267;
pub const S_THROWNBOUNCE1: state = 2266;
pub const S_GRENADEPICKUPFADE8: state = 2265;
pub const S_GRENADEPICKUPFADE7: state = 2264;
pub const S_GRENADEPICKUPFADE6: state = 2263;
pub const S_GRENADEPICKUPFADE5: state = 2262;
pub const S_GRENADEPICKUPFADE4: state = 2261;
pub const S_GRENADEPICKUPFADE3: state = 2260;
pub const S_GRENADEPICKUPFADE2: state = 2259;
pub const S_GRENADEPICKUPFADE1: state = 2258;
pub const S_GRENADEPICKUP: state = 2257;
pub const S_SCATTERPICKUPFADE8: state = 2256;
pub const S_SCATTERPICKUPFADE7: state = 2255;
pub const S_SCATTERPICKUPFADE6: state = 2254;
pub const S_SCATTERPICKUPFADE5: state = 2253;
pub const S_SCATTERPICKUPFADE4: state = 2252;
pub const S_SCATTERPICKUPFADE3: state = 2251;
pub const S_SCATTERPICKUPFADE2: state = 2250;
pub const S_SCATTERPICKUPFADE1: state = 2249;
pub const S_SCATTERPICKUP: state = 2248;
pub const S_EXPLODEPICKUPFADE8: state = 2247;
pub const S_EXPLODEPICKUPFADE7: state = 2246;
pub const S_EXPLODEPICKUPFADE6: state = 2245;
pub const S_EXPLODEPICKUPFADE5: state = 2244;
pub const S_EXPLODEPICKUPFADE4: state = 2243;
pub const S_EXPLODEPICKUPFADE3: state = 2242;
pub const S_EXPLODEPICKUPFADE2: state = 2241;
pub const S_EXPLODEPICKUPFADE1: state = 2240;
pub const S_EXPLODEPICKUP: state = 2239;
pub const S_AUTOPICKUPFADE8: state = 2238;
pub const S_AUTOPICKUPFADE7: state = 2237;
pub const S_AUTOPICKUPFADE6: state = 2236;
pub const S_AUTOPICKUPFADE5: state = 2235;
pub const S_AUTOPICKUPFADE4: state = 2234;
pub const S_AUTOPICKUPFADE3: state = 2233;
pub const S_AUTOPICKUPFADE2: state = 2232;
pub const S_AUTOPICKUPFADE1: state = 2231;
pub const S_AUTOPICKUP: state = 2230;
pub const S_RAILPICKUPFADE8: state = 2229;
pub const S_RAILPICKUPFADE7: state = 2228;
pub const S_RAILPICKUPFADE6: state = 2227;
pub const S_RAILPICKUPFADE5: state = 2226;
pub const S_RAILPICKUPFADE4: state = 2225;
pub const S_RAILPICKUPFADE3: state = 2224;
pub const S_RAILPICKUPFADE2: state = 2223;
pub const S_RAILPICKUPFADE1: state = 2222;
pub const S_RAILPICKUP: state = 2221;
pub const S_BOUNCEPICKUPFADE8: state = 2220;
pub const S_BOUNCEPICKUPFADE7: state = 2219;
pub const S_BOUNCEPICKUPFADE6: state = 2218;
pub const S_BOUNCEPICKUPFADE5: state = 2217;
pub const S_BOUNCEPICKUPFADE4: state = 2216;
pub const S_BOUNCEPICKUPFADE3: state = 2215;
pub const S_BOUNCEPICKUPFADE2: state = 2214;
pub const S_BOUNCEPICKUPFADE1: state = 2213;
pub const S_BOUNCEPICKUP: state = 2212;
pub const S_GRENADERINGAMMO: state = 2211;
pub const S_SCATTERRINGAMMO: state = 2210;
pub const S_EXPLOSIONRINGAMMO: state = 2209;
pub const S_AUTOMATICRINGAMMO: state = 2208;
pub const S_INFINITYRINGAMMO: state = 2207;
pub const S_RAILRINGAMMO: state = 2206;
pub const S_BOUNCERINGAMMO: state = 2205;
pub const S_RRNG7: state = 2204;
pub const S_RRNG6: state = 2203;
pub const S_RRNG5: state = 2202;
pub const S_RRNG4: state = 2201;
pub const S_RRNG3: state = 2200;
pub const S_RRNG2: state = 2199;
pub const S_RRNG1: state = 2198;
pub const S_LHRT: state = 2197;
pub const S_CORK: state = 2196;
pub const S_FINISHFLAG: state = 2195;
pub const S_GOTFLAG: state = 2194;
pub const S_TTAG: state = 2193;
pub const S_LOCKONINF4: state = 2192;
pub const S_LOCKONINF3: state = 2191;
pub const S_LOCKONINF2: state = 2190;
pub const S_LOCKONINF1: state = 2189;
pub const S_LOCKON4: state = 2188;
pub const S_LOCKON3: state = 2187;
pub const S_LOCKON2: state = 2186;
pub const S_LOCKON1: state = 2185;
pub const S_FLIGHTINDICATOR: state = 2184;
pub const S_FIVE2: state = 2183;
pub const S_FOUR2: state = 2182;
pub const S_THREE2: state = 2181;
pub const S_TWO2: state = 2180;
pub const S_ONE2: state = 2179;
pub const S_ZERO2: state = 2178;
pub const S_FIVE1: state = 2177;
pub const S_FOUR1: state = 2176;
pub const S_THREE1: state = 2175;
pub const S_TWO1: state = 2174;
pub const S_ONE1: state = 2173;
pub const S_ZERO1: state = 2172;
pub const S_SCRL: state = 2171;
pub const S_SCRK: state = 2170;
pub const S_SCRJ: state = 2169;
pub const S_SCRI: state = 2168;
pub const S_SCRH: state = 2167;
pub const S_SCRG: state = 2166;
pub const S_SCRF: state = 2165;
pub const S_SCRE: state = 2164;
pub const S_SCRD: state = 2163;
pub const S_SCRC: state = 2162;
pub const S_SCRB: state = 2161;
pub const S_SCRA: state = 2160;
pub const S_PARTICLE: state = 2159;
pub const S_SEED: state = 2158;
pub const S_FOG14: state = 2157;
pub const S_FOG13: state = 2156;
pub const S_FOG12: state = 2155;
pub const S_FOG11: state = 2154;
pub const S_FOG10: state = 2153;
pub const S_FOG9: state = 2152;
pub const S_FOG8: state = 2151;
pub const S_FOG7: state = 2150;
pub const S_FOG6: state = 2149;
pub const S_FOG5: state = 2148;
pub const S_FOG4: state = 2147;
pub const S_FOG3: state = 2146;
pub const S_FOG2: state = 2145;
pub const S_FOG1: state = 2144;
pub const S_SPINDUST_FIRE4: state = 2143;
pub const S_SPINDUST_FIRE3: state = 2142;
pub const S_SPINDUST_FIRE2: state = 2141;
pub const S_SPINDUST_FIRE1: state = 2140;
pub const S_SPINDUST_BUBBLE4: state = 2139;
pub const S_SPINDUST_BUBBLE3: state = 2138;
pub const S_SPINDUST_BUBBLE2: state = 2137;
pub const S_SPINDUST_BUBBLE1: state = 2136;
pub const S_SPINDUST4: state = 2135;
pub const S_SPINDUST3: state = 2134;
pub const S_SPINDUST2: state = 2133;
pub const S_SPINDUST1: state = 2132;
pub const S_WATERZAP: state = 2131;
pub const S_POP1: state = 2130;
pub const S_EXTRALARGEBUBBLE: state = 2129;
pub const S_LARGEBUBBLE2: state = 2128;
pub const S_LARGEBUBBLE1: state = 2127;
pub const S_MEDIUMBUBBLE: state = 2126;
pub const S_SMALLBUBBLE: state = 2125;
pub const S_SMOKE5: state = 2124;
pub const S_SMOKE4: state = 2123;
pub const S_SMOKE3: state = 2122;
pub const S_SMOKE2: state = 2121;
pub const S_SMOKE1: state = 2120;
pub const S_SPLASH3: state = 2119;
pub const S_SPLASH2: state = 2118;
pub const S_SPLASH1: state = 2117;
pub const S_LAVASPLISH: state = 2116;
pub const S_SPLISH9: state = 2115;
pub const S_SPLISH8: state = 2114;
pub const S_SPLISH7: state = 2113;
pub const S_SPLISH6: state = 2112;
pub const S_SPLISH5: state = 2111;
pub const S_SPLISH4: state = 2110;
pub const S_SPLISH3: state = 2109;
pub const S_SPLISH2: state = 2108;
pub const S_SPLISH1: state = 2107;
pub const S_SNOW3: state = 2106;
pub const S_SNOW2: state = 2105;
pub const S_SNOW1: state = 2104;
pub const S_RAINRETURN: state = 2103;
pub const S_RAIN1: state = 2102;
pub const S_REDBOOSTERSEG_FACE: state = 2101;
pub const S_REDBOOSTERSEG_RIGHT: state = 2100;
pub const S_REDBOOSTERSEG_LEFT: state = 2099;
pub const S_REDBOOSTERROLLER: state = 2098;
pub const S_YELLOWBOOSTERSEG_FACE: state = 2097;
pub const S_YELLOWBOOSTERSEG_RIGHT: state = 2096;
pub const S_YELLOWBOOSTERSEG_LEFT: state = 2095;
pub const S_YELLOWBOOSTERROLLER: state = 2094;
pub const S_BOOSTERSOUND: state = 2093;
pub const S_BHORIZ8: state = 2092;
pub const S_BHORIZ7: state = 2091;
pub const S_BHORIZ6: state = 2090;
pub const S_BHORIZ5: state = 2089;
pub const S_BHORIZ4: state = 2088;
pub const S_BHORIZ3: state = 2087;
pub const S_BHORIZ2: state = 2086;
pub const S_BHORIZ1: state = 2085;
pub const S_RHORIZ8: state = 2084;
pub const S_RHORIZ7: state = 2083;
pub const S_RHORIZ6: state = 2082;
pub const S_RHORIZ5: state = 2081;
pub const S_RHORIZ4: state = 2080;
pub const S_RHORIZ3: state = 2079;
pub const S_RHORIZ2: state = 2078;
pub const S_RHORIZ1: state = 2077;
pub const S_YHORIZ8: state = 2076;
pub const S_YHORIZ7: state = 2075;
pub const S_YHORIZ6: state = 2074;
pub const S_YHORIZ5: state = 2073;
pub const S_YHORIZ4: state = 2072;
pub const S_YHORIZ3: state = 2071;
pub const S_YHORIZ2: state = 2070;
pub const S_YHORIZ1: state = 2069;
pub const S_BDIAG8: state = 2068;
pub const S_BDIAG7: state = 2067;
pub const S_BDIAG6: state = 2066;
pub const S_BDIAG5: state = 2065;
pub const S_BDIAG4: state = 2064;
pub const S_BDIAG3: state = 2063;
pub const S_BDIAG2: state = 2062;
pub const S_BDIAG1: state = 2061;
pub const S_RDIAG8: state = 2060;
pub const S_RDIAG7: state = 2059;
pub const S_RDIAG6: state = 2058;
pub const S_RDIAG5: state = 2057;
pub const S_RDIAG4: state = 2056;
pub const S_RDIAG3: state = 2055;
pub const S_RDIAG2: state = 2054;
pub const S_RDIAG1: state = 2053;
pub const S_YDIAG8: state = 2052;
pub const S_YDIAG7: state = 2051;
pub const S_YDIAG6: state = 2050;
pub const S_YDIAG5: state = 2049;
pub const S_YDIAG4: state = 2048;
pub const S_YDIAG3: state = 2047;
pub const S_YDIAG2: state = 2046;
pub const S_YDIAG1: state = 2045;
pub const S_BLUESPRING5: state = 2044;
pub const S_BLUESPRING4: state = 2043;
pub const S_BLUESPRING3: state = 2042;
pub const S_BLUESPRING2: state = 2041;
pub const S_BLUESPRING: state = 2040;
pub const S_REDSPRING5: state = 2039;
pub const S_REDSPRING4: state = 2038;
pub const S_REDSPRING3: state = 2037;
pub const S_REDSPRING2: state = 2036;
pub const S_REDSPRING: state = 2035;
pub const S_YELLOWSPRING5: state = 2034;
pub const S_YELLOWSPRING4: state = 2033;
pub const S_YELLOWSPRING3: state = 2032;
pub const S_YELLOWSPRING2: state = 2031;
pub const S_YELLOWSPRING: state = 2030;
pub const S_BALLOONPOP6: state = 2029;
pub const S_BALLOONPOP5: state = 2028;
pub const S_BALLOONPOP4: state = 2027;
pub const S_BALLOONPOP3: state = 2026;
pub const S_BALLOONPOP2: state = 2025;
pub const S_BALLOONPOP1: state = 2024;
pub const S_BALLOON: state = 2023;
pub const S_BUMPERHIT: state = 2022;
pub const S_BUMPER: state = 2021;
pub const S_STEAM8: state = 2020;
pub const S_STEAM7: state = 2019;
pub const S_STEAM6: state = 2018;
pub const S_STEAM5: state = 2017;
pub const S_STEAM4: state = 2016;
pub const S_STEAM3: state = 2015;
pub const S_STEAM2: state = 2014;
pub const S_STEAM1: state = 2013;
pub const S_FAN5: state = 2012;
pub const S_FAN4: state = 2011;
pub const S_FAN3: state = 2010;
pub const S_FAN2: state = 2009;
pub const S_FAN: state = 2008;
pub const S_SECRETFLICKY_02_CENTER: state = 2007;
pub const S_SECRETFLICKY_02_STAND: state = 2006;
pub const S_SECRETFLICKY_02_FLAP3: state = 2005;
pub const S_SECRETFLICKY_02_FLAP2: state = 2004;
pub const S_SECRETFLICKY_02_FLAP1: state = 2003;
pub const S_SECRETFLICKY_02_OUT: state = 2002;
pub const S_SECRETFLICKY_01_CENTER: state = 2001;
pub const S_SECRETFLICKY_01_STAND: state = 2000;
pub const S_SECRETFLICKY_01_DOWN: state = 1999;
pub const S_SECRETFLICKY_01_UP: state = 1998;
pub const S_SECRETFLICKY_01_HOP: state = 1997;
pub const S_SECRETFLICKY_01_AIM: state = 1996;
pub const S_SECRETFLICKY_01_OUT: state = 1995;
pub const S_FLICKY_16_CENTER: state = 1994;
pub const S_FLICKY_16_STAND: state = 1993;
pub const S_FLICKY_16_FLAP3: state = 1992;
pub const S_FLICKY_16_FLAP2: state = 1991;
pub const S_FLICKY_16_FLAP1: state = 1990;
pub const S_FLICKY_16_OUT: state = 1989;
pub const S_FLICKY_15_CENTER: state = 1988;
pub const S_FLICKY_15_STAND: state = 1987;
pub const S_FLICKY_15_DOWN: state = 1986;
pub const S_FLICKY_15_UP: state = 1985;
pub const S_FLICKY_15_HOP: state = 1984;
pub const S_FLICKY_15_AIM: state = 1983;
pub const S_FLICKY_15_OUT: state = 1982;
pub const S_FLICKY_14_CENTER: state = 1981;
pub const S_FLICKY_14_STAND: state = 1980;
pub const S_FLICKY_14_FLAP3: state = 1979;
pub const S_FLICKY_14_FLAP2: state = 1978;
pub const S_FLICKY_14_FLAP1: state = 1977;
pub const S_FLICKY_14_OUT: state = 1976;
pub const S_FLICKY_13_CENTER: state = 1975;
pub const S_FLICKY_13_STAND: state = 1974;
pub const S_FLICKY_13_DOWN: state = 1973;
pub const S_FLICKY_13_UP: state = 1972;
pub const S_FLICKY_13_HOP: state = 1971;
pub const S_FLICKY_13_AIM: state = 1970;
pub const S_FLICKY_13_OUT: state = 1969;
pub const S_FLICKY_12_CENTER: state = 1968;
pub const S_FLICKY_12_STAND: state = 1967;
pub const S_FLICKY_12_RUN3: state = 1966;
pub const S_FLICKY_12_RUN2: state = 1965;
pub const S_FLICKY_12_RUN1: state = 1964;
pub const S_FLICKY_12_AIM: state = 1963;
pub const S_FLICKY_12_OUT: state = 1962;
pub const S_FLICKY_11_CENTER: state = 1961;
pub const S_FLICKY_11_STAND: state = 1960;
pub const S_FLICKY_11_RUN3: state = 1959;
pub const S_FLICKY_11_RUN2: state = 1958;
pub const S_FLICKY_11_RUN1: state = 1957;
pub const S_FLICKY_11_AIM: state = 1956;
pub const S_FLICKY_11_OUT: state = 1955;
pub const S_FLICKY_10_CENTER: state = 1954;
pub const S_FLICKY_10_STAND: state = 1953;
pub const S_FLICKY_10_FLAP2: state = 1952;
pub const S_FLICKY_10_FLAP1: state = 1951;
pub const S_FLICKY_10_OUT: state = 1950;
pub const S_FLICKY_09_CENTER: state = 1949;
pub const S_FLICKY_09_STAND: state = 1948;
pub const S_FLICKY_09_DOWN: state = 1947;
pub const S_FLICKY_09_UP: state = 1946;
pub const S_FLICKY_09_HOP: state = 1945;
pub const S_FLICKY_09_AIM: state = 1944;
pub const S_FLICKY_09_OUT: state = 1943;
pub const S_FLICKY_08_CENTER: state = 1942;
pub const S_FLICKY_08_STAND: state = 1941;
pub const S_FLICKY_08_SWIM4: state = 1940;
pub const S_FLICKY_08_SWIM3: state = 1939;
pub const S_FLICKY_08_SWIM2: state = 1938;
pub const S_FLICKY_08_SWIM1: state = 1937;
pub const S_FLICKY_08_FLAP4: state = 1936;
pub const S_FLICKY_08_FLAP3: state = 1935;
pub const S_FLICKY_08_FLAP2: state = 1934;
pub const S_FLICKY_08_FLAP1: state = 1933;
pub const S_FLICKY_08_HOP: state = 1932;
pub const S_FLICKY_08_AIM: state = 1931;
pub const S_FLICKY_08_OUT: state = 1930;
pub const S_FLICKY_07_CENTER: state = 1929;
pub const S_FLICKY_07_STAND: state = 1928;
pub const S_FLICKY_07_SWIM3: state = 1927;
pub const S_FLICKY_07_SWIM2: state = 1926;
pub const S_FLICKY_07_SWIM1: state = 1925;
pub const S_FLICKY_07_DOWNR: state = 1924;
pub const S_FLICKY_07_UPR: state = 1923;
pub const S_FLICKY_07_HOPR: state = 1922;
pub const S_FLICKY_07_AIMR: state = 1921;
pub const S_FLICKY_07_DOWNL: state = 1920;
pub const S_FLICKY_07_UPL: state = 1919;
pub const S_FLICKY_07_HOPL: state = 1918;
pub const S_FLICKY_07_AIML: state = 1917;
pub const S_FLICKY_07_OUT: state = 1916;
pub const S_FLICKY_06_CENTER: state = 1915;
pub const S_FLICKY_06_STAND: state = 1914;
pub const S_FLICKY_06_DOWN: state = 1913;
pub const S_FLICKY_06_UP: state = 1912;
pub const S_FLICKY_06_HOP: state = 1911;
pub const S_FLICKY_06_AIM: state = 1910;
pub const S_FLICKY_06_OUT: state = 1909;
pub const S_FLICKY_05_CENTER: state = 1908;
pub const S_FLICKY_05_STAND: state = 1907;
pub const S_FLICKY_05_DOWN: state = 1906;
pub const S_FLICKY_05_UP: state = 1905;
pub const S_FLICKY_05_HOP: state = 1904;
pub const S_FLICKY_05_AIM: state = 1903;
pub const S_FLICKY_05_OUT: state = 1902;
pub const S_FLICKY_04_CENTER: state = 1901;
pub const S_FLICKY_04_STAND: state = 1900;
pub const S_FLICKY_04_SWIM4: state = 1899;
pub const S_FLICKY_04_SWIM3: state = 1898;
pub const S_FLICKY_04_SWIM2: state = 1897;
pub const S_FLICKY_04_SWIM1: state = 1896;
pub const S_FLICKY_04_DOWN: state = 1895;
pub const S_FLICKY_04_UP: state = 1894;
pub const S_FLICKY_04_HOP: state = 1893;
pub const S_FLICKY_04_AIM: state = 1892;
pub const S_FLICKY_04_OUT: state = 1891;
pub const S_FLICKY_03_CENTER: state = 1890;
pub const S_FLICKY_03_STAND: state = 1889;
pub const S_FLICKY_03_FLAP2: state = 1888;
pub const S_FLICKY_03_FLAP1: state = 1887;
pub const S_FLICKY_03_UP: state = 1886;
pub const S_FLICKY_03_HOP: state = 1885;
pub const S_FLICKY_03_AIM: state = 1884;
pub const S_FLICKY_03_OUT: state = 1883;
pub const S_FLICKY_02_CENTER: state = 1882;
pub const S_FLICKY_02_STAND: state = 1881;
pub const S_FLICKY_02_DOWN: state = 1880;
pub const S_FLICKY_02_UP: state = 1879;
pub const S_FLICKY_02_HOP: state = 1878;
pub const S_FLICKY_02_AIM: state = 1877;
pub const S_FLICKY_02_OUT: state = 1876;
pub const S_FLICKY_01_CENTER: state = 1875;
pub const S_FLICKY_01_STAND: state = 1874;
pub const S_FLICKY_01_FLAP3: state = 1873;
pub const S_FLICKY_01_FLAP2: state = 1872;
pub const S_FLICKY_01_FLAP1: state = 1871;
pub const S_FLICKY_01_OUT: state = 1870;
pub const S_FLICKY_BUBBLE: state = 1869;
pub const S_SSPK5: state = 1868;
pub const S_SSPK4: state = 1867;
pub const S_SSPK3: state = 1866;
pub const S_SSPK2: state = 1865;
pub const S_SSPK1: state = 1864;
pub const S_IVSP: state = 1863;
pub const S_THUNDERCOIN_SPARK: state = 1862;
pub const S_ZAPSB11: state = 1861;
pub const S_ZAPSB10: state = 1860;
pub const S_ZAPSB9: state = 1859;
pub const S_ZAPSB8: state = 1858;
pub const S_ZAPSB7: state = 1857;
pub const S_ZAPSB6: state = 1856;
pub const S_ZAPSB5: state = 1855;
pub const S_ZAPSB4: state = 1854;
pub const S_ZAPSB3: state = 1853;
pub const S_ZAPSB2: state = 1852;
pub const S_ZAPSB1: state = 1851;
pub const S_ZAPS16: state = 1850;
pub const S_ZAPS15: state = 1849;
pub const S_ZAPS14: state = 1848;
pub const S_ZAPS13: state = 1847;
pub const S_ZAPS12: state = 1846;
pub const S_ZAPS11: state = 1845;
pub const S_ZAPS10: state = 1844;
pub const S_ZAPS9: state = 1843;
pub const S_ZAPS8: state = 1842;
pub const S_ZAPS7: state = 1841;
pub const S_ZAPS6: state = 1840;
pub const S_ZAPS5: state = 1839;
pub const S_ZAPS4: state = 1838;
pub const S_ZAPS3: state = 1837;
pub const S_ZAPS2: state = 1836;
pub const S_ZAPS1: state = 1835;
pub const S_BUBSB6: state = 1834;
pub const S_BUBSB5: state = 1833;
pub const S_BUBSB4: state = 1832;
pub const S_BUBSB3: state = 1831;
pub const S_BUBSB2: state = 1830;
pub const S_BUBSB1: state = 1829;
pub const S_BUBS11: state = 1828;
pub const S_BUBS10: state = 1827;
pub const S_BUBS9: state = 1826;
pub const S_BUBS8: state = 1825;
pub const S_BUBS7: state = 1824;
pub const S_BUBS6: state = 1823;
pub const S_BUBS5: state = 1822;
pub const S_BUBS4: state = 1821;
pub const S_BUBS3: state = 1820;
pub const S_BUBS2: state = 1819;
pub const S_BUBS1: state = 1818;
pub const S_FIRSB10: state = 1817;
pub const S_FIRSB9: state = 1816;
pub const S_FIRSB8: state = 1815;
pub const S_FIRSB7: state = 1814;
pub const S_FIRSB6: state = 1813;
pub const S_FIRSB5: state = 1812;
pub const S_FIRSB4: state = 1811;
pub const S_FIRSB3: state = 1810;
pub const S_FIRSB2: state = 1809;
pub const S_FIRSB1: state = 1808;
pub const S_FIRS11: state = 1807;
pub const S_FIRS10: state = 1806;
pub const S_FIRS9: state = 1805;
pub const S_FIRS8: state = 1804;
pub const S_FIRS7: state = 1803;
pub const S_FIRS6: state = 1802;
pub const S_FIRS5: state = 1801;
pub const S_FIRS4: state = 1800;
pub const S_FIRS3: state = 1799;
pub const S_FIRS2: state = 1798;
pub const S_FIRS1: state = 1797;
pub const S_PITY12: state = 1796;
pub const S_PITY11: state = 1795;
pub const S_PITY10: state = 1794;
pub const S_PITY9: state = 1793;
pub const S_PITY8: state = 1792;
pub const S_PITY7: state = 1791;
pub const S_PITY6: state = 1790;
pub const S_PITY5: state = 1789;
pub const S_PITY4: state = 1788;
pub const S_PITY3: state = 1787;
pub const S_PITY2: state = 1786;
pub const S_PITY1: state = 1785;
pub const S_ELEMF10: state = 1784;
pub const S_ELEMF9: state = 1783;
pub const S_ELEMF8: state = 1782;
pub const S_ELEMF7: state = 1781;
pub const S_ELEMF6: state = 1780;
pub const S_ELEMF5: state = 1779;
pub const S_ELEMF4: state = 1778;
pub const S_ELEMF3: state = 1777;
pub const S_ELEMF2: state = 1776;
pub const S_ELEMF1: state = 1775;
pub const S_ELEM14: state = 1774;
pub const S_ELEM13: state = 1773;
pub const S_ELEM12: state = 1772;
pub const S_ELEM11: state = 1771;
pub const S_ELEM10: state = 1770;
pub const S_ELEM9: state = 1769;
pub const S_ELEM8: state = 1768;
pub const S_ELEM7: state = 1767;
pub const S_ELEM6: state = 1766;
pub const S_ELEM5: state = 1765;
pub const S_ELEM4: state = 1764;
pub const S_ELEM3: state = 1763;
pub const S_ELEM2: state = 1762;
pub const S_ELEM1: state = 1761;
pub const S_FORC21: state = 1760;
pub const S_FORC20: state = 1759;
pub const S_FORC19: state = 1758;
pub const S_FORC18: state = 1757;
pub const S_FORC17: state = 1756;
pub const S_FORC16: state = 1755;
pub const S_FORC15: state = 1754;
pub const S_FORC14: state = 1753;
pub const S_FORC13: state = 1752;
pub const S_FORC12: state = 1751;
pub const S_FORC11: state = 1750;
pub const S_FORC10: state = 1749;
pub const S_FORC9: state = 1748;
pub const S_FORC8: state = 1747;
pub const S_FORC7: state = 1746;
pub const S_FORC6: state = 1745;
pub const S_FORC5: state = 1744;
pub const S_FORC4: state = 1743;
pub const S_FORC3: state = 1742;
pub const S_FORC2: state = 1741;
pub const S_FORC1: state = 1740;
pub const S_MAGN13: state = 1739;
pub const S_MAGN12: state = 1738;
pub const S_MAGN11: state = 1737;
pub const S_MAGN10: state = 1736;
pub const S_MAGN9: state = 1735;
pub const S_MAGN8: state = 1734;
pub const S_MAGN7: state = 1733;
pub const S_MAGN6: state = 1732;
pub const S_MAGN5: state = 1731;
pub const S_MAGN4: state = 1730;
pub const S_MAGN3: state = 1729;
pub const S_MAGN2: state = 1728;
pub const S_MAGN1: state = 1727;
pub const S_WIND8: state = 1726;
pub const S_WIND7: state = 1725;
pub const S_WIND6: state = 1724;
pub const S_WIND5: state = 1723;
pub const S_WIND4: state = 1722;
pub const S_WIND3: state = 1721;
pub const S_WIND2: state = 1720;
pub const S_WIND1: state = 1719;
pub const S_ARMB32: state = 1718;
pub const S_ARMB31: state = 1717;
pub const S_ARMB30: state = 1716;
pub const S_ARMB29: state = 1715;
pub const S_ARMB28: state = 1714;
pub const S_ARMB27: state = 1713;
pub const S_ARMB26: state = 1712;
pub const S_ARMB25: state = 1711;
pub const S_ARMB24: state = 1710;
pub const S_ARMB23: state = 1709;
pub const S_ARMB22: state = 1708;
pub const S_ARMB21: state = 1707;
pub const S_ARMB20: state = 1706;
pub const S_ARMB19: state = 1705;
pub const S_ARMB18: state = 1704;
pub const S_ARMB17: state = 1703;
pub const S_ARMB16: state = 1702;
pub const S_ARMB15: state = 1701;
pub const S_ARMB14: state = 1700;
pub const S_ARMB13: state = 1699;
pub const S_ARMB12: state = 1698;
pub const S_ARMB11: state = 1697;
pub const S_ARMB10: state = 1696;
pub const S_ARMB9: state = 1695;
pub const S_ARMB8: state = 1694;
pub const S_ARMB7: state = 1693;
pub const S_ARMB6: state = 1692;
pub const S_ARMB5: state = 1691;
pub const S_ARMB4: state = 1690;
pub const S_ARMB3: state = 1689;
pub const S_ARMB2: state = 1688;
pub const S_ARMB1: state = 1687;
pub const S_ARMF32: state = 1686;
pub const S_ARMF31: state = 1685;
pub const S_ARMF30: state = 1684;
pub const S_ARMF29: state = 1683;
pub const S_ARMF28: state = 1682;
pub const S_ARMF27: state = 1681;
pub const S_ARMF26: state = 1680;
pub const S_ARMF25: state = 1679;
pub const S_ARMF24: state = 1678;
pub const S_ARMF23: state = 1677;
pub const S_ARMF22: state = 1676;
pub const S_ARMF21: state = 1675;
pub const S_ARMF20: state = 1674;
pub const S_ARMF19: state = 1673;
pub const S_ARMF18: state = 1672;
pub const S_ARMF17: state = 1671;
pub const S_ARMF16: state = 1670;
pub const S_ARMF15: state = 1669;
pub const S_ARMF14: state = 1668;
pub const S_ARMF13: state = 1667;
pub const S_ARMF12: state = 1666;
pub const S_ARMF11: state = 1665;
pub const S_ARMF10: state = 1664;
pub const S_ARMF9: state = 1663;
pub const S_ARMF8: state = 1662;
pub const S_ARMF7: state = 1661;
pub const S_ARMF6: state = 1660;
pub const S_ARMF5: state = 1659;
pub const S_ARMF4: state = 1658;
pub const S_ARMF3: state = 1657;
pub const S_ARMF2: state = 1656;
pub const S_ARMF1: state = 1655;
pub const S_ARMA16: state = 1654;
pub const S_ARMA15: state = 1653;
pub const S_ARMA14: state = 1652;
pub const S_ARMA13: state = 1651;
pub const S_ARMA12: state = 1650;
pub const S_ARMA11: state = 1649;
pub const S_ARMA10: state = 1648;
pub const S_ARMA9: state = 1647;
pub const S_ARMA8: state = 1646;
pub const S_ARMA7: state = 1645;
pub const S_ARMA6: state = 1644;
pub const S_ARMA5: state = 1643;
pub const S_ARMA4: state = 1642;
pub const S_ARMA3: state = 1641;
pub const S_ARMA2: state = 1640;
pub const S_ARMA1: state = 1639;
pub const S_EGGSTATUE2: state = 1638;
pub const S_DBALL6: state = 1637;
pub const S_DBALL5: state = 1636;
pub const S_DBALL4: state = 1635;
pub const S_DBALL3: state = 1634;
pub const S_DBALL2: state = 1633;
pub const S_DBALL1: state = 1632;
pub const S_PALMTREE_TOP: state = 1631;
pub const S_PALMTREE_TRUNK: state = 1630;
pub const S_BIG_PALMTREE_TOP: state = 1629;
pub const S_BIG_PALMTREE_TRUNK: state = 1628;
pub const S_BSZCLOVER: state = 1627;
pub const S_BSZSHRUB: state = 1626;
pub const S_BSZVINE_ORANGE: state = 1625;
pub const S_BSZVINE_YELLOW: state = 1624;
pub const S_BSZVINE_CYAN: state = 1623;
pub const S_BSZVINE_BLUE: state = 1622;
pub const S_BSZVINE_PURPLE: state = 1621;
pub const S_BSZVINE_RED: state = 1620;
pub const S_BSZBUSH_ORANGE: state = 1619;
pub const S_BSZBUSH_YELLOW: state = 1618;
pub const S_BSZBUSH_CYAN: state = 1617;
pub const S_BSZBUSH_BLUE: state = 1616;
pub const S_BSZBUSH_PURPLE: state = 1615;
pub const S_BSZBUSH_RED: state = 1614;
pub const S_BSZCLUSTER_ORANGE: state = 1613;
pub const S_BSZCLUSTER_YELLOW: state = 1612;
pub const S_BSZCLUSTER_CYAN: state = 1611;
pub const S_BSZCLUSTER_BLUE: state = 1610;
pub const S_BSZCLUSTER_PURPLE: state = 1609;
pub const S_BSZCLUSTER_RED: state = 1608;
pub const S_BSZTULIP_ORANGE: state = 1607;
pub const S_BSZTULIP_YELLOW: state = 1606;
pub const S_BSZTULIP_CYAN: state = 1605;
pub const S_BSZTULIP_BLUE: state = 1604;
pub const S_BSZTULIP_PURPLE: state = 1603;
pub const S_BSZTULIP_RED: state = 1602;
pub const S_BSZSHORTFLOWER_ORANGE: state = 1601;
pub const S_BSZSHORTFLOWER_YELLOW: state = 1600;
pub const S_BSZSHORTFLOWER_CYAN: state = 1599;
pub const S_BSZSHORTFLOWER_BLUE: state = 1598;
pub const S_BSZSHORTFLOWER_PURPLE: state = 1597;
pub const S_BSZSHORTFLOWER_RED: state = 1596;
pub const S_BSZFLOWER_ORANGE: state = 1595;
pub const S_BSZFLOWER_YELLOW: state = 1594;
pub const S_BSZFLOWER_CYAN: state = 1593;
pub const S_BSZFLOWER_BLUE: state = 1592;
pub const S_BSZFLOWER_PURPLE: state = 1591;
pub const S_BSZFLOWER_RED: state = 1590;
pub const S_BSZTALLFLOWER_ORANGE: state = 1589;
pub const S_BSZTALLFLOWER_YELLOW: state = 1588;
pub const S_BSZTALLFLOWER_CYAN: state = 1587;
pub const S_BSZTALLFLOWER_BLUE: state = 1586;
pub const S_BSZTALLFLOWER_PURPLE: state = 1585;
pub const S_BSZTALLFLOWER_RED: state = 1584;
pub const S_HHZSTALAGMITE_SHORT: state = 1583;
pub const S_HHZSTALAGMITE_TALL: state = 1582;
pub const S_HHZTENT2: state = 1581;
pub const S_HHZTENT1: state = 1580;
pub const S_HHZGRASS: state = 1579;
pub const S_HHZSHROOM_16: state = 1578;
pub const S_HHZSHROOM_15: state = 1577;
pub const S_HHZSHROOM_14: state = 1576;
pub const S_HHZSHROOM_13: state = 1575;
pub const S_HHZSHROOM_12: state = 1574;
pub const S_HHZSHROOM_11: state = 1573;
pub const S_HHZSHROOM_10: state = 1572;
pub const S_HHZSHROOM_9: state = 1571;
pub const S_HHZSHROOM_8: state = 1570;
pub const S_HHZSHROOM_7: state = 1569;
pub const S_HHZSHROOM_6: state = 1568;
pub const S_HHZSHROOM_5: state = 1567;
pub const S_HHZSHROOM_4: state = 1566;
pub const S_HHZSHROOM_3: state = 1565;
pub const S_HHZSHROOM_2: state = 1564;
pub const S_HHZSHROOM_1: state = 1563;
pub const S_HHZTREE_LEAF: state = 1562;
pub const S_HHZTREE_TRUNK: state = 1561;
pub const S_HHZTREE_TOP: state = 1560;
pub const S_JACKO3OVERLAY_4: state = 1559;
pub const S_JACKO3OVERLAY_3: state = 1558;
pub const S_JACKO3OVERLAY_2: state = 1557;
pub const S_JACKO3OVERLAY_1: state = 1556;
pub const S_JACKO3: state = 1555;
pub const S_JACKO2OVERLAY_4: state = 1554;
pub const S_JACKO2OVERLAY_3: state = 1553;
pub const S_JACKO2OVERLAY_2: state = 1552;
pub const S_JACKO2OVERLAY_1: state = 1551;
pub const S_JACKO2: state = 1550;
pub const S_JACKO1OVERLAY_4: state = 1549;
pub const S_JACKO1OVERLAY_3: state = 1548;
pub const S_JACKO1OVERLAY_2: state = 1547;
pub const S_JACKO1OVERLAY_1: state = 1546;
pub const S_JACKO1: state = 1545;
pub const S_ROSY_UNHAPPY: state = 1544;
pub const S_ROSY_STND: state = 1543;
pub const S_ROSY_PAIN: state = 1542;
pub const S_ROSY_HUG: state = 1541;
pub const S_ROSY_WALK: state = 1540;
pub const S_ROSY_JUMP: state = 1539;
pub const S_ROSY_IDLE4: state = 1538;
pub const S_ROSY_IDLE3: state = 1537;
pub const S_ROSY_IDLE2: state = 1536;
pub const S_ROSY_IDLE1: state = 1535;
pub const S_FHZICE2: state = 1534;
pub const S_FHZICE1: state = 1533;
pub const S_XMASBUSH: state = 1532;
pub const S_XMASBERRYBUSH: state = 1531;
pub const S_XMASBLUEBERRYBUSH: state = 1530;
pub const S_MISTLETOE: state = 1529;
pub const S_HANGSTAR: state = 1528;
pub const S_LAMPPOST2: state = 1527;
pub const S_LAMPPOST1: state = 1526;
pub const S_SNOWMANHAT: state = 1525;
pub const S_SNOWMAN: state = 1524;
pub const S_CANDYCANE: state = 1523;
pub const S_XMASPOLE: state = 1522;
pub const S_STG9: state = 1521;
pub const S_STG8: state = 1520;
pub const S_STG7: state = 1519;
pub const S_STG6: state = 1518;
pub const S_STG5: state = 1517;
pub const S_STG4: state = 1516;
pub const S_STG3: state = 1515;
pub const S_STG2: state = 1514;
pub const S_STG1: state = 1513;
pub const S_STG0: state = 1512;
pub const S_BLUEGARGOYLE: state = 1511;
pub const S_GREENFLAME: state = 1510;
pub const S_TARGET_ALLDONE: state = 1509;
pub const S_TARGET_RESPAWN: state = 1508;
pub const S_TARGET_HIT2: state = 1507;
pub const S_TARGET_HIT1: state = 1506;
pub const S_TARGET_IDLE: state = 1505;
pub const S_GLAREGOYLELONG_COOLDOWN: state = 1504;
pub const S_GLAREGOYLELONG_LOOP: state = 1503;
pub const S_GLAREGOYLELONG_FIRE: state = 1502;
pub const S_GLAREGOYLELONG_HOLD: state = 1501;
pub const S_GLAREGOYLELONG_BLINK: state = 1500;
pub const S_GLAREGOYLELONG_CHARGE: state = 1499;
pub const S_GLAREGOYLELONG: state = 1498;
pub const S_GLAREGOYLEDOWN_COOLDOWN: state = 1497;
pub const S_GLAREGOYLEDOWN_LOOP: state = 1496;
pub const S_GLAREGOYLEDOWN_FIRE: state = 1495;
pub const S_GLAREGOYLEDOWN_HOLD: state = 1494;
pub const S_GLAREGOYLEDOWN_BLINK: state = 1493;
pub const S_GLAREGOYLEDOWN_CHARGE: state = 1492;
pub const S_GLAREGOYLEDOWN: state = 1491;
pub const S_GLAREGOYLEUP_COOLDOWN: state = 1490;
pub const S_GLAREGOYLEUP_LOOP: state = 1489;
pub const S_GLAREGOYLEUP_FIRE: state = 1488;
pub const S_GLAREGOYLEUP_HOLD: state = 1487;
pub const S_GLAREGOYLEUP_BLINK: state = 1486;
pub const S_GLAREGOYLEUP_CHARGE: state = 1485;
pub const S_GLAREGOYLEUP: state = 1484;
pub const S_GLAREGOYLE_COOLDOWN: state = 1483;
pub const S_GLAREGOYLE_LOOP: state = 1482;
pub const S_GLAREGOYLE_FIRE: state = 1481;
pub const S_GLAREGOYLE_HOLD: state = 1480;
pub const S_GLAREGOYLE_BLINK: state = 1479;
pub const S_GLAREGOYLE_CHARGE: state = 1478;
pub const S_GLAREGOYLE: state = 1477;
pub const S_WALLVINE_SHORT: state = 1476;
pub const S_WALLVINE_LONG: state = 1475;
pub const S_TORCHFLOWER: state = 1474;
pub const S_JUNGLEPALM: state = 1473;
pub const S_BIGFERN2: state = 1472;
pub const S_BIGFERN1: state = 1471;
pub const S_BIGFERNLEAF: state = 1470;
pub const S_ROLLOUTROCK: state = 1469;
pub const S_ROLLOUTSPAWN: state = 1468;
pub const S_LAVAFALLROCK: state = 1467;
pub const S_LAVAFALL_LAVA3: state = 1466;
pub const S_LAVAFALL_LAVA2: state = 1465;
pub const S_LAVAFALL_LAVA1: state = 1464;
pub const S_LAVAFALL_SHOOT: state = 1463;
pub const S_LAVAFALL_TELL: state = 1462;
pub const S_LAVAFALL_DORMANT: state = 1461;
pub const S_FLAMEJETFLAMEB3: state = 1460;
pub const S_FLAMEJETFLAMEB2: state = 1459;
pub const S_FLAMEJETFLAMEB1: state = 1458;
pub const S_FJSPINAXISB2: state = 1457;
pub const S_FJSPINAXISB1: state = 1456;
pub const S_FJSPINAXISA2: state = 1455;
pub const S_FJSPINAXISA1: state = 1454;
pub const S_FLAMEJETFLAME9: state = 1453;
pub const S_FLAMEJETFLAME8: state = 1452;
pub const S_FLAMEJETFLAME7: state = 1451;
pub const S_FLAMEJETFLAME6: state = 1450;
pub const S_FLAMEJETFLAME5: state = 1449;
pub const S_FLAMEJETFLAME4: state = 1448;
pub const S_FLAMEJETFLAME3: state = 1447;
pub const S_FLAMEJETFLAME2: state = 1446;
pub const S_FLAMEJETFLAME1: state = 1445;
pub const S_FLAMEJETSTOP: state = 1444;
pub const S_FLAMEJETSTART: state = 1443;
pub const S_FLAMEJETSTND: state = 1442;
pub const S_TRAINSTEAM: state = 1441;
pub const S_TRAINDUST: state = 1440;
pub const S_TRAINPUFFMAKER: state = 1439;
pub const S_TRAINCAMEOSPAWNER_5: state = 1438;
pub const S_TRAINCAMEOSPAWNER_4: state = 1437;
pub const S_TRAINCAMEOSPAWNER_3: state = 1436;
pub const S_TRAINCAMEOSPAWNER_2: state = 1435;
pub const S_TRAINCAMEOSPAWNER_1: state = 1434;
pub const S_SALOONDOORCENTER: state = 1433;
pub const S_SALOONDOOR: state = 1432;
pub const S_MINECARTSPARK: state = 1431;
pub const S_MINECARTSIDEMARK2: state = 1430;
pub const S_MINECARTSIDEMARK1: state = 1429;
pub const S_MINECARTSEG_RIGHT: state = 1428;
pub const S_MINECARTSEG_LEFT: state = 1427;
pub const S_MINECARTSEG_BACK: state = 1426;
pub const S_MINECARTSEG_FRONT: state = 1425;
pub const S_MINECARTEND: state = 1424;
pub const S_MINECART_DTH1: state = 1423;
pub const S_MINECART_IDLE: state = 1422;
pub const S_ARIDDUST3: state = 1421;
pub const S_ARIDDUST2: state = 1420;
pub const S_ARIDDUST1: state = 1419;
pub const S_DUSTLAYER5: state = 1418;
pub const S_DUSTLAYER4: state = 1417;
pub const S_DUSTLAYER3: state = 1416;
pub const S_DUSTLAYER2: state = 1415;
pub const S_DUSTLAYER1: state = 1414;
pub const S_DUSTDEVIL: state = 1413;
pub const S_PROXIMITY_TNT_TRIGGER23: state = 1412;
pub const S_PROXIMITY_TNT_TRIGGER22: state = 1411;
pub const S_PROXIMITY_TNT_TRIGGER21: state = 1410;
pub const S_PROXIMITY_TNT_TRIGGER20: state = 1409;
pub const S_PROXIMITY_TNT_TRIGGER19: state = 1408;
pub const S_PROXIMITY_TNT_TRIGGER18: state = 1407;
pub const S_PROXIMITY_TNT_TRIGGER17: state = 1406;
pub const S_PROXIMITY_TNT_TRIGGER16: state = 1405;
pub const S_PROXIMITY_TNT_TRIGGER15: state = 1404;
pub const S_PROXIMITY_TNT_TRIGGER14: state = 1403;
pub const S_PROXIMITY_TNT_TRIGGER13: state = 1402;
pub const S_PROXIMITY_TNT_TRIGGER12: state = 1401;
pub const S_PROXIMITY_TNT_TRIGGER11: state = 1400;
pub const S_PROXIMITY_TNT_TRIGGER10: state = 1399;
pub const S_PROXIMITY_TNT_TRIGGER9: state = 1398;
pub const S_PROXIMITY_TNT_TRIGGER8: state = 1397;
pub const S_PROXIMITY_TNT_TRIGGER7: state = 1396;
pub const S_PROXIMITY_TNT_TRIGGER6: state = 1395;
pub const S_PROXIMITY_TNT_TRIGGER5: state = 1394;
pub const S_PROXIMITY_TNT_TRIGGER4: state = 1393;
pub const S_PROXIMITY_TNT_TRIGGER3: state = 1392;
pub const S_PROXIMITY_TNT_TRIGGER2: state = 1391;
pub const S_PROXIMITY_TNT_TRIGGER1: state = 1390;
pub const S_PROXIMITY_TNT: state = 1389;
pub const S_TNTBARREL_FLYING: state = 1388;
pub const S_TNTBARREL_EXPL7: state = 1387;
pub const S_TNTBARREL_EXPL6: state = 1386;
pub const S_TNTBARREL_EXPL5: state = 1385;
pub const S_TNTBARREL_EXPL4: state = 1384;
pub const S_TNTBARREL_EXPL3: state = 1383;
pub const S_TNTBARREL_EXPL2: state = 1382;
pub const S_TNTBARREL_EXPL1: state = 1381;
pub const S_TNTBARREL_STND1: state = 1380;
pub const S_OILLAMPFLARE: state = 1379;
pub const S_OILLAMP: state = 1378;
pub const S_ARIDSIGN_SHARPTURN: state = 1377;
pub const S_ARIDSIGN_CACTI: state = 1376;
pub const S_ARIDSIGN_CAUTION: state = 1375;
pub const S_CACTISMALLSEG: state = 1374;
pub const S_CACTITINYSEG: state = 1373;
pub const S_CACTI11: state = 1372;
pub const S_CACTI10: state = 1371;
pub const S_CACTI9: state = 1370;
pub const S_CACTI8: state = 1369;
pub const S_CACTI7: state = 1368;
pub const S_CACTI6: state = 1367;
pub const S_CACTI5: state = 1366;
pub const S_CACTI4: state = 1365;
pub const S_CACTI3: state = 1364;
pub const S_CACTI2: state = 1363;
pub const S_CACTI1: state = 1362;
pub const S_LITTLETUMBLEWEED_ROLL8: state = 1361;
pub const S_LITTLETUMBLEWEED_ROLL7: state = 1360;
pub const S_LITTLETUMBLEWEED_ROLL6: state = 1359;
pub const S_LITTLETUMBLEWEED_ROLL5: state = 1358;
pub const S_LITTLETUMBLEWEED_ROLL4: state = 1357;
pub const S_LITTLETUMBLEWEED_ROLL3: state = 1356;
pub const S_LITTLETUMBLEWEED_ROLL2: state = 1355;
pub const S_LITTLETUMBLEWEED_ROLL1: state = 1354;
pub const S_LITTLETUMBLEWEED: state = 1353;
pub const S_BIGTUMBLEWEED_ROLL8: state = 1352;
pub const S_BIGTUMBLEWEED_ROLL7: state = 1351;
pub const S_BIGTUMBLEWEED_ROLL6: state = 1350;
pub const S_BIGTUMBLEWEED_ROLL5: state = 1349;
pub const S_BIGTUMBLEWEED_ROLL4: state = 1348;
pub const S_BIGTUMBLEWEED_ROLL3: state = 1347;
pub const S_BIGTUMBLEWEED_ROLL2: state = 1346;
pub const S_BIGTUMBLEWEED_ROLL1: state = 1345;
pub const S_BIGTUMBLEWEED: state = 1344;
pub const S_BRAMBLES: state = 1343;
pub const S_SUSPICIOUSFACESTABBERSTATUE_BURST2: state = 1342;
pub const S_SUSPICIOUSFACESTABBERSTATUE_BURST1: state = 1341;
pub const S_SUSPICIOUSFACESTABBERSTATUE_WAIT: state = 1340;
pub const S_FACESTABBERSTATUE: state = 1339;
pub const S_CRAWLASTATUE: state = 1338;
pub const S_WAVINGFLAGSEG2: state = 1337;
pub const S_WAVINGFLAGSEG1: state = 1336;
pub const S_WAVINGFLAG: state = 1335;
pub const S_FIRETORCH: state = 1334;
pub const S_FLAMEHOLDER: state = 1333;
pub const S_CANDLEPRICKET: state = 1332;
pub const S_CANDLE: state = 1331;
pub const S_CEZBUSH2: state = 1330;
pub const S_CEZBUSH1: state = 1329;
pub const S_PINETREE: state = 1328;
pub const S_CEZBANNER2: state = 1327;
pub const S_CEZBANNER1: state = 1326;
pub const S_CEZPOLE: state = 1325;
pub const S_CEZFLOWER: state = 1324;
pub const S_BIGFIREBAR16: state = 1323;
pub const S_BIGFIREBAR15: state = 1322;
pub const S_BIGFIREBAR14: state = 1321;
pub const S_BIGFIREBAR13: state = 1320;
pub const S_BIGFIREBAR12: state = 1319;
pub const S_BIGFIREBAR11: state = 1318;
pub const S_BIGFIREBAR10: state = 1317;
pub const S_BIGFIREBAR9: state = 1316;
pub const S_BIGFIREBAR8: state = 1315;
pub const S_BIGFIREBAR7: state = 1314;
pub const S_BIGFIREBAR6: state = 1313;
pub const S_BIGFIREBAR5: state = 1312;
pub const S_BIGFIREBAR4: state = 1311;
pub const S_BIGFIREBAR3: state = 1310;
pub const S_BIGFIREBAR2: state = 1309;
pub const S_BIGFIREBAR1: state = 1308;
pub const S_SMALLFIREBAR16: state = 1307;
pub const S_SMALLFIREBAR15: state = 1306;
pub const S_SMALLFIREBAR14: state = 1305;
pub const S_SMALLFIREBAR13: state = 1304;
pub const S_SMALLFIREBAR12: state = 1303;
pub const S_SMALLFIREBAR11: state = 1302;
pub const S_SMALLFIREBAR10: state = 1301;
pub const S_SMALLFIREBAR9: state = 1300;
pub const S_SMALLFIREBAR8: state = 1299;
pub const S_SMALLFIREBAR7: state = 1298;
pub const S_SMALLFIREBAR6: state = 1297;
pub const S_SMALLFIREBAR5: state = 1296;
pub const S_SMALLFIREBAR4: state = 1295;
pub const S_SMALLFIREBAR3: state = 1294;
pub const S_SMALLFIREBAR2: state = 1293;
pub const S_SMALLFIREBAR1: state = 1292;
pub const S_REDSPRINGBALL5: state = 1291;
pub const S_REDSPRINGBALL4: state = 1290;
pub const S_REDSPRINGBALL3: state = 1289;
pub const S_REDSPRINGBALL2: state = 1288;
pub const S_REDSPRINGBALL: state = 1287;
pub const S_YELLOWSPRINGBALL5: state = 1286;
pub const S_YELLOWSPRINGBALL4: state = 1285;
pub const S_YELLOWSPRINGBALL3: state = 1284;
pub const S_YELLOWSPRINGBALL2: state = 1283;
pub const S_YELLOWSPRINGBALL: state = 1282;
pub const S_BIGGRABCHAIN: state = 1281;
pub const S_SMALLGRABCHAIN: state = 1280;
pub const S_BIGMACE: state = 1279;
pub const S_SMALLMACE: state = 1278;
pub const S_BIGMACECHAIN: state = 1277;
pub const S_SMALLMACECHAIN: state = 1276;
pub const S_SLING2: state = 1275;
pub const S_SLING1: state = 1274;
pub const S_EGGSTATUE1: state = 1273;
pub const S_FLAMEREST: state = 1272;
pub const S_FLAMEPARTICLE: state = 1271;
pub const S_FLAME: state = 1270;
pub const S_CEZCHAIN: state = 1269;
pub const S_LIGHTBEAM12: state = 1268;
pub const S_LIGHTBEAM11: state = 1267;
pub const S_LIGHTBEAM10: state = 1266;
pub const S_LIGHTBEAM9: state = 1265;
pub const S_LIGHTBEAM8: state = 1264;
pub const S_LIGHTBEAM7: state = 1263;
pub const S_LIGHTBEAM6: state = 1262;
pub const S_LIGHTBEAM5: state = 1261;
pub const S_LIGHTBEAM4: state = 1260;
pub const S_LIGHTBEAM3: state = 1259;
pub const S_LIGHTBEAM2: state = 1258;
pub const S_LIGHTBEAM1: state = 1257;
pub const S_DSZ2STALAGMITE: state = 1256;
pub const S_DSZSTALAGMITE: state = 1255;
pub const S_ANIMALGAESEG: state = 1254;
pub const S_ANIMALGAETOP2: state = 1253;
pub const S_ANIMALGAETOP1: state = 1252;
pub const S_KELP: state = 1251;
pub const S_BLUECRYSTAL1: state = 1250;
pub const S_CORAL5: state = 1249;
pub const S_CORAL4: state = 1248;
pub const S_CORAL3: state = 1247;
pub const S_CORAL2: state = 1246;
pub const S_CORAL1: state = 1245;
pub const S_DRIPC2: state = 1244;
pub const S_DRIPC1: state = 1243;
pub const S_DRIPB1: state = 1242;
pub const S_DRIPA4: state = 1241;
pub const S_DRIPA3: state = 1240;
pub const S_DRIPA2: state = 1239;
pub const S_DRIPA1: state = 1238;
pub const S_SEAWEED6: state = 1237;
pub const S_SEAWEED5: state = 1236;
pub const S_SEAWEED4: state = 1235;
pub const S_SEAWEED3: state = 1234;
pub const S_SEAWEED2: state = 1233;
pub const S_SEAWEED1: state = 1232;
pub const S_BIGGARGOYLE: state = 1231;
pub const S_GARGOYLE: state = 1230;
pub const S_ALARM1: state = 1229;
pub const S_THZTREEBRANCH13: state = 1228;
pub const S_THZTREEBRANCH12: state = 1227;
pub const S_THZTREEBRANCH11: state = 1226;
pub const S_THZTREEBRANCH10: state = 1225;
pub const S_THZTREEBRANCH9: state = 1224;
pub const S_THZTREEBRANCH8: state = 1223;
pub const S_THZTREEBRANCH7: state = 1222;
pub const S_THZTREEBRANCH6: state = 1221;
pub const S_THZTREEBRANCH5: state = 1220;
pub const S_THZTREEBRANCH4: state = 1219;
pub const S_THZTREEBRANCH3: state = 1218;
pub const S_THZTREEBRANCH2: state = 1217;
pub const S_THZTREEBRANCH1: state = 1216;
pub const S_THZTREE: state = 1215;
pub const S_THZFLOWERC: state = 1214;
pub const S_THZFLOWERB: state = 1213;
pub const S_THZFLOWERA: state = 1212;
pub const S_SPRINGTREE: state = 1211;
pub const S_BUSHREDTREE: state = 1210;
pub const S_BUSHTREE: state = 1209;
pub const S_POLYGONTREE: state = 1208;
pub const S_FHZPINKTREE: state = 1207;
pub const S_FHZTREE: state = 1206;
pub const S_CHECKERSUNSETTREE: state = 1205;
pub const S_CHECKERTREE: state = 1204;
pub const S_GFZCHERRYTREE: state = 1203;
pub const S_GFZBERRYTREE: state = 1202;
pub const S_GFZTREE: state = 1201;
pub const S_BUSH: state = 1200;
pub const S_BERRYBUSH: state = 1199;
pub const S_BLUEBERRYBUSH: state = 1198;
pub const S_GFZFLOWERC: state = 1197;
pub const S_GFZFLOWERB: state = 1196;
pub const S_GFZFLOWERA: state = 1195;
pub const S_TUTORIALFLOWERF16: state = 1194;
pub const S_TUTORIALFLOWERF15: state = 1193;
pub const S_TUTORIALFLOWERF14: state = 1192;
pub const S_TUTORIALFLOWERF13: state = 1191;
pub const S_TUTORIALFLOWERF12: state = 1190;
pub const S_TUTORIALFLOWERF11: state = 1189;
pub const S_TUTORIALFLOWERF10: state = 1188;
pub const S_TUTORIALFLOWERF9: state = 1187;
pub const S_TUTORIALFLOWERF8: state = 1186;
pub const S_TUTORIALFLOWERF7: state = 1185;
pub const S_TUTORIALFLOWERF6: state = 1184;
pub const S_TUTORIALFLOWERF5: state = 1183;
pub const S_TUTORIALFLOWERF4: state = 1182;
pub const S_TUTORIALFLOWERF3: state = 1181;
pub const S_TUTORIALFLOWERF2: state = 1180;
pub const S_TUTORIALFLOWERF1: state = 1179;
pub const S_TUTORIALFLOWER16: state = 1178;
pub const S_TUTORIALFLOWER15: state = 1177;
pub const S_TUTORIALFLOWER14: state = 1176;
pub const S_TUTORIALFLOWER13: state = 1175;
pub const S_TUTORIALFLOWER12: state = 1174;
pub const S_TUTORIALFLOWER11: state = 1173;
pub const S_TUTORIALFLOWER10: state = 1172;
pub const S_TUTORIALFLOWER9: state = 1171;
pub const S_TUTORIALFLOWER8: state = 1170;
pub const S_TUTORIALFLOWER7: state = 1169;
pub const S_TUTORIALFLOWER6: state = 1168;
pub const S_TUTORIALFLOWER5: state = 1167;
pub const S_TUTORIALFLOWER4: state = 1166;
pub const S_TUTORIALFLOWER3: state = 1165;
pub const S_TUTORIALFLOWER2: state = 1164;
pub const S_TUTORIALFLOWER1: state = 1163;
pub const S_TUTORIALLEAF16: state = 1162;
pub const S_TUTORIALLEAF15: state = 1161;
pub const S_TUTORIALLEAF14: state = 1160;
pub const S_TUTORIALLEAF13: state = 1159;
pub const S_TUTORIALLEAF12: state = 1158;
pub const S_TUTORIALLEAF11: state = 1157;
pub const S_TUTORIALLEAF10: state = 1156;
pub const S_TUTORIALLEAF9: state = 1155;
pub const S_TUTORIALLEAF8: state = 1154;
pub const S_TUTORIALLEAF7: state = 1153;
pub const S_TUTORIALLEAF6: state = 1152;
pub const S_TUTORIALLEAF5: state = 1151;
pub const S_TUTORIALLEAF4: state = 1150;
pub const S_TUTORIALLEAF3: state = 1149;
pub const S_TUTORIALLEAF2: state = 1148;
pub const S_TUTORIALLEAF1: state = 1147;
pub const S_LETTER: state = 1146;
pub const S_DEMONFIRE: state = 1145;
pub const S_ARROWBONK: state = 1144;
pub const S_ARROW: state = 1143;
pub const S_CANNONBALL1: state = 1142;
pub const S_TURRETLASEREXPLODE2: state = 1141;
pub const S_TURRETLASEREXPLODE1: state = 1140;
pub const S_TURRETLASER: state = 1139;
pub const S_JETBULLET2: state = 1138;
pub const S_JETBULLET1: state = 1137;
pub const S_MINE_BOOM4: state = 1136;
pub const S_MINE_BOOM3: state = 1135;
pub const S_MINE_BOOM2: state = 1134;
pub const S_MINE_BOOM1: state = 1133;
pub const S_MINE1: state = 1132;
pub const S_ENERGYBALL2: state = 1131;
pub const S_ENERGYBALL1: state = 1130;
pub const S_TORPEDO: state = 1129;
pub const S_LASERFLAME5: state = 1128;
pub const S_LASERFLAME4: state = 1127;
pub const S_LASERFLAME3: state = 1126;
pub const S_LASERFLAME2: state = 1125;
pub const S_LASERFLAME1: state = 1124;
pub const S_LASERFLASH: state = 1123;
pub const S_LASER2: state = 1122;
pub const S_LASER: state = 1121;
pub const S_ROCKET: state = 1120;
pub const S_THUNDERCOIN_ICON2: state = 1119;
pub const S_THUNDERCOIN_ICON1: state = 1118;
pub const S_BUBBLEWRAP_ICON2: state = 1117;
pub const S_BUBBLEWRAP_ICON1: state = 1116;
pub const S_FLAMEAURA_ICON2: state = 1115;
pub const S_FLAMEAURA_ICON1: state = 1114;
pub const S_SCORE10K_ICON2: state = 1113;
pub const S_SCORE10K_ICON1: state = 1112;
pub const S_SCORE1K_ICON2: state = 1111;
pub const S_SCORE1K_ICON1: state = 1110;
pub const S_RECYCLER_ICON2: state = 1109;
pub const S_RECYCLER_ICON1: state = 1108;
pub const S_GRAVITY_ICON2: state = 1107;
pub const S_GRAVITY_ICON1: state = 1106;
pub const S_MIXUP_ICON2: state = 1105;
pub const S_MIXUP_ICON1: state = 1104;
pub const S_EGGMAN_ICON2: state = 1103;
pub const S_EGGMAN_ICON1: state = 1102;
pub const S_1UP_ICON2: state = 1101;
pub const S_1UP_ICON1: state = 1100;
pub const S_INVULN_ICON2: state = 1099;
pub const S_INVULN_ICON1: state = 1098;
pub const S_SNEAKERS_ICON2: state = 1097;
pub const S_SNEAKERS_ICON1: state = 1096;
pub const S_ELEMENTAL_ICON2: state = 1095;
pub const S_ELEMENTAL_ICON1: state = 1094;
pub const S_WHIRLWIND_ICON2: state = 1093;
pub const S_WHIRLWIND_ICON1: state = 1092;
pub const S_ARMAGEDDON_ICON2: state = 1091;
pub const S_ARMAGEDDON_ICON1: state = 1090;
pub const S_FORCE_ICON2: state = 1089;
pub const S_FORCE_ICON1: state = 1088;
pub const S_ATTRACT_ICON2: state = 1087;
pub const S_ATTRACT_ICON1: state = 1086;
pub const S_PITY_ICON2: state = 1085;
pub const S_PITY_ICON1: state = 1084;
pub const S_RING_ICON2: state = 1083;
pub const S_RING_ICON1: state = 1082;
pub const S_BLUEBOX_POP2: state = 1081;
pub const S_BLUEBOX_POP1: state = 1080;
pub const S_RING_BLUEBOX2: state = 1079;
pub const S_RING_BLUEBOX1: state = 1078;
pub const S_REDBOX_POP2: state = 1077;
pub const S_REDBOX_POP1: state = 1076;
pub const S_RING_REDBOX2: state = 1075;
pub const S_RING_REDBOX1: state = 1074;
pub const S_THUNDERCOIN_GOLDBOX: state = 1073;
pub const S_BUBBLEWRAP_GOLDBOX: state = 1072;
pub const S_FLAMEAURA_GOLDBOX: state = 1071;
pub const S_GRAVITY_GOLDBOX: state = 1070;
pub const S_EGGMAN_GOLDBOX: state = 1069;
pub const S_INVULN_GOLDBOX: state = 1068;
pub const S_SNEAKERS_GOLDBOX: state = 1067;
pub const S_ELEMENTAL_GOLDBOX: state = 1066;
pub const S_WHIRLWIND_GOLDBOX: state = 1065;
pub const S_ARMAGEDDON_GOLDBOX: state = 1064;
pub const S_FORCE_GOLDBOX: state = 1063;
pub const S_ATTRACT_GOLDBOX: state = 1062;
pub const S_PITY_GOLDBOX: state = 1061;
pub const S_THUNDERCOIN_BOX: state = 1060;
pub const S_BUBBLEWRAP_BOX: state = 1059;
pub const S_FLAMEAURA_BOX: state = 1058;
pub const S_SCORE10K_BOX: state = 1057;
pub const S_SCORE1K_BOX: state = 1056;
pub const S_RECYCLER_BOX: state = 1055;
pub const S_GRAVITY_BOX: state = 1054;
pub const S_MIXUP_BOX: state = 1053;
pub const S_EGGMAN_BOX: state = 1052;
pub const S_1UP_BOX: state = 1051;
pub const S_INVULN_BOX: state = 1050;
pub const S_SNEAKERS_BOX: state = 1049;
pub const S_ELEMENTAL_BOX: state = 1048;
pub const S_WHIRLWIND_BOX: state = 1047;
pub const S_ARMAGEDDON_BOX: state = 1046;
pub const S_FORCE_BOX: state = 1045;
pub const S_ATTRACT_BOX: state = 1044;
pub const S_PITY_BOX: state = 1043;
pub const S_RING_BOX: state = 1042;
pub const S_MYSTERY_BOX: state = 1041;
pub const S_GOLDBOX_OFF7: state = 1040;
pub const S_GOLDBOX_OFF6: state = 1039;
pub const S_GOLDBOX_OFF5: state = 1038;
pub const S_GOLDBOX_OFF4: state = 1037;
pub const S_GOLDBOX_OFF3: state = 1036;
pub const S_GOLDBOX_OFF2: state = 1035;
pub const S_GOLDBOX_OFF1: state = 1034;
pub const S_GOLDBOX_FLICKER: state = 1033;
pub const S_BOX_POP2: state = 1032;
pub const S_BOX_POP1: state = 1031;
pub const S_BOX_FLICKER: state = 1030;
pub const S_BOXSPARKLE4: state = 1029;
pub const S_BOXSPARKLE3: state = 1028;
pub const S_BOXSPARKLE2: state = 1027;
pub const S_BOXSPARKLE1: state = 1026;
pub const S_CANNONLAUNCHER3: state = 1025;
pub const S_CANNONLAUNCHER2: state = 1024;
pub const S_CANNONLAUNCHER1: state = 1023;
pub const S_BIGMINE_BLAST5: state = 1022;
pub const S_BIGMINE_BLAST4: state = 1021;
pub const S_BIGMINE_BLAST3: state = 1020;
pub const S_BIGMINE_BLAST2: state = 1019;
pub const S_BIGMINE_BLAST1: state = 1018;
pub const S_BIGMINE_SET3: state = 1017;
pub const S_BIGMINE_SET2: state = 1016;
pub const S_BIGMINE_SET1: state = 1015;
pub const S_BIGMINE_ALERT3: state = 1014;
pub const S_BIGMINE_ALERT2: state = 1013;
pub const S_BIGMINE_ALERT1: state = 1012;
pub const S_BIGMINE_IDLE: state = 1011;
pub const S_STARPOST_ENDSPIN: state = 1010;
pub const S_STARPOST_SPIN: state = 1009;
pub const S_STARPOST_STARTSPIN: state = 1008;
pub const S_STARPOST_FLASH: state = 1007;
pub const S_STARPOST_IDLE: state = 1006;
pub const S_WALLSPIKED2: state = 1005;
pub const S_WALLSPIKED1: state = 1004;
pub const S_WALLSPIKEBASE: state = 1003;
pub const S_WALLSPIKE6: state = 1002;
pub const S_WALLSPIKE5: state = 1001;
pub const S_WALLSPIKE4: state = 1000;
pub const S_WALLSPIKE3: state = 999;
pub const S_WALLSPIKE2: state = 998;
pub const S_WALLSPIKE1: state = 997;
pub const S_SPIKED2: state = 996;
pub const S_SPIKED1: state = 995;
pub const S_SPIKE6: state = 994;
pub const S_SPIKE5: state = 993;
pub const S_SPIKE4: state = 992;
pub const S_SPIKE3: state = 991;
pub const S_SPIKE2: state = 990;
pub const S_SPIKE1: state = 989;
pub const S_TEAM_SPINFIRE6: state = 988;
pub const S_TEAM_SPINFIRE5: state = 987;
pub const S_TEAM_SPINFIRE4: state = 986;
pub const S_TEAM_SPINFIRE3: state = 985;
pub const S_TEAM_SPINFIRE2: state = 984;
pub const S_TEAM_SPINFIRE1: state = 983;
pub const S_SPINFIRE6: state = 982;
pub const S_SPINFIRE5: state = 981;
pub const S_SPINFIRE4: state = 980;
pub const S_SPINFIRE3: state = 979;
pub const S_SPINFIRE2: state = 978;
pub const S_SPINFIRE1: state = 977;
pub const S_SPIKEBALL8: state = 976;
pub const S_SPIKEBALL7: state = 975;
pub const S_SPIKEBALL6: state = 974;
pub const S_SPIKEBALL5: state = 973;
pub const S_SPIKEBALL4: state = 972;
pub const S_SPIKEBALL3: state = 971;
pub const S_SPIKEBALL2: state = 970;
pub const S_SPIKEBALL1: state = 969;
pub const S_CLEARSIGN: state = 968;
pub const S_EGGMANSIGN: state = 967;
pub const S_SIGNBOARD: state = 966;
pub const S_SIGNSTOP: state = 965;
pub const S_SIGNSLOW: state = 964;
pub const S_SIGNPLAYER: state = 963;
pub const S_SIGNSPIN6: state = 962;
pub const S_SIGNSPIN5: state = 961;
pub const S_SIGNSPIN4: state = 960;
pub const S_SIGNSPIN3: state = 959;
pub const S_SIGNSPIN2: state = 958;
pub const S_SIGNSPIN1: state = 957;
pub const S_SIGN: state = 956;
pub const S_BUBBLES4: state = 955;
pub const S_BUBBLES3: state = 954;
pub const S_BUBBLES2: state = 953;
pub const S_BUBBLES1: state = 952;
pub const S_SHRD3: state = 951;
pub const S_SHRD2: state = 950;
pub const S_SHRD1: state = 949;
pub const S_CEMG7: state = 948;
pub const S_CEMG6: state = 947;
pub const S_CEMG5: state = 946;
pub const S_CEMG4: state = 945;
pub const S_CEMG3: state = 944;
pub const S_CEMG2: state = 943;
pub const S_CEMG1: state = 942;
pub const S_EMBLEM26: state = 941;
pub const S_EMBLEM25: state = 940;
pub const S_EMBLEM24: state = 939;
pub const S_EMBLEM23: state = 938;
pub const S_EMBLEM22: state = 937;
pub const S_EMBLEM21: state = 936;
pub const S_EMBLEM20: state = 935;
pub const S_EMBLEM19: state = 934;
pub const S_EMBLEM18: state = 933;
pub const S_EMBLEM17: state = 932;
pub const S_EMBLEM16: state = 931;
pub const S_EMBLEM15: state = 930;
pub const S_EMBLEM14: state = 929;
pub const S_EMBLEM13: state = 928;
pub const S_EMBLEM12: state = 927;
pub const S_EMBLEM11: state = 926;
pub const S_EMBLEM10: state = 925;
pub const S_EMBLEM9: state = 924;
pub const S_EMBLEM8: state = 923;
pub const S_EMBLEM7: state = 922;
pub const S_EMBLEM6: state = 921;
pub const S_EMBLEM5: state = 920;
pub const S_EMBLEM4: state = 919;
pub const S_EMBLEM3: state = 918;
pub const S_EMBLEM2: state = 917;
pub const S_EMBLEM1: state = 916;
pub const S_BLUEFLAG: state = 915;
pub const S_REDFLAG: state = 914;
pub const S_TOKEN: state = 913;
pub const S_TEAMRING: state = 912;
pub const S_GRAVWELLRED: state = 911;
pub const S_GRAVWELLGREEN: state = 910;
pub const S_NIGHTSSTARXMAS: state = 909;
pub const S_NIGHTSSTAR: state = 908;
pub const S_NIGHTSCHIPBONUS: state = 907;
pub const S_NIGHTSCHIP: state = 906;
pub const S_BOMBSPHERE4: state = 905;
pub const S_BOMBSPHERE3: state = 904;
pub const S_BOMBSPHERE2: state = 903;
pub const S_BOMBSPHERE1: state = 902;
pub const S_BLUESPHERESPARK: state = 901;
pub const S_BLUESPHEREBONUS: state = 900;
pub const S_BLUESPHERE: state = 899;
pub const S_RING: state = 898;
pub const S_MSSHIELD_F2: state = 897;
pub const S_MSSHIELD_F1: state = 896;
pub const S_METALSONIC_FLEE2: state = 895;
pub const S_METALSONIC_FLEE1: state = 894;
pub const S_METALSONIC_DEATH4: state = 893;
pub const S_METALSONIC_DEATH3: state = 892;
pub const S_METALSONIC_DEATH2: state = 891;
pub const S_METALSONIC_DEATH1: state = 890;
pub const S_METALSONIC_PAIN: state = 889;
pub const S_METALSONIC_SHOOT: state = 888;
pub const S_METALSONIC_BADBOUNCE: state = 887;
pub const S_METALSONIC_BOUNCE: state = 886;
pub const S_METALSONIC_DASH: state = 885;
pub const S_METALSONIC_GATHER: state = 884;
pub const S_METALSONIC_RAISE: state = 883;
pub const S_METALSONIC_STUN: state = 882;
pub const S_METALSONIC_VECTOR: state = 881;
pub const S_METALSONIC_FLOAT: state = 880;
pub const S_METALSONIC_RACE: state = 879;
pub const S_CYBRAKDEMONVILEEXPLOSION3: state = 878;
pub const S_CYBRAKDEMONVILEEXPLOSION2: state = 877;
pub const S_CYBRAKDEMONVILEEXPLOSION1: state = 876;
pub const S_CYBRAKDEMONNAPALMFLAME_DIE: state = 875;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY6: state = 874;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY5: state = 873;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY4: state = 872;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY3: state = 871;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY2: state = 870;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY1: state = 869;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE5: state = 868;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE4: state = 867;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE3: state = 866;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE2: state = 865;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE1: state = 864;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL: state = 863;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE4: state = 862;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE3: state = 861;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE2: state = 860;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE1: state = 859;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY4: state = 858;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY3: state = 857;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY2: state = 856;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY1: state = 855;
pub const S_CYBRAKDEMONTARGETDOT: state = 854;
pub const S_CYBRAKDEMONTARGETRETICULE14: state = 853;
pub const S_CYBRAKDEMONTARGETRETICULE13: state = 852;
pub const S_CYBRAKDEMONTARGETRETICULE12: state = 851;
pub const S_CYBRAKDEMONTARGETRETICULE11: state = 850;
pub const S_CYBRAKDEMONTARGETRETICULE10: state = 849;
pub const S_CYBRAKDEMONTARGETRETICULE9: state = 848;
pub const S_CYBRAKDEMONTARGETRETICULE8: state = 847;
pub const S_CYBRAKDEMONTARGETRETICULE7: state = 846;
pub const S_CYBRAKDEMONTARGETRETICULE6: state = 845;
pub const S_CYBRAKDEMONTARGETRETICULE5: state = 844;
pub const S_CYBRAKDEMONTARGETRETICULE4: state = 843;
pub const S_CYBRAKDEMONTARGETRETICULE3: state = 842;
pub const S_CYBRAKDEMONTARGETRETICULE2: state = 841;
pub const S_CYBRAKDEMONTARGETRETICULE1: state = 840;
pub const S_CYBRAKDEMONELECTRICBARRIER_REVIVE3: state = 839;
pub const S_CYBRAKDEMONELECTRICBARRIER_REVIVE2: state = 838;
pub const S_CYBRAKDEMONELECTRICBARRIER_REVIVE1: state = 837;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMLOOP: state = 836;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMFAIL: state = 835;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM12: state = 834;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM11: state = 833;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM10: state = 832;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM9: state = 831;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM8: state = 830;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM7: state = 829;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM6: state = 828;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM5: state = 827;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM4: state = 826;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM3: state = 825;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM2: state = 824;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM1: state = 823;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMCHOOSE: state = 822;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMSUCCESS: state = 821;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMCHECK: state = 820;
pub const S_CYBRAKDEMONELECTRICBARRIER_DIE3: state = 819;
pub const S_CYBRAKDEMONELECTRICBARRIER_DIE2: state = 818;
pub const S_CYBRAKDEMONELECTRICBARRIER_DIE1: state = 817;
pub const S_CYBRAKDEMONELECTRICBARRIER24: state = 816;
pub const S_CYBRAKDEMONELECTRICBARRIER23: state = 815;
pub const S_CYBRAKDEMONELECTRICBARRIER22: state = 814;
pub const S_CYBRAKDEMONELECTRICBARRIER21: state = 813;
pub const S_CYBRAKDEMONELECTRICBARRIER20: state = 812;
pub const S_CYBRAKDEMONELECTRICBARRIER19: state = 811;
pub const S_CYBRAKDEMONELECTRICBARRIER18: state = 810;
pub const S_CYBRAKDEMONELECTRICBARRIER17: state = 809;
pub const S_CYBRAKDEMONELECTRICBARRIER16: state = 808;
pub const S_CYBRAKDEMONELECTRICBARRIER15: state = 807;
pub const S_CYBRAKDEMONELECTRICBARRIER14: state = 806;
pub const S_CYBRAKDEMONELECTRICBARRIER13: state = 805;
pub const S_CYBRAKDEMONELECTRICBARRIER12: state = 804;
pub const S_CYBRAKDEMONELECTRICBARRIER11: state = 803;
pub const S_CYBRAKDEMONELECTRICBARRIER10: state = 802;
pub const S_CYBRAKDEMONELECTRICBARRIER9: state = 801;
pub const S_CYBRAKDEMONELECTRICBARRIER8: state = 800;
pub const S_CYBRAKDEMONELECTRICBARRIER7: state = 799;
pub const S_CYBRAKDEMONELECTRICBARRIER6: state = 798;
pub const S_CYBRAKDEMONELECTRICBARRIER5: state = 797;
pub const S_CYBRAKDEMONELECTRICBARRIER4: state = 796;
pub const S_CYBRAKDEMONELECTRICBARRIER3: state = 795;
pub const S_CYBRAKDEMONELECTRICBARRIER2: state = 794;
pub const S_CYBRAKDEMONELECTRICBARRIER1: state = 793;
pub const S_CYBRAKDEMONELECTRICBARRIER_PLAYSOUND: state = 792;
pub const S_CYBRAKDEMONELECTRICBARRIER_INIT2: state = 791;
pub const S_CYBRAKDEMONELECTRICBARRIER_INIT1: state = 790;
pub const S_CYBRAKDEMONFLAMEREST: state = 789;
pub const S_CYBRAKDEMONFLAMESHOT_DIE: state = 788;
pub const S_CYBRAKDEMONFLAMESHOT_FLY3: state = 787;
pub const S_CYBRAKDEMONFLAMESHOT_FLY2: state = 786;
pub const S_CYBRAKDEMONFLAMESHOT_FLY1: state = 785;
pub const S_CYBRAKDEMONMISSILE_EXPLODE3: state = 784;
pub const S_CYBRAKDEMONMISSILE_EXPLODE2: state = 783;
pub const S_CYBRAKDEMONMISSILE_EXPLODE1: state = 782;
pub const S_CYBRAKDEMONMISSILE: state = 781;
pub const S_CYBRAKDEMON_INVINCIBLERIZE: state = 780;
pub const S_CYBRAKDEMON_DEINVINCIBLERIZE: state = 779;
pub const S_CYBRAKDEMON_DIE8: state = 778;
pub const S_CYBRAKDEMON_DIE7: state = 777;
pub const S_CYBRAKDEMON_DIE6: state = 776;
pub const S_CYBRAKDEMON_DIE5: state = 775;
pub const S_CYBRAKDEMON_DIE4: state = 774;
pub const S_CYBRAKDEMON_DIE3: state = 773;
pub const S_CYBRAKDEMON_DIE2: state = 772;
pub const S_CYBRAKDEMON_DIE1: state = 771;
pub const S_CYBRAKDEMON_PAIN3: state = 770;
pub const S_CYBRAKDEMON_PAIN2: state = 769;
pub const S_CYBRAKDEMON_PAIN1: state = 768;
pub const S_CYBRAKDEMON_FINISH_ATTACK2: state = 767;
pub const S_CYBRAKDEMON_FINISH_ATTACK1: state = 766;
pub const S_CYBRAKDEMON_NAPALM_ATTACK3: state = 765;
pub const S_CYBRAKDEMON_NAPALM_ATTACK2: state = 764;
pub const S_CYBRAKDEMON_NAPALM_ATTACK1: state = 763;
pub const S_CYBRAKDEMON_VILE_ATTACK6: state = 762;
pub const S_CYBRAKDEMON_VILE_ATTACK5: state = 761;
pub const S_CYBRAKDEMON_VILE_ATTACK4: state = 760;
pub const S_CYBRAKDEMON_VILE_ATTACK3: state = 759;
pub const S_CYBRAKDEMON_VILE_ATTACK2: state = 758;
pub const S_CYBRAKDEMON_VILE_ATTACK1: state = 757;
pub const S_CYBRAKDEMON_CHOOSE_ATTACK2: state = 756;
pub const S_CYBRAKDEMON_FLAME_ATTACK4: state = 755;
pub const S_CYBRAKDEMON_FLAME_ATTACK3: state = 754;
pub const S_CYBRAKDEMON_FLAME_ATTACK2: state = 753;
pub const S_CYBRAKDEMON_FLAME_ATTACK1: state = 752;
pub const S_CYBRAKDEMON_MISSILE_ATTACK6: state = 751;
pub const S_CYBRAKDEMON_MISSILE_ATTACK5: state = 750;
pub const S_CYBRAKDEMON_MISSILE_ATTACK4: state = 749;
pub const S_CYBRAKDEMON_MISSILE_ATTACK3: state = 748;
pub const S_CYBRAKDEMON_MISSILE_ATTACK2: state = 747;
pub const S_CYBRAKDEMON_MISSILE_ATTACK1: state = 746;
pub const S_CYBRAKDEMON_CHOOSE_ATTACK1: state = 745;
pub const S_CYBRAKDEMON_WALK6: state = 744;
pub const S_CYBRAKDEMON_WALK5: state = 743;
pub const S_CYBRAKDEMON_WALK4: state = 742;
pub const S_CYBRAKDEMON_WALK3: state = 741;
pub const S_CYBRAKDEMON_WALK2: state = 740;
pub const S_CYBRAKDEMON_WALK1: state = 739;
pub const S_CYBRAKDEMON_IDLE: state = 738;
pub const S_BLACKEGG_MISSILE: state = 737;
pub const S_BLACKEGG_GOOP7: state = 736;
pub const S_BLACKEGG_GOOP6: state = 735;
pub const S_BLACKEGG_GOOP5: state = 734;
pub const S_BLACKEGG_GOOP4: state = 733;
pub const S_BLACKEGG_GOOP3: state = 732;
pub const S_BLACKEGG_GOOP2: state = 731;
pub const S_BLACKEGG_GOOP1: state = 730;
pub const S_BLACKEGG_HELPER: state = 729;
pub const S_BLACKEGG_DESTROYPLAT3: state = 728;
pub const S_BLACKEGG_DESTROYPLAT2: state = 727;
pub const S_BLACKEGG_DESTROYPLAT1: state = 726;
pub const S_BLACKEGG_JUMP2: state = 725;
pub const S_BLACKEGG_JUMP1: state = 724;
pub const S_BLACKEGG_GOOP: state = 723;
pub const S_BLACKEGG_MISSILE3: state = 722;
pub const S_BLACKEGG_MISSILE2: state = 721;
pub const S_BLACKEGG_MISSILE1: state = 720;
pub const S_BLACKEGG_DIE5: state = 719;
pub const S_BLACKEGG_DIE4: state = 718;
pub const S_BLACKEGG_DIE3: state = 717;
pub const S_BLACKEGG_DIE2: state = 716;
pub const S_BLACKEGG_DIE1: state = 715;
pub const S_BLACKEGG_HITFACE4: state = 714;
pub const S_BLACKEGG_HITFACE3: state = 713;
pub const S_BLACKEGG_HITFACE2: state = 712;
pub const S_BLACKEGG_HITFACE1: state = 711;
pub const S_BLACKEGG_PAIN35: state = 710;
pub const S_BLACKEGG_PAIN34: state = 709;
pub const S_BLACKEGG_PAIN33: state = 708;
pub const S_BLACKEGG_PAIN32: state = 707;
pub const S_BLACKEGG_PAIN31: state = 706;
pub const S_BLACKEGG_PAIN30: state = 705;
pub const S_BLACKEGG_PAIN29: state = 704;
pub const S_BLACKEGG_PAIN28: state = 703;
pub const S_BLACKEGG_PAIN27: state = 702;
pub const S_BLACKEGG_PAIN26: state = 701;
pub const S_BLACKEGG_PAIN25: state = 700;
pub const S_BLACKEGG_PAIN24: state = 699;
pub const S_BLACKEGG_PAIN23: state = 698;
pub const S_BLACKEGG_PAIN22: state = 697;
pub const S_BLACKEGG_PAIN21: state = 696;
pub const S_BLACKEGG_PAIN20: state = 695;
pub const S_BLACKEGG_PAIN19: state = 694;
pub const S_BLACKEGG_PAIN18: state = 693;
pub const S_BLACKEGG_PAIN17: state = 692;
pub const S_BLACKEGG_PAIN16: state = 691;
pub const S_BLACKEGG_PAIN15: state = 690;
pub const S_BLACKEGG_PAIN14: state = 689;
pub const S_BLACKEGG_PAIN13: state = 688;
pub const S_BLACKEGG_PAIN12: state = 687;
pub const S_BLACKEGG_PAIN11: state = 686;
pub const S_BLACKEGG_PAIN10: state = 685;
pub const S_BLACKEGG_PAIN9: state = 684;
pub const S_BLACKEGG_PAIN8: state = 683;
pub const S_BLACKEGG_PAIN7: state = 682;
pub const S_BLACKEGG_PAIN6: state = 681;
pub const S_BLACKEGG_PAIN5: state = 680;
pub const S_BLACKEGG_PAIN4: state = 679;
pub const S_BLACKEGG_PAIN3: state = 678;
pub const S_BLACKEGG_PAIN2: state = 677;
pub const S_BLACKEGG_PAIN1: state = 676;
pub const S_BLACKEGG_SHOOT2: state = 675;
pub const S_BLACKEGG_SHOOT1: state = 674;
pub const S_BLACKEGG_WALK6: state = 673;
pub const S_BLACKEGG_WALK5: state = 672;
pub const S_BLACKEGG_WALK4: state = 671;
pub const S_BLACKEGG_WALK3: state = 670;
pub const S_BLACKEGG_WALK2: state = 669;
pub const S_BLACKEGG_WALK1: state = 668;
pub const S_BLACKEGG_STND2: state = 667;
pub const S_BLACKEGG_STND: state = 666;
pub const S_FSGND: state = 665;
pub const S_FSGNC: state = 664;
pub const S_FSGNB: state = 663;
pub const S_FSGNA: state = 662;
pub const S_TNTDUST_8: state = 661;
pub const S_TNTDUST_7: state = 660;
pub const S_TNTDUST_6: state = 659;
pub const S_TNTDUST_5: state = 658;
pub const S_TNTDUST_4: state = 657;
pub const S_TNTDUST_3: state = 656;
pub const S_TNTDUST_2: state = 655;
pub const S_TNTDUST_1: state = 654;
pub const S_FBOMB_EXPL6: state = 653;
pub const S_FBOMB_EXPL5: state = 652;
pub const S_FBOMB_EXPL4: state = 651;
pub const S_FBOMB_EXPL3: state = 650;
pub const S_FBOMB_EXPL2: state = 649;
pub const S_FBOMB_EXPL1: state = 648;
pub const S_FBOMB2: state = 647;
pub const S_FBOMB1: state = 646;
pub const S_PROJECTORLIGHT5: state = 645;
pub const S_PROJECTORLIGHT4: state = 644;
pub const S_PROJECTORLIGHT3: state = 643;
pub const S_PROJECTORLIGHT2: state = 642;
pub const S_PROJECTORLIGHT1: state = 641;
pub const S_VWREB: state = 640;
pub const S_VWREF: state = 639;
pub const S_ALART2: state = 638;
pub const S_ALART1: state = 637;
pub const S_BROKENROBOTF: state = 636;
pub const S_BROKENROBOTE: state = 635;
pub const S_BROKENROBOTD: state = 634;
pub const S_BROKENROBOTC: state = 633;
pub const S_BROKENROBOTB: state = 632;
pub const S_BROKENROBOTA: state = 631;
pub const S_BROKENROBOTRANDOM: state = 630;
pub const S_FANG_KO: state = 629;
pub const S_FANG_FLEEBOUNCE2: state = 628;
pub const S_FANG_FLEEBOUNCE1: state = 627;
pub const S_FANG_FLEEPATHING2: state = 626;
pub const S_FANG_FLEEPATHING1: state = 625;
pub const S_FANG_DIE8: state = 624;
pub const S_FANG_DIE7: state = 623;
pub const S_FANG_DIE6: state = 622;
pub const S_FANG_DIE5: state = 621;
pub const S_FANG_DIE4: state = 620;
pub const S_FANG_DIE3: state = 619;
pub const S_FANG_DIE2: state = 618;
pub const S_FANG_DIE1: state = 617;
pub const S_FANG_PINCHLOBSHOT4: state = 616;
pub const S_FANG_PINCHLOBSHOT3: state = 615;
pub const S_FANG_PINCHLOBSHOT2: state = 614;
pub const S_FANG_PINCHLOBSHOT1: state = 613;
pub const S_FANG_PINCHLOBSHOT0: state = 612;
pub const S_FANG_PINCHSKID2: state = 611;
pub const S_FANG_PINCHSKID1: state = 610;
pub const S_FANG_PINCHFALL2: state = 609;
pub const S_FANG_PINCHFALL1: state = 608;
pub const S_FANG_PINCHFALL0: state = 607;
pub const S_FANG_PINCHBOUNCE4: state = 606;
pub const S_FANG_PINCHBOUNCE3: state = 605;
pub const S_FANG_PINCHBOUNCE2: state = 604;
pub const S_FANG_PINCHBOUNCE1: state = 603;
pub const S_FANG_PINCHBOUNCE0: state = 602;
pub const S_FANG_PINCHPATHING: state = 601;
pub const S_FANG_PINCHPATHINGSTART2: state = 600;
pub const S_FANG_PINCHPATHINGSTART1: state = 599;
pub const S_FANG_WALLHIT: state = 598;
pub const S_FANG_WAIT2: state = 597;
pub const S_FANG_WAIT1: state = 596;
pub const S_FANG_LOBSHOT2: state = 595;
pub const S_FANG_LOBSHOT1: state = 594;
pub const S_FANG_LOBSHOT0: state = 593;
pub const S_FANG_FIREREPEAT: state = 592;
pub const S_FANG_FIRE4: state = 591;
pub const S_FANG_FIRE3: state = 590;
pub const S_FANG_FIRE2: state = 589;
pub const S_FANG_FIRE1: state = 588;
pub const S_FANG_FIRESTART2: state = 587;
pub const S_FANG_FIRESTART1: state = 586;
pub const S_FANG_CHOOSEATTACK: state = 585;
pub const S_FANG_SKID3: state = 584;
pub const S_FANG_SKID2: state = 583;
pub const S_FANG_SKID1: state = 582;
pub const S_FANG_PATHINGCONT3: state = 581;
pub const S_FANG_PATHINGCONT2: state = 580;
pub const S_FANG_PATHINGCONT1: state = 579;
pub const S_FANG_CHECKPATH2: state = 578;
pub const S_FANG_CHECKPATH1: state = 577;
pub const S_FANG_FALL2: state = 576;
pub const S_FANG_FALL1: state = 575;
pub const S_FANG_BOUNCE4: state = 574;
pub const S_FANG_BOUNCE3: state = 573;
pub const S_FANG_BOUNCE2: state = 572;
pub const S_FANG_BOUNCE1: state = 571;
pub const S_FANG_PATHING: state = 570;
pub const S_FANG_PATHINGSTART2: state = 569;
pub const S_FANG_PATHINGSTART1: state = 568;
pub const S_FANG_PAIN2: state = 567;
pub const S_FANG_PAIN1: state = 566;
pub const S_FANG_IDLE8: state = 565;
pub const S_FANG_IDLE7: state = 564;
pub const S_FANG_IDLE6: state = 563;
pub const S_FANG_IDLE5: state = 562;
pub const S_FANG_IDLE4: state = 561;
pub const S_FANG_IDLE3: state = 560;
pub const S_FANG_IDLE2: state = 559;
pub const S_FANG_IDLE1: state = 558;
pub const S_FANG_IDLE0: state = 557;
pub const S_FANG_CLONE4: state = 556;
pub const S_FANG_CLONE3: state = 555;
pub const S_FANG_CLONE2: state = 554;
pub const S_FANG_CLONE1: state = 553;
pub const S_FANG_INTRO12: state = 552;
pub const S_FANG_INTRO11: state = 551;
pub const S_FANG_INTRO10: state = 550;
pub const S_FANG_INTRO9: state = 549;
pub const S_FANG_INTRO8: state = 548;
pub const S_FANG_INTRO7: state = 547;
pub const S_FANG_INTRO6: state = 546;
pub const S_FANG_INTRO5: state = 545;
pub const S_FANG_INTRO4: state = 544;
pub const S_FANG_INTRO3: state = 543;
pub const S_FANG_INTRO2: state = 542;
pub const S_FANG_INTRO1: state = 541;
pub const S_FANG_INTRO0: state = 540;
pub const S_FANG_SETUP: state = 539;
pub const S_EGGROBOJET: state = 538;
pub const S_EGGROBO1_PISSED: state = 537;
pub const S_EGGROBO1_BSLAP2: state = 536;
pub const S_EGGROBO1_BSLAP1: state = 535;
pub const S_EGGROBO1_STND: state = 534;
pub const S_JETFLAME: state = 533;
pub const S_EGGMOBILE4_MACE_DIE3: state = 532;
pub const S_EGGMOBILE4_MACE_DIE2: state = 531;
pub const S_EGGMOBILE4_MACE_DIE1: state = 530;
pub const S_EGGMOBILE4_MACE: state = 529;
pub const S_EGGMOBILE4_FLEE2: state = 528;
pub const S_EGGMOBILE4_FLEE1: state = 527;
pub const S_EGGMOBILE4_DIE4: state = 526;
pub const S_EGGMOBILE4_DIE3: state = 525;
pub const S_EGGMOBILE4_DIE2: state = 524;
pub const S_EGGMOBILE4_DIE1: state = 523;
pub const S_EGGMOBILE4_PAIN2: state = 522;
pub const S_EGGMOBILE4_PAIN1: state = 521;
pub const S_EGGMOBILE4_RAISE2: state = 520;
pub const S_EGGMOBILE4_RAISE1: state = 519;
pub const S_EGGMOBILE4_RATK6: state = 518;
pub const S_EGGMOBILE4_RATK5: state = 517;
pub const S_EGGMOBILE4_RATK4: state = 516;
pub const S_EGGMOBILE4_RATK3: state = 515;
pub const S_EGGMOBILE4_RATK2: state = 514;
pub const S_EGGMOBILE4_RATK1: state = 513;
pub const S_EGGMOBILE4_LATK6: state = 512;
pub const S_EGGMOBILE4_LATK5: state = 511;
pub const S_EGGMOBILE4_LATK4: state = 510;
pub const S_EGGMOBILE4_LATK3: state = 509;
pub const S_EGGMOBILE4_LATK2: state = 508;
pub const S_EGGMOBILE4_LATK1: state = 507;
pub const S_EGGMOBILE4_STND: state = 506;
pub const S_SHOCKWAVE2: state = 505;
pub const S_SHOCKWAVE1: state = 504;
pub const S_BOSSSEBH2: state = 503;
pub const S_BOSSSEBH1: state = 502;
pub const S_FAKEMOBILE_DIE2: state = 501;
pub const S_FAKEMOBILE_DIE1: state = 500;
pub const S_FAKEMOBILE_ATK3D: state = 499;
pub const S_FAKEMOBILE_ATK3C: state = 498;
pub const S_FAKEMOBILE_ATK3B: state = 497;
pub const S_FAKEMOBILE_ATK3A: state = 496;
pub const S_FAKEMOBILE_ATK2: state = 495;
pub const S_FAKEMOBILE_ATK1: state = 494;
pub const S_FAKEMOBILE: state = 493;
pub const S_FAKEMOBILE_INIT: state = 492;
pub const S_EGGMOBILE3_FLEE2: state = 491;
pub const S_EGGMOBILE3_FLEE1: state = 490;
pub const S_EGGMOBILE3_DIE4: state = 489;
pub const S_EGGMOBILE3_DIE3: state = 488;
pub const S_EGGMOBILE3_DIE2: state = 487;
pub const S_EGGMOBILE3_DIE1: state = 486;
pub const S_EGGMOBILE3_PAIN2: state = 485;
pub const S_EGGMOBILE3_PAIN: state = 484;
pub const S_EGGMOBILE3_ROFL: state = 483;
pub const S_EGGMOBILE3_ATK5: state = 482;
pub const S_EGGMOBILE3_ATK4: state = 481;
pub const S_EGGMOBILE3_ATK3D: state = 480;
pub const S_EGGMOBILE3_ATK3C: state = 479;
pub const S_EGGMOBILE3_ATK3B: state = 478;
pub const S_EGGMOBILE3_ATK3A: state = 477;
pub const S_EGGMOBILE3_ATK2: state = 476;
pub const S_EGGMOBILE3_ATK1: state = 475;
pub const S_EGGMOBILE3_SHOCK: state = 474;
pub const S_EGGMOBILE3_STND: state = 473;
pub const S_GOOPTRAIL: state = 472;
pub const S_GOOP3: state = 471;
pub const S_GOOP2: state = 470;
pub const S_GOOP1: state = 469;
pub const S_BOSSSPIGOT: state = 468;
pub const S_BOSSTANK2: state = 467;
pub const S_BOSSTANK1: state = 466;
pub const S_EGGMOBILE2_FLEE2: state = 465;
pub const S_EGGMOBILE2_FLEE1: state = 464;
pub const S_EGGMOBILE2_DIE4: state = 463;
pub const S_EGGMOBILE2_DIE3: state = 462;
pub const S_EGGMOBILE2_DIE2: state = 461;
pub const S_EGGMOBILE2_DIE1: state = 460;
pub const S_EGGMOBILE2_PAIN2: state = 459;
pub const S_EGGMOBILE2_PAIN: state = 458;
pub const S_EGGMOBILE2_POGO7: state = 457;
pub const S_EGGMOBILE2_POGO6: state = 456;
pub const S_EGGMOBILE2_POGO5: state = 455;
pub const S_EGGMOBILE2_POGO4: state = 454;
pub const S_EGGMOBILE2_POGO3: state = 453;
pub const S_EGGMOBILE2_POGO2: state = 452;
pub const S_EGGMOBILE2_POGO1: state = 451;
pub const S_EGGMOBILE2_STND: state = 450;
pub const S_BOSSEGLZ2: state = 449;
pub const S_BOSSEGLZ1: state = 448;
pub const S_EGGMOBILE_TARGET: state = 447;
pub const S_EGGMOBILE_BALL: state = 446;
pub const S_EGGMOBILE_FLEE2: state = 445;
pub const S_EGGMOBILE_FLEE1: state = 444;
pub const S_EGGMOBILE_DIE4: state = 443;
pub const S_EGGMOBILE_DIE3: state = 442;
pub const S_EGGMOBILE_DIE2: state = 441;
pub const S_EGGMOBILE_DIE1: state = 440;
pub const S_EGGMOBILE_PAIN2: state = 439;
pub const S_EGGMOBILE_PAIN: state = 438;
pub const S_EGGMOBILE_PANIC15: state = 437;
pub const S_EGGMOBILE_PANIC14: state = 436;
pub const S_EGGMOBILE_PANIC13: state = 435;
pub const S_EGGMOBILE_PANIC12: state = 434;
pub const S_EGGMOBILE_PANIC11: state = 433;
pub const S_EGGMOBILE_PANIC10: state = 432;
pub const S_EGGMOBILE_PANIC9: state = 431;
pub const S_EGGMOBILE_PANIC8: state = 430;
pub const S_EGGMOBILE_PANIC7: state = 429;
pub const S_EGGMOBILE_PANIC6: state = 428;
pub const S_EGGMOBILE_PANIC5: state = 427;
pub const S_EGGMOBILE_PANIC4: state = 426;
pub const S_EGGMOBILE_PANIC3: state = 425;
pub const S_EGGMOBILE_PANIC2: state = 424;
pub const S_EGGMOBILE_PANIC1: state = 423;
pub const S_EGGMOBILE_RATK9: state = 422;
pub const S_EGGMOBILE_RATK8: state = 421;
pub const S_EGGMOBILE_RATK7: state = 420;
pub const S_EGGMOBILE_RATK6: state = 419;
pub const S_EGGMOBILE_RATK5: state = 418;
pub const S_EGGMOBILE_RATK4: state = 417;
pub const S_EGGMOBILE_RATK3: state = 416;
pub const S_EGGMOBILE_RATK2: state = 415;
pub const S_EGGMOBILE_RATK1: state = 414;
pub const S_EGGMOBILE_LATK9: state = 413;
pub const S_EGGMOBILE_LATK8: state = 412;
pub const S_EGGMOBILE_LATK7: state = 411;
pub const S_EGGMOBILE_LATK6: state = 410;
pub const S_EGGMOBILE_LATK5: state = 409;
pub const S_EGGMOBILE_LATK4: state = 408;
pub const S_EGGMOBILE_LATK3: state = 407;
pub const S_EGGMOBILE_LATK2: state = 406;
pub const S_EGGMOBILE_LATK1: state = 405;
pub const S_EGGMOBILE_ROFL: state = 404;
pub const S_EGGMOBILE_STND: state = 403;
pub const S_JETFUME1: state = 402;
pub const S_SONIC3KBOSSEXPLOSION6: state = 401;
pub const S_SONIC3KBOSSEXPLOSION5: state = 400;
pub const S_SONIC3KBOSSEXPLOSION4: state = 399;
pub const S_SONIC3KBOSSEXPLOSION3: state = 398;
pub const S_SONIC3KBOSSEXPLOSION2: state = 397;
pub const S_SONIC3KBOSSEXPLOSION1: state = 396;
pub const S_BOSSEXPLODE: state = 395;
pub const S_DRAGONMINE_FASTLOOP: state = 394;
pub const S_DRAGONMINE_FASTFLASH2: state = 393;
pub const S_DRAGONMINE_FASTFLASH1: state = 392;
pub const S_DRAGONMINE_SLOWLOOP: state = 391;
pub const S_DRAGONMINE_SLOWFLASH2: state = 390;
pub const S_DRAGONMINE_SLOWFLASH1: state = 389;
pub const S_DRAGONMINE_LAND2: state = 388;
pub const S_DRAGONMINE_LAND1: state = 387;
pub const S_DRAGONMINE: state = 386;
pub const S_DRAGONTAIL_RELOAD: state = 385;
pub const S_DRAGONTAIL_EMPTYLOOP: state = 384;
pub const S_DRAGONTAIL_EMPTY: state = 383;
pub const S_DRAGONTAIL_LOADED: state = 382;
pub const S_DRAGONWING4: state = 381;
pub const S_DRAGONWING3: state = 380;
pub const S_DRAGONWING2: state = 379;
pub const S_DRAGONWING1: state = 378;
pub const S_DRAGONBOMBER: state = 377;
pub const S_PTERABYTE_SWOOPUP: state = 376;
pub const S_PTERABYTE_SWOOPDOWN: state = 375;
pub const S_PTERABYTE_FLY4: state = 374;
pub const S_PTERABYTE_FLY3: state = 373;
pub const S_PTERABYTE_FLY2: state = 372;
pub const S_PTERABYTE_FLY1: state = 371;
pub const S_PTERABYTEWAYPOINT: state = 370;
pub const S_PTERABYTESPAWNER: state = 369;
pub const S_PYREFIRE2: state = 368;
pub const S_PYREFIRE1: state = 367;
pub const S_PYREFLY_BURN: state = 366;
pub const S_PYREFLY_FLY: state = 365;
pub const S_CANARIVOREGAS_8: state = 364;
pub const S_CANARIVOREGAS_7: state = 363;
pub const S_CANARIVOREGAS_6: state = 362;
pub const S_CANARIVOREGAS_5: state = 361;
pub const S_CANARIVOREGAS_4: state = 360;
pub const S_CANARIVOREGAS_3: state = 359;
pub const S_CANARIVOREGAS_2: state = 358;
pub const S_CANARIVOREGAS_1: state = 357;
pub const S_CANARIVORE_CLOSE2: state = 356;
pub const S_CANARIVORE_CLOSE1: state = 355;
pub const S_CANARIVORE_GASREPEAT: state = 354;
pub const S_CANARIVORE_GAS5: state = 353;
pub const S_CANARIVORE_GAS4: state = 352;
pub const S_CANARIVORE_GAS3: state = 351;
pub const S_CANARIVORE_GAS2: state = 350;
pub const S_CANARIVORE_GAS1: state = 349;
pub const S_CANARIVORE_AWAKEN3: state = 348;
pub const S_CANARIVORE_AWAKEN2: state = 347;
pub const S_CANARIVORE_AWAKEN1: state = 346;
pub const S_CANARIVORE_LOOK: state = 345;
pub const S_UNIDUS_BALL: state = 344;
pub const S_UNIDUS_RUN: state = 343;
pub const S_UNIDUS_STND: state = 342;
pub const S_YSHELL_SPRING4: state = 341;
pub const S_YSHELL_SPRING3: state = 340;
pub const S_YSHELL_SPRING2: state = 339;
pub const S_YSHELL_SPRING1: state = 338;
pub const S_YSHELL_RUN4: state = 337;
pub const S_YSHELL_RUN3: state = 336;
pub const S_YSHELL_RUN2: state = 335;
pub const S_YSHELL_RUN1: state = 334;
pub const S_YSHELL_STND: state = 333;
pub const S_SSHELL_SPRING4: state = 332;
pub const S_SSHELL_SPRING3: state = 331;
pub const S_SSHELL_SPRING2: state = 330;
pub const S_SSHELL_SPRING1: state = 329;
pub const S_SSHELL_RUN4: state = 328;
pub const S_SSHELL_RUN3: state = 327;
pub const S_SSHELL_RUN2: state = 326;
pub const S_SSHELL_RUN1: state = 325;
pub const S_SSHELL_STND: state = 324;
pub const S_MINUSDIRT7: state = 323;
pub const S_MINUSDIRT6: state = 322;
pub const S_MINUSDIRT5: state = 321;
pub const S_MINUSDIRT4: state = 320;
pub const S_MINUSDIRT3: state = 319;
pub const S_MINUSDIRT2: state = 318;
pub const S_MINUSDIRT1: state = 317;
pub const S_MINUS_AERIAL4: state = 316;
pub const S_MINUS_AERIAL3: state = 315;
pub const S_MINUS_AERIAL2: state = 314;
pub const S_MINUS_AERIAL1: state = 313;
pub const S_MINUS_POPUP: state = 312;
pub const S_MINUS_BURST5: state = 311;
pub const S_MINUS_BURST4: state = 310;
pub const S_MINUS_BURST3: state = 309;
pub const S_MINUS_BURST2: state = 308;
pub const S_MINUS_BURST1: state = 307;
pub const S_MINUS_BURST0: state = 306;
pub const S_MINUS_DIGGING4: state = 305;
pub const S_MINUS_DIGGING3: state = 304;
pub const S_MINUS_DIGGING2: state = 303;
pub const S_MINUS_DIGGING1: state = 302;
pub const S_MINUS_STND: state = 301;
pub const S_MINUS_INIT: state = 300;
pub const S_SNAPPER_HEAD: state = 299;
pub const S_SNAPPER_LEGRAISE: state = 298;
pub const S_SNAPPER_LEG: state = 297;
pub const S_SNAPPER_XPLD: state = 296;
pub const S_GSNAPPER4: state = 295;
pub const S_GSNAPPER3: state = 294;
pub const S_GSNAPPER2: state = 293;
pub const S_GSNAPPER1: state = 292;
pub const S_GSNAPPER_STND: state = 291;
pub const S_SNAPPER_SPAWN2: state = 290;
pub const S_SNAPPER_SPAWN: state = 289;
pub const S_EGGSHIELDBREAK: state = 288;
pub const S_EGGSHIELD: state = 287;
pub const S_EGGGUARD_RUN4: state = 286;
pub const S_EGGGUARD_RUN3: state = 285;
pub const S_EGGGUARD_RUN2: state = 284;
pub const S_EGGGUARD_RUN1: state = 283;
pub const S_EGGGUARD_MAD3: state = 282;
pub const S_EGGGUARD_MAD2: state = 281;
pub const S_EGGGUARD_MAD1: state = 280;
pub const S_EGGGUARD_WALK4: state = 279;
pub const S_EGGGUARD_WALK3: state = 278;
pub const S_EGGGUARD_WALK2: state = 277;
pub const S_EGGGUARD_WALK1: state = 276;
pub const S_EGGGUARD_STND: state = 275;
pub const S_FACESTABBERSPEAR: state = 274;
pub const S_FACESTABBER_DIE3: state = 273;
pub const S_FACESTABBER_DIE2: state = 272;
pub const S_FACESTABBER_DIE1: state = 271;
pub const S_FACESTABBER_PAIN: state = 270;
pub const S_FACESTABBER_CHARGE4: state = 269;
pub const S_FACESTABBER_CHARGE3: state = 268;
pub const S_FACESTABBER_CHARGE2: state = 267;
pub const S_FACESTABBER_CHARGE1: state = 266;
pub const S_FACESTABBER_STND6: state = 265;
pub const S_FACESTABBER_STND5: state = 264;
pub const S_FACESTABBER_STND4: state = 263;
pub const S_FACESTABBER_STND3: state = 262;
pub const S_FACESTABBER_STND2: state = 261;
pub const S_FACESTABBER_STND1: state = 260;
pub const S_ROBOHOOD_JUMP3: state = 259;
pub const S_ROBOHOOD_JUMP2: state = 258;
pub const S_ROBOHOOD_JUMP1: state = 257;
pub const S_ROBOHOOD_FIRE2: state = 256;
pub const S_ROBOHOOD_FIRE1: state = 255;
pub const S_ROBOHOOD_STAND: state = 254;
pub const S_ROBOHOOD_LOOK: state = 253;
pub const S_POINTYBALL1: state = 252;
pub const S_POINTY1: state = 251;
pub const S_VULTURE_STUNNED: state = 250;
pub const S_VULTURE_ZOOM2: state = 249;
pub const S_VULTURE_ZOOM1: state = 248;
pub const S_VULTURE_DRIFT: state = 247;
pub const S_VULTURE_STND: state = 246;
pub const S_SNAILER_FLICKY: state = 245;
pub const S_SNAILER1: state = 244;
pub const S_JETJAW_SOUND: state = 243;
pub const S_JETJAW_CHOMP16: state = 242;
pub const S_JETJAW_CHOMP15: state = 241;
pub const S_JETJAW_CHOMP14: state = 240;
pub const S_JETJAW_CHOMP13: state = 239;
pub const S_JETJAW_CHOMP12: state = 238;
pub const S_JETJAW_CHOMP11: state = 237;
pub const S_JETJAW_CHOMP10: state = 236;
pub const S_JETJAW_CHOMP9: state = 235;
pub const S_JETJAW_CHOMP8: state = 234;
pub const S_JETJAW_CHOMP7: state = 233;
pub const S_JETJAW_CHOMP6: state = 232;
pub const S_JETJAW_CHOMP5: state = 231;
pub const S_JETJAW_CHOMP4: state = 230;
pub const S_JETJAW_CHOMP3: state = 229;
pub const S_JETJAW_CHOMP2: state = 228;
pub const S_JETJAW_CHOMP1: state = 227;
pub const S_JETJAW_ROAM8: state = 226;
pub const S_JETJAW_ROAM7: state = 225;
pub const S_JETJAW_ROAM6: state = 224;
pub const S_JETJAW_ROAM5: state = 223;
pub const S_JETJAW_ROAM4: state = 222;
pub const S_JETJAW_ROAM3: state = 221;
pub const S_JETJAW_ROAM2: state = 220;
pub const S_JETJAW_ROAM1: state = 219;
pub const S_CDIAG8: state = 218;
pub const S_CDIAG7: state = 217;
pub const S_CDIAG6: state = 216;
pub const S_CDIAG5: state = 215;
pub const S_CDIAG4: state = 214;
pub const S_CDIAG3: state = 213;
pub const S_CDIAG2: state = 212;
pub const S_CDIAG1: state = 211;
pub const S_BANPYURA_ROAMPAUSE: state = 210;
pub const S_BANPYURA_ROAM4: state = 209;
pub const S_BANPYURA_ROAM3: state = 208;
pub const S_BANPYURA_ROAM2: state = 207;
pub const S_BANPYURA_ROAM1: state = 206;
pub const S_CRUSHCHAIN: state = 205;
pub const S_CRUSHCLAW_WAIT: state = 204;
pub const S_CRUSHCLAW_IN: state = 203;
pub const S_CRUSHCLAW_STAY: state = 202;
pub const S_CRUSHCLAW_OUT: state = 201;
pub const S_CRUSHCLAW_AIM: state = 200;
pub const S_CRUSHSTACEAN_PUNCH2: state = 199;
pub const S_CRUSHSTACEAN_PUNCH1: state = 198;
pub const S_CRUSHSTACEAN_ROAMPAUSE: state = 197;
pub const S_CRUSHSTACEAN_ROAM4: state = 196;
pub const S_CRUSHSTACEAN_ROAM3: state = 195;
pub const S_CRUSHSTACEAN_ROAM2: state = 194;
pub const S_CRUSHSTACEAN_ROAM1: state = 193;
pub const S_SPINCUSHION_STOP4: state = 192;
pub const S_SPINCUSHION_STOP3: state = 191;
pub const S_SPINCUSHION_STOP2: state = 190;
pub const S_SPINCUSHION_STOP1: state = 189;
pub const S_SPINCUSHION_SPIN4: state = 188;
pub const S_SPINCUSHION_SPIN3: state = 187;
pub const S_SPINCUSHION_SPIN2: state = 186;
pub const S_SPINCUSHION_SPIN1: state = 185;
pub const S_SPINCUSHION_AIM5: state = 184;
pub const S_SPINCUSHION_AIM4: state = 183;
pub const S_SPINCUSHION_AIM3: state = 182;
pub const S_SPINCUSHION_AIM2: state = 181;
pub const S_SPINCUSHION_AIM1: state = 180;
pub const S_SPINCUSHION_CHASE4: state = 179;
pub const S_SPINCUSHION_CHASE3: state = 178;
pub const S_SPINCUSHION_CHASE2: state = 177;
pub const S_SPINCUSHION_CHASE1: state = 176;
pub const S_SPINCUSHION_LOOK: state = 175;
pub const S_TURRETPOPDOWN8: state = 174;
pub const S_TURRETPOPDOWN7: state = 173;
pub const S_TURRETPOPDOWN6: state = 172;
pub const S_TURRETPOPDOWN5: state = 171;
pub const S_TURRETPOPDOWN4: state = 170;
pub const S_TURRETPOPDOWN3: state = 169;
pub const S_TURRETPOPDOWN2: state = 168;
pub const S_TURRETPOPDOWN1: state = 167;
pub const S_TURRETSHOOT: state = 166;
pub const S_TURRETPOPUP8: state = 165;
pub const S_TURRETPOPUP7: state = 164;
pub const S_TURRETPOPUP6: state = 163;
pub const S_TURRETPOPUP5: state = 162;
pub const S_TURRETPOPUP4: state = 161;
pub const S_TURRETPOPUP3: state = 160;
pub const S_TURRETPOPUP2: state = 159;
pub const S_TURRETPOPUP1: state = 158;
pub const S_TURRETSEE: state = 157;
pub const S_TURRETLOOK: state = 156;
pub const S_TURRETSHOCK9: state = 155;
pub const S_TURRETSHOCK8: state = 154;
pub const S_TURRETSHOCK7: state = 153;
pub const S_TURRETSHOCK6: state = 152;
pub const S_TURRETSHOCK5: state = 151;
pub const S_TURRETSHOCK4: state = 150;
pub const S_TURRETSHOCK3: state = 149;
pub const S_TURRETSHOCK2: state = 148;
pub const S_TURRETSHOCK1: state = 147;
pub const S_TURRETFIRE: state = 146;
pub const S_TURRET: state = 145;
pub const S_SKIM4: state = 144;
pub const S_SKIM3: state = 143;
pub const S_SKIM2: state = 142;
pub const S_SKIM1: state = 141;
pub const S_DETON15: state = 140;
pub const S_DETON14: state = 139;
pub const S_DETON13: state = 138;
pub const S_DETON12: state = 137;
pub const S_DETON11: state = 136;
pub const S_DETON10: state = 135;
pub const S_DETON9: state = 134;
pub const S_DETON8: state = 133;
pub const S_DETON7: state = 132;
pub const S_DETON6: state = 131;
pub const S_DETON5: state = 130;
pub const S_DETON4: state = 129;
pub const S_DETON3: state = 128;
pub const S_DETON2: state = 127;
pub const S_DETON1: state = 126;
pub const S_CCOMMAND4: state = 125;
pub const S_CCOMMAND3: state = 124;
pub const S_CCOMMAND2: state = 123;
pub const S_CCOMMAND1: state = 122;
pub const S_JETGSHOOT2: state = 121;
pub const S_JETGSHOOT1: state = 120;
pub const S_JETGZOOM2: state = 119;
pub const S_JETGZOOM1: state = 118;
pub const S_JETGLOOK2: state = 117;
pub const S_JETGLOOK1: state = 116;
pub const S_JETBZOOM2: state = 115;
pub const S_JETBZOOM1: state = 114;
pub const S_JETBLOOK2: state = 113;
pub const S_JETBLOOK1: state = 112;
pub const S_RBUZZFLY2: state = 111;
pub const S_RBUZZFLY1: state = 110;
pub const S_RBUZZLOOK2: state = 109;
pub const S_RBUZZLOOK1: state = 108;
pub const S_BUZZFLY2: state = 107;
pub const S_BUZZFLY1: state = 106;
pub const S_BUZZLOOK2: state = 105;
pub const S_BUZZLOOK1: state = 104;
pub const S_FISH4: state = 103;
pub const S_FISH3: state = 102;
pub const S_FISH2: state = 101;
pub const S_FISH1: state = 100;
pub const S_SPOS_RUN6: state = 99;
pub const S_SPOS_RUN5: state = 98;
pub const S_SPOS_RUN4: state = 97;
pub const S_SPOS_RUN3: state = 96;
pub const S_SPOS_RUN2: state = 95;
pub const S_SPOS_RUN1: state = 94;
pub const S_SPOS_STND: state = 93;
pub const S_POSS_RUN6: state = 92;
pub const S_POSS_RUN5: state = 91;
pub const S_POSS_RUN4: state = 90;
pub const S_POSS_RUN3: state = 89;
pub const S_POSS_RUN2: state = 88;
pub const S_POSS_RUN1: state = 87;
pub const S_POSS_STND: state = 86;
pub const S_JETFUMEFLASH: state = 85;
pub const S_TAILSOVERLAY_DASH: state = 84;
pub const S_TAILSOVERLAY_EDGE: state = 83;
pub const S_TAILSOVERLAY_GASP: state = 82;
pub const S_TAILSOVERLAY_PAIN: state = 81;
pub const S_TAILSOVERLAY_TIRE: state = 80;
pub const S_TAILSOVERLAY_FLY: state = 79;
pub const S_TAILSOVERLAY_RUN: state = 78;
pub const S_TAILSOVERLAY_MINUS60DEGREES: state = 77;
pub const S_TAILSOVERLAY_MINUS30DEGREES: state = 76;
pub const S_TAILSOVERLAY_PLUS60DEGREES: state = 75;
pub const S_TAILSOVERLAY_PLUS30DEGREES: state = 74;
pub const S_TAILSOVERLAY_0DEGREES: state = 73;
pub const S_TAILSOVERLAY_STAND: state = 72;
pub const S_PLAY_NIGHTS_ATTACK: state = 71;
pub const S_PLAY_NIGHTS_PULL: state = 70;
pub const S_PLAY_NIGHTS_STUN: state = 69;
pub const S_PLAY_NIGHTS_DRILL: state = 68;
pub const S_PLAY_NIGHTS_FLY: state = 67;
pub const S_PLAY_NIGHTS_FLOAT: state = 66;
pub const S_PLAY_NIGHTS_STAND: state = 65;
pub const S_PLAY_NIGHTS_TRANS6: state = 64;
pub const S_PLAY_NIGHTS_TRANS5: state = 63;
pub const S_PLAY_NIGHTS_TRANS4: state = 62;
pub const S_PLAY_NIGHTS_TRANS3: state = 61;
pub const S_PLAY_NIGHTS_TRANS2: state = 60;
pub const S_PLAY_NIGHTS_TRANS1: state = 59;
pub const S_PLAY_SIGN: state = 58;
pub const S_PLAY_ICON3: state = 57;
pub const S_PLAY_ICON2: state = 56;
pub const S_PLAY_ICON1: state = 55;
pub const S_PLAY_BOX2: state = 54;
pub const S_PLAY_BOX1: state = 53;
pub const S_OBJPLACE_DUMMY: state = 52;
pub const S_PLAY_SUPER_TRANS6: state = 51;
pub const S_PLAY_SUPER_TRANS5: state = 50;
pub const S_PLAY_SUPER_TRANS4: state = 49;
pub const S_PLAY_SUPER_TRANS3: state = 48;
pub const S_PLAY_SUPER_TRANS2: state = 47;
pub const S_PLAY_SUPER_TRANS1: state = 46;
pub const S_PLAY_MELEE_LANDING: state = 45;
pub const S_PLAY_MELEE_FINISH: state = 44;
pub const S_PLAY_MELEE: state = 43;
pub const S_PLAY_TWINSPIN: state = 42;
pub const S_PLAY_FIRE_FINISH: state = 41;
pub const S_PLAY_FIRE: state = 40;
pub const S_PLAY_BOUNCE_LANDING: state = 39;
pub const S_PLAY_BOUNCE: state = 38;
pub const S_PLAY_FLOAT_RUN: state = 37;
pub const S_PLAY_FLOAT: state = 36;
pub const S_PLAY_CLIMB: state = 35;
pub const S_PLAY_CLING: state = 34;
pub const S_PLAY_GLIDE_LANDING: state = 33;
pub const S_PLAY_GLIDE: state = 32;
pub const S_PLAY_FLY_TIRED: state = 31;
pub const S_PLAY_SWIM: state = 30;
pub const S_PLAY_FLY: state = 29;
pub const S_PLAY_SPINDASH: state = 28;
pub const S_PLAY_RIDE: state = 27;
pub const S_PLAY_EDGE: state = 26;
pub const S_PLAY_FALL: state = 25;
pub const S_PLAY_SPRING: state = 24;
pub const S_PLAY_JUMP: state = 23;
pub const S_PLAY_GASP: state = 22;
pub const S_PLAY_ROLL: state = 21;
pub const S_PLAY_DRWN: state = 20;
pub const S_PLAY_DEAD: state = 19;
pub const S_PLAY_STUN: state = 18;
pub const S_PLAY_PAIN: state = 17;
pub const S_PLAY_DASH: state = 16;
pub const S_PLAY_RUN: state = 15;
pub const S_PLAY_SKID: state = 14;
pub const S_PLAY_WALK: state = 13;
pub const S_PLAY_WAIT: state = 12;
pub const S_PLAY_STND: state = 11;
pub const S_THOK: state = 10;
pub const S_RAISESTATE: state = 9;
pub const S_XDEATHSTATE: state = 8;
pub const S_DEATHSTATE: state = 7;
pub const S_MISSILESTATE: state = 6;
pub const S_MELEESTATE: state = 5;
pub const S_SEESTATE: state = 4;
pub const S_SPAWNSTATE: state = 3;
pub const S_INVISIBLE: state = 2;
pub const S_UNKNOWN: state = 1;
pub const S_NULL: state = 0;
pub type sfxenum_t = libc::c_uint;
pub const NUMSFX: sfxenum_t = 3008;
pub const sfx_lastskinsoundslot: sfxenum_t = 3007;
pub const sfx_skinsoundslot0: sfxenum_t = 2336;
pub const sfx_lastfreeslot: sfxenum_t = 2335;
pub const sfx_freeslot0: sfxenum_t = 736;
pub const sfx_kc6e: sfxenum_t = 735;
pub const sfx_kc6d: sfxenum_t = 734;
pub const sfx_kc6c: sfxenum_t = 733;
pub const sfx_kc6b: sfxenum_t = 732;
pub const sfx_kc69: sfxenum_t = 731;
pub const sfx_kc68: sfxenum_t = 730;
pub const sfx_kc67: sfxenum_t = 729;
pub const sfx_kc66: sfxenum_t = 728;
pub const sfx_kc65: sfxenum_t = 727;
pub const sfx_kc64: sfxenum_t = 726;
pub const sfx_kc63: sfxenum_t = 725;
pub const sfx_kc62: sfxenum_t = 724;
pub const sfx_kc61: sfxenum_t = 723;
pub const sfx_kc60: sfxenum_t = 722;
pub const sfx_kc5f: sfxenum_t = 721;
pub const sfx_kc5e: sfxenum_t = 720;
pub const sfx_kc5d: sfxenum_t = 719;
pub const sfx_kc5c: sfxenum_t = 718;
pub const sfx_kc5b: sfxenum_t = 717;
pub const sfx_kc5a: sfxenum_t = 716;
pub const sfx_kc59: sfxenum_t = 715;
pub const sfx_kc58: sfxenum_t = 714;
pub const sfx_kc57: sfxenum_t = 713;
pub const sfx_kc56: sfxenum_t = 712;
pub const sfx_kc55: sfxenum_t = 711;
pub const sfx_kc54: sfxenum_t = 710;
pub const sfx_kc53: sfxenum_t = 709;
pub const sfx_kc52: sfxenum_t = 708;
pub const sfx_kc51: sfxenum_t = 707;
pub const sfx_kc50: sfxenum_t = 706;
pub const sfx_kc4f: sfxenum_t = 705;
pub const sfx_kc4e: sfxenum_t = 704;
pub const sfx_kc4d: sfxenum_t = 703;
pub const sfx_kc4c: sfxenum_t = 702;
pub const sfx_kc4b: sfxenum_t = 701;
pub const sfx_kc4a: sfxenum_t = 700;
pub const sfx_kc49: sfxenum_t = 699;
pub const sfx_kc48: sfxenum_t = 698;
pub const sfx_kc47: sfxenum_t = 697;
pub const sfx_kc46: sfxenum_t = 696;
pub const sfx_kc45: sfxenum_t = 695;
pub const sfx_kc44: sfxenum_t = 694;
pub const sfx_kc43: sfxenum_t = 693;
pub const sfx_kc42: sfxenum_t = 692;
pub const sfx_kc41: sfxenum_t = 691;
pub const sfx_kc40: sfxenum_t = 690;
pub const sfx_kc3f: sfxenum_t = 689;
pub const sfx_kc3e: sfxenum_t = 688;
pub const sfx_kc3d: sfxenum_t = 687;
pub const sfx_kc3c: sfxenum_t = 686;
pub const sfx_kc3b: sfxenum_t = 685;
pub const sfx_kc3a: sfxenum_t = 684;
pub const sfx_kc39: sfxenum_t = 683;
pub const sfx_kc38: sfxenum_t = 682;
pub const sfx_kc37: sfxenum_t = 681;
pub const sfx_kc36: sfxenum_t = 680;
pub const sfx_kc35: sfxenum_t = 679;
pub const sfx_kc34: sfxenum_t = 678;
pub const sfx_kc33: sfxenum_t = 677;
pub const sfx_kc32: sfxenum_t = 676;
pub const sfx_kc31: sfxenum_t = 675;
pub const sfx_kc30: sfxenum_t = 674;
pub const sfx_kc2f: sfxenum_t = 673;
pub const sfx_kc2e: sfxenum_t = 672;
pub const sfx_kc2d: sfxenum_t = 671;
pub const sfx_kc2c: sfxenum_t = 670;
pub const sfx_kc2b: sfxenum_t = 669;
pub const sfx_kc2a: sfxenum_t = 668;
pub const sfx_cdpcm9: sfxenum_t = 667;
pub const sfx_cdpcm8: sfxenum_t = 666;
pub const sfx_cdpcm7: sfxenum_t = 665;
pub const sfx_cdpcm6: sfxenum_t = 664;
pub const sfx_cdpcm5: sfxenum_t = 663;
pub const sfx_cdpcm4: sfxenum_t = 662;
pub const sfx_cdpcm3: sfxenum_t = 661;
pub const sfx_cdpcm2: sfxenum_t = 660;
pub const sfx_cdpcm1: sfxenum_t = 659;
pub const sfx_cdpcm0: sfxenum_t = 658;
pub const sfx_cdfm79: sfxenum_t = 657;
pub const sfx_cdfm78: sfxenum_t = 656;
pub const sfx_cdfm77: sfxenum_t = 655;
pub const sfx_cdfm76: sfxenum_t = 654;
pub const sfx_cdfm75: sfxenum_t = 653;
pub const sfx_cdfm74: sfxenum_t = 652;
pub const sfx_cdfm73: sfxenum_t = 651;
pub const sfx_cdfm72: sfxenum_t = 650;
pub const sfx_cdfm71: sfxenum_t = 649;
pub const sfx_cdfm70: sfxenum_t = 648;
pub const sfx_cdfm69: sfxenum_t = 647;
pub const sfx_cdfm68: sfxenum_t = 646;
pub const sfx_cdfm67: sfxenum_t = 645;
pub const sfx_cdfm66: sfxenum_t = 644;
pub const sfx_cdfm65: sfxenum_t = 643;
pub const sfx_cdfm64: sfxenum_t = 642;
pub const sfx_cdfm63: sfxenum_t = 641;
pub const sfx_cdfm62: sfxenum_t = 640;
pub const sfx_cdfm61: sfxenum_t = 639;
pub const sfx_cdfm60: sfxenum_t = 638;
pub const sfx_cdfm59: sfxenum_t = 637;
pub const sfx_cdfm58: sfxenum_t = 636;
pub const sfx_cdfm57: sfxenum_t = 635;
pub const sfx_cdfm56: sfxenum_t = 634;
pub const sfx_cdfm55: sfxenum_t = 633;
pub const sfx_cdfm54: sfxenum_t = 632;
pub const sfx_cdfm53: sfxenum_t = 631;
pub const sfx_cdfm52: sfxenum_t = 630;
pub const sfx_cdfm51: sfxenum_t = 629;
pub const sfx_cdfm50: sfxenum_t = 628;
pub const sfx_cdfm49: sfxenum_t = 627;
pub const sfx_cdfm48: sfxenum_t = 626;
pub const sfx_cdfm47: sfxenum_t = 625;
pub const sfx_cdfm46: sfxenum_t = 624;
pub const sfx_cdfm45: sfxenum_t = 623;
pub const sfx_cdfm44: sfxenum_t = 622;
pub const sfx_cdfm43: sfxenum_t = 621;
pub const sfx_cdfm42: sfxenum_t = 620;
pub const sfx_cdfm41: sfxenum_t = 619;
pub const sfx_cdfm40: sfxenum_t = 618;
pub const sfx_cdfm39: sfxenum_t = 617;
pub const sfx_cdfm38: sfxenum_t = 616;
pub const sfx_cdfm37: sfxenum_t = 615;
pub const sfx_cdfm36: sfxenum_t = 614;
pub const sfx_cdfm35: sfxenum_t = 613;
pub const sfx_cdfm34: sfxenum_t = 612;
pub const sfx_cdfm33: sfxenum_t = 611;
pub const sfx_cdfm32: sfxenum_t = 610;
pub const sfx_cdfm31: sfxenum_t = 609;
pub const sfx_cdfm30: sfxenum_t = 608;
pub const sfx_cdfm29: sfxenum_t = 607;
pub const sfx_cdfm28: sfxenum_t = 606;
pub const sfx_cdfm27: sfxenum_t = 605;
pub const sfx_cdfm26: sfxenum_t = 604;
pub const sfx_cdfm25: sfxenum_t = 603;
pub const sfx_cdfm24: sfxenum_t = 602;
pub const sfx_cdfm23: sfxenum_t = 601;
pub const sfx_cdfm22: sfxenum_t = 600;
pub const sfx_cdfm21: sfxenum_t = 599;
pub const sfx_cdfm20: sfxenum_t = 598;
pub const sfx_cdfm19: sfxenum_t = 597;
pub const sfx_cdfm18: sfxenum_t = 596;
pub const sfx_cdfm17: sfxenum_t = 595;
pub const sfx_cdfm16: sfxenum_t = 594;
pub const sfx_cdfm15: sfxenum_t = 593;
pub const sfx_cdfm14: sfxenum_t = 592;
pub const sfx_cdfm13: sfxenum_t = 591;
pub const sfx_cdfm12: sfxenum_t = 590;
pub const sfx_cdfm11: sfxenum_t = 589;
pub const sfx_cdfm10: sfxenum_t = 588;
pub const sfx_cdfm09: sfxenum_t = 587;
pub const sfx_cdfm08: sfxenum_t = 586;
pub const sfx_cdfm07: sfxenum_t = 585;
pub const sfx_cdfm06: sfxenum_t = 584;
pub const sfx_cdfm05: sfxenum_t = 583;
pub const sfx_cdfm04: sfxenum_t = 582;
pub const sfx_cdfm03: sfxenum_t = 581;
pub const sfx_cdfm02: sfxenum_t = 580;
pub const sfx_cdfm01: sfxenum_t = 579;
pub const sfx_cdfm00: sfxenum_t = 578;
pub const sfx_3db16: sfxenum_t = 577;
pub const sfx_3db14: sfxenum_t = 576;
pub const sfx_3db09: sfxenum_t = 575;
pub const sfx_3db06: sfxenum_t = 574;
pub const sfx_s3kdbl: sfxenum_t = 573;
pub const sfx_s3kdbs: sfxenum_t = 572;
pub const sfx_s3kdal: sfxenum_t = 571;
pub const sfx_s3kdas: sfxenum_t = 570;
pub const sfx_s3kd9l: sfxenum_t = 569;
pub const sfx_s3kd9s: sfxenum_t = 568;
pub const sfx_s3kd8l: sfxenum_t = 567;
pub const sfx_s3kd8s: sfxenum_t = 566;
pub const sfx_s3kd7l: sfxenum_t = 565;
pub const sfx_s3kd7s: sfxenum_t = 564;
pub const sfx_s3kd6l: sfxenum_t = 563;
pub const sfx_s3kd6s: sfxenum_t = 562;
pub const sfx_s3kd5l: sfxenum_t = 561;
pub const sfx_s3kd5s: sfxenum_t = 560;
pub const sfx_s3kd4l: sfxenum_t = 559;
pub const sfx_s3kd4s: sfxenum_t = 558;
pub const sfx_s3kd3l: sfxenum_t = 557;
pub const sfx_s3kd3s: sfxenum_t = 556;
pub const sfx_s3kd2l: sfxenum_t = 555;
pub const sfx_s3kd2s: sfxenum_t = 554;
pub const sfx_s3kd1l: sfxenum_t = 553;
pub const sfx_s3kd1s: sfxenum_t = 552;
pub const sfx_s3kd0l: sfxenum_t = 551;
pub const sfx_s3kd0s: sfxenum_t = 550;
pub const sfx_s3kcfl: sfxenum_t = 549;
pub const sfx_s3kcfs: sfxenum_t = 548;
pub const sfx_s3kcel: sfxenum_t = 547;
pub const sfx_s3kces: sfxenum_t = 546;
pub const sfx_s3kcdl: sfxenum_t = 545;
pub const sfx_s3kcds: sfxenum_t = 544;
pub const sfx_s3kccl: sfxenum_t = 543;
pub const sfx_s3kccs: sfxenum_t = 542;
pub const sfx_s3kcbl: sfxenum_t = 541;
pub const sfx_s3kcbs: sfxenum_t = 540;
pub const sfx_s3kcal: sfxenum_t = 539;
pub const sfx_s3kcas: sfxenum_t = 538;
pub const sfx_s3kc9l: sfxenum_t = 537;
pub const sfx_s3kc9s: sfxenum_t = 536;
pub const sfx_s3kc8l: sfxenum_t = 535;
pub const sfx_s3kc8s: sfxenum_t = 534;
pub const sfx_s3kc7l: sfxenum_t = 533;
pub const sfx_s3kc7s: sfxenum_t = 532;
pub const sfx_s3kc6l: sfxenum_t = 531;
pub const sfx_s3kc6s: sfxenum_t = 530;
pub const sfx_s3kc5l: sfxenum_t = 529;
pub const sfx_s3kc5s: sfxenum_t = 528;
pub const sfx_s3kc4l: sfxenum_t = 527;
pub const sfx_s3kc4s: sfxenum_t = 526;
pub const sfx_s3kc3l: sfxenum_t = 525;
pub const sfx_s3kc3s: sfxenum_t = 524;
pub const sfx_s3kc2l: sfxenum_t = 523;
pub const sfx_s3kc2s: sfxenum_t = 522;
pub const sfx_s3kc1l: sfxenum_t = 521;
pub const sfx_s3kc1s: sfxenum_t = 520;
pub const sfx_s3kc0l: sfxenum_t = 519;
pub const sfx_s3kc0s: sfxenum_t = 518;
pub const sfx_s3kbfl: sfxenum_t = 517;
pub const sfx_s3kbfs: sfxenum_t = 516;
pub const sfx_s3kbel: sfxenum_t = 515;
pub const sfx_s3kbes: sfxenum_t = 514;
pub const sfx_s3kbdl: sfxenum_t = 513;
pub const sfx_s3kbds: sfxenum_t = 512;
pub const sfx_s3kbcl: sfxenum_t = 511;
pub const sfx_s3kbcs: sfxenum_t = 510;
pub const sfx_s3kbb: sfxenum_t = 509;
pub const sfx_s3kba: sfxenum_t = 508;
pub const sfx_s3kb9: sfxenum_t = 507;
pub const sfx_s3kb8: sfxenum_t = 506;
pub const sfx_s3kb7: sfxenum_t = 505;
pub const sfx_s3kb6: sfxenum_t = 504;
pub const sfx_s3kb5: sfxenum_t = 503;
pub const sfx_s3kb4: sfxenum_t = 502;
pub const sfx_s3kb3: sfxenum_t = 501;
pub const sfx_s3kb2: sfxenum_t = 500;
pub const sfx_s3kb1: sfxenum_t = 499;
pub const sfx_s3kb0: sfxenum_t = 498;
pub const sfx_s3kaf: sfxenum_t = 497;
pub const sfx_s3kae: sfxenum_t = 496;
pub const sfx_s3kad: sfxenum_t = 495;
pub const sfx_s3kac: sfxenum_t = 494;
pub const sfx_s3kabf: sfxenum_t = 493;
pub const sfx_s3kabe: sfxenum_t = 492;
pub const sfx_s3kabd: sfxenum_t = 491;
pub const sfx_s3kabc: sfxenum_t = 490;
pub const sfx_s3kabb: sfxenum_t = 489;
pub const sfx_s3kaba: sfxenum_t = 488;
pub const sfx_s3kab9: sfxenum_t = 487;
pub const sfx_s3kab8: sfxenum_t = 486;
pub const sfx_s3kab7: sfxenum_t = 485;
pub const sfx_s3kab6: sfxenum_t = 484;
pub const sfx_s3kab5: sfxenum_t = 483;
pub const sfx_s3kab4: sfxenum_t = 482;
pub const sfx_s3kab3: sfxenum_t = 481;
pub const sfx_s3kab2: sfxenum_t = 480;
pub const sfx_s3kab1: sfxenum_t = 479;
pub const sfx_s3kab: sfxenum_t = 478;
pub const sfx_s3kaa: sfxenum_t = 477;
pub const sfx_s3ka9: sfxenum_t = 476;
pub const sfx_s3ka8: sfxenum_t = 475;
pub const sfx_s3ka7: sfxenum_t = 474;
pub const sfx_s3ka6: sfxenum_t = 473;
pub const sfx_s3ka5: sfxenum_t = 472;
pub const sfx_s3ka4: sfxenum_t = 471;
pub const sfx_s3ka3: sfxenum_t = 470;
pub const sfx_s3ka2: sfxenum_t = 469;
pub const sfx_s3ka1: sfxenum_t = 468;
pub const sfx_s3ka0: sfxenum_t = 467;
pub const sfx_s3k9f: sfxenum_t = 466;
pub const sfx_s3k9e: sfxenum_t = 465;
pub const sfx_s3k9d: sfxenum_t = 464;
pub const sfx_s3k9c: sfxenum_t = 463;
pub const sfx_s3k9b: sfxenum_t = 462;
pub const sfx_s3k9a: sfxenum_t = 461;
pub const sfx_s3k99: sfxenum_t = 460;
pub const sfx_s3k98: sfxenum_t = 459;
pub const sfx_s3k97: sfxenum_t = 458;
pub const sfx_s3k96: sfxenum_t = 457;
pub const sfx_s3k95: sfxenum_t = 456;
pub const sfx_s3k94: sfxenum_t = 455;
pub const sfx_s3k93: sfxenum_t = 454;
pub const sfx_s3k92: sfxenum_t = 453;
pub const sfx_s3k91: sfxenum_t = 452;
pub const sfx_s3k90: sfxenum_t = 451;
pub const sfx_s3k8f: sfxenum_t = 450;
pub const sfx_s3k8e: sfxenum_t = 449;
pub const sfx_s3k8d: sfxenum_t = 448;
pub const sfx_s3k8c: sfxenum_t = 447;
pub const sfx_s3k8b: sfxenum_t = 446;
pub const sfx_s3k8a: sfxenum_t = 445;
pub const sfx_s3k89: sfxenum_t = 444;
pub const sfx_s3k88: sfxenum_t = 443;
pub const sfx_s3k87: sfxenum_t = 442;
pub const sfx_s3k86: sfxenum_t = 441;
pub const sfx_s3k85: sfxenum_t = 440;
pub const sfx_s3k84: sfxenum_t = 439;
pub const sfx_s3k83: sfxenum_t = 438;
pub const sfx_s3k82: sfxenum_t = 437;
pub const sfx_s3k81: sfxenum_t = 436;
pub const sfx_s3k80: sfxenum_t = 435;
pub const sfx_s3k7f: sfxenum_t = 434;
pub const sfx_s3k7e: sfxenum_t = 433;
pub const sfx_s3k7d: sfxenum_t = 432;
pub const sfx_s3k7c: sfxenum_t = 431;
pub const sfx_s3k7b: sfxenum_t = 430;
pub const sfx_s3k7a: sfxenum_t = 429;
pub const sfx_s3k79: sfxenum_t = 428;
pub const sfx_s3k78: sfxenum_t = 427;
pub const sfx_s3k77: sfxenum_t = 426;
pub const sfx_s3k76: sfxenum_t = 425;
pub const sfx_s3k75: sfxenum_t = 424;
pub const sfx_s3k74: sfxenum_t = 423;
pub const sfx_s3k73: sfxenum_t = 422;
pub const sfx_s3k72: sfxenum_t = 421;
pub const sfx_s3k71: sfxenum_t = 420;
pub const sfx_s3k70: sfxenum_t = 419;
pub const sfx_s3k6f: sfxenum_t = 418;
pub const sfx_s3k6e: sfxenum_t = 417;
pub const sfx_s3k6d: sfxenum_t = 416;
pub const sfx_s3k6c: sfxenum_t = 415;
pub const sfx_s3k6b: sfxenum_t = 414;
pub const sfx_s3k6a: sfxenum_t = 413;
pub const sfx_s3k69: sfxenum_t = 412;
pub const sfx_s3k68: sfxenum_t = 411;
pub const sfx_s3k67: sfxenum_t = 410;
pub const sfx_s3k66: sfxenum_t = 409;
pub const sfx_s3k65: sfxenum_t = 408;
pub const sfx_s3k64: sfxenum_t = 407;
pub const sfx_s3k63: sfxenum_t = 406;
pub const sfx_s3k62: sfxenum_t = 405;
pub const sfx_s3k61: sfxenum_t = 404;
pub const sfx_s3k60: sfxenum_t = 403;
pub const sfx_s3k5f: sfxenum_t = 402;
pub const sfx_s3k5e: sfxenum_t = 401;
pub const sfx_s3k5d: sfxenum_t = 400;
pub const sfx_s3k5c: sfxenum_t = 399;
pub const sfx_s3k5b: sfxenum_t = 398;
pub const sfx_s3k5a: sfxenum_t = 397;
pub const sfx_s3k59: sfxenum_t = 396;
pub const sfx_s3k58: sfxenum_t = 395;
pub const sfx_s3k57: sfxenum_t = 394;
pub const sfx_s3k56: sfxenum_t = 393;
pub const sfx_s3k55: sfxenum_t = 392;
pub const sfx_s3k54: sfxenum_t = 391;
pub const sfx_s3k53: sfxenum_t = 390;
pub const sfx_s3k52: sfxenum_t = 389;
pub const sfx_s3k51: sfxenum_t = 388;
pub const sfx_s3k50: sfxenum_t = 387;
pub const sfx_s3k4f: sfxenum_t = 386;
pub const sfx_s3k4e: sfxenum_t = 385;
pub const sfx_s3k4d: sfxenum_t = 384;
pub const sfx_s3k4c: sfxenum_t = 383;
pub const sfx_s3k4b: sfxenum_t = 382;
pub const sfx_s3k4a: sfxenum_t = 381;
pub const sfx_s3k49: sfxenum_t = 380;
pub const sfx_s3k48: sfxenum_t = 379;
pub const sfx_s3k47: sfxenum_t = 378;
pub const sfx_s3k46: sfxenum_t = 377;
pub const sfx_s3k45: sfxenum_t = 376;
pub const sfx_s3k44: sfxenum_t = 375;
pub const sfx_s3k43: sfxenum_t = 374;
pub const sfx_s3k42: sfxenum_t = 373;
pub const sfx_s3k41: sfxenum_t = 372;
pub const sfx_s3k40: sfxenum_t = 371;
pub const sfx_s3k3f: sfxenum_t = 370;
pub const sfx_s3k3e: sfxenum_t = 369;
pub const sfx_s3k3d: sfxenum_t = 368;
pub const sfx_s3k3c: sfxenum_t = 367;
pub const sfx_s3k3b: sfxenum_t = 366;
pub const sfx_s3k3a: sfxenum_t = 365;
pub const sfx_s3k39: sfxenum_t = 364;
pub const sfx_s3k38: sfxenum_t = 363;
pub const sfx_s3k37: sfxenum_t = 362;
pub const sfx_s3k36: sfxenum_t = 361;
pub const sfx_s3k35: sfxenum_t = 360;
pub const sfx_s3k34: sfxenum_t = 359;
pub const sfx_s3k33: sfxenum_t = 358;
pub const sfx_s3k2b: sfxenum_t = 357;
pub const sfx_s260: sfxenum_t = 356;
pub const sfx_s25f: sfxenum_t = 355;
pub const sfx_s25e: sfxenum_t = 354;
pub const sfx_s25d: sfxenum_t = 353;
pub const sfx_s25c: sfxenum_t = 352;
pub const sfx_s25b: sfxenum_t = 351;
pub const sfx_s25a: sfxenum_t = 350;
pub const sfx_s259: sfxenum_t = 349;
pub const sfx_s258: sfxenum_t = 348;
pub const sfx_s257: sfxenum_t = 347;
pub const sfx_s256: sfxenum_t = 346;
pub const sfx_s255: sfxenum_t = 345;
pub const sfx_s254: sfxenum_t = 344;
pub const sfx_s253: sfxenum_t = 343;
pub const sfx_s252: sfxenum_t = 342;
pub const sfx_s251: sfxenum_t = 341;
pub const sfx_s250: sfxenum_t = 340;
pub const sfx_s24f: sfxenum_t = 339;
pub const sfx_s24e: sfxenum_t = 338;
pub const sfx_s24d: sfxenum_t = 337;
pub const sfx_s24c: sfxenum_t = 336;
pub const sfx_s24b: sfxenum_t = 335;
pub const sfx_s24a: sfxenum_t = 334;
pub const sfx_s249: sfxenum_t = 333;
pub const sfx_s248: sfxenum_t = 332;
pub const sfx_s247: sfxenum_t = 331;
pub const sfx_s246: sfxenum_t = 330;
pub const sfx_s245: sfxenum_t = 329;
pub const sfx_s244: sfxenum_t = 328;
pub const sfx_s243: sfxenum_t = 327;
pub const sfx_s242: sfxenum_t = 326;
pub const sfx_s241: sfxenum_t = 325;
pub const sfx_s240: sfxenum_t = 324;
pub const sfx_s23f: sfxenum_t = 323;
pub const sfx_s23e: sfxenum_t = 322;
pub const sfx_s23d: sfxenum_t = 321;
pub const sfx_s23c: sfxenum_t = 320;
pub const sfx_s23b: sfxenum_t = 319;
pub const sfx_s23a: sfxenum_t = 318;
pub const sfx_s239: sfxenum_t = 317;
pub const sfx_s238: sfxenum_t = 316;
pub const sfx_s237: sfxenum_t = 315;
pub const sfx_s236: sfxenum_t = 314;
pub const sfx_s235: sfxenum_t = 313;
pub const sfx_s234: sfxenum_t = 312;
pub const sfx_s233: sfxenum_t = 311;
pub const sfx_s232: sfxenum_t = 310;
pub const sfx_s231: sfxenum_t = 309;
pub const sfx_s230: sfxenum_t = 308;
pub const sfx_s22f: sfxenum_t = 307;
pub const sfx_s22e: sfxenum_t = 306;
pub const sfx_s22d: sfxenum_t = 305;
pub const sfx_s22c: sfxenum_t = 304;
pub const sfx_s22b: sfxenum_t = 303;
pub const sfx_s22a: sfxenum_t = 302;
pub const sfx_s229: sfxenum_t = 301;
pub const sfx_s228: sfxenum_t = 300;
pub const sfx_s227: sfxenum_t = 299;
pub const sfx_s226: sfxenum_t = 298;
pub const sfx_s225: sfxenum_t = 297;
pub const sfx_s224: sfxenum_t = 296;
pub const sfx_s223: sfxenum_t = 295;
pub const sfx_s222: sfxenum_t = 294;
pub const sfx_s221: sfxenum_t = 293;
pub const sfx_s220: sfxenum_t = 292;
pub const sfx_s1cf: sfxenum_t = 291;
pub const sfx_s1ce: sfxenum_t = 290;
pub const sfx_s1cd: sfxenum_t = 289;
pub const sfx_s1cc: sfxenum_t = 288;
pub const sfx_s1cb: sfxenum_t = 287;
pub const sfx_s1ca: sfxenum_t = 286;
pub const sfx_s1c9: sfxenum_t = 285;
pub const sfx_s1c8: sfxenum_t = 284;
pub const sfx_s1c7: sfxenum_t = 283;
pub const sfx_s1c6: sfxenum_t = 282;
pub const sfx_s1c5: sfxenum_t = 281;
pub const sfx_s1c4: sfxenum_t = 280;
pub const sfx_s1c3: sfxenum_t = 279;
pub const sfx_s1c2: sfxenum_t = 278;
pub const sfx_s1c1: sfxenum_t = 277;
pub const sfx_s1c0: sfxenum_t = 276;
pub const sfx_s1bf: sfxenum_t = 275;
pub const sfx_s1be: sfxenum_t = 274;
pub const sfx_s1bd: sfxenum_t = 273;
pub const sfx_s1bc: sfxenum_t = 272;
pub const sfx_s1bb: sfxenum_t = 271;
pub const sfx_s1ba: sfxenum_t = 270;
pub const sfx_s1b9: sfxenum_t = 269;
pub const sfx_s1b8: sfxenum_t = 268;
pub const sfx_s1b7: sfxenum_t = 267;
pub const sfx_s1b6: sfxenum_t = 266;
pub const sfx_s1b5: sfxenum_t = 265;
pub const sfx_s1b4: sfxenum_t = 264;
pub const sfx_s1b3: sfxenum_t = 263;
pub const sfx_s1b2: sfxenum_t = 262;
pub const sfx_s1b1: sfxenum_t = 261;
pub const sfx_s1b0: sfxenum_t = 260;
pub const sfx_s1af: sfxenum_t = 259;
pub const sfx_s1ae: sfxenum_t = 258;
pub const sfx_s1ad: sfxenum_t = 257;
pub const sfx_s1ac: sfxenum_t = 256;
pub const sfx_s1ab: sfxenum_t = 255;
pub const sfx_s1aa: sfxenum_t = 254;
pub const sfx_s1a9: sfxenum_t = 253;
pub const sfx_s1a8: sfxenum_t = 252;
pub const sfx_s1a7: sfxenum_t = 251;
pub const sfx_s1a6: sfxenum_t = 250;
pub const sfx_s1a5: sfxenum_t = 249;
pub const sfx_s1a4: sfxenum_t = 248;
pub const sfx_s1a3: sfxenum_t = 247;
pub const sfx_s1a2: sfxenum_t = 246;
pub const sfx_s1a1: sfxenum_t = 245;
pub const sfx_s1a0: sfxenum_t = 244;
pub const sfx_brakrx: sfxenum_t = 243;
pub const sfx_brakrl: sfxenum_t = 242;
pub const sfx_beelec: sfxenum_t = 241;
pub const sfx_bgxpld: sfxenum_t = 240;
pub const sfx_bexpld: sfxenum_t = 239;
pub const sfx_bewar4: sfxenum_t = 238;
pub const sfx_bewar3: sfxenum_t = 237;
pub const sfx_bewar2: sfxenum_t = 236;
pub const sfx_bewar1: sfxenum_t = 235;
pub const sfx_bestp2: sfxenum_t = 234;
pub const sfx_bestep: sfxenum_t = 233;
pub const sfx_beshot: sfxenum_t = 232;
pub const sfx_beragh: sfxenum_t = 231;
pub const sfx_beoutb: sfxenum_t = 230;
pub const sfx_belnch: sfxenum_t = 229;
pub const sfx_bejet1: sfxenum_t = 228;
pub const sfx_behurt: sfxenum_t = 227;
pub const sfx_begrnd: sfxenum_t = 226;
pub const sfx_begoop: sfxenum_t = 225;
pub const sfx_beflap: sfxenum_t = 224;
pub const sfx_befire: sfxenum_t = 223;
pub const sfx_befall: sfxenum_t = 222;
pub const sfx_beeyow: sfxenum_t = 221;
pub const sfx_bedie2: sfxenum_t = 220;
pub const sfx_bedie1: sfxenum_t = 219;
pub const sfx_bedeen: sfxenum_t = 218;
pub const sfx_becrsh: sfxenum_t = 217;
pub const sfx_bechrg: sfxenum_t = 216;
pub const sfx_bebomb: sfxenum_t = 215;
pub const sfx_thwomp: sfxenum_t = 214;
pub const sfx_marioa: sfxenum_t = 213;
pub const sfx_mario9: sfxenum_t = 212;
pub const sfx_mario8: sfxenum_t = 211;
pub const sfx_mario7: sfxenum_t = 210;
pub const sfx_mario6: sfxenum_t = 209;
pub const sfx_mario5: sfxenum_t = 208;
pub const sfx_mario4: sfxenum_t = 207;
pub const sfx_mario3: sfxenum_t = 206;
pub const sfx_mario2: sfxenum_t = 205;
pub const sfx_mario1: sfxenum_t = 204;
pub const sfx_koopfr: sfxenum_t = 203;
pub const sfx_ghosty: sfxenum_t = 202;
pub const sfx_pumpkn: sfxenum_t = 201;
pub const sfx_lntdie: sfxenum_t = 200;
pub const sfx_lntsit: sfxenum_t = 199;
pub const sfx_peww: sfxenum_t = 198;
pub const sfx_ngjump: sfxenum_t = 197;
pub const sfx_timeup: sfxenum_t = 196;
pub const sfx_prloop: sfxenum_t = 195;
pub const sfx_hidden: sfxenum_t = 194;
pub const sfx_hoop3: sfxenum_t = 193;
pub const sfx_hoop2: sfxenum_t = 192;
pub const sfx_hoop1: sfxenum_t = 191;
pub const sfx_ngskid: sfxenum_t = 190;
pub const sfx_nghurt: sfxenum_t = 189;
pub const sfx_ncspec: sfxenum_t = 188;
pub const sfx_drill2: sfxenum_t = 187;
pub const sfx_drill1: sfxenum_t = 186;
pub const sfx_nxdone: sfxenum_t = 185;
pub const sfx_ngdone: sfxenum_t = 184;
pub const sfx_nxitem: sfxenum_t = 183;
pub const sfx_ncitem: sfxenum_t = 182;
pub const sfx_ncchip: sfxenum_t = 181;
pub const sfx_nxbump: sfxenum_t = 180;
pub const sfx_nbmper: sfxenum_t = 179;
pub const sfx_xideya: sfxenum_t = 178;
pub const sfx_ideya: sfxenum_t = 177;
pub const sfx_addfil: sfxenum_t = 176;
pub const sfx_notadd: sfxenum_t = 175;
pub const sfx_adderr: sfxenum_t = 174;
pub const sfx_zelda: sfxenum_t = 173;
pub const sfx_wtrdng: sfxenum_t = 172;
pub const sfx_wepchg: sfxenum_t = 171;
pub const sfx_radio: sfxenum_t = 170;
pub const sfx_ptally: sfxenum_t = 169;
pub const sfx_oneup: sfxenum_t = 168;
pub const sfx_menu1: sfxenum_t = 167;
pub const sfx_flgcap: sfxenum_t = 166;
pub const sfx_emfind: sfxenum_t = 165;
pub const sfx_dwnind: sfxenum_t = 164;
pub const sfx_chchng: sfxenum_t = 163;
pub const sfx_antiri: sfxenum_t = 162;
pub const sfx_shattr: sfxenum_t = 161;
pub const sfx_iceb: sfxenum_t = 160;
pub const sfx_pscree: sfxenum_t = 159;
pub const sfx_lvfal1: sfxenum_t = 158;
pub const sfx_sprong: sfxenum_t = 157;
pub const sfx_bsnipe: sfxenum_t = 156;
pub const sfx_chuchu: sfxenum_t = 155;
pub const sfx_bowl: sfxenum_t = 154;
pub const sfx_vwre: sfxenum_t = 153;
pub const sfx_alart: sfxenum_t = 152;
pub const sfx_corkh: sfxenum_t = 151;
pub const sfx_corkp: sfxenum_t = 150;
pub const sfx_boingf: sfxenum_t = 149;
pub const sfx_mspogo: sfxenum_t = 148;
pub const sfx_mswarp: sfxenum_t = 147;
pub const sfx_shrpgo: sfxenum_t = 146;
pub const sfx_shrpsp: sfxenum_t = 145;
pub const sfx_wdjump: sfxenum_t = 144;
pub const sfx_turhit: sfxenum_t = 143;
pub const sfx_trpowr: sfxenum_t = 142;
pub const sfx_trfire: sfxenum_t = 141;
pub const sfx_token: sfxenum_t = 140;
pub const sfx_tink: sfxenum_t = 139;
pub const sfx_telept: sfxenum_t = 138;
pub const sfx_supert: sfxenum_t = 137;
pub const sfx_strpst: sfxenum_t = 136;
pub const sfx_statu2: sfxenum_t = 135;
pub const sfx_statu1: sfxenum_t = 134;
pub const sfx_spring: sfxenum_t = 133;
pub const sfx_spkdth: sfxenum_t = 132;
pub const sfx_spdpad: sfxenum_t = 131;
pub const sfx_shldls: sfxenum_t = 130;
pub const sfx_attrsg: sfxenum_t = 129;
pub const sfx_armasg: sfxenum_t = 128;
pub const sfx_elemsg: sfxenum_t = 127;
pub const sfx_frcssg: sfxenum_t = 126;
pub const sfx_forcsg: sfxenum_t = 125;
pub const sfx_wirlsg: sfxenum_t = 124;
pub const sfx_shield: sfxenum_t = 123;
pub const sfx_rlaunc: sfxenum_t = 122;
pub const sfx_rail2: sfxenum_t = 121;
pub const sfx_rail1: sfxenum_t = 120;
pub const sfx_pop: sfxenum_t = 119;
pub const sfx_pogo: sfxenum_t = 118;
pub const sfx_monton: sfxenum_t = 117;
pub const sfx_mixup: sfxenum_t = 116;
pub const sfx_mindig: sfxenum_t = 115;
pub const sfx_lvpass: sfxenum_t = 114;
pub const sfx_lose: sfxenum_t = 113;
pub const sfx_jshard: sfxenum_t = 112;
pub const sfx_jet: sfxenum_t = 111;
pub const sfx_itemup: sfxenum_t = 110;
pub const sfx_gravch: sfxenum_t = 109;
pub const sfx_gspray: sfxenum_t = 108;
pub const sfx_gloop: sfxenum_t = 107;
pub const sfx_ghit: sfxenum_t = 106;
pub const sfx_wepfir: sfxenum_t = 105;
pub const sfx_gbeep: sfxenum_t = 104;
pub const sfx_fizzle: sfxenum_t = 103;
pub const sfx_drown: sfxenum_t = 102;
pub const sfx_dmpain: sfxenum_t = 101;
pub const sfx_ding: sfxenum_t = 100;
pub const sfx_deton: sfxenum_t = 99;
pub const sfx_cybdth: sfxenum_t = 98;
pub const sfx_cgot: sfxenum_t = 97;
pub const sfx_cannon: sfxenum_t = 96;
pub const sfx_bnce2: sfxenum_t = 95;
pub const sfx_bnce1: sfxenum_t = 94;
pub const sfx_bkpoof: sfxenum_t = 93;
pub const sfx_appear: sfxenum_t = 92;
pub const sfx_rumble: sfxenum_t = 91;
pub const sfx_rumbam: sfxenum_t = 90;
pub const sfx_rocks4: sfxenum_t = 89;
pub const sfx_rocks3: sfxenum_t = 88;
pub const sfx_rocks2: sfxenum_t = 87;
pub const sfx_rocks1: sfxenum_t = 86;
pub const sfx_lavbub: sfxenum_t = 85;
pub const sfx_ambin2: sfxenum_t = 84;
pub const sfx_elevb3: sfxenum_t = 83;
pub const sfx_elevb2: sfxenum_t = 82;
pub const sfx_elevb1: sfxenum_t = 81;
pub const sfx_eleva3: sfxenum_t = 80;
pub const sfx_eleva2: sfxenum_t = 79;
pub const sfx_eleva1: sfxenum_t = 78;
pub const sfx_doord2: sfxenum_t = 77;
pub const sfx_doord1: sfxenum_t = 76;
pub const sfx_doorc2: sfxenum_t = 75;
pub const sfx_doorc1: sfxenum_t = 74;
pub const sfx_doorb1: sfxenum_t = 73;
pub const sfx_doora1: sfxenum_t = 72;
pub const sfx_wslap: sfxenum_t = 71;
pub const sfx_wdrip8: sfxenum_t = 70;
pub const sfx_wdrip7: sfxenum_t = 69;
pub const sfx_wdrip6: sfxenum_t = 68;
pub const sfx_wdrip5: sfxenum_t = 67;
pub const sfx_wdrip4: sfxenum_t = 66;
pub const sfx_wdrip3: sfxenum_t = 65;
pub const sfx_wdrip2: sfxenum_t = 64;
pub const sfx_wdrip1: sfxenum_t = 63;
pub const sfx_splish: sfxenum_t = 62;
pub const sfx_splash: sfxenum_t = 61;
pub const sfx_floush: sfxenum_t = 60;
pub const sfx_bubbl5: sfxenum_t = 59;
pub const sfx_bubbl4: sfxenum_t = 58;
pub const sfx_bubbl3: sfxenum_t = 57;
pub const sfx_bubbl2: sfxenum_t = 56;
pub const sfx_bubbl1: sfxenum_t = 55;
pub const sfx_amwtr8: sfxenum_t = 54;
pub const sfx_amwtr7: sfxenum_t = 53;
pub const sfx_amwtr6: sfxenum_t = 52;
pub const sfx_amwtr5: sfxenum_t = 51;
pub const sfx_amwtr4: sfxenum_t = 50;
pub const sfx_amwtr3: sfxenum_t = 49;
pub const sfx_amwtr2: sfxenum_t = 48;
pub const sfx_amwtr1: sfxenum_t = 47;
pub const sfx_athun2: sfxenum_t = 46;
pub const sfx_athun1: sfxenum_t = 45;
pub const sfx_litng4: sfxenum_t = 44;
pub const sfx_litng3: sfxenum_t = 43;
pub const sfx_litng2: sfxenum_t = 42;
pub const sfx_litng1: sfxenum_t = 41;
pub const sfx_rainin: sfxenum_t = 40;
pub const sfx_spsmsh: sfxenum_t = 39;
pub const sfx_ambmac: sfxenum_t = 38;
pub const sfx_wbreak: sfxenum_t = 37;
pub const sfx_steam2: sfxenum_t = 36;
pub const sfx_steam1: sfxenum_t = 35;
pub const sfx_pstop: sfxenum_t = 34;
pub const sfx_pstart: sfxenum_t = 33;
pub const sfx_mswing: sfxenum_t = 32;
pub const sfx_laser: sfxenum_t = 31;
pub const sfx_grind: sfxenum_t = 30;
pub const sfx_fire: sfxenum_t = 29;
pub const sfx_crumbl: sfxenum_t = 28;
pub const sfx_buzz4: sfxenum_t = 27;
pub const sfx_buzz3: sfxenum_t = 26;
pub const sfx_buzz2: sfxenum_t = 25;
pub const sfx_buzz1: sfxenum_t = 24;
pub const sfx_alarm: sfxenum_t = 23;
pub const sfx_ambint: sfxenum_t = 22;
pub const sfx_skid: sfxenum_t = 21;
pub const sfx_zoom: sfxenum_t = 20;
pub const sfx_thok: sfxenum_t = 19;
pub const sfx_spndsh: sfxenum_t = 18;
pub const sfx_spin: sfxenum_t = 17;
pub const sfx_putput: sfxenum_t = 16;
pub const sfx_pudpud: sfxenum_t = 15;
pub const sfx_jump: sfxenum_t = 14;
pub const sfx_gasp: sfxenum_t = 13;
pub const sfx_victr4: sfxenum_t = 12;
pub const sfx_victr3: sfxenum_t = 11;
pub const sfx_victr2: sfxenum_t = 10;
pub const sfx_victr1: sfxenum_t = 9;
pub const sfx_altow4: sfxenum_t = 8;
pub const sfx_altow3: sfxenum_t = 7;
pub const sfx_altow2: sfxenum_t = 6;
pub const sfx_altow1: sfxenum_t = 5;
pub const sfx_altdi4: sfxenum_t = 4;
pub const sfx_altdi3: sfxenum_t = 3;
pub const sfx_altdi2: sfxenum_t = 2;
pub const sfx_altdi1: sfxenum_t = 1;
pub const sfx_None: sfxenum_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct state_t {
    pub sprite: spritenum_t,
    pub frame: uint32_t,
    pub tics: int32_t,
    pub action: actionf_t,
    pub var1: int32_t,
    pub var2: int32_t,
    pub nextstate: statenum_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union actionf_t {
    pub acv: actionf_v,
    pub acp1: actionf_p1,
}
pub type actionf_p1 = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type actionf_v = Option::<unsafe extern "C" fn() -> ()>;
pub type spritenum_t = sprite;
pub type sprite = libc::c_uint;
pub const NUMSPRITES: sprite = 907;
pub const SPR_LASTFREESLOT: sprite = 906;
pub const SPR_FIRSTFREESLOT: sprite = 395;
pub const SPR_GWLR: sprite = 394;
pub const SPR_GWLG: sprite = 393;
pub const SPR_BRIY: sprite = 392;
pub const SPR_BRIB: sprite = 391;
pub const SPR_BRIR: sprite = 390;
pub const SPR_WDDB: sprite = 389;
pub const SPR_BRIC: sprite = 388;
pub const SPR_GFZD: sprite = 387;
pub const SPR_ROIP: sprite = 386;
pub const SPR_ROIO: sprite = 385;
pub const SPR_ROIN: sprite = 384;
pub const SPR_ROIM: sprite = 383;
pub const SPR_ROIL: sprite = 382;
pub const SPR_ROIK: sprite = 381;
pub const SPR_ROIJ: sprite = 380;
pub const SPR_ROII: sprite = 379;
pub const SPR_ROIH: sprite = 378;
pub const SPR_ROIG: sprite = 377;
pub const SPR_ROIF: sprite = 376;
pub const SPR_ROIE: sprite = 375;
pub const SPR_ROID: sprite = 374;
pub const SPR_ROIC: sprite = 373;
pub const SPR_ROIB: sprite = 372;
pub const SPR_ROIA: sprite = 371;
pub const SPR_BMNB: sprite = 370;
pub const SPR_BOM4: sprite = 369;
pub const SPR_BOM3: sprite = 368;
pub const SPR_BOM2: sprite = 367;
pub const SPR_BOM1: sprite = 366;
pub const SPR_SPRK: sprite = 365;
pub const SPR_HBAT: sprite = 364;
pub const SPR_SBSK: sprite = 363;
pub const SPR_SBFL: sprite = 362;
pub const SPR_SBOB: sprite = 361;
pub const SPR_BAL2: sprite = 360;
pub const SPR_CACO: sprite = 359;
pub const SPR_HMCE: sprite = 358;
pub const SPR_FMCE: sprite = 357;
pub const SPR_BBUZ: sprite = 356;
pub const SPR_BUMB: sprite = 355;
pub const SPR_HIVE: sprite = 354;
pub const SPR_POPH: sprite = 353;
pub const SPR_PENG: sprite = 352;
pub const SPR_SHLP: sprite = 351;
pub const SPR_NTPN: sprite = 350;
pub const SPR_IDYA: sprite = 349;
pub const SPR_CAPS: sprite = 348;
pub const SPR_NPRU: sprite = 347;
pub const SPR_NSCR: sprite = 346;
pub const SPR_HOOP: sprite = 345;
pub const SPR_NBMP: sprite = 344;
pub const SPR_NSPK: sprite = 343;
pub const SPR_NDRN: sprite = 342;
pub const SPR_TOAD: sprite = 341;
pub const SPR_MUS2: sprite = 340;
pub const SPR_MUS1: sprite = 339;
pub const SPR_MAXE: sprite = 338;
pub const SPR_BFLM: sprite = 337;
pub const SPR_KOOP: sprite = 336;
pub const SPR_HAMM: sprite = 335;
pub const SPR_PUMA: sprite = 334;
pub const SPR_SHLL: sprite = 333;
pub const SPR_FBLL: sprite = 332;
pub const SPR_FFWR: sprite = 331;
pub const SPR_BGOM: sprite = 330;
pub const SPR_GOOM: sprite = 329;
pub const SPR_CPRK: sprite = 328;
pub const SPR_COIN: sprite = 327;
pub const SPR_TSCR: sprite = 326;
pub const SPR_TGRE: sprite = 325;
pub const SPR_TAUT: sprite = 324;
pub const SPR_PIKG: sprite = 323;
pub const SPR_PIKS: sprite = 322;
pub const SPR_PIKE: sprite = 321;
pub const SPR_PIKA: sprite = 320;
pub const SPR_PIKR: sprite = 319;
pub const SPR_PIKB: sprite = 318;
pub const SPR_RNGG: sprite = 317;
pub const SPR_RNGS: sprite = 316;
pub const SPR_RNGE: sprite = 315;
pub const SPR_RNGA: sprite = 314;
pub const SPR_RNGI: sprite = 313;
pub const SPR_RNGR: sprite = 312;
pub const SPR_RNGB: sprite = 311;
pub const SPR_RRNG: sprite = 310;
pub const SPR_LHRT: sprite = 309;
pub const SPR_CORK: sprite = 308;
pub const SPR_FNSF: sprite = 307;
pub const SPR_GFLG: sprite = 306;
pub const SPR_TTAG: sprite = 305;
pub const SPR_LCKN: sprite = 304;
pub const SPR_FLII: sprite = 303;
pub const SPR_DRWN: sprite = 302;
pub const SPR_SCOR: sprite = 301;
pub const SPR_PRTL: sprite = 300;
pub const SPR_SEED: sprite = 299;
pub const SPR_TFOG: sprite = 298;
pub const SPR_FPRT: sprite = 297;
pub const SPR_DUST: sprite = 296;
pub const SPR_WZAP: sprite = 295;
pub const SPR_BUBL: sprite = 294;
pub const SPR_SMOK: sprite = 293;
pub const SPR_SPLA: sprite = 292;
pub const SPR_LSPL: sprite = 291;
pub const SPR_SPLH: sprite = 290;
pub const SPR_SNO1: sprite = 289;
pub const SPR_RAIN: sprite = 288;
pub const SPR_BSTR: sprite = 287;
pub const SPR_BSTY: sprite = 286;
pub const SPR_SSWB: sprite = 285;
pub const SPR_SSWR: sprite = 284;
pub const SPR_SSWY: sprite = 283;
pub const SPR_BSPR: sprite = 282;
pub const SPR_RSPR: sprite = 281;
pub const SPR_YSPR: sprite = 280;
pub const SPR_SPRB: sprite = 279;
pub const SPR_SPRR: sprite = 278;
pub const SPR_SPRY: sprite = 277;
pub const SPR_BLON: sprite = 276;
pub const SPR_BUMP: sprite = 275;
pub const SPR_STEM: sprite = 274;
pub const SPR_FANS: sprite = 273;
pub const SPR_FS02: sprite = 272;
pub const SPR_FS01: sprite = 271;
pub const SPR_FL16: sprite = 270;
pub const SPR_FL15: sprite = 269;
pub const SPR_FL14: sprite = 268;
pub const SPR_FL13: sprite = 267;
pub const SPR_FL12: sprite = 266;
pub const SPR_FL11: sprite = 265;
pub const SPR_FL10: sprite = 264;
pub const SPR_FL09: sprite = 263;
pub const SPR_FL08: sprite = 262;
pub const SPR_FL07: sprite = 261;
pub const SPR_FL06: sprite = 260;
pub const SPR_FL05: sprite = 259;
pub const SPR_FL04: sprite = 258;
pub const SPR_FL03: sprite = 257;
pub const SPR_FL02: sprite = 256;
pub const SPR_FL01: sprite = 255;
pub const SPR_FBUB: sprite = 254;
pub const SPR_GOAL: sprite = 253;
pub const SPR_SSPK: sprite = 252;
pub const SPR_IVSP: sprite = 251;
pub const SPR_ZAPS: sprite = 250;
pub const SPR_BUBS: sprite = 249;
pub const SPR_FIRS: sprite = 248;
pub const SPR_PITY: sprite = 247;
pub const SPR_FORC: sprite = 246;
pub const SPR_ELEM: sprite = 245;
pub const SPR_MAGN: sprite = 244;
pub const SPR_WIND: sprite = 243;
pub const SPR_ARMB: sprite = 242;
pub const SPR_ARMF: sprite = 241;
pub const SPR_ARMA: sprite = 240;
pub const SPR_DBAL: sprite = 239;
pub const SPR_STLG: sprite = 238;
pub const SPR_BSZ8: sprite = 237;
pub const SPR_BSZ7: sprite = 236;
pub const SPR_BSZ6: sprite = 235;
pub const SPR_BSZ5: sprite = 234;
pub const SPR_BST6: sprite = 233;
pub const SPR_BST5: sprite = 232;
pub const SPR_BST4: sprite = 231;
pub const SPR_BST3: sprite = 230;
pub const SPR_BST2: sprite = 229;
pub const SPR_BST1: sprite = 228;
pub const SPR_BSZ3: sprite = 227;
pub const SPR_BSZ2: sprite = 226;
pub const SPR_BSZ1: sprite = 225;
pub const SPR_CFLM: sprite = 224;
pub const SPR_RCRY: sprite = 223;
pub const SPR_BGAR: sprite = 222;
pub const SPR_HHZM: sprite = 221;
pub const SPR_SHRM: sprite = 220;
pub const SPR_HHPL: sprite = 219;
pub const SPR_PUMK: sprite = 218;
pub const SPR_ROSY: sprite = 217;
pub const SPR_FHZI: sprite = 216;
pub const SPR_XMS6: sprite = 215;
pub const SPR_XMS5: sprite = 214;
pub const SPR_XMS4: sprite = 213;
pub const SPR_XMS3: sprite = 212;
pub const SPR_XMS2: sprite = 211;
pub const SPR_XMS1: sprite = 210;
pub const SPR_WVIN: sprite = 209;
pub const SPR_TFLO: sprite = 208;
pub const SPR_JPLA: sprite = 207;
pub const SPR_LFAL: sprite = 206;
pub const SPR_DFLM: sprite = 205;
pub const SPR_FLME: sprite = 204;
pub const SPR_STEA: sprite = 203;
pub const SPR_TRAI: sprite = 202;
pub const SPR_TRAE: sprite = 201;
pub const SPR_SALD: sprite = 200;
pub const SPR_MCSP: sprite = 199;
pub const SPR_MCRT: sprite = 198;
pub const SPR_ADST: sprite = 197;
pub const SPR_TAZD: sprite = 196;
pub const SPR_REMT: sprite = 195;
pub const SPR_BARR: sprite = 194;
pub const SPR_OILF: sprite = 193;
pub const SPR_OILL: sprite = 192;
pub const SPR_WWS3: sprite = 191;
pub const SPR_WWS2: sprite = 190;
pub const SPR_WWSG: sprite = 189;
pub const SPR_CACT: sprite = 188;
pub const SPR_STBL: sprite = 187;
pub const SPR_BTBL: sprite = 186;
pub const SPR_CABR: sprite = 185;
pub const SPR_CBBS: sprite = 184;
pub const SPR_CSTA: sprite = 183;
pub const SPR_CFLG: sprite = 182;
pub const SPR_CTRC: sprite = 181;
pub const SPR_FLMH: sprite = 180;
pub const SPR_CNDL: sprite = 179;
pub const SPR_CEZB: sprite = 178;
pub const SPR_PINE: sprite = 177;
pub const SPR_BANR: sprite = 176;
pub const SPR_BFBR: sprite = 175;
pub const SPR_SFBR: sprite = 174;
pub const SPR_RSPB: sprite = 173;
pub const SPR_YSPB: sprite = 172;
pub const SPR_BMCE: sprite = 171;
pub const SPR_SMCE: sprite = 170;
pub const SPR_BMCH: sprite = 169;
pub const SPR_SMCH: sprite = 168;
pub const SPR_ESTA: sprite = 167;
pub const SPR_FLAM: sprite = 166;
pub const SPR_CHAN: sprite = 165;
pub const SPR_LIBE: sprite = 164;
pub const SPR_DSTG: sprite = 163;
pub const SPR_ALGB: sprite = 162;
pub const SPR_ALGA: sprite = 161;
pub const SPR_KELP: sprite = 160;
pub const SPR_BCRY: sprite = 159;
pub const SPR_CORL: sprite = 158;
pub const SPR_DRIP: sprite = 157;
pub const SPR_SEWE: sprite = 156;
pub const SPR_GARG: sprite = 155;
pub const SPR_ALRM: sprite = 154;
pub const SPR_THZT: sprite = 153;
pub const SPR_FWR6: sprite = 152;
pub const SPR_FWR5: sprite = 151;
pub const SPR_THZP: sprite = 150;
pub const SPR_TRE6: sprite = 149;
pub const SPR_TRE5: sprite = 148;
pub const SPR_TRE4: sprite = 147;
pub const SPR_TRE3: sprite = 146;
pub const SPR_TRE2: sprite = 145;
pub const SPR_TRE1: sprite = 144;
pub const SPR_BUS3: sprite = 143;
pub const SPR_BUS2: sprite = 142;
pub const SPR_BUS1: sprite = 141;
pub const SPR_FWR4: sprite = 140;
pub const SPR_FWR3: sprite = 139;
pub const SPR_FWR2: sprite = 138;
pub const SPR_FWR1: sprite = 137;
pub const SPR_TUPF: sprite = 136;
pub const SPR_TUPL: sprite = 135;
pub const SPR_LETR: sprite = 134;
pub const SPR_CFIR: sprite = 133;
pub const SPR_AROW: sprite = 132;
pub const SPR_CBLL: sprite = 131;
pub const SPR_TRLS: sprite = 130;
pub const SPR_JBUL: sprite = 129;
pub const SPR_MINE: sprite = 128;
pub const SPR_ENRG: sprite = 127;
pub const SPR_TORP: sprite = 126;
pub const SPR_LASF: sprite = 125;
pub const SPR_LASR: sprite = 124;
pub const SPR_MISL: sprite = 123;
pub const SPR_TVZP: sprite = 122;
pub const SPR_TVBB: sprite = 121;
pub const SPR_TVFL: sprite = 120;
pub const SPR_TVTK: sprite = 119;
pub const SPR_TV1K: sprite = 118;
pub const SPR_TVRC: sprite = 117;
pub const SPR_TVGV: sprite = 116;
pub const SPR_TVMY: sprite = 115;
pub const SPR_TVMX: sprite = 114;
pub const SPR_TVEG: sprite = 113;
pub const SPR_TV1P: sprite = 112;
pub const SPR_TV1U: sprite = 111;
pub const SPR_TVIV: sprite = 110;
pub const SPR_TVSS: sprite = 109;
pub const SPR_TVEL: sprite = 108;
pub const SPR_TVWW: sprite = 107;
pub const SPR_TVAR: sprite = 106;
pub const SPR_TVFO: sprite = 105;
pub const SPR_TVAT: sprite = 104;
pub const SPR_TVPI: sprite = 103;
pub const SPR_TVRI: sprite = 102;
pub const SPR_TBRI: sprite = 101;
pub const SPR_TRRI: sprite = 100;
pub const SPR_XLTV: sprite = 99;
pub const SPR_MSTV: sprite = 98;
pub const SPR_PUMI: sprite = 97;
pub const SPR_BMNE: sprite = 96;
pub const SPR_STPT: sprite = 95;
pub const SPR_WSPB: sprite = 94;
pub const SPR_WSPK: sprite = 93;
pub const SPR_USPK: sprite = 92;
pub const SPR_TFLM: sprite = 91;
pub const SPR_SFLM: sprite = 90;
pub const SPR_SPIK: sprite = 89;
pub const SPR_SIGN: sprite = 88;
pub const SPR_BBLS: sprite = 87;
pub const SPR_SHRD: sprite = 86;
pub const SPR_CEMG: sprite = 85;
pub const SPR_EMBM: sprite = 84;
pub const SPR_NSTR: sprite = 83;
pub const SPR_NCHP: sprite = 82;
pub const SPR_SPHR: sprite = 81;
pub const SPR_BFLG: sprite = 80;
pub const SPR_RFLG: sprite = 79;
pub const SPR_TOKE: sprite = 78;
pub const SPR_TRNG: sprite = 77;
pub const SPR_RING: sprite = 76;
pub const SPR_MSCB: sprite = 75;
pub const SPR_MSCF: sprite = 74;
pub const SPR_METL: sprite = 73;
pub const SPR_MNPL: sprite = 72;
pub const SPR_NPLM: sprite = 71;
pub const SPR_TARG: sprite = 70;
pub const SPR_ELEC: sprite = 69;
pub const SPR_RCKT: sprite = 68;
pub const SPR_EGGT: sprite = 67;
pub const SPR_BMSL: sprite = 66;
pub const SPR_BGOO: sprite = 65;
pub const SPR_BRAK: sprite = 64;
pub const SPR_EGGR: sprite = 63;
pub const SPR_BARD: sprite = 62;
pub const SPR_BARX: sprite = 61;
pub const SPR_FSGN: sprite = 60;
pub const SPR_FBOM: sprite = 59;
pub const SPR_PROJ: sprite = 58;
pub const SPR_VWRE: sprite = 57;
pub const SPR_WHAT: sprite = 56;
pub const SPR_BRKN: sprite = 55;
pub const SPR_FANG: sprite = 54;
pub const SPR_EGR1: sprite = 53;
pub const SPR_EFIR: sprite = 52;
pub const SPR_EGGP: sprite = 51;
pub const SPR_SHCK: sprite = 50;
pub const SPR_FAKE: sprite = 49;
pub const SPR_SEBH: sprite = 48;
pub const SPR_EGGO: sprite = 47;
pub const SPR_GOOP: sprite = 46;
pub const SPR_TANK: sprite = 45;
pub const SPR_EGGN: sprite = 44;
pub const SPR_EGLZ: sprite = 43;
pub const SPR_EGGM: sprite = 42;
pub const SPR_JETF: sprite = 41;
pub const SPR_DRAB: sprite = 40;
pub const SPR_PTER: sprite = 39;
pub const SPR_PYRE: sprite = 38;
pub const SPR_CANG: sprite = 37;
pub const SPR_CANA: sprite = 36;
pub const SPR_UNID: sprite = 35;
pub const SPR_SSHL: sprite = 34;
pub const SPR_MNUD: sprite = 33;
pub const SPR_MNUS: sprite = 32;
pub const SPR_GSNH: sprite = 31;
pub const SPR_GSNL: sprite = 30;
pub const SPR_GSNP: sprite = 29;
pub const SPR_ESHI: sprite = 28;
pub const SPR_SPSH: sprite = 27;
pub const SPR_STAB: sprite = 26;
pub const SPR_CBFS: sprite = 25;
pub const SPR_ARCH: sprite = 24;
pub const SPR_PNTY: sprite = 23;
pub const SPR_VLTR: sprite = 22;
pub const SPR_SNLR: sprite = 21;
pub const SPR_JJAW: sprite = 20;
pub const SPR_CSPR: sprite = 19;
pub const SPR_CR2B: sprite = 18;
pub const SPR_CRAB: sprite = 17;
pub const SPR_SHRP: sprite = 16;
pub const SPR_TURR: sprite = 15;
pub const SPR_TRET: sprite = 14;
pub const SPR_SKIM: sprite = 13;
pub const SPR_DETN: sprite = 12;
pub const SPR_CCOM: sprite = 11;
pub const SPR_JETG: sprite = 10;
pub const SPR_JETB: sprite = 9;
pub const SPR_RBUZ: sprite = 8;
pub const SPR_BUZZ: sprite = 7;
pub const SPR_FISH: sprite = 6;
pub const SPR_SPOS: sprite = 5;
pub const SPR_POSS: sprite = 4;
pub const SPR_PLAY: sprite = 3;
pub const SPR_THOK: sprite = 2;
pub const SPR_UNKN: sprite = 1;
pub const SPR_NULL: sprite = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ffloor_s {
    pub topheight: *mut fixed_t,
    pub toppic: *mut int32_t,
    pub toplightlevel: *mut int16_t,
    pub topxoffs: *mut fixed_t,
    pub topyoffs: *mut fixed_t,
    pub topangle: *mut angle_t,
    pub bottomheight: *mut fixed_t,
    pub bottompic: *mut int32_t,
    pub bottomxoffs: *mut fixed_t,
    pub bottomyoffs: *mut fixed_t,
    pub bottomangle: *mut angle_t,
    pub t_slope: *mut *mut pslope_s,
    pub b_slope: *mut *mut pslope_s,
    pub secnum: size_t,
    pub fofflags: ffloortype_e,
    pub master: *mut line_s,
    pub target: *mut sector_s,
    pub next: *mut ffloor_s,
    pub prev: *mut ffloor_s,
    pub lastlight: int32_t,
    pub alpha: int32_t,
    pub blend: uint8_t,
    pub norender: tic_t,
    pub bustflags: ffloorbustflags_e,
    pub busttype: uint8_t,
    pub busttag: int16_t,
    pub sinkspeed: fixed_t,
    pub friction: fixed_t,
    pub bouncestrength: fixed_t,
    pub spawnflags: ffloortype_e,
    pub spawnalpha: int32_t,
    pub fadingdata: *mut libc::c_void,
}
pub type ffloortype_e = libc::c_uint;
pub const FOF_SPLAT: ffloortype_e = 1073741824;
pub const FOF_BOUNCY: ffloortype_e = 536870912;
pub const FOF_COLORMAPONLY: ffloortype_e = 268435456;
pub const FOF_RIPPLE: ffloortype_e = 134217728;
pub const FOF_INTANGIBLEFLATS: ffloortype_e = 100663296;
pub const FOF_REVERSEPLATFORM: ffloortype_e = 67108864;
pub const FOF_PLATFORM: ffloortype_e = 33554432;
pub const FOF_QUICKSAND: ffloortype_e = 16777216;
pub const FOF_BUSTUP: ffloortype_e = 8388608;
pub const FOF_MARIO: ffloortype_e = 4194304;
pub const FOF_GOOWATER: ffloortype_e = 2097152;
pub const FOF_CRUMBLE: ffloortype_e = 1048576;
pub const FOF_NORETURN: ffloortype_e = 524288;
pub const FOF_FLOATBOB: ffloortype_e = 262144;
pub const FOF_DOUBLESHADOW: ffloortype_e = 131072;
pub const FOF_INVERTSIDES: ffloortype_e = 65536;
pub const FOF_ALLSIDES: ffloortype_e = 32768;
pub const FOF_INVERTPLANES: ffloortype_e = 16384;
pub const FOF_FOG: ffloortype_e = 8192;
pub const FOF_TRANSLUCENT: ffloortype_e = 4096;
pub const FOF_EXTRA: ffloortype_e = 2048;
pub const FOF_BOTHPLANES: ffloortype_e = 1024;
pub const FOF_CUTSPRITES: ffloortype_e = 512;
pub const FOF_CUTLEVEL: ffloortype_e = 384;
pub const FOF_CUTEXTRA: ffloortype_e = 256;
pub const FOF_CUTSOLIDS: ffloortype_e = 128;
pub const FOF_NOSHADE: ffloortype_e = 64;
pub const FOF_SWIMMABLE: ffloortype_e = 32;
pub const FOF_RENDERALL: ffloortype_e = 24;
pub const FOF_RENDERPLANES: ffloortype_e = 16;
pub const FOF_RENDERSIDES: ffloortype_e = 8;
pub const FOF_SOLID: ffloortype_e = 6;
pub const FOF_BLOCKOTHERS: ffloortype_e = 4;
pub const FOF_BLOCKPLAYER: ffloortype_e = 2;
pub const FOF_EXISTS: ffloortype_e = 1;
pub type ffloorbustflags_e = libc::c_uint;
pub const FB_ONLYBOTTOM: ffloorbustflags_e = 4;
pub const FB_EXECUTOR: ffloorbustflags_e = 2;
pub const FB_PUSHABLES: ffloorbustflags_e = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sector_s {
    pub floorheight: fixed_t,
    pub ceilingheight: fixed_t,
    pub floorpic: int32_t,
    pub ceilingpic: int32_t,
    pub lightlevel: int16_t,
    pub special: int16_t,
    pub tags: taglist_t,
    pub soundorg: degenmobj_t,
    pub validcount: size_t,
    pub thinglist: *mut mobj_t,
    pub floordata: *mut libc::c_void,
    pub ceilingdata: *mut libc::c_void,
    pub lightingdata: *mut libc::c_void,
    pub fadecolormapdata: *mut libc::c_void,
    pub floorxoffset: fixed_t,
    pub flooryoffset: fixed_t,
    pub ceilingxoffset: fixed_t,
    pub ceilingyoffset: fixed_t,
    pub floorangle: angle_t,
    pub ceilingangle: angle_t,
    pub heightsec: int32_t,
    pub camsec: int32_t,
    pub floorlightlevel: int16_t,
    pub ceilinglightlevel: int16_t,
    pub floorlightabsolute: boolean,
    pub ceilinglightabsolute: boolean,
    pub floorlightsec: int32_t,
    pub ceilinglightsec: int32_t,
    pub crumblestate: int32_t,
    pub touching_thinglist: *mut msecnode_s,
    pub linecount: size_t,
    pub lines: *mut *mut line_s,
    pub ffloors: *mut ffloor_t,
    pub attached: *mut size_t,
    pub attachedsolid: *mut boolean,
    pub numattached: size_t,
    pub maxattached: size_t,
    pub lightlist: *mut lightlist_t,
    pub numlights: int32_t,
    pub moved: boolean,
    pub extra_colormap: *mut extracolormap_t,
    pub colormap_protected: boolean,
    pub gravity: fixed_t,
    pub gravityptr: *mut fixed_t,
    pub flags: sectorflags_t,
    pub specialflags: sectorspecialflags_t,
    pub damagetype: uint8_t,
    pub triggertag: mtag_t,
    pub triggerer: uint8_t,
    pub friction: fixed_t,
    pub cullheight: *mut line_s,
    pub floorspeed: fixed_t,
    pub ceilspeed: fixed_t,
    pub preciplist: *mut precipmobj_t,
    pub touching_preciplist: *mut mprecipsecnode_s,
    pub f_slope: *mut pslope_t,
    pub c_slope: *mut pslope_t,
    pub hasslope: boolean,
    pub spawn_lightlevel: int16_t,
    pub spawn_extra_colormap: *mut extracolormap_t,
}
pub type extracolormap_t = extracolormap_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct extracolormap_s {
    pub fadestart: uint8_t,
    pub fadeend: uint8_t,
    pub flags: uint8_t,
    pub rgba: int32_t,
    pub fadergba: int32_t,
    pub colormap: *mut lighttable_t,
    pub next: *mut extracolormap_s,
    pub prev: *mut extracolormap_s,
}
pub type lighttable_t = uint8_t;
pub type pslope_t = pslope_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mprecipsecnode_s {
    pub m_sector: *mut sector_t,
    pub m_thing: *mut precipmobj_s,
    pub m_sectorlist_prev: *mut mprecipsecnode_s,
    pub m_sectorlist_next: *mut mprecipsecnode_s,
    pub m_thinglist_prev: *mut mprecipsecnode_s,
    pub m_thinglist_next: *mut mprecipsecnode_s,
    pub visited: boolean,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct precipmobj_s {
    pub thinker: thinker_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub old_x: fixed_t,
    pub old_y: fixed_t,
    pub old_z: fixed_t,
    pub old_x2: fixed_t,
    pub old_y2: fixed_t,
    pub old_z2: fixed_t,
    pub snext: *mut precipmobj_s,
    pub sprev: *mut *mut precipmobj_s,
    pub angle: angle_t,
    pub pitch: angle_t,
    pub roll: angle_t,
    pub old_angle: angle_t,
    pub old_pitch: angle_t,
    pub old_roll: angle_t,
    pub old_angle2: angle_t,
    pub old_pitch2: angle_t,
    pub old_roll2: angle_t,
    pub spriteroll: angle_t,
    pub old_spriteroll: angle_t,
    pub old_spriteroll2: angle_t,
    pub sprite: spritenum_t,
    pub frame: uint32_t,
    pub sprite2: uint8_t,
    pub anim_duration: uint16_t,
    pub renderflags: uint32_t,
    pub blendmode: int32_t,
    pub spritexscale: fixed_t,
    pub spriteyscale: fixed_t,
    pub spritexoffset: fixed_t,
    pub spriteyoffset: fixed_t,
    pub old_spritexscale: fixed_t,
    pub old_spriteyscale: fixed_t,
    pub old_spritexoffset: fixed_t,
    pub old_spriteyoffset: fixed_t,
    pub floorspriteslope: *mut pslope_s,
    pub touching_sectorlist: *mut mprecipsecnode_s,
    pub subsector: *mut subsector_s,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
    pub floorrover: *mut ffloor_s,
    pub ceilingrover: *mut ffloor_s,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub momx: fixed_t,
    pub momy: fixed_t,
    pub momz: fixed_t,
    pub precipflags: fixed_t,
    pub tics: int32_t,
    pub state: *mut state_t,
    pub flags: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct subsector_s {
    pub sector: *mut sector_t,
    pub numlines: int16_t,
    pub firstline: uint32_t,
    pub polyList: *mut polyobj_s,
    pub validcount: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct polyobj_s {
    pub link: mdllistitem_t,
    pub id: int32_t,
    pub first: int32_t,
    pub next: int32_t,
    pub parent: int32_t,
    pub segCount: size_t,
    pub numSegsAlloc: size_t,
    pub segs: *mut *mut seg_s,
    pub numVertices: size_t,
    pub numVerticesAlloc: size_t,
    pub origVerts: *mut vertex_t,
    pub tmpVerts: *mut vertex_t,
    pub vertices: *mut *mut vertex_t,
    pub numLines: size_t,
    pub numLinesAlloc: size_t,
    pub lines: *mut *mut line_s,
    pub spawnSpot: degenmobj_t,
    pub centerPt: vertex_t,
    pub zdist: fixed_t,
    pub angle: angle_t,
    pub attached: uint8_t,
    pub blockbox: [fixed_t; 4],
    pub linked: uint8_t,
    pub validcount: size_t,
    pub damage: int32_t,
    pub thrust: fixed_t,
    pub flags: int32_t,
    pub thinker: *mut thinker_t,
    pub isBad: uint8_t,
    pub translucency: int32_t,
    pub triggertag: int16_t,
    pub visplane: *mut visplane_s,
    pub spawnflags: int32_t,
    pub spawntrans: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct visplane_s {
    pub next: *mut visplane_s,
    pub height: fixed_t,
    pub viewx: fixed_t,
    pub viewy: fixed_t,
    pub viewz: fixed_t,
    pub viewangle: angle_t,
    pub plangle: angle_t,
    pub picnum: int32_t,
    pub lightlevel: int32_t,
    pub minx: int32_t,
    pub maxx: int32_t,
    pub extra_colormap: *mut extracolormap_t,
    pub padtopstart: uint16_t,
    pub top: [uint16_t; 1920],
    pub padtopend: uint16_t,
    pub padbottomstart: uint16_t,
    pub bottom: [uint16_t; 1920],
    pub padbottomend: uint16_t,
    pub high: int32_t,
    pub low: int32_t,
    pub xoffs: fixed_t,
    pub yoffs: fixed_t,
    pub ffloor: *mut ffloor_s,
    pub polyobj: *mut polyobj_t,
    pub slope: *mut pslope_t,
}
pub type polyobj_t = polyobj_s;
pub type thinker_t = thinker_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct thinker_s {
    pub prev: *mut thinker_s,
    pub next: *mut thinker_s,
    pub function: think_t,
    pub references: int32_t,
}
pub type think_t = actionf_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vertex_t {
    pub x: fixed_t,
    pub y: fixed_t,
    pub floorzset: boolean,
    pub ceilingzset: boolean,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct degenmobj_t {
    pub thinker: thinker_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct line_s {
    pub v1: *mut vertex_t,
    pub v2: *mut vertex_t,
    pub dx: fixed_t,
    pub dy: fixed_t,
    pub angle: angle_t,
    pub flags: int16_t,
    pub special: int16_t,
    pub tags: taglist_t,
    pub args: [int32_t; 10],
    pub stringargs: [*mut libc::c_char; 2],
    pub sidenum: [uint16_t; 2],
    pub alpha: fixed_t,
    pub blendmode: uint8_t,
    pub executordelay: int32_t,
    pub bbox: [fixed_t; 4],
    pub slopetype: slopetype_t,
    pub frontsector: *mut sector_t,
    pub backsector: *mut sector_t,
    pub validcount: size_t,
    pub polyobj: *mut polyobj_t,
    pub callcount: int16_t,
}
pub type sector_t = sector_s;
pub type slopetype_t = libc::c_uint;
pub const ST_NEGATIVE: slopetype_t = 3;
pub const ST_POSITIVE: slopetype_t = 2;
pub const ST_VERTICAL: slopetype_t = 1;
pub const ST_HORIZONTAL: slopetype_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct seg_s {
    pub v1: *mut vertex_t,
    pub v2: *mut vertex_t,
    pub side: int32_t,
    pub offset: fixed_t,
    pub angle: angle_t,
    pub sidedef: *mut side_t,
    pub linedef: *mut line_t,
    pub frontsector: *mut sector_t,
    pub backsector: *mut sector_t,
    pub length: fixed_t,
    pub numlights: size_t,
    pub rlights: *mut r_lightlist_t,
    pub polyseg: *mut polyobj_t,
    pub dontrenderme: boolean,
    pub glseg: boolean,
}
pub type r_lightlist_t = r_lightlist_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct r_lightlist_s {
    pub height: fixed_t,
    pub heightstep: fixed_t,
    pub botheight: fixed_t,
    pub botheightstep: fixed_t,
    pub startheight: fixed_t,
    pub lightlevel: int16_t,
    pub extra_colormap: *mut extracolormap_t,
    pub rcolormap: *mut lighttable_t,
    pub flags: ffloortype_e,
    pub lightnum: int32_t,
}
pub type line_t = line_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct side_t {
    pub textureoffset: fixed_t,
    pub rowoffset: fixed_t,
    pub offsetx_top: fixed_t,
    pub offsetx_mid: fixed_t,
    pub offsetx_bot: fixed_t,
    pub offsety_top: fixed_t,
    pub offsety_mid: fixed_t,
    pub offsety_bot: fixed_t,
    pub toptexture: int32_t,
    pub bottomtexture: int32_t,
    pub midtexture: int32_t,
    pub line: *mut line_t,
    pub sector: *mut sector_t,
    pub special: int16_t,
    pub repeatcnt: int16_t,
    pub colormap_data: *mut extracolormap_t,
}
pub type mdllistitem_t = mdllistitem_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mdllistitem_s {
    pub next: *mut mdllistitem_s,
    pub prev: *mut *mut mdllistitem_s,
}
pub type precipmobj_t = precipmobj_s;
pub type sectorspecialflags_t = libc::c_uint;
pub const SSF_GRAVITYOVERRIDE: sectorspecialflags_t = 1048576;
pub const SSF_JUMPFLIP: sectorspecialflags_t = 524288;
pub const SSF_ROPEHANG: sectorspecialflags_t = 262144;
pub const SSF_FINISHLINE: sectorspecialflags_t = 131072;
pub const SSF_ZOOMTUBEEND: sectorspecialflags_t = 65536;
pub const SSF_ZOOMTUBESTART: sectorspecialflags_t = 32768;
pub const SSF_FORCESPIN: sectorspecialflags_t = 16384;
pub const SSF_SUPERTRANSFORM: sectorspecialflags_t = 8192;
pub const SSF_FAN: sectorspecialflags_t = 4096;
pub const SSF_BLUETEAMBASE: sectorspecialflags_t = 2048;
pub const SSF_REDTEAMBASE: sectorspecialflags_t = 1024;
pub const SSF_RETURNFLAG: sectorspecialflags_t = 512;
pub const SSF_SPECIALSTAGEPIT: sectorspecialflags_t = 256;
pub const SSF_EXIT: sectorspecialflags_t = 128;
pub const SSF_STARPOSTACTIVATOR: sectorspecialflags_t = 64;
pub const SSF_SPEEDPAD: sectorspecialflags_t = 32;
pub const SSF_CONVEYOR: sectorspecialflags_t = 16;
pub const SSF_WINDCURRENT: sectorspecialflags_t = 8;
pub const SSF_NOSTEPDOWN: sectorspecialflags_t = 4;
pub const SSF_DOUBLESTEPUP: sectorspecialflags_t = 2;
pub const SSF_OUTERSPACE: sectorspecialflags_t = 1;
pub type sectorflags_t = libc::c_uint;
pub const MSF_NOCLIPCAMERA: sectorflags_t = 512;
pub const MSF_HEATWAVE: sectorflags_t = 256;
pub const MSF_GRAVITYFLIP: sectorflags_t = 128;
pub const MSF_INVERTPRECIP: sectorflags_t = 64;
pub const MSF_TRIGGERLINE_MOBJ: sectorflags_t = 32;
pub const MSF_TRIGGERLINE_PLANE: sectorflags_t = 16;
pub const MSF_TRIGGERSPECIAL_HEADBUMP: sectorflags_t = 8;
pub const MSF_TRIGGERSPECIAL_TOUCH: sectorflags_t = 4;
pub const MSF_FLIPSPECIAL_BOTH: sectorflags_t = 3;
pub const MSF_FLIPSPECIAL_CEILING: sectorflags_t = 2;
pub const MSF_FLIPSPECIAL_FLOOR: sectorflags_t = 1;
pub type lightlist_t = lightlist_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lightlist_s {
    pub height: fixed_t,
    pub lightlevel: *mut int16_t,
    pub extra_colormap: *mut *mut extracolormap_t,
    pub flags: int32_t,
    pub caster: *mut ffloor_t,
    pub slope: *mut pslope_s,
}
pub type ffloor_t = ffloor_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct msecnode_s {
    pub m_sector: *mut sector_t,
    pub m_thing: *mut mobj_s,
    pub m_sectorlist_prev: *mut msecnode_s,
    pub m_sectorlist_next: *mut msecnode_s,
    pub m_thinglist_prev: *mut msecnode_s,
    pub m_thinglist_next: *mut msecnode_s,
    pub visited: boolean,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sfxinfo_struct {
    pub name: *const libc::c_char,
    pub singularity: boolean,
    pub priority: int32_t,
    pub pitch: int32_t,
    pub volume: int32_t,
    pub data: *mut libc::c_void,
    pub length: size_t,
    pub skinsound: int32_t,
    pub usefulness: int32_t,
    pub lumpnum: lumpnum_t,
    pub caption: [libc::c_char; 32],
}
pub type sfxinfo_t = sfxinfo_struct;
pub type playersprite = libc::c_uint;
pub const NUMPLAYERSPRITES: playersprite = 128;
pub const SPR2_LASTFREESLOT: playersprite = 127;
pub const SPR2_FIRSTFREESLOT: playersprite = 60;
pub const SPR2_XTRA: playersprite = 59;
pub const SPR2_LIFE: playersprite = 58;
pub const SPR2_SIGN: playersprite = 57;
pub const SPR2_CNT4: playersprite = 56;
pub const SPR2_CNT3: playersprite = 55;
pub const SPR2_CNT2: playersprite = 54;
pub const SPR2_CNT1: playersprite = 53;
pub const SPR2_TALC: playersprite = 52;
pub const SPR2_TALB: playersprite = 51;
pub const SPR2_TALA: playersprite = 50;
pub const SPR2_TAL9: playersprite = 49;
pub const SPR2_TAL8: playersprite = 48;
pub const SPR2_TAL7: playersprite = 47;
pub const SPR2_TAL6: playersprite = 46;
pub const SPR2_TAL5: playersprite = 45;
pub const SPR2_TAL4: playersprite = 44;
pub const SPR2_TAL3: playersprite = 43;
pub const SPR2_TAL2: playersprite = 42;
pub const SPR2_TAL1: playersprite = 41;
pub const SPR2_TAL0: playersprite = 40;
pub const SPR2_NATK: playersprite = 39;
pub const SPR2_NPUL: playersprite = 38;
pub const SPR2_NSTN: playersprite = 37;
pub const SPR2_NDRL: playersprite = 36;
pub const SPR2_NFLY: playersprite = 35;
pub const SPR2_NFLT: playersprite = 34;
pub const SPR2_NSTD: playersprite = 33;
pub const SPR2_TRNS: playersprite = 32;
pub const SPR2_MLEL: playersprite = 31;
pub const SPR2_MLEE: playersprite = 30;
pub const SPR2_TWIN: playersprite = 29;
pub const SPR2_FIRE: playersprite = 28;
pub const SPR2_BNCE: playersprite = 27;
pub const SPR2_FRUN: playersprite = 26;
pub const SPR2_FLT: playersprite = 25;
pub const SPR2_CLMB: playersprite = 24;
pub const SPR2_CLNG: playersprite = 23;
pub const SPR2_LAND: playersprite = 22;
pub const SPR2_GLID: playersprite = 21;
pub const SPR2_TIRE: playersprite = 20;
pub const SPR2_SWIM: playersprite = 19;
pub const SPR2_FLY: playersprite = 18;
pub const SPR2_SPIN: playersprite = 17;
pub const SPR2_RIDE: playersprite = 16;
pub const SPR2_EDGE: playersprite = 15;
pub const SPR2_FALL: playersprite = 14;
pub const SPR2_SPNG: playersprite = 13;
pub const SPR2_JUMP: playersprite = 12;
pub const SPR2_GASP: playersprite = 11;
pub const SPR2_ROLL: playersprite = 10;
pub const SPR2_DRWN: playersprite = 9;
pub const SPR2_DEAD: playersprite = 8;
pub const SPR2_STUN: playersprite = 7;
pub const SPR2_PAIN: playersprite = 6;
pub const SPR2_DASH: playersprite = 5;
pub const SPR2_RUN: playersprite = 4;
pub const SPR2_SKID: playersprite = 3;
pub const SPR2_WALK: playersprite = 2;
pub const SPR2_WAIT: playersprite = 1;
pub const SPR2_STND: playersprite = 0;
pub type skinflags_t = libc::c_uint;
pub const SF_NOSHIELDABILITY: skinflags_t = 524288;
pub const SF_CANBUSTWALLS: skinflags_t = 262144;
pub const SF_NOSUPERJUMPBOOST: skinflags_t = 131072;
pub const SF_NOSUPERSPRITES: skinflags_t = 65536;
pub const SF_NONIGHTSSUPER: skinflags_t = 32768;
pub const SF_NONIGHTSROTATION: skinflags_t = 16384;
pub const SF_MULTIABILITY: skinflags_t = 8192;
pub const SF_FASTEDGE: skinflags_t = 4096;
pub const SF_DASHMODE: skinflags_t = 2048;
pub const SF_MACHINE: skinflags_t = 1024;
pub const SF_MARIODAMAGE: skinflags_t = 768;
pub const SF_STOMPDAMAGE: skinflags_t = 512;
pub const SF_NOJUMPDAMAGE: skinflags_t = 256;
pub const SF_NOJUMPSPIN: skinflags_t = 128;
pub const SF_RUNONWATER: skinflags_t = 64;
pub const SF_NOSPEEDADJUST: skinflags_t = 32;
pub const SF_NOSKID: skinflags_t = 16;
pub const SF_HIRES: skinflags_t = 8;
pub const SF_NOSPINDASHDUST: skinflags_t = 4;
pub const SF_NOSUPERSPIN: skinflags_t = 2;
pub const SF_SUPER: skinflags_t = 1;
pub type player_t = player_s;
pub type marathonmode_t = libc::c_uint;
pub const MA_INGAME: marathonmode_t = 8;
pub const MA_NOCUTSCENES: marathonmode_t = 4;
pub const MA_INIT: marathonmode_t = 2;
pub const MA_RUNNING: marathonmode_t = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nightsgrades_t {
    pub grade: [uint32_t; 6],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct customoption_t {
    pub option: [libc::c_char; 32],
    pub value: [libc::c_char; 256],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mapheader_t {
    pub lvlttl: [libc::c_char; 22],
    pub subttl: [libc::c_char; 33],
    pub actnum: uint8_t,
    pub typeoflevel: uint32_t,
    pub nextlevel: int16_t,
    pub marathonnext: int16_t,
    pub keywords: [libc::c_char; 33],
    pub musname: [libc::c_char; 7],
    pub mustrack: uint16_t,
    pub muspos: uint32_t,
    pub forcecharacter: [libc::c_char; 17],
    pub weather: uint8_t,
    pub skynum: int16_t,
    pub skybox_scalex: int16_t,
    pub skybox_scaley: int16_t,
    pub skybox_scalez: int16_t,
    pub interscreen: [libc::c_char; 8],
    pub runsoc: [libc::c_char; 33],
    pub scriptname: [libc::c_char; 33],
    pub precutscenenum: uint8_t,
    pub cutscenenum: uint8_t,
    pub countdown: int16_t,
    pub palette: uint16_t,
    pub numlaps: uint8_t,
    pub unlockrequired: int8_t,
    pub levelselect: uint8_t,
    pub bonustype: int8_t,
    pub maxbonuslives: int8_t,
    pub levelflags: uint16_t,
    pub menuflags: uint8_t,
    pub selectheading: [libc::c_char; 22],
    pub startrings: uint16_t,
    pub sstimer: int32_t,
    pub ssspheres: uint32_t,
    pub gravity: fixed_t,
    pub ltzzpatch: [libc::c_char; 9],
    pub ltzztext: [libc::c_char; 9],
    pub ltactdiamond: [libc::c_char; 9],
    pub numFlickies: uint8_t,
    pub flickies: *mut mobjtype_t,
    pub numGradedMares: uint8_t,
    pub grades: *mut nightsgrades_t,
    pub musinterfadeout: uint32_t,
    pub musintername: [libc::c_char; 7],
    pub muspostbossname: [libc::c_char; 7],
    pub muspostbosstrack: uint16_t,
    pub muspostbosspos: uint32_t,
    pub muspostbossfadein: uint32_t,
    pub musforcereset: int8_t,
    pub numCustomOptions: uint8_t,
    pub customopts: *mut customoption_t,
}
pub type GameType = libc::c_uint;
pub const NUMGAMETYPES: GameType = 136;
pub const GT_LASTFREESLOT: GameType = 135;
pub const GT_FIRSTFREESLOT: GameType = 8;
pub const GT_CTF: GameType = 7;
pub const GT_HIDEANDSEEK: GameType = 6;
pub const GT_TAG: GameType = 5;
pub const GT_TEAMMATCH: GameType = 4;
pub const GT_MATCH: GameType = 3;
pub const GT_RACE: GameType = 2;
pub const GT_COMPETITION: GameType = 1;
pub const GT_COOP: GameType = 0;
pub type TypeOfLevel = libc::c_uint;
pub const TOL_XMAS: TypeOfLevel = 4096;
pub const TOL_ERZ3: TypeOfLevel = 2048;
pub const TOL_NIGHTS: TypeOfLevel = 1024;
pub const TOL_MARIO: TypeOfLevel = 512;
pub const TOL_2D: TypeOfLevel = 256;
pub const TOL_CTF: TypeOfLevel = 64;
pub const TOL_TAG: TypeOfLevel = 32;
pub const TOL_MATCH: TypeOfLevel = 16;
pub const TOL_RACE: TypeOfLevel = 8;
pub const TOL_COMPETITION: TypeOfLevel = 4;
pub const TOL_COOP: TypeOfLevel = 2;
pub const TOL_SP: TypeOfLevel = 1;
pub type com_flags_t = libc::c_uint;
pub const COM_LUA: com_flags_t = 8;
pub const COM_LOCAL: com_flags_t = 4;
pub const COM_SPLITSCREEN: com_flags_t = 2;
pub const COM_ADMIN: com_flags_t = 1;
pub type com_func_t = Option::<unsafe extern "C" fn() -> ()>;
pub type C2RustUnnamed_0 = libc::c_uint;
pub const CV_ALLOWLUA: C2RustUnnamed_0 = 4096;
pub const CV_CHEAT: C2RustUnnamed_0 = 2048;
pub const CV_HIDEN: C2RustUnnamed_0 = 1024;
pub const CV_NOSHOWHELP: C2RustUnnamed_0 = 512;
pub const CV_SHOWMODIFONETIME: C2RustUnnamed_0 = 256;
pub const CV_SHOWMODIF: C2RustUnnamed_0 = 128;
pub const CV_MODIFIED: C2RustUnnamed_0 = 64;
pub const CV_NOTINNET: C2RustUnnamed_0 = 32;
pub const CV_FLOAT: C2RustUnnamed_0 = 16;
pub const CV_NOINIT: C2RustUnnamed_0 = 8;
pub const CV_NETVAR: C2RustUnnamed_0 = 4;
pub const CV_CALL: C2RustUnnamed_0 = 2;
pub const CV_SAVE: C2RustUnnamed_0 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CV_PossibleValue_s {
    pub value: int32_t,
    pub strvalue: *const libc::c_char,
}
pub type CV_PossibleValue_t = CV_PossibleValue_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct consvar_s {
    pub name: *const libc::c_char,
    pub defaultvalue: *const libc::c_char,
    pub flags: int32_t,
    pub PossibleValue: *mut CV_PossibleValue_t,
    pub func: Option::<unsafe extern "C" fn() -> ()>,
    pub value: int32_t,
    pub string: *const libc::c_char,
    pub zstring: *mut libc::c_char,
    pub revert: C2RustUnnamed_1,
    pub netid: uint16_t,
    pub changed: libc::c_char,
    pub next: *mut consvar_s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub allocated: libc::c_char,
    pub v: C2RustUnnamed_2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_2 {
    pub string: *mut libc::c_char,
    pub const_munge: *const libc::c_char,
}
pub type consvar_t = consvar_s;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union msg_header_t {
    pub buffer: [libc::c_char; 16],
    pub signature: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct msg_rooms_t {
    pub header: msg_header_t,
    pub id: int32_t,
    pub name: [libc::c_char; 32],
    pub motd: [libc::c_char; 255],
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct serverinfo_pak {
    pub _255: uint8_t,
    pub packetversion: uint8_t,
    pub application: [libc::c_char; 16],
    pub version: uint8_t,
    pub subversion: uint8_t,
    pub numberofplayer: uint8_t,
    pub maxplayer: uint8_t,
    pub refusereason: uint8_t,
    pub gametypename: [libc::c_char; 24],
    pub modifiedgame: uint8_t,
    pub cheatsenabled: uint8_t,
    pub flags: uint8_t,
    pub fileneedednum: uint8_t,
    pub time: tic_t,
    pub leveltime: tic_t,
    pub servername: [libc::c_char; 32],
    pub mapname: [libc::c_char; 8],
    pub maptitle: [libc::c_char; 33],
    pub mapmd5: [libc::c_uchar; 16],
    pub actnum: uint8_t,
    pub iszone: uint8_t,
    pub fileneeded: [uint8_t; 915],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct serverelem_t {
    pub node: int8_t,
    pub info: serverinfo_pak,
}
pub type evtype_t = libc::c_uint;
pub const ev_joystick2: evtype_t = 6;
pub const ev_mouse2: evtype_t = 5;
pub const ev_joystick: evtype_t = 4;
pub const ev_mouse: evtype_t = 3;
pub const ev_console: evtype_t = 2;
pub const ev_keyup: evtype_t = 1;
pub const ev_keydown: evtype_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct event_t {
    pub type_0: evtype_t,
    pub key: int32_t,
    pub x: int32_t,
    pub y: int32_t,
    pub repeated: boolean,
}
pub type ttmode_enum = libc::c_uint;
pub const TTMODE_USER: ttmode_enum = 3;
pub const TTMODE_ALACROIX: ttmode_enum = 2;
pub const TTMODE_OLD: ttmode_enum = 1;
pub const TTMODE_NONE: ttmode_enum = 0;
pub type C2RustUnnamed_3 = libc::c_uint;
pub const TITLEMAP_RUNNING: C2RustUnnamed_3 = 2;
pub const TITLEMAP_LOADING: C2RustUnnamed_3 = 1;
pub const TITLEMAP_OFF: C2RustUnnamed_3 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct viddef_s {
    pub modenum: int32_t,
    pub buffer: *mut uint8_t,
    pub rowbytes: size_t,
    pub width: int32_t,
    pub height: int32_t,
    pub u: C2RustUnnamed_4,
    pub recalc: int32_t,
    pub direct: *mut uint8_t,
    pub dupx: int32_t,
    pub dupy: int32_t,
    pub fdupx: int32_t,
    pub fdupy: int32_t,
    pub bpp: int32_t,
    pub baseratio: int32_t,
    pub WndParent: *mut libc::c_void,
    pub smalldupx: uint8_t,
    pub smalldupy: uint8_t,
    pub meddupx: uint8_t,
    pub meddupy: uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_4 {
    pub numpages: int32_t,
    pub windowed: int32_t,
}
pub type viddef_t = viddef_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rotsprite_t {
    pub angles: int32_t,
    pub patches: *mut *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct patch_t {
    pub width: int16_t,
    pub height: int16_t,
    pub leftoffset: int16_t,
    pub topoffset: int16_t,
    pub columnofs: *mut int32_t,
    pub columns: *mut uint8_t,
    pub hardware: *mut libc::c_void,
    pub flats: [*mut libc::c_void; 4],
    pub rotated: *mut rotsprite_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct pic_t {
    pub width: int16_t,
    pub zero: uint8_t,
    pub mode: uint8_t,
    pub height: int16_t,
    pub reserved1: int16_t,
    pub data: [uint8_t; 0],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spriteframe_t {
    pub rotate: uint8_t,
    pub lumppat: [lumpnum_t; 16],
    pub lumpid: [size_t; 16],
    pub flip: uint16_t,
    pub rotated: [[*mut rotsprite_t; 16]; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spritedef_t {
    pub numframes: size_t,
    pub spriteframes: *mut spriteframe_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spriteframepivot_t {
    pub x: int32_t,
    pub y: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spriteinfo_t {
    pub pivot: [spriteframepivot_t; 64],
    pub available: boolean,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct camera_s {
    pub chase: boolean,
    pub aiming: angle_t,
    pub viewheight: fixed_t,
    pub startangle: angle_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub reset: boolean,
    pub angle: angle_t,
    pub subsector: *mut subsector_s,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub relativex: fixed_t,
    pub momx: fixed_t,
    pub momy: fixed_t,
    pub momz: fixed_t,
}
pub type camera_t = camera_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct skin_t {
    pub name: [libc::c_char; 17],
    pub wadnum: uint16_t,
    pub flags: skinflags_t,
    pub realname: [libc::c_char; 17],
    pub hudname: [libc::c_char; 17],
    pub supername: [libc::c_char; 23],
    pub ability: uint8_t,
    pub ability2: uint8_t,
    pub thokitem: int32_t,
    pub spinitem: int32_t,
    pub revitem: int32_t,
    pub followitem: int32_t,
    pub actionspd: fixed_t,
    pub mindash: fixed_t,
    pub maxdash: fixed_t,
    pub normalspeed: fixed_t,
    pub runspeed: fixed_t,
    pub thrustfactor: uint8_t,
    pub accelstart: uint8_t,
    pub acceleration: uint8_t,
    pub jumpfactor: fixed_t,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub spinheight: fixed_t,
    pub shieldscale: fixed_t,
    pub camerascale: fixed_t,
    pub starttranscolor: uint8_t,
    pub prefcolor: uint16_t,
    pub supercolor: uint16_t,
    pub prefoppositecolor: uint16_t,
    pub highresscale: fixed_t,
    pub contspeed: uint8_t,
    pub contangle: uint8_t,
    pub soundsid: [sfxenum_t; 21],
    pub sprites: [spritedef_t; 256],
    pub sprinfo: [spriteinfo_t; 256],
}
pub type C2RustUnnamed_5 = libc::c_uint;
pub const NUMMENUTYPES: C2RustUnnamed_5 = 58;
pub const MN_SPECIAL: C2RustUnnamed_5 = 57;
pub const MN_AD_MAIN: C2RustUnnamed_5 = 56;
pub const MN_SR_SOUNDTEST: C2RustUnnamed_5 = 55;
pub const MN_SR_PLAYER: C2RustUnnamed_5 = 54;
pub const MN_SR_EMBLEMHINT: C2RustUnnamed_5 = 53;
pub const MN_SR_UNLOCKCHECKLIST: C2RustUnnamed_5 = 52;
pub const MN_SR_LEVELSELECT: C2RustUnnamed_5 = 51;
pub const MN_SR_PANDORA: C2RustUnnamed_5 = 50;
pub const MN_SR_MAIN: C2RustUnnamed_5 = 49;
pub const MN_OP_ERASEDATA: C2RustUnnamed_5 = 48;
pub const MN_OP_SCREENSHOTS: C2RustUnnamed_5 = 47;
pub const MN_OP_ADDONS: C2RustUnnamed_5 = 46;
pub const MN_OP_DATA: C2RustUnnamed_5 = 45;
pub const MN_OP_MONITORTOGGLE: C2RustUnnamed_5 = 44;
pub const MN_OP_SERVER: C2RustUnnamed_5 = 43;
pub const MN_OP_SOUND: C2RustUnnamed_5 = 42;
pub const MN_OP_OPENGL_LIGHTING: C2RustUnnamed_5 = 41;
pub const MN_OP_OPENGL: C2RustUnnamed_5 = 40;
pub const MN_OP_COLOR: C2RustUnnamed_5 = 39;
pub const MN_OP_VIDEOMODE: C2RustUnnamed_5 = 38;
pub const MN_OP_VIDEO: C2RustUnnamed_5 = 37;
pub const MN_OP_PLAYSTYLE: C2RustUnnamed_5 = 36;
pub const MN_OP_P2CAMERA: C2RustUnnamed_5 = 35;
pub const MN_OP_P2JOYSTICK: C2RustUnnamed_5 = 34;
pub const MN_OP_P2MOUSE: C2RustUnnamed_5 = 33;
pub const MN_OP_P2CONTROLS: C2RustUnnamed_5 = 32;
pub const MN_OP_P1CAMERA: C2RustUnnamed_5 = 31;
pub const MN_OP_JOYSTICKSET: C2RustUnnamed_5 = 30;
pub const MN_OP_P1JOYSTICK: C2RustUnnamed_5 = 29;
pub const MN_OP_P1MOUSE: C2RustUnnamed_5 = 28;
pub const MN_OP_CHANGECONTROLS: C2RustUnnamed_5 = 27;
pub const MN_OP_P1CONTROLS: C2RustUnnamed_5 = 26;
pub const MN_OP_MAIN: C2RustUnnamed_5 = 25;
pub const MN_MP_SERVER_OPTIONS: C2RustUnnamed_5 = 24;
pub const MN_MP_PLAYERSETUP: C2RustUnnamed_5 = 23;
pub const MN_MP_ROOM: C2RustUnnamed_5 = 22;
pub const MN_MP_CONNECT: C2RustUnnamed_5 = 21;
pub const MN_MP_SERVER: C2RustUnnamed_5 = 20;
pub const MN_MP_SPLITSCREEN: C2RustUnnamed_5 = 19;
pub const MN_MP_MAIN: C2RustUnnamed_5 = 18;
pub const MN_SP_MARATHON: C2RustUnnamed_5 = 17;
pub const MN_SP_NIGHTS_GHOST: C2RustUnnamed_5 = 16;
pub const MN_SP_NIGHTS_REPLAY: C2RustUnnamed_5 = 15;
pub const MN_SP_NIGHTS_GUESTREPLAY: C2RustUnnamed_5 = 14;
pub const MN_SP_NIGHTS_LEVELSELECT: C2RustUnnamed_5 = 13;
pub const MN_SP_NIGHTSATTACK: C2RustUnnamed_5 = 12;
pub const MN_SP_GHOST: C2RustUnnamed_5 = 11;
pub const MN_SP_REPLAY: C2RustUnnamed_5 = 10;
pub const MN_SP_GUESTREPLAY: C2RustUnnamed_5 = 9;
pub const MN_SP_TIMEATTACK_LEVELSELECT: C2RustUnnamed_5 = 8;
pub const MN_SP_TIMEATTACK: C2RustUnnamed_5 = 7;
pub const MN_SP_LEVELSTATS: C2RustUnnamed_5 = 6;
pub const MN_SP_LEVELSELECT: C2RustUnnamed_5 = 5;
pub const MN_SP_PLAYER: C2RustUnnamed_5 = 4;
pub const MN_SP_LOAD: C2RustUnnamed_5 = 3;
pub const MN_SP_MAIN: C2RustUnnamed_5 = 2;
pub const MN_MAIN: C2RustUnnamed_5 = 1;
pub const MN_NONE: C2RustUnnamed_5 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct menupres_t {
    pub bgname: [libc::c_char; 8],
    pub fadestrength: int8_t,
    pub bgcolor: int32_t,
    pub titlescrollxspeed: int32_t,
    pub titlescrollyspeed: int32_t,
    pub bghide: boolean,
    pub hidetitlepics: int8_t,
    pub ttmode: ttmode_enum,
    pub ttscale: uint8_t,
    pub ttname: [libc::c_char; 9],
    pub ttx: int16_t,
    pub tty: int16_t,
    pub ttloop: int16_t,
    pub tttics: uint16_t,
    pub musname: [libc::c_char; 7],
    pub mustrack: uint16_t,
    pub muslooping: boolean,
    pub musstop: boolean,
    pub musignore: boolean,
    pub enterbubble: boolean,
    pub exitbubble: boolean,
    pub entertag: int32_t,
    pub exittag: int32_t,
    pub enterwipe: int16_t,
    pub exitwipe: int16_t,
}
pub type menutree_iterator = Option::<
    unsafe extern "C" fn(
        uint32_t,
        int32_t,
        *mut int32_t,
        *mut *mut libc::c_void,
        boolean,
    ) -> boolean,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct menupresmusic_t {
    pub musname: [libc::c_char; 7],
    pub mustrack: uint16_t,
    pub muslooping: boolean,
}
pub type menu_t = menu_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct menu_s {
    pub menuid: uint32_t,
    pub menutitlepic: *const libc::c_char,
    pub numitems: int16_t,
    pub prevMenu: *mut menu_s,
    pub menuitems: *mut menuitem_t,
    pub drawroutine: Option::<unsafe extern "C" fn() -> ()>,
    pub x: int16_t,
    pub y: int16_t,
    pub lastOn: int16_t,
    pub quitroutine: Option::<unsafe extern "C" fn() -> boolean>,
}
pub type menuitem_t = menuitem_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct menuitem_s {
    pub status: uint16_t,
    pub patch: *const libc::c_char,
    pub text: *const libc::c_char,
    pub itemaction: *mut libc::c_void,
    pub alphaKey: uint16_t,
}
pub const PU_PATCH: C2RustUnnamed_14 = 14;
pub type menumessagetype_t = libc::c_uint;
pub const MM_EVENTHANDLER: menumessagetype_t = 2;
pub const MM_YESNO: menumessagetype_t = 1;
pub const MM_NOTHING: menumessagetype_t = 0;
pub const hook_GameQuit: C2RustUnnamed_15 = 23;
pub const NUM_QUITMESSAGES: C2RustUnnamed_17 = 22;
pub const LLM_NIGHTSATTACK: levellist_mode_t = 3;
pub type levellist_mode_t = libc::c_uint;
pub const LLM_RECORDATTACK: levellist_mode_t = 2;
pub const LLM_LEVELSELECT: levellist_mode_t = 1;
pub const LLM_CREATESERVER: levellist_mode_t = 0;
pub const mpause_continue: C2RustUnnamed_20 = 4;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct emblem_t {
    pub type_0: uint8_t,
    pub tag: int16_t,
    pub level: int16_t,
    pub sprite: uint8_t,
    pub color: uint16_t,
    pub var: int32_t,
    pub stringVar: *mut libc::c_char,
    pub hint: [libc::c_char; 110],
}
pub const TC_DEFAULT: C2RustUnnamed_6 = -122;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct gamedata_t {
    pub loaded: boolean,
    pub achieved: [boolean; 128],
    pub collected: [boolean; 512],
    pub extraCollected: [boolean; 48],
    pub unlocked: [boolean; 80],
    pub mainrecords: [*mut recorddata_t; 1035],
    pub nightsrecords: [*mut nightsdata_t; 1035],
    pub mapvisited: [uint8_t; 1035],
    pub timesBeaten: uint32_t,
    pub timesBeatenWithEmeralds: uint32_t,
    pub timesBeatenUltimate: uint32_t,
    pub totalplaytime: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct nightsdata_t {
    pub nummares: uint8_t,
    pub score: [uint32_t; 9],
    pub grade: [uint8_t; 9],
    pub time: [tic_t; 9],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct recorddata_t {
    pub time: tic_t,
    pub score: uint32_t,
    pub rings: uint16_t,
}
pub const op_screenshot_colorprofile: C2RustUnnamed_29 = 1;
pub const op_screenshot_apng_end: C2RustUnnamed_29 = 20;
pub const op_screenshot_apng_start: C2RustUnnamed_29 = 16;
pub const MM_APNG: C2RustUnnamed_16 = 1;
pub const op_screenshot_gif_end: C2RustUnnamed_29 = 15;
pub const op_screenshot_gif_start: C2RustUnnamed_29 = 13;
pub const MM_GIF: C2RustUnnamed_16 = 2;
pub const op_screenshot_folder: C2RustUnnamed_29 = 4;
pub const op_addons_folder: C2RustUnnamed_30 = 2;
pub const mp_server_levelgt: C2RustUnnamed_26 = 4;
pub const tastart: C2RustUnnamed_23 = 5;
pub const tareplay: C2RustUnnamed_23 = 3;
pub const taghost: C2RustUnnamed_23 = 4;
pub const taplayer: C2RustUnnamed_23 = 1;
pub const talevel: C2RustUnnamed_23 = 0;
pub const DFILE_ERROR_EXTRAFILES: C2RustUnnamed_7 = 5;
pub const DFILE_ERROR_CANNOTLOAD: C2RustUnnamed_7 = 4;
pub const DFILE_ERROR_INCOMPLETEOUTOFORDER: C2RustUnnamed_7 = 3;
pub const DFILE_ERROR_OUTOFORDER: C2RustUnnamed_7 = 2;
pub type demo_file_override_e = libc::c_uint;
pub const DFILE_OVERRIDE_SKIP: demo_file_override_e = 2;
pub const DFILE_OVERRIDE_LOAD: demo_file_override_e = 1;
pub const DFILE_OVERRIDE_NONE: demo_file_override_e = 0;
pub const DFILE_ERROR_NOTLOADED: C2RustUnnamed_7 = 1;
pub const DFILE_ERROR_NOTDEMO: C2RustUnnamed_7 = 255;
pub const DFILE_ERROR_NONE: C2RustUnnamed_7 = 0;
pub const nalevel: C2RustUnnamed_24 = 0;
pub const PU_STATIC: C2RustUnnamed_14 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct levelselectrow_t {
    pub header: [libc::c_char; 27],
    pub maplist: [int32_t; 3],
    pub mapnames: [[libc::c_char; 22]; 3],
    pub mapavailable: [boolean; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct levelselect_t {
    pub numrows: uint8_t,
    pub rows: *mut levelselectrow_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct description_t {
    pub used: boolean,
    pub notes: [libc::c_char; 441],
    pub picname: [libc::c_char; 8],
    pub skinname: [libc::c_char; 34],
    pub charpic: *mut patch_t,
    pub prev: uint8_t,
    pub next: uint8_t,
    pub displayname: [libc::c_char; 17],
    pub skinnum: [int8_t; 2],
    pub oppositecolor: uint16_t,
    pub nametag: [libc::c_char; 8],
    pub namepic: *mut patch_t,
    pub tagtextcolor: uint16_t,
    pub tagoutlinecolor: uint16_t,
}
pub const marathonplayer: C2RustUnnamed_25 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct saveinfo_t {
    pub levelname: [libc::c_char; 32],
    pub skinnum: uint8_t,
    pub botskin: uint8_t,
    pub numemeralds: uint8_t,
    pub numgameovers: uint8_t,
    pub lives: int32_t,
    pub continuescore: int32_t,
    pub gamemap: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct gtdesc_t {
    pub col: [uint8_t; 2],
    pub notes: [libc::c_char; 441],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct extraemblem_t {
    pub name: [libc::c_char; 20],
    pub description: [libc::c_char; 40],
    pub conditionset: uint8_t,
    pub showconditionset: uint8_t,
    pub sprite: uint8_t,
    pub color: uint16_t,
}
pub const gcs_custom: C2RustUnnamed_10 = 0;
pub const gcs_fps: C2RustUnnamed_10 = 1;
pub const marathonstart: C2RustUnnamed_25 = 4;
pub const marathoncutscenes: C2RustUnnamed_25 = 3;
pub const nastart: C2RustUnnamed_24 = 6;
pub const taguest: C2RustUnnamed_23 = 2;
pub const nareplay: C2RustUnnamed_24 = 4;
pub const naghost: C2RustUnnamed_24 = 5;
pub const naguest: C2RustUnnamed_24 = 3;
pub const narecords: C2RustUnnamed_24 = 2;
pub type menucolor_t = menucolor_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct menucolor_s {
    pub next: *mut menucolor_s,
    pub prev: *mut menucolor_s,
    pub color: uint16_t,
}
pub const render_soft: rendermode_t = 1;
pub type rendermode_t = libc::c_uint;
pub const render_none: rendermode_t = 3;
pub const render_opengl: rendermode_t = 2;
pub type M_waiting_mode_t = libc::c_uint;
pub const M_WAITING_SERVERS: M_waiting_mode_t = 3;
pub const M_WAITING_ROOMS: M_waiting_mode_t = 2;
pub const M_WAITING_VERSION: M_waiting_mode_t = 1;
pub const M_NOT_WAITING: M_waiting_mode_t = 0;
pub const FIRSTSERVERLINE: C2RustUnnamed_27 = 4;
pub const mp_connect_page: C2RustUnnamed_27 = 2;
pub const mp_connect_room: C2RustUnnamed_27 = 0;
pub const mp_server_room: C2RustUnnamed_26 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct modedesc_t {
    pub modenum: int32_t,
    pub desc: *const libc::c_char,
    pub goodratio: uint8_t,
}
pub const op_video_renderer: C2RustUnnamed_28 = 4;
pub const PU_CACHE: C2RustUnnamed_14 = 49;
pub const GC_CUSTOM3: C2RustUnnamed_9 = 42;
pub const GC_PAUSE: C2RustUnnamed_9 = 34;
pub const KEY_DBL2JOY1: C2RustUnnamed_8 = 432;
pub const KEY_2JOY1: C2RustUnnamed_8 = 376;
pub const KEY_DBL2MOUSE1: C2RustUnnamed_8 = 424;
pub const KEY_2MOUSE1: C2RustUnnamed_8 = 368;
pub const KEY_DBLJOY1: C2RustUnnamed_8 = 320;
pub const KEY_JOY1: C2RustUnnamed_8 = 264;
pub const KEY_DBLMOUSE1: C2RustUnnamed_8 = 312;
pub const KEY_MOUSE1: C2RustUnnamed_8 = 256;
pub const GC_CUSTOM2: C2RustUnnamed_9 = 41;
pub const GC_CUSTOM1: C2RustUnnamed_9 = 40;
pub const GC_WEPSLOT7: C2RustUnnamed_9 = 15;
pub const GC_WEPSLOT6: C2RustUnnamed_9 = 14;
pub const GC_WEPSLOT5: C2RustUnnamed_9 = 13;
pub const GC_WEPSLOT4: C2RustUnnamed_9 = 12;
pub const GC_WEPSLOT3: C2RustUnnamed_9 = 11;
pub const GC_WEPSLOT2: C2RustUnnamed_9 = 10;
pub const GC_WEPSLOT1: C2RustUnnamed_9 = 9;
pub const GC_WEAPONPREV: C2RustUnnamed_9 = 8;
pub const GC_WEAPONNEXT: C2RustUnnamed_9 = 7;
pub const GC_TOSSFLAG: C2RustUnnamed_9 = 21;
pub const GC_FIRENORMAL: C2RustUnnamed_9 = 20;
pub const GC_FIRE: C2RustUnnamed_9 = 19;
pub const GC_TEAMKEY: C2RustUnnamed_9 = 30;
pub const GC_TALKKEY: C2RustUnnamed_9 = 29;
pub const GC_CONSOLE: C2RustUnnamed_9 = 33;
pub const GC_VIEWPOINTPREV: C2RustUnnamed_9 = 39;
pub const GC_VIEWPOINTNEXT: C2RustUnnamed_9 = 38;
pub const GC_SYSTEMMENU: C2RustUnnamed_9 = 35;
pub const GC_RECORDGIF: C2RustUnnamed_9 = 37;
pub const GC_SCREENSHOT: C2RustUnnamed_9 = 36;
pub const GC_SCORES: C2RustUnnamed_9 = 31;
pub const GC_CAMRESET: C2RustUnnamed_9 = 24;
pub const GC_CAMTOGGLE: C2RustUnnamed_9 = 23;
pub const GC_MOUSEAIMING: C2RustUnnamed_9 = 28;
pub const GC_CENTERVIEW: C2RustUnnamed_9 = 27;
pub const GC_TURNRIGHT: C2RustUnnamed_9 = 6;
pub const GC_TURNLEFT: C2RustUnnamed_9 = 5;
pub const GC_LOOKDOWN: C2RustUnnamed_9 = 26;
pub const GC_LOOKUP: C2RustUnnamed_9 = 25;
pub const GC_SPIN: C2RustUnnamed_9 = 22;
pub const GC_JUMP: C2RustUnnamed_9 = 32;
pub const GC_STRAFERIGHT: C2RustUnnamed_9 = 4;
pub const GC_STRAFELEFT: C2RustUnnamed_9 = 3;
pub const GC_BACKWARD: C2RustUnnamed_9 = 2;
pub const GC_FORWARD: C2RustUnnamed_9 = 1;
pub const NUM_EXT: C2RustUnnamed_11 = 9;
pub const DIR_STRING: C2RustUnnamed_12 = 2;
pub const DIR_LEN: C2RustUnnamed_12 = 1;
pub const EXT_LOADED: C2RustUnnamed_11 = 128;
pub const DIR_TYPE: C2RustUnnamed_12 = 0;
pub const REFRESHDIR_ERROR: C2RustUnnamed_13 = 8;
pub const REFRESHDIR_WARNING: C2RustUnnamed_13 = 4;
pub const REFRESHDIR_MAX: C2RustUnnamed_13 = 32;
pub const REFRESHDIR_NOTLOADED: C2RustUnnamed_13 = 16;
pub const REFRESHDIR_ADDFILE: C2RustUnnamed_13 = 2;
pub const REFRESHDIR_NORMAL: C2RustUnnamed_13 = 1;
pub const secrets: C2RustUnnamed_18 = 2;
pub const EXT_PK3: C2RustUnnamed_11 = 6;
pub const EXT_WAD: C2RustUnnamed_11 = 5;
pub const EXT_SOC: C2RustUnnamed_11 = 7;
pub const EXT_LUA: C2RustUnnamed_11 = 8;
pub const EXT_CFG: C2RustUnnamed_11 = 4;
pub const EXT_TXT: C2RustUnnamed_11 = 3;
pub const EXT_UP: C2RustUnnamed_11 = 1;
pub const EXT_FOLDER: C2RustUnnamed_11 = 0;
pub const EXT_NORESULTS: C2RustUnnamed_11 = 2;
pub const mpause_hints: C2RustUnnamed_20 = 2;
pub const mpause_spectate: C2RustUnnamed_20 = 7;
pub const mpause_entergame: C2RustUnnamed_20 = 8;
pub const mpause_switchteam: C2RustUnnamed_20 = 9;
pub const mpause_psetup: C2RustUnnamed_20 = 10;
pub const mpause_psetupsplit2: C2RustUnnamed_20 = 6;
pub const mpause_psetupsplit: C2RustUnnamed_20 = 5;
pub const mpause_scramble: C2RustUnnamed_20 = 1;
pub const mpause_addons: C2RustUnnamed_20 = 0;
pub const mpause_switchmap: C2RustUnnamed_20 = 3;
pub const spause_continue: C2RustUnnamed_21 = 3;
pub const spause_hints: C2RustUnnamed_21 = 1;
pub const spause_levelselect: C2RustUnnamed_21 = 2;
pub const spause_retry: C2RustUnnamed_21 = 4;
pub const spause_pandora: C2RustUnnamed_21 = 0;
pub const mapause_continue: C2RustUnnamed_19 = 1;
pub const mapause_hints: C2RustUnnamed_19 = 0;
pub const singleplr: C2RustUnnamed_18 = 0;
pub const multiplr: C2RustUnnamed_18 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct condition_t {
    pub id: uint32_t,
    pub type_0: conditiontype_t,
    pub requirement: int32_t,
    pub extrainfo1: int16_t,
    pub extrainfo2: int16_t,
}
pub type conditiontype_t = libc::c_uint;
pub const UC_CONDITIONSET: conditiontype_t = 22;
pub const UC_EXTRAEMBLEM: conditiontype_t = 21;
pub const UC_EMBLEM: conditiontype_t = 20;
pub const UC_TOTALEMBLEMS: conditiontype_t = 19;
pub const UC_TRIGGER: conditiontype_t = 18;
pub const UC_NIGHTSGRADE: conditiontype_t = 17;
pub const UC_NIGHTSTIME: conditiontype_t = 16;
pub const UC_NIGHTSSCORE: conditiontype_t = 15;
pub const UC_MAPRINGS: conditiontype_t = 14;
pub const UC_MAPTIME: conditiontype_t = 13;
pub const UC_MAPSCORE: conditiontype_t = 12;
pub const UC_MAPPERFECT: conditiontype_t = 11;
pub const UC_MAPULTIMATE: conditiontype_t = 10;
pub const UC_MAPALLEMERALDS: conditiontype_t = 9;
pub const UC_MAPBEATEN: conditiontype_t = 8;
pub const UC_MAPVISITED: conditiontype_t = 7;
pub const UC_OVERALLRINGS: conditiontype_t = 6;
pub const UC_OVERALLTIME: conditiontype_t = 5;
pub const UC_OVERALLSCORE: conditiontype_t = 4;
pub const UC_ULTIMATECLEAR: conditiontype_t = 3;
pub const UC_ALLEMERALDS: conditiontype_t = 2;
pub const UC_GAMECLEAR: conditiontype_t = 1;
pub const UC_PLAYTIME: conditiontype_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct unlockable_t {
    pub name: [libc::c_char; 64],
    pub objective: [libc::c_char; 64],
    pub height: uint16_t,
    pub conditionset: uint8_t,
    pub showconditionset: uint8_t,
    pub type_0: int16_t,
    pub variable: int16_t,
    pub stringVar: *mut libc::c_char,
    pub nocecho: uint8_t,
    pub nochecklist: uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct conditionset_t {
    pub numconditions: uint32_t,
    pub condition: *mut condition_t,
}
pub type musicdef_t = musicdef_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct musicdef_s {
    pub name: [libc::c_char; 7],
    pub title: [libc::c_char; 32],
    pub alttitle: [libc::c_char; 64],
    pub authors: [libc::c_char; 256],
    pub soundtestpage: uint8_t,
    pub soundtestcond: int16_t,
    pub stoppingtics: tic_t,
    pub bpm: fixed_t,
    pub loop_ms: uint32_t,
    pub allowed: boolean,
    pub next: *mut musicdef_s,
}
pub const TC_RAINBOW: C2RustUnnamed_6 = -125;
pub const spmarathon: C2RustUnnamed_22 = 3;
pub const spnightsmode: C2RustUnnamed_22 = 2;
pub const sprecordattack: C2RustUnnamed_22 = 1;
pub const spstartgame: C2RustUnnamed_22 = 0;
pub const sptutorial: C2RustUnnamed_22 = 4;
pub type JoyType_t = JoyType_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct JoyType_s {
    pub bJoyNeedPoll: int32_t,
    pub bGamepadStyle: int32_t,
}
pub const KEY_HAT1: C2RustUnnamed_8 = 296;
pub const QUIT3MSG6: C2RustUnnamed_17 = 21;
pub const QUIT3MSG5: C2RustUnnamed_17 = 20;
pub const QUIT3MSG4: C2RustUnnamed_17 = 19;
pub const QUIT3MSG3: C2RustUnnamed_17 = 18;
pub const QUIT3MSG2: C2RustUnnamed_17 = 17;
pub const QUIT3MSG1: C2RustUnnamed_17 = 16;
pub const QUIT3MSG: C2RustUnnamed_17 = 15;
pub const QUIT2MSG6: C2RustUnnamed_17 = 14;
pub const QUIT2MSG5: C2RustUnnamed_17 = 13;
pub const QUIT2MSG4: C2RustUnnamed_17 = 12;
pub const QUIT2MSG3: C2RustUnnamed_17 = 11;
pub const QUIT2MSG2: C2RustUnnamed_17 = 10;
pub const QUIT2MSG1: C2RustUnnamed_17 = 9;
pub const QUIT2MSG: C2RustUnnamed_17 = 8;
pub const QUITMSG7: C2RustUnnamed_17 = 7;
pub const QUITMSG6: C2RustUnnamed_17 = 6;
pub const QUITMSG5: C2RustUnnamed_17 = 5;
pub const QUITMSG4: C2RustUnnamed_17 = 4;
pub const QUITMSG3: C2RustUnnamed_17 = 3;
pub const QUITMSG2: C2RustUnnamed_17 = 2;
pub const QUITMSG1: C2RustUnnamed_17 = 1;
pub const QUITMSG: C2RustUnnamed_17 = 0;
pub const op_movie_folder: C2RustUnnamed_29 = 11;
pub type C2RustUnnamed_6 = libc::c_int;
pub const TC_DASHMODE: C2RustUnnamed_6 = -123;
pub const TC_BLINK: C2RustUnnamed_6 = -124;
pub const TC_ALLWHITE: C2RustUnnamed_6 = -126;
pub const TC_METALSONIC: C2RustUnnamed_6 = -127;
pub const TC_BOSS: C2RustUnnamed_6 = -128;
pub type C2RustUnnamed_7 = libc::c_uint;
pub type C2RustUnnamed_8 = libc::c_uint;
pub const NUMINPUTS: C2RustUnnamed_8 = 484;
pub const KEY_2MOUSEWHEELDOWN: C2RustUnnamed_8 = 483;
pub const KEY_2MOUSEWHEELUP: C2RustUnnamed_8 = 482;
pub const KEY_MOUSEWHEELDOWN: C2RustUnnamed_8 = 481;
pub const KEY_MOUSEWHEELUP: C2RustUnnamed_8 = 480;
pub const KEY_DBL2HAT1: C2RustUnnamed_8 = 464;
pub const KEY_2HAT1: C2RustUnnamed_8 = 408;
pub const KEY_DBLHAT1: C2RustUnnamed_8 = 352;
pub type C2RustUnnamed_9 = libc::c_uint;
pub const NUM_GAMECONTROLS: C2RustUnnamed_9 = 43;
pub const GC_WEPSLOT10: C2RustUnnamed_9 = 18;
pub const GC_WEPSLOT9: C2RustUnnamed_9 = 17;
pub const GC_WEPSLOT8: C2RustUnnamed_9 = 16;
pub const GC_NULL: C2RustUnnamed_9 = 0;
pub type C2RustUnnamed_10 = libc::c_uint;
pub const num_gamecontrolschemes: C2RustUnnamed_10 = 3;
pub const gcs_platform: C2RustUnnamed_10 = 2;
pub type C2RustUnnamed_11 = libc::c_uint;
pub const NUM_EXT_TABLE: C2RustUnnamed_11 = 6;
pub const EXT_LOADSTART: C2RustUnnamed_11 = 5;
pub const EXT_START: C2RustUnnamed_11 = 3;
pub type C2RustUnnamed_12 = libc::c_uint;
pub type C2RustUnnamed_13 = libc::c_uint;
pub type C2RustUnnamed_14 = libc::c_uint;
pub const PU_HWRMODELTEXTURE_UNLOCKED: C2RustUnnamed_14 = 103;
pub const PU_HWRCACHE_UNLOCKED: C2RustUnnamed_14 = 102;
pub const PU_CACHE_UNLOCKED: C2RustUnnamed_14 = 101;
pub const PU_PURGELEVEL: C2RustUnnamed_14 = 100;
pub const PU_HWRPLANE: C2RustUnnamed_14 = 52;
pub const PU_LEVSPEC: C2RustUnnamed_14 = 51;
pub const PU_LEVEL: C2RustUnnamed_14 = 50;
pub const PU_HWRCACHE: C2RustUnnamed_14 = 48;
pub const PU_HWRMODELTEXTURE: C2RustUnnamed_14 = 23;
pub const PU_HWRPATCHCOLMIPMAP: C2RustUnnamed_14 = 22;
pub const PU_HWRPATCHINFO: C2RustUnnamed_14 = 21;
pub const PU_HUDGFX: C2RustUnnamed_14 = 19;
pub const PU_SPRITE: C2RustUnnamed_14 = 18;
pub const PU_PATCH_DATA: C2RustUnnamed_14 = 17;
pub const PU_PATCH_ROTATED: C2RustUnnamed_14 = 16;
pub const PU_PATCH_LOWPRIORITY: C2RustUnnamed_14 = 15;
pub const PU_MUSIC: C2RustUnnamed_14 = 12;
pub const PU_SOUND: C2RustUnnamed_14 = 11;
pub const PU_PERFSTATS: C2RustUnnamed_14 = 3;
pub const PU_LUA: C2RustUnnamed_14 = 2;
pub type C2RustUnnamed_15 = libc::c_uint;
pub const hook_MAX: C2RustUnnamed_15 = 30;
pub const hook_KeyUp: C2RustUnnamed_15 = 29;
pub const hook_KeyDown: C2RustUnnamed_15 = 28;
pub const hook_PlayerCanEnterSpinGaps: C2RustUnnamed_15 = 27;
pub const hook_PlayerHeight: C2RustUnnamed_15 = 26;
pub const hook_MusicChange: C2RustUnnamed_15 = 25;
pub const hook_PlayerCmd: C2RustUnnamed_15 = 24;
pub const hook_PlayerThink: C2RustUnnamed_15 = 22;
pub const hook_SeenPlayer: C2RustUnnamed_15 = 21;
pub const hook_ViewpointSwitch: C2RustUnnamed_15 = 20;
pub const hook_TeamSwitch: C2RustUnnamed_15 = 19;
pub const hook_IntermissionThinker: C2RustUnnamed_15 = 18;
pub const hook_PlayerQuit: C2RustUnnamed_15 = 17;
pub const hook_PlayerCanDamage: C2RustUnnamed_15 = 16;
pub const hook_ShieldSpecial: C2RustUnnamed_15 = 15;
pub const hook_ShieldSpawn: C2RustUnnamed_15 = 14;
pub const hook_PlayerSpawn: C2RustUnnamed_15 = 13;
pub const hook_PlayerMsg: C2RustUnnamed_15 = 12;
pub const hook_BotTiccmd: C2RustUnnamed_15 = 11;
pub const hook_JumpSpinSpecial: C2RustUnnamed_15 = 10;
pub const hook_SpinSpecial: C2RustUnnamed_15 = 9;
pub const hook_AbilitySpecial: C2RustUnnamed_15 = 8;
pub const hook_JumpSpecial: C2RustUnnamed_15 = 7;
pub const hook_PostThinkFrame: C2RustUnnamed_15 = 6;
pub const hook_ThinkFrame: C2RustUnnamed_15 = 5;
pub const hook_PreThinkFrame: C2RustUnnamed_15 = 4;
pub const hook_PlayerJoin: C2RustUnnamed_15 = 3;
pub const hook_MapLoad: C2RustUnnamed_15 = 2;
pub const hook_MapChange: C2RustUnnamed_15 = 1;
pub const hook_NetVars: C2RustUnnamed_15 = 0;
pub type C2RustUnnamed_16 = libc::c_uint;
pub const MM_SCREENSHOT: C2RustUnnamed_16 = 3;
pub const MM_OFF: C2RustUnnamed_16 = 0;
pub type C2RustUnnamed_17 = libc::c_uint;
pub type C2RustUnnamed_18 = libc::c_uint;
pub const quitdoom: C2RustUnnamed_18 = 5;
pub const options: C2RustUnnamed_18 = 4;
pub const addons: C2RustUnnamed_18 = 3;
pub type C2RustUnnamed_19 = libc::c_uint;
pub const mapause_abort: C2RustUnnamed_19 = 3;
pub const mapause_retry: C2RustUnnamed_19 = 2;
pub type C2RustUnnamed_20 = libc::c_uint;
pub const mpause_quit: C2RustUnnamed_20 = 13;
pub const mpause_title: C2RustUnnamed_20 = 12;
pub const mpause_options: C2RustUnnamed_20 = 11;
pub type C2RustUnnamed_21 = libc::c_uint;
pub const spause_quit: C2RustUnnamed_21 = 7;
pub const spause_title: C2RustUnnamed_21 = 6;
pub const spause_options: C2RustUnnamed_21 = 5;
pub type C2RustUnnamed_22 = libc::c_uint;
pub const spstatistics: C2RustUnnamed_22 = 5;
pub type C2RustUnnamed_23 = libc::c_uint;
pub type C2RustUnnamed_24 = libc::c_uint;
pub const nachar: C2RustUnnamed_24 = 1;
pub type C2RustUnnamed_25 = libc::c_uint;
pub const marathonloadless: C2RustUnnamed_25 = 2;
pub const marathonultimate: C2RustUnnamed_25 = 1;
pub type C2RustUnnamed_26 = libc::c_uint;
pub const mp_server_start: C2RustUnnamed_26 = 6;
pub const mp_server_options: C2RustUnnamed_26 = 5;
pub const mp_server_waddl: C2RustUnnamed_26 = 3;
pub const mp_server_maxpl: C2RustUnnamed_26 = 2;
pub const mp_server_name: C2RustUnnamed_26 = 1;
pub type C2RustUnnamed_27 = libc::c_uint;
pub const mp_connect_refresh: C2RustUnnamed_27 = 3;
pub const mp_connect_sort: C2RustUnnamed_27 = 1;
pub type C2RustUnnamed_28 = libc::c_uint;
pub const op_video_vsync: C2RustUnnamed_28 = 3;
pub const op_video_fullscreen: C2RustUnnamed_28 = 2;
pub const op_video_resolution: C2RustUnnamed_28 = 1;
pub type C2RustUnnamed_29 = libc::c_uint;
pub const op_screenshot_capture: C2RustUnnamed_29 = 12;
pub const op_screenshot_storagelocation: C2RustUnnamed_29 = 3;
pub type C2RustUnnamed_30 = libc::c_uint;
#[inline]
unsafe extern "C" fn atof(mut __nptr: *const libc::c_char) -> libc::c_double {
    return strtod(__nptr, 0 as *mut libc::c_void as *mut *mut libc::c_char);
}
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    return strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    ) as libc::c_int;
}
#[inline(always)]
unsafe extern "C" fn FixedToFloat(mut x: fixed_t) -> libc::c_float {
    return x as libc::c_float
        / ((1 as libc::c_int) << 16 as libc::c_int) as libc::c_float;
}
#[inline(always)]
unsafe extern "C" fn FixedMul(mut a: fixed_t, mut b: fixed_t) -> fixed_t {
    return ((a as int64_t * b as int64_t) as uint64_t >> 16 as libc::c_int) as fixed_t;
}
#[inline(always)]
unsafe extern "C" fn FixedDiv2(mut a: fixed_t, mut b: fixed_t) -> fixed_t {
    return (a as int64_t * ((1 as libc::c_int) << 16 as libc::c_int) as int64_t
        / b as int64_t) as fixed_t;
}
#[inline(always)]
unsafe extern "C" fn FixedInt(mut a: fixed_t) -> fixed_t {
    return FixedMul(a, 1 as libc::c_int);
}
#[inline(always)]
unsafe extern "C" fn FixedDiv(mut a: fixed_t, mut b: fixed_t) -> fixed_t {
    if abs(a) >> 16 as libc::c_int - 2 as libc::c_int >= abs(b) {
        return if a ^ b < 0 as libc::c_int {
            -(2147483647 as libc::c_int) - 1 as libc::c_int
        } else {
            2147483647 as libc::c_int
        };
    }
    return FixedDiv2(a, b);
}
#[inline(always)]
unsafe extern "C" fn fastcmp(
    mut s: *const libc::c_char,
    mut c: *const libc::c_char,
) -> boolean {
    while *s as libc::c_int != 0 && *s as libc::c_int == *c as libc::c_int {
        s = s.offset(1);
        s;
        c = c.offset(1);
        c;
    }
    return (*s as libc::c_int == *c as libc::c_int) as libc::c_int;
}
#[no_mangle]
pub static mut m_waiting_mode: M_waiting_mode_t = M_NOT_WAITING;
#[no_mangle]
pub static mut quitmsg: [*const libc::c_char; 22] = [0 as *const libc::c_char; 22];
#[no_mangle]
pub static mut description: [description_t; 32] = [description_t {
    used: 0,
    notes: [0; 441],
    picname: [0; 8],
    skinname: [0; 34],
    charpic: 0 as *const patch_t as *mut patch_t,
    prev: 0,
    next: 0,
    displayname: [0; 17],
    skinnum: [0; 2],
    oppositecolor: 0,
    nametag: [0; 8],
    namepic: 0 as *const patch_t as *mut patch_t,
    tagtextcolor: 0,
    tagoutlinecolor: 0,
}; 32];
#[no_mangle]
pub static mut char_on: int16_t = -(1 as libc::c_int) as int16_t;
#[no_mangle]
pub static mut startchar: int16_t = 0 as libc::c_int as int16_t;
static mut char_notes: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;
#[no_mangle]
pub static mut menuactive: boolean = false_0 as libc::c_int;
#[no_mangle]
pub static mut fromlevelselect: boolean = false_0 as libc::c_int;
#[no_mangle]
pub static mut levellistmode: levellist_mode_t = LLM_CREATESERVER;
#[no_mangle]
pub static mut maplistoption: uint8_t = 0 as libc::c_int as uint8_t;
static mut joystickInfo: [[libc::c_char; 29]; 5] = [[0; 29]; 5];
static mut serverlistpage: uint32_t = 0;
static mut numsaves: uint8_t = 0 as libc::c_int as uint8_t;
static mut savegameinfo: *mut saveinfo_t = 0 as *const saveinfo_t as *mut saveinfo_t;
static mut savselp: [*mut patch_t; 7] = [0 as *const patch_t as *mut patch_t; 7];
#[no_mangle]
pub static mut startmap: int16_t = 0;
static mut itemOn: int16_t = 1 as libc::c_int as int16_t;
static mut skullAnimCounter: int16_t = 10 as libc::c_int as int16_t;
static mut setupcontrols_secondaryplayer: boolean = 0;
static mut setupcontrols: *mut [int32_t; 2] = 0 as *const [int32_t; 2]
    as *mut [int32_t; 2];
static mut vidm_testingmode: int32_t = 0 as libc::c_int;
static mut vidm_previousmode: int32_t = 0;
static mut vidm_selected: int32_t = 0 as libc::c_int;
static mut vidm_nummodes: int32_t = 0;
static mut vidm_column_size: int32_t = 0;
static mut recatkdrawtimer: fixed_t = 0 as libc::c_int;
static mut ntsatkdrawtimer: fixed_t = 0 as libc::c_int;
static mut charseltimer: fixed_t = 0 as libc::c_int;
static mut char_scroll: fixed_t = 0 as libc::c_int;
static mut keydown: tic_t = 0 as libc::c_int as tic_t;
static mut stopstopmessage: boolean = false_0 as libc::c_int;
static mut levelselect: levelselect_t = {
    let mut init = levelselect_t {
        numrows: 0 as libc::c_int as uint8_t,
        rows: 0 as *const levelselectrow_t as *mut levelselectrow_t,
    };
    init
};
static mut levelselectselect: [uint8_t; 3] = [0; 3];
static mut levselp: [[*mut patch_t; 3]; 2] = [[0 as *const patch_t
    as *mut patch_t; 3]; 2];
static mut lsoffs: [fixed_t; 2] = [0; 2];
#[no_mangle]
pub static mut hintpage: uint32_t = 1 as libc::c_int as uint32_t;
static mut check_on: uint8_t = 0;
#[no_mangle]
pub static mut OP_MPControlsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_MiscControlsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut addonsp: [*mut patch_t; 14] = [0 as *const patch_t as *mut patch_t; 14];
#[no_mangle]
pub static mut cv_showfocuslost: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"showfocuslost\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Yes\0" as *const u8 as *const libc::c_char,
            flags: CV_SAVE as libc::c_int,
            PossibleValue: CV_YesNo.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut map_cons_t: [CV_PossibleValue_t; 3] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"MIN\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 1035 as libc::c_int,
            strvalue: b"MAX\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut cv_nextmap: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"nextmap\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"1\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int | CV_CALL as libc::c_int,
            PossibleValue: map_cons_t.as_ptr() as *mut _,
            func: Some(Nextmap_OnChange as unsafe extern "C" fn() -> ()),
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut skins_cons_t: [CV_PossibleValue_t; 33] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"sonic\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
    CV_PossibleValue_s {
        value: 0,
        strvalue: 0 as *const libc::c_char,
    },
];
#[no_mangle]
pub static mut cv_chooseskin: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"chooseskin\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"sonic\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int | CV_CALL as libc::c_int,
            PossibleValue: skins_cons_t.as_ptr() as *mut _,
            func: Some(Nextmap_OnChange as unsafe extern "C" fn() -> ()),
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut gametype_cons_t: [CV_PossibleValue_t; 137] = [CV_PossibleValue_s {
    value: 0,
    strvalue: 0 as *const libc::c_char,
}; 137];
#[no_mangle]
pub static mut cv_newgametype: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"newgametype\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Co-op\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int | CV_CALL as libc::c_int,
            PossibleValue: gametype_cons_t.as_ptr() as *mut _,
            func: Some(Newgametype_OnChange as unsafe extern "C" fn() -> ()),
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut serversort_cons_t: [CV_PossibleValue_t; 7] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"Ping\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"Modified State\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 2 as libc::c_int,
            strvalue: b"Most Players\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 3 as libc::c_int,
            strvalue: b"Least Players\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 4 as libc::c_int,
            strvalue: b"Max Player Slots\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 5 as libc::c_int,
            strvalue: b"Gametype\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut cv_serversort: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"serversort\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Ping\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int | CV_CALL as libc::c_int,
            PossibleValue: serversort_cons_t.as_ptr() as *mut _,
            func: Some(M_SortServerList as unsafe extern "C" fn() -> ()),
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut cv_tutorialprompt: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"tutorialprompt\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"On\0" as *const u8 as *const libc::c_char,
            flags: CV_SAVE as libc::c_int,
            PossibleValue: CV_OnOff.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut cv_autorecord: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"autorecord\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Yes\0" as *const u8 as *const libc::c_char,
            flags: 0 as libc::c_int,
            PossibleValue: CV_YesNo.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut ghost_cons_t: [CV_PossibleValue_t; 4] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"Hide\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"Show\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 2 as libc::c_int,
            strvalue: b"Show All\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut ghost2_cons_t: [CV_PossibleValue_t; 3] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"Hide\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"Show\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut cv_ghost_bestscore: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"ghost_bestscore\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Show\0" as *const u8 as *const libc::c_char,
            flags: CV_SAVE as libc::c_int,
            PossibleValue: ghost_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut cv_ghost_besttime: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"ghost_besttime\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Show\0" as *const u8 as *const libc::c_char,
            flags: CV_SAVE as libc::c_int,
            PossibleValue: ghost_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut cv_ghost_bestrings: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"ghost_bestrings\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Show\0" as *const u8 as *const libc::c_char,
            flags: CV_SAVE as libc::c_int,
            PossibleValue: ghost_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut cv_ghost_last: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"ghost_last\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Show\0" as *const u8 as *const libc::c_char,
            flags: CV_SAVE as libc::c_int,
            PossibleValue: ghost_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut cv_ghost_guest: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"ghost_guest\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Show\0" as *const u8 as *const libc::c_char,
            flags: CV_SAVE as libc::c_int,
            PossibleValue: ghost2_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut dummyteam_cons_t: [CV_PossibleValue_t; 4] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"Spectator\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"Red\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 2 as libc::c_int,
            strvalue: b"Blue\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
static mut dummyscramble_cons_t: [CV_PossibleValue_t; 3] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"Random\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"Points\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
static mut ringlimit_cons_t: [CV_PossibleValue_t; 3] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"MIN\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 9999 as libc::c_int,
            strvalue: b"MAX\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
static mut liveslimit_cons_t: [CV_PossibleValue_t; 4] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"MIN\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 99 as libc::c_int,
            strvalue: b"MAX\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: -(1 as libc::c_int),
            strvalue: b"Infinite\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
static mut contlimit_cons_t: [CV_PossibleValue_t; 3] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"MIN\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 99 as libc::c_int,
            strvalue: b"MAX\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
static mut dummymares_cons_t: [CV_PossibleValue_t; 11] = [
    {
        let mut init = CV_PossibleValue_s {
            value: -(1 as libc::c_int),
            strvalue: b"END\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"Overall\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"Mare 1\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 2 as libc::c_int,
            strvalue: b"Mare 2\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 3 as libc::c_int,
            strvalue: b"Mare 3\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 4 as libc::c_int,
            strvalue: b"Mare 4\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 5 as libc::c_int,
            strvalue: b"Mare 5\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 6 as libc::c_int,
            strvalue: b"Mare 6\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 7 as libc::c_int,
            strvalue: b"Mare 7\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 8 as libc::c_int,
            strvalue: b"Mare 8\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
static mut cv_dummyteam: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"dummyteam\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Spectator\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int,
            PossibleValue: dummyteam_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut cv_dummyscramble: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"dummyscramble\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Random\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int,
            PossibleValue: dummyscramble_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut cv_dummyrings: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"dummyrings\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"0\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int,
            PossibleValue: ringlimit_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut cv_dummylives: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"dummylives\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"0\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int,
            PossibleValue: liveslimit_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut cv_dummycontinues: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"dummycontinues\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"0\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int,
            PossibleValue: contlimit_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut cv_dummymares: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"dummymares\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Overall\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int | CV_CALL as libc::c_int,
            PossibleValue: dummymares_cons_t.as_ptr() as *mut _,
            func: Some(Dummymares_OnChange as unsafe extern "C" fn() -> ()),
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut marathon_cons_t: [CV_PossibleValue_t; 4] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"Standard\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"Live Event Backup\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 2 as libc::c_int,
            strvalue: b"Ultimate\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut loadless_cons_t: [CV_PossibleValue_t; 3] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"Realtime\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"In-game\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut cv_dummymarathon: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"dummymarathon\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Standard\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int,
            PossibleValue: marathon_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut cv_dummycutscenes: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"dummycutscenes\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"Off\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int,
            PossibleValue: CV_OnOff.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut cv_dummyloadless: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"dummyloadless\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"In-game\0" as *const u8 as *const libc::c_char,
            flags: CV_HIDEN as libc::c_int,
            PossibleValue: loadless_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_1 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_2 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut MainMenu: [menuitem_t; 6] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"1  Player\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SinglePlayerMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 76 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Multiplayer\0" as *const u8 as *const libc::c_char,
                itemaction: &MP_MainDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 84 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Extras\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SecretsMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 92 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Addons\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Addons as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Options\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Options as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 108 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Quit  Game\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_QuitSRB2 as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 116 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MISC_AddonsMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleAddons as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MAPauseMenu: [menuitem_t; 4] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Emblem Hints...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_EmblemHints as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 32 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Continue\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SelectableClearMenus as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 48 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Retry\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ModeAttackRetry as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 56 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Abort\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ModeAttackEndGame as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 64 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MPauseMenu: [menuitem_t; 14] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Add-ons...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Addons as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 8 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Scramble Teams...\0" as *const u8 as *const libc::c_char,
                itemaction: &MISC_ScrambleTeamDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Emblem Hints...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_EmblemHints as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 24 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Switch Gametype/Level...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_MapChange as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 32 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Continue\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SelectableClearMenus as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 48 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Player 1 Setup\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetupMultiPlayer as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 56 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Player 2 Setup\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetupMultiPlayer2 as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 64 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Spectate\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ConfirmSpectate as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 56 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Enter Game\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ConfirmEnterGame as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 56 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Switch Team...\0" as *const u8 as *const libc::c_char,
                itemaction: &MISC_ChangeTeamDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 56 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Player Setup\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetupMultiPlayer as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 64 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Options\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Options as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 72 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Return to Title\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_EndGame as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 88 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Quit Game\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_QuitSRB2 as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 96 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SPauseMenu: [menuitem_t; 8] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Pandora's Box...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_PandorasBox as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Emblem Hints...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_EmblemHints as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 24 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Level Select...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_PauseLevelSelect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 32 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Continue\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SelectableClearMenus as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 48 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Retry\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Retry as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 56 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Options\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Options as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 64 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Return to Title\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_EndGame as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 80 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Quit Game\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_QuitSRB2 as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 88 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MISC_ScrambleTeamMenu: [menuitem_t; 2] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Scramble Method\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_dummyscramble as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Confirm\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ConfirmTeamScramble as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MISC_ChangeTeamMenu: [menuitem_t; 2] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Select Team\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_dummyteam as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Confirm\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ConfirmTeamChange as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
#[no_mangle]
pub static mut gametypedesc: [gtdesc_t; 136] = unsafe {
    [
        {
            let mut init = gtdesc_t {
                col: [54 as libc::c_int as uint8_t, 54 as libc::c_int as uint8_t],
                notes: *::core::mem::transmute::<
                    &[u8; 441],
                    &mut [libc::c_char; 441],
                >(
                    b"Play through the single-player campaign with your friends, teaming up to beat Dr Eggman's nefarious challenges!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = gtdesc_t {
                col: [103 as libc::c_int as uint8_t, 103 as libc::c_int as uint8_t],
                notes: *::core::mem::transmute::<
                    &[u8; 441],
                    &mut [libc::c_char; 441],
                >(
                    b"Speed your way through the main acts, competing in several different categories to see who's the best.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = gtdesc_t {
                col: [190 as libc::c_int as uint8_t, 190 as libc::c_int as uint8_t],
                notes: *::core::mem::transmute::<
                    &[u8; 441],
                    &mut [libc::c_char; 441],
                >(
                    b"There's not much to it - zoom through the level faster than everyone else.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = gtdesc_t {
                col: [66 as libc::c_int as uint8_t, 66 as libc::c_int as uint8_t],
                notes: *::core::mem::transmute::<
                    &[u8; 441],
                    &mut [libc::c_char; 441],
                >(
                    b"Sling rings at your foes in a free-for-all battle. Use the special weapon rings to your advantage!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = gtdesc_t {
                col: [153 as libc::c_int as uint8_t, 37 as libc::c_int as uint8_t],
                notes: *::core::mem::transmute::<
                    &[u8; 441],
                    &mut [libc::c_char; 441],
                >(
                    b"Sling rings at your foes in a color-coded battle. Use the special weapon rings to your advantage!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = gtdesc_t {
                col: [123 as libc::c_int as uint8_t, 123 as libc::c_int as uint8_t],
                notes: *::core::mem::transmute::<
                    &[u8; 441],
                    &mut [libc::c_char; 441],
                >(
                    b"Whoever's IT has to hunt down everyone else. If you get caught, you have to turn on your former friends!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = gtdesc_t {
                col: [150 as libc::c_int as uint8_t, 150 as libc::c_int as uint8_t],
                notes: *::core::mem::transmute::<
                    &[u8; 441],
                    &mut [libc::c_char; 441],
                >(
                    b"Try and find a good hiding place in these maps - we dare you.\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        {
            let mut init = gtdesc_t {
                col: [37 as libc::c_int as uint8_t, 153 as libc::c_int as uint8_t],
                notes: *::core::mem::transmute::<
                    &[u8; 441],
                    &mut [libc::c_char; 441],
                >(
                    b"Steal the flag from the enemy's base and bring it back to your own, but watch out - they could just as easily steal yours!\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                ),
            };
            init
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
        gtdesc_t {
            col: [0; 2],
            notes: [0; 441],
        },
    ]
};
static mut MISC_ChangeLevelMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleLevelPlatter as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MISC_HelpMenu: [menuitem_t; 5] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"HELPN01\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleImageDef as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"HELPN02\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleImageDef as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"HELPN03\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleImageDef as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"HELPM01\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleImageDef as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"HELPM02\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleImageDef as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SR_PandorasBox: [menuitem_t; 10] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Mid-game add-ons...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Addons as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Rings\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_dummyrings as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Lives\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_dummylives as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Continues\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_dummycontinues as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 40 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Gravity\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_gravity as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Throw Rings\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ringslinger as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 70 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Enable Super form\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_AllowSuper as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Get All Emeralds\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_GetAllEmeralds as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Destroy All Robots\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_DestroyRobots as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 110 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Ultimate Cheat\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> !>,
                    *mut libc::c_void,
                >(Some(M_UltimateCheat as unsafe extern "C" fn(int32_t) -> !)),
                alphaKey: 130 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SR_MainMenu: [menuitem_t; 81] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Extras Checklist\0" as *const u8 as *const libc::c_char,
                itemaction: &SR_UnlockChecklistDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
        menuitem_s {
            status: 0,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0,
        },
    ]
};
static mut SR_LevelSelectMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleLevelPlatter as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SR_UnlockChecklistMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleChecklist as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SR_SoundTestMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleSoundTest as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SR_EmblemHintMenu: [menuitem_t; 3] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 2 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Page\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleEmblemHints as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Emblem Radar\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_itemfinder as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Back\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_GoBack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_MainMenu: [menuitem_t; 6] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Start Game\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_LoadGame as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 76 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (64 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Record Attack\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_TimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 84 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (64 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"NiGHTS Mode\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_NightsAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 92 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (64 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Marathon Run\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Marathon as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Tutorial\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_StartTutorial as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 108 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Statistics\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Statistics as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 116 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_LoadGameMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleLoadSave as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_LevelSelectMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleLevelPlatter as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_TimeAttackLevelSelectMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleLevelPlatter as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_TimeAttackMenu: [menuitem_t; 6] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 4 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Level Select...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(
                    Some(
                        M_HandleTimeAttackLevelSelect
                            as unsafe extern "C" fn(int32_t) -> (),
                    ),
                ),
                alphaKey: 62 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Character\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chooseskin as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 72 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Guest Option...\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_GuestReplayDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay...\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_ReplayDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 110 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Ghosts...\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_GhostDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 120 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Start\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseTimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 130 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_ReplayMenu: [menuitem_t; 6] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay Best Score\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ReplayTimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay Best Time\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ReplayTimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 8 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay Best Rings\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ReplayTimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay Last\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ReplayTimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 29 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay Guest\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ReplayTimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 37 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Back\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_TimeAttackDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_NightsReplayMenu: [menuitem_t; 5] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay Best Score\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ReplayTimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 8 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay Best Time\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ReplayTimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay Last\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ReplayTimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 29 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay Guest\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ReplayTimeAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 37 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Back\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_NightsAttackDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_GuestReplayMenu: [menuitem_t; 6] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Save Best Score as Guest\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetGuestReplay as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Save Best Time as Guest\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetGuestReplay as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 8 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Save Best Rings as Guest\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetGuestReplay as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Save Last as Guest\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetGuestReplay as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 24 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Delete Guest Replay\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetGuestReplay as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 37 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Back\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_TimeAttackDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_NightsGuestReplayMenu: [menuitem_t; 5] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Save Best Score as Guest\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetGuestReplay as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 8 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Save Best Time as Guest\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetGuestReplay as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Save Last as Guest\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetGuestReplay as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 24 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Delete Guest Replay\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetGuestReplay as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 37 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Back\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_NightsAttackDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_GhostMenu: [menuitem_t; 6] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Best Score\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ghost_bestscore as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Best Time\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ghost_besttime as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 8 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Best Rings\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ghost_bestrings as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Last\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ghost_last as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 24 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Guest\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ghost_guest as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 37 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Back\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_TimeAttackDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_NightsGhostMenu: [menuitem_t; 5] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Best Score\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ghost_bestscore as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 8 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Best Time\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ghost_besttime as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Last\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ghost_last as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 24 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Guest\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ghost_guest as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 37 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Back\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_NightsAttackDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_NightsAttackLevelSelectMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleLevelPlatter as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_NightsAttackMenu: [menuitem_t; 7] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 4 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Level Select...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(
                    Some(
                        M_HandleTimeAttackLevelSelect
                            as unsafe extern "C" fn(int32_t) -> (),
                    ),
                ),
                alphaKey: 52 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Character\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chooseskin as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 62 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Show Records For\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_dummymares as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 72 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Guest Option...\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_NightsGuestReplayDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Replay...\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_NightsReplayDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 110 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Ghosts...\0" as *const u8 as *const libc::c_char,
                itemaction: &SP_NightsGhostDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 120 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Start\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseNightsAttack as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 130 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_MarathonMenu: [menuitem_t; 5] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 4 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Character\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(
                    Some(
                        M_HandleMarathonChoosePlayer
                            as unsafe extern "C" fn(int32_t) -> (),
                    ),
                ),
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Category\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_dummymarathon as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Timer\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_dummyloadless as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 110 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Cutscenes\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_dummycutscenes as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 120 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Start\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_StartMarathon as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 130 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_LevelStatsMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleLevelStats as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut SP_PlayerMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 4 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleChoosePlayerMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MP_SplitServerMenu: [menuitem_t; 3] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Select Gametype/Level...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_MapChange as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"More Options...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ServerOptions as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 130 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Start\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_StartServer as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 140 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MP_MainMenu: [menuitem_t; 9] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Join a game\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Server browser...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ConnectMenuModChecks as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 12 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 4 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Specify server address:\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleConnectIP as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 22 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Host a game\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 54 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Internet/LAN...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_StartServerMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 66 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Splitscreen...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_StartSplitServerMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 76 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Player setup\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 94 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Player 1...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetupMultiPlayer as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 106 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Player 2... \0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_SetupMultiPlayer2 as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 116 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MP_ServerMenu: [menuitem_t; 7] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Room...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_RoomMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 1024 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Server Name\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_servername as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Max Players\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_maxplayers as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 46 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Allow Add-on Downloading\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_downloading as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 56 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Select Gametype/Level...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_MapChange as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"More Options...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ServerOptions as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 130 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (48 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Start\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_StartServer as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 140 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MP_ConnectMenu: [menuitem_t; 15] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Room...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_RoomMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 4 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Sort By\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_serversort as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 12 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 4 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Page\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleServerPage as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Refresh\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Refresh as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 28 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (48 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (60 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (72 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (84 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (96 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (108 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (120 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (132 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (144 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (156 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 1 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Connect as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: (168 as libc::c_int - 4 as libc::c_int) as uint16_t,
            };
            init
        },
    ]
};
#[no_mangle]
pub static mut MP_RoomMenu: [menuitem_t; 18] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"<Unlisted Mode>\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 9 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 18 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 27 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 36 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 45 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 54 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 63 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 72 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 81 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 99 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 108 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 117 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 126 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 135 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 144 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 153 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChooseRoom as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 162 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut MP_PlayerSetupMenu: [menuitem_t; 4] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: 4 as libc::c_int as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleSetupMultiPlayer as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: 4 as libc::c_int as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleSetupMultiPlayer as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: 4 as libc::c_int as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleSetupMultiPlayer as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: 4 as libc::c_int as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleSetupMultiPlayer as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_MainMenu: [menuitem_t; 7] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Player 1 Controls...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_P1ControlsDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Player 2 Controls...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_P2ControlsDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (8 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Controls per key\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_controlperkey as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Video Options...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_VideoOptions as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Sound Options...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_SoundOptionsDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Server Options...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ServerOptions as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 80 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Data Options...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_DataOptionsDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_P1ControlsMenu: [menuitem_t; 6] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Control Configuration...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Setup1PControlsMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Mouse Options...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_MouseOptionsDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Gamepad Options...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_Joystick1Def as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Options...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_CameraOptionsDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Automatic braking\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_autobrake as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 70 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Play Style...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Setup1PPlaystyleMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 80 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_P2ControlsMenu: [menuitem_t; 6] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Control Configuration...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Setup2PControlsMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Second Mouse Options...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_Mouse2OptionsDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Second Gamepad Options...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_Joystick2Def as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Options...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_Camera2OptionsDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Automatic braking\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_autobrake2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 70 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Play Style...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Setup2PPlaystyleMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 80 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_ChangeControlsMenu: [menuitem_t; 51] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Movement\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: 1 as libc::c_int as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Move Forward\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_FORWARD as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Move Backward\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_BACKWARD as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Move Left\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_STRAFELEFT as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Move Right\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_STRAFERIGHT as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Jump\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_JUMP as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Spin\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_SPIN as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: 1 as libc::c_int as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Look Up\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_LOOKUP as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Look Down\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_LOOKDOWN as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Look Left\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_TURNLEFT as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Look Right\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_TURNRIGHT as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Center View\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_CENTERVIEW as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Toggle Mouselook\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_MOUSEAIMING as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Toggle Third-Person\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_CAMTOGGLE as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Reset Camera\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_CAMRESET as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Meta\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: 1 as libc::c_int as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Game Status\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_SCORES as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Pause / Run Retry\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_PAUSE as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Screenshot\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_SCREENSHOT as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Toggle GIF Recording\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_RECORDGIF as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Open/Close Menu (ESC)\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_SYSTEMMENU as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Next Viewpoint\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_VIEWPOINTNEXT as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Prev Viewpoint\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_VIEWPOINTPREV as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Console\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_CONSOLE as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Multiplayer\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: 1 as libc::c_int as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Talk\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_TALKKEY as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Talk (Team only)\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_TEAMKEY as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Ringslinger (Match, CTF, Tag, H&S)\0" as *const u8
                    as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: 1 as libc::c_int as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Fire\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_FIRE as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Fire Normal\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_FIRENORMAL as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Toss Flag\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_TOSSFLAG as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Next Weapon\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_WEAPONNEXT as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Prev Weapon\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_WEAPONPREV as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Normal / Infinity\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_WEPSLOT1 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Automatic\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_WEPSLOT2 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Bounce\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_WEPSLOT3 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Scatter\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_WEPSLOT4 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Grenade\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_WEPSLOT5 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Explosion\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_WEPSLOT6 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Rail\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_WEPSLOT7 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Add-ons\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: 1 as libc::c_int as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Custom Action 1\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_CUSTOM1 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Custom Action 2\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_CUSTOM2 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Custom Action 3\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ChangeControl as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: GC_CUSTOM3 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_Joystick1Menu: [menuitem_t; 13] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Select Gamepad...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Setup1PJoystickMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Move \x17 Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_moveaxis as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Move \x18 Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_sideaxis as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 40 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera \x17 Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_lookaxis as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera \x18 Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_turnaxis as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Jump Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_jumpaxis as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 70 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Spin Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_spinaxis as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 80 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Fire Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_fireaxis as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Fire Normal Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_firenaxis as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"First-Person Vert-Look\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_alwaysfreelook as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 120 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Third-Person Vert-Look\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chasefreelook as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 130 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Analog Deadzone\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_deadzone as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 140 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Digital Deadzone\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_digitaldeadzone as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 150 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_Joystick2Menu: [menuitem_t; 13] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Select Gamepad...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_Setup2PJoystickMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Move \x17 Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_moveaxis2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Move \x18 Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_sideaxis2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 40 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera \x17 Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_lookaxis2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera \x18 Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_turnaxis2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Jump Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_jumpaxis2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 70 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Spin Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_spinaxis2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 80 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Fire Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_fireaxis2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Fire Normal Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_firenaxis2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"First-Person Vert-Look\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_alwaysfreelook2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 120 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Third-Person Vert-Look\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chasefreelook2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 130 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Analog Deadzone\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_deadzone2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 140 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Digital Deadzone\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_digitaldeadzone2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 150 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_JoystickSetMenu: [menuitem_t; 5] = [menuitem_s {
    status: 0,
    patch: 0 as *const libc::c_char,
    text: 0 as *const libc::c_char,
    itemaction: 0 as *const libc::c_void as *mut libc::c_void,
    alphaKey: 0,
}; 5];
static mut OP_MouseOptionsMenu: [menuitem_t; 7] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Use Mouse\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_usemouse as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"First-Person MouseLook\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_alwaysfreelook as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Third-Person MouseLook\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chasefreelook as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 40 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Mouse Move\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_mousemove as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Invert Y Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_invertmouse as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Mouse X Sensitivity\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_mousesens as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 70 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Mouse Y Sensitivity\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_mouseysens as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 80 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_Mouse2OptionsMenu: [menuitem_t; 8] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Use Mouse 2\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_usemouse2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Second Mouse Serial Port\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_mouse2port as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"First-Person MouseLook\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_alwaysfreelook2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Third-Person MouseLook\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chasefreelook2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 40 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Mouse Move\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_mousemove2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Invert Y Axis\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_invertmouse2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Mouse X Sensitivity\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_mousesens2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 70 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Mouse Y Sensitivity\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_mouseysens2 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 80 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_CameraOptionsMenu: [menuitem_t; 12] = [menuitem_s {
    status: 0,
    patch: 0 as *const libc::c_char,
    text: 0 as *const libc::c_char,
    itemaction: 0 as *const libc::c_void as *mut libc::c_void,
    alphaKey: 0,
}; 12];
static mut OP_Camera2OptionsMenu: [menuitem_t; 12] = [menuitem_s {
    status: 0,
    patch: 0 as *const libc::c_char,
    text: 0 as *const libc::c_char,
    itemaction: 0 as *const libc::c_void as *mut libc::c_void,
    alphaKey: 0,
}; 12];
static mut OP_CameraExtendedOptionsMenu: [menuitem_t; 22] = [menuitem_s {
    status: 0,
    patch: 0 as *const libc::c_char,
    text: 0 as *const libc::c_char,
    itemaction: 0 as *const libc::c_void as *mut libc::c_void,
    alphaKey: 0,
}; 22];
static mut OP_Camera2ExtendedOptionsMenu: [menuitem_t; 22] = [menuitem_s {
    status: 0,
    patch: 0 as *const libc::c_char,
    text: 0 as *const libc::c_char,
    itemaction: 0 as *const libc::c_void as *mut libc::c_void,
    alphaKey: 0,
}; 22];
static mut OP_VideoOptionsMenu: [menuitem_t; 35] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Screen\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Set Resolution...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_VideoModeMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 6 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Fullscreen (F11)\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_fullscreen as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 11 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Vertical Sync\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_vidwait as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (16 as libc::c_int + 128 as libc::c_int | 11 as libc::c_int)
                    as uint16_t,
                patch: b"Renderer\0" as *const u8 as *const libc::c_char,
                text: b"Software\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_renderer as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 21 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Color Profile\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Brightness\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_globalgamma as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 36 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Saturation\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_globalsaturation as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 41 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (6 as libc::c_int | 32 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Advanced Settings...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_ColorOptionsDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 46 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Heads-Up Display\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 55 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Show HUD\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_showhud as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 61 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"HUD Transparency\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_translucenthud as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 66 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Score/Time/Rings\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_timetic as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 71 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Show Powerups\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_powerupdisplay as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 76 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Local ping display\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_showping as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 81 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Show player names\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_seenames as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 86 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Console\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 95 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Background color\0" as *const u8 as *const libc::c_char,
                itemaction: &cons_backcolor as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 101 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Text Size\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_constextsize as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 106 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Chat\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 115 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Chat Mode\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_consolechat as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 121 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Chat Box Width\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chatwidth as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 126 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Chat Box Height\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chatheight as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 131 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Message Fadeout Time\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chattime as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 136 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Chat Notifications\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chatnotifications as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 141 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Spam Protection\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chatspamprotection as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 146 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Chat background tint\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chatbacktint as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 151 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Level\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 160 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Draw Distance\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_drawdist as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 166 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Weather Draw Dist.\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_drawdist_precip as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 171 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"NiGHTS Hoop Draw Dist.\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_drawdist_nights as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 176 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Diagnostic\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 184 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Show FPS\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ticrate as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 190 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Clear Before Redraw\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_homremoval as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 195 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Show \"FOCUS LOST\"\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_showfocuslost as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 200 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_VideoModeMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandleVideoMode as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_ColorOptionsMenu: [menuitem_t; 31] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Reset to defaults\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> ()>,
                    *mut libc::c_void,
                >(Some(M_ResetCvars as unsafe extern "C" fn() -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Red\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 9 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 35 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Hue\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_rhue as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 15 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Saturation\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_rsaturation as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Brightness\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_rgamma as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 25 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Yellow\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 34 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 73 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Hue\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_yhue as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 40 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Saturation\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ysaturation as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 45 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Brightness\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ygamma as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Green\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 59 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 112 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Hue\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ghue as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 65 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Saturation\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_gsaturation as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 70 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Brightness\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ggamma as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 75 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Cyan\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 84 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 255 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Hue\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_chue as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Saturation\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_csaturation as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 95 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Brightness\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_cgamma as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Blue\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 109 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 152 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Hue\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_bhue as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 115 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Saturation\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_bsaturation as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 120 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Brightness\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_bgamma as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 125 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Magenta\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 134 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: 0 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 181 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Hue\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_mhue as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 140 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Saturation\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_msaturation as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 145 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Brightness\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_mgamma as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 150 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_SoundOptionsMenu: [menuitem_t; 13] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Game Audio\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Sound Effects\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_gamesounds as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 6 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Sound Volume\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_soundvolume as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 11 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Digital Music\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_gamedigimusic as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 21 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Digital Music Volume\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_digmusicvolume as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 26 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"MIDI Music\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_gamemidimusic as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 36 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"MIDI Music Volume\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_midimusicvolume as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 41 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Music Preference\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_musicpref as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 51 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Miscellaneous\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 61 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Closed Captioning\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_closedcaptioning as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 67 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Reset Music Upon Dying\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_resetmusic as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 72 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Default 1-Up sound\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_1upsound as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 77 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Advanced Settings...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_SoundAdvancedDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 87 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_SoundAdvancedMenu: [menuitem_t; 6] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"OpenMPT Settings\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Instrument Filter\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_modfilter as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 12 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Miscellaneous\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: (32 as libc::c_int + 0 as libc::c_int) as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Play Sound Effects if Unfocused\0" as *const u8
                    as *const libc::c_char,
                itemaction: &cv_playsoundsifunfocused as *const consvar_t
                    as *mut consvar_t as *mut libc::c_void,
                alphaKey: (32 as libc::c_int + 0 as libc::c_int + 12 as libc::c_int)
                    as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Play Music if Unfocused\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_playmusicifunfocused as *const consvar_t
                    as *mut consvar_t as *mut libc::c_void,
                alphaKey: (32 as libc::c_int + 0 as libc::c_int + 22 as libc::c_int)
                    as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Let Levels Force Reset Music\0" as *const u8
                    as *const libc::c_char,
                itemaction: &cv_resetmusicbyheader as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: (32 as libc::c_int + 0 as libc::c_int + 32 as libc::c_int)
                    as uint16_t,
            };
            init
        },
    ]
};
static mut OP_DataOptionsMenu: [menuitem_t; 3] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Add-on Options...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_AddonsOptions as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Screenshot Options...\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_ScreenshotOptions as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\x85Erase Data...\0" as *const u8 as *const libc::c_char,
                itemaction: &OP_EraseDataDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 40 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_ScreenshotOptionsMenu: [menuitem_t; 21] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"General\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Use color profile\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_screenshot_colorprofile as *const consvar_t
                    as *mut consvar_t as *mut libc::c_void,
                alphaKey: 6 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Screenshots (F8)\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Storage Location\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_screenshot_option as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 22 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 1024 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Custom Folder\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_screenshot_folder as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 27 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Memory Level\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_zlib_memory as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 42 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Compression Level\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_zlib_level as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 47 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Strategy\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_zlib_strategy as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 52 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Window Size\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_zlib_window_bits as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 57 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Movie Mode (F9)\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 64 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Storage Location\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_movie_option as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 70 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 1024 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Custom Folder\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_movie_folder as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 75 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Capture Mode\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_moviemode as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Downscaling\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_gif_downscale as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 95 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Region Optimizing\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_gif_optimize as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Local Color Table\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_gif_localcolortable as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 105 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Downscaling\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_apng_downscale as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 95 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Memory Level\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_zlib_memorya as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Compression Level\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_zlib_levela as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 105 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Strategy\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_zlib_strategya as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 110 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Window Size\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_zlib_window_bitsa as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 115 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_EraseDataMenu: [menuitem_t; 3] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Erase Record Data\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_EraseData as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 10 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Erase Extras Data\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_EraseData as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 20 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\x85Erase ALL Data\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_EraseData as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 40 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_AddonsOptionsMenu: [menuitem_t; 8] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Menu\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Location\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_addons_option as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 12 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 1024 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Custom Folder\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_addons_folder as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 22 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Identify add-ons via\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_addons_md5 as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Show unsupported file types\0" as *const u8
                    as *const libc::c_char,
                itemaction: &cv_addons_showall as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Search\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 78 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Matching\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_addons_search_type as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Case-sensitive\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_addons_search_case as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_ServerOptionsMenu: [menuitem_t; 40] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"General\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 1024 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Server name\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_servername as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 7 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Max Players\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_maxplayers as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 21 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Allow Add-on Downloading\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_downloading as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 26 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Allow players to join\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_allownewplayer as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 31 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Minutes for reconnecting\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_rejointimeout as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 36 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Map progression\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_advancemap as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 41 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Intermission Timer\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_inttime as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 46 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Characters\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 55 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Force a character\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_forceskin as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 61 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Restrict character changes\0" as *const u8
                    as *const libc::c_char,
                itemaction: &cv_restrictskinchange as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 66 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Items\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 75 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Item respawn delay\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_itemrespawntime as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 81 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 6 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Mystery Item Monitor Toggles...\0" as *const u8
                    as *const libc::c_char,
                itemaction: &OP_MonitorToggleDef as *const menu_t as *mut menu_t
                    as *mut libc::c_void,
                alphaKey: 86 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Cooperative\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 95 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Players required for exit\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_playersforexit as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 101 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Starposts\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_coopstarposts as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 106 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Life sharing\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_cooplives as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 111 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Post-goal free roaming\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_exitmove as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 116 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Race, Competition\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 125 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Level completion countdown\0" as *const u8
                    as *const libc::c_char,
                itemaction: &cv_countdowntime as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 131 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Item Monitors\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_competitionboxes as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 136 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Ringslinger (Match, CTF, Tag, H&S)\0" as *const u8
                    as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 145 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Time Limit\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_timelimit as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 151 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Score Limit\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_pointlimit as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 156 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Overtime on Tie\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_overtime as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 161 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Player respawn delay\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_respawntime as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 166 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Item Monitors\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_matchboxes as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 176 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Weapon Rings\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_specialrings as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 181 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Power Stones\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_powerstones as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 186 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Flag respawn delay\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_flagtime as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 196 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Hiding time\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_hidetime as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 201 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Teams\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 210 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Autobalance sizes\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_autobalance as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 216 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Scramble on Map Change\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_scrambleonchange as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 221 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Advanced\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *const libc::c_void as *mut libc::c_void,
                alphaKey: 230 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 1024 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Master server\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_masterserver as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 236 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Join delay\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_joindelay as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 251 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Attempts to resynchronise\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_resynchattempts as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 256 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Show IP Address of Joiners\0" as *const u8
                    as *const libc::c_char,
                itemaction: &cv_showjoinaddress as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 261 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
static mut OP_MonitorToggleMenu: [menuitem_t; 13] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Reset to defaults\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn() -> ()>,
                    *mut libc::c_void,
                >(Some(M_ResetCvars as unsafe extern "C" fn() -> ())),
                alphaKey: 15 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Recycler\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_recycler as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Teleport\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_teleporters as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 40 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Super Ring\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_superring as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 50 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Super Sneakers\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_supersneakers as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Invincibility\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_invincibility as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 70 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Whirlwind Shield\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_jumpshield as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 80 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Elemental Shield\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_watershield as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 90 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Attraction Shield\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_ringshield as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 100 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Force Shield\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_forceshield as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 110 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Armageddon Shield\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_bombshield as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 120 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"1 Up\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_1up as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 130 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 2560 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Eggman Box\0" as *const u8 as *const libc::c_char,
                itemaction: &cv_eggmanbox as *const consvar_t as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 140 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
#[no_mangle]
pub static mut MainDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MISC_AddonsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MAPauseDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SPauseDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MPauseDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MISC_ScrambleTeamDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MISC_ChangeTeamDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MISC_ChangeLevelDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MISC_HelpDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut highlightflags: int32_t = 0;
static mut recommendedflags: int32_t = 0;
static mut warningflags: int32_t = 0;
#[no_mangle]
pub static mut SR_PandoraDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SR_MainDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SR_LevelSelectDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SR_UnlockChecklistDef: menu_t = unsafe {
    {
        let mut init = menu_s {
            menuid: (MN_SR_MAIN as libc::c_int
                | (MN_SR_UNLOCKCHECKLIST as libc::c_int) << 6 as libc::c_int)
                as uint32_t,
            menutitlepic: b"M_SECRET\0" as *const u8 as *const libc::c_char,
            numitems: 1 as libc::c_int as int16_t,
            prevMenu: &SR_MainDef as *const menu_t as *mut menu_t,
            menuitems: SR_UnlockChecklistMenu.as_ptr() as *mut _,
            drawroutine: Some(M_DrawChecklist as unsafe extern "C" fn() -> ()),
            x: 30 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    }
};
#[no_mangle]
pub static mut SR_SoundTestDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SR_EmblemHintDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SP_MainDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SP_LoadDef: menu_t = unsafe {
    {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_LOAD as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_PICKG\0" as *const u8 as *const libc::c_char,
            numitems: 1 as libc::c_int as int16_t,
            prevMenu: &SP_MainDef as *const menu_t as *mut menu_t,
            menuitems: SP_LoadGameMenu.as_ptr() as *mut _,
            drawroutine: Some(M_DrawLoad as unsafe extern "C" fn() -> ()),
            x: 68 as libc::c_int as int16_t,
            y: 46 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    }
};
#[no_mangle]
pub static mut SP_LevelSelectDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SP_PauseLevelSelectDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SP_LevelStatsDef: menu_t = unsafe {
    {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_LEVELSTATS as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_STATS\0" as *const u8 as *const libc::c_char,
            numitems: 1 as libc::c_int as int16_t,
            prevMenu: &SP_MainDef as *const menu_t as *mut menu_t,
            menuitems: SP_LevelStatsMenu.as_ptr() as *mut _,
            drawroutine: Some(M_DrawLevelStats as unsafe extern "C" fn() -> ()),
            x: 280 as libc::c_int as int16_t,
            y: 185 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    }
};
#[no_mangle]
pub static mut SP_TimeAttackLevelSelectDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut SP_TimeAttackDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut SP_ReplayDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut SP_GuestReplayDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut SP_GhostDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SP_NightsAttackLevelSelectDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut SP_NightsAttackDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut SP_NightsReplayDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut SP_NightsGuestReplayDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut SP_NightsGhostDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut SP_MarathonDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut SP_PlayerDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MP_SplitServerDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MP_MainDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MP_ServerDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MP_ConnectDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MP_RoomDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut MP_PlayerSetupDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_MainDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_ChangeControlsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_P1ControlsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_P2ControlsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_MouseOptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_Mouse2OptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_Joystick1Def: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_Joystick2Def: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_JoystickSetDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_CameraOptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_Camera2OptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
static mut OP_PlaystyleMenu: [menuitem_t; 1] = unsafe {
    [
        {
            let mut init = menuitem_s {
                status: (4 as libc::c_int | 0 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"\0" as *const u8 as *const libc::c_char,
                itemaction: ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_HandlePlaystyleMenu as unsafe extern "C" fn(int32_t) -> ())),
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
    ]
};
#[no_mangle]
pub static mut OP_PlaystyleDef: menu_t = unsafe {
    {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_P1CONTROLS as libc::c_int
                    | (MN_OP_PLAYSTYLE as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: 1 as libc::c_int as int16_t,
            prevMenu: &OP_P1ControlsDef as *const menu_t as *mut menu_t,
            menuitems: OP_PlaystyleMenu.as_ptr() as *mut _,
            drawroutine: Some(M_DrawPlaystyleMenu as unsafe extern "C" fn() -> ()),
            x: 0 as libc::c_int as int16_t,
            y: 0 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    }
};
unsafe extern "C" fn M_VideoOptions(mut choice: int32_t) {
    OP_VideoOptionsMenu[op_video_renderer as libc::c_int as usize]
        .status = (16 as libc::c_int + 128 as libc::c_int | 11 as libc::c_int)
        as uint16_t;
    OP_VideoOptionsMenu[op_video_renderer as libc::c_int as usize]
        .patch = b"Renderer\0" as *const u8 as *const libc::c_char;
    OP_VideoOptionsMenu[op_video_renderer as libc::c_int as usize]
        .text = b"Software\0" as *const u8 as *const libc::c_char;
    M_SetupNextMenu(&mut OP_VideoOptionsDef);
}
#[no_mangle]
pub static mut OP_VideoOptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_VideoModeDef: menu_t = unsafe {
    {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_VIDEO as libc::c_int
                    | (MN_OP_VIDEOMODE as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_VIDEO\0" as *const u8 as *const libc::c_char,
            numitems: 1 as libc::c_int as int16_t,
            prevMenu: &OP_VideoOptionsDef as *const menu_t as *mut menu_t,
            menuitems: OP_VideoModeMenu.as_ptr() as *mut _,
            drawroutine: Some(M_DrawVideoMode as unsafe extern "C" fn() -> ()),
            x: 48 as libc::c_int as int16_t,
            y: 26 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    }
};
#[no_mangle]
pub static mut OP_ColorOptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_SoundOptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_SoundAdvancedDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_ServerOptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_MonitorToggleDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_DataOptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_ScreenshotOptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_AddonsOptionsDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub static mut OP_EraseDataDef: menu_t = menu_s {
    menuid: 0,
    menutitlepic: 0 as *const libc::c_char,
    numitems: 0,
    prevMenu: 0 as *const menu_s as *mut menu_s,
    menuitems: 0 as *const menuitem_t as *mut menuitem_t,
    drawroutine: None,
    x: 0,
    y: 0,
    lastOn: 0,
    quitroutine: None,
};
#[no_mangle]
pub unsafe extern "C" fn Nextmap_OnChange() {
    let mut data: *mut gamedata_t = clientGamedata;
    let mut leveltitle: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tabase: [libc::c_char; 256] = [0; 256];
    let mut tabaseold: [libc::c_char; 256] = [0; 256];
    let mut i: libc::c_short = 0;
    let mut active: boolean = 0;
    Z_Free(cv_nextmap.zstring as *mut libc::c_void);
    leveltitle = G_BuildMapTitle(cv_nextmap.value);
    cv_nextmap
        .zstring = if !leveltitle.is_null() {
        leveltitle
    } else {
        Z_StrDup(G_BuildMapName(cv_nextmap.value))
    };
    cv_nextmap.string = cv_nextmap.zstring;
    if currentMenu == &mut SP_NightsAttackDef as *mut menu_t {
        CV_StealthSetValue(&mut cv_dummymares, 0 as libc::c_int);
        if ((*data).nightsrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
            .is_null()
            || ((*(*data).nightsrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
                .nummares as libc::c_int) < 2 as libc::c_int
        {
            SP_NightsAttackMenu[narecords as libc::c_int as usize]
                .status = (1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                as uint16_t;
        } else {
            SP_NightsAttackMenu[narecords as libc::c_int as usize]
                .status = (32 as libc::c_int | 8 as libc::c_int) as uint16_t;
        }
        active = false_0 as libc::c_int;
        SP_NightsAttackMenu[naguest as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        SP_NightsAttackMenu[nareplay as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        SP_NightsAttackMenu[naghost as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        sprintf(
            tabase.as_mut_ptr(),
            b"%s/replay/%s/%s-%s\0" as *const u8 as *const libc::c_char,
            srb2home.as_mut_ptr(),
            timeattackfolder.as_mut_ptr(),
            G_BuildMapName(cv_nextmap.value),
            (skins[(cv_chooseskin.value - 1 as libc::c_int) as usize].name).as_mut_ptr(),
        );
        sprintf(
            tabaseold.as_mut_ptr(),
            b"%s/replay/%s/%s\0" as *const u8 as *const libc::c_char,
            srb2home.as_mut_ptr(),
            timeattackfolder.as_mut_ptr(),
            G_BuildMapName(cv_nextmap.value),
        );
        i = 0 as libc::c_int as libc::c_short;
        while (i as libc::c_int) < 4 as libc::c_int {
            SP_NightsReplayMenu[i as usize]
                .status = (1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                as uint16_t;
            SP_NightsGuestReplayMenu[i as usize]
                .status = (1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                as uint16_t;
            i += 1;
            i;
        }
        if FIL_FileExists(
            va(
                b"%s-score-best.lmp\0" as *const u8 as *const libc::c_char,
                tabase.as_mut_ptr(),
            ),
        ) != 0
        {
            SP_NightsReplayMenu[0 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_NightsGuestReplayMenu[0 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if FIL_FileExists(
            va(
                b"%s-time-best.lmp\0" as *const u8 as *const libc::c_char,
                tabase.as_mut_ptr(),
            ),
        ) != 0
        {
            SP_NightsReplayMenu[1 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_NightsGuestReplayMenu[1 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if FIL_FileExists(
            va(b"%s-last.lmp\0" as *const u8 as *const libc::c_char, tabase.as_mut_ptr()),
        ) != 0
        {
            SP_NightsReplayMenu[2 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_NightsGuestReplayMenu[2 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if FIL_FileExists(
            va(
                b"%s/replay/%s/%s-guest.lmp\0" as *const u8 as *const libc::c_char,
                srb2home.as_mut_ptr(),
                timeattackfolder.as_mut_ptr(),
                G_BuildMapName(cv_nextmap.value),
            ),
        ) != 0
        {
            SP_NightsReplayMenu[3 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_NightsGuestReplayMenu[3 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if FIL_FileExists(
            va(
                b"%s-score-best.lmp\0" as *const u8 as *const libc::c_char,
                tabaseold.as_mut_ptr(),
            ),
        ) != 0
        {
            SP_NightsReplayMenu[0 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_NightsGuestReplayMenu[0 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if FIL_FileExists(
            va(
                b"%s-time-best.lmp\0" as *const u8 as *const libc::c_char,
                tabaseold.as_mut_ptr(),
            ),
        ) != 0
        {
            SP_NightsReplayMenu[1 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_NightsGuestReplayMenu[1 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if FIL_FileExists(
            va(
                b"%s-last.lmp\0" as *const u8 as *const libc::c_char,
                tabaseold.as_mut_ptr(),
            ),
        ) != 0
        {
            SP_NightsReplayMenu[2 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_NightsGuestReplayMenu[2 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if active != 0 {
            SP_NightsAttackMenu[naguest as libc::c_int as usize]
                .status = (48 as libc::c_int | 6 as libc::c_int) as uint16_t;
            SP_NightsAttackMenu[nareplay as libc::c_int as usize]
                .status = (48 as libc::c_int | 6 as libc::c_int) as uint16_t;
            SP_NightsAttackMenu[naghost as libc::c_int as usize]
                .status = (48 as libc::c_int | 6 as libc::c_int) as uint16_t;
        } else if itemOn as libc::c_int == nareplay as libc::c_int {
            (*currentMenu).lastOn = itemOn;
            itemOn = nastart as libc::c_int as int16_t;
        }
    } else if currentMenu == &mut SP_TimeAttackDef as *mut menu_t {
        active = false_0 as libc::c_int;
        SP_TimeAttackMenu[taguest as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        SP_TimeAttackMenu[tareplay as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        SP_TimeAttackMenu[taghost as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        sprintf(
            tabase.as_mut_ptr(),
            b"%s/replay/%s/%s-%s\0" as *const u8 as *const libc::c_char,
            srb2home.as_mut_ptr(),
            timeattackfolder.as_mut_ptr(),
            G_BuildMapName(cv_nextmap.value),
            (skins[(cv_chooseskin.value - 1 as libc::c_int) as usize].name).as_mut_ptr(),
        );
        i = 0 as libc::c_int as libc::c_short;
        while (i as libc::c_int) < 5 as libc::c_int {
            SP_ReplayMenu[i as usize]
                .status = (1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                as uint16_t;
            SP_GuestReplayMenu[i as usize]
                .status = (1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                as uint16_t;
            i += 1;
            i;
        }
        if FIL_FileExists(
            va(
                b"%s-time-best.lmp\0" as *const u8 as *const libc::c_char,
                tabase.as_mut_ptr(),
            ),
        ) != 0
        {
            SP_ReplayMenu[0 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_GuestReplayMenu[0 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if FIL_FileExists(
            va(
                b"%s-score-best.lmp\0" as *const u8 as *const libc::c_char,
                tabase.as_mut_ptr(),
            ),
        ) != 0
        {
            SP_ReplayMenu[1 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_GuestReplayMenu[1 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if FIL_FileExists(
            va(
                b"%s-rings-best.lmp\0" as *const u8 as *const libc::c_char,
                tabase.as_mut_ptr(),
            ),
        ) != 0
        {
            SP_ReplayMenu[2 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_GuestReplayMenu[2 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if FIL_FileExists(
            va(b"%s-last.lmp\0" as *const u8 as *const libc::c_char, tabase.as_mut_ptr()),
        ) != 0
        {
            SP_ReplayMenu[3 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_GuestReplayMenu[3 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if FIL_FileExists(
            va(
                b"%s/replay/%s/%s-guest.lmp\0" as *const u8 as *const libc::c_char,
                srb2home.as_mut_ptr(),
                timeattackfolder.as_mut_ptr(),
                G_BuildMapName(cv_nextmap.value),
            ),
        ) != 0
        {
            SP_ReplayMenu[4 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            SP_GuestReplayMenu[4 as libc::c_int as usize]
                .status = (48 as libc::c_int | 0 as libc::c_int) as uint16_t;
            active = true_0 as libc::c_int;
        }
        if active != 0 {
            SP_TimeAttackMenu[taguest as libc::c_int as usize]
                .status = (48 as libc::c_int | 6 as libc::c_int) as uint16_t;
            SP_TimeAttackMenu[tareplay as libc::c_int as usize]
                .status = (48 as libc::c_int | 6 as libc::c_int) as uint16_t;
            SP_TimeAttackMenu[taghost as libc::c_int as usize]
                .status = (48 as libc::c_int | 6 as libc::c_int) as uint16_t;
        } else if itemOn as libc::c_int == tareplay as libc::c_int {
            (*currentMenu).lastOn = itemOn;
            itemOn = tastart as libc::c_int as int16_t;
        }
        if !(mapheaderinfo[(cv_nextmap.value - 1 as libc::c_int) as usize]).is_null()
            && (*mapheaderinfo[(cv_nextmap.value - 1 as libc::c_int) as usize])
                .forcecharacter[0 as libc::c_int as usize] as libc::c_int != '\0' as i32
        {
            CV_Set(
                &mut cv_chooseskin,
                ((*mapheaderinfo[(cv_nextmap.value - 1 as libc::c_int) as usize])
                    .forcecharacter)
                    .as_mut_ptr(),
            );
        }
    }
}
unsafe extern "C" fn Dummymares_OnChange() {
    let mut data: *mut gamedata_t = clientGamedata;
    if ((*data).nightsrecords[(cv_nextmap.value - 1 as libc::c_int) as usize]).is_null()
    {
        CV_StealthSetValue(&mut cv_dummymares, 0 as libc::c_int);
        return;
    } else {
        let mut mares: uint8_t = (*(*data)
            .nightsrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
            .nummares;
        if cv_dummymares.value < 0 as libc::c_int {
            CV_StealthSetValue(&mut cv_dummymares, mares as int32_t);
        } else if cv_dummymares.value > mares as libc::c_int {
            CV_StealthSetValue(&mut cv_dummymares, 0 as libc::c_int);
        }
    };
}
unsafe extern "C" fn Newgametype_OnChange() {
    if menuactive != 0 {
        if (mapheaderinfo[(cv_nextmap.value - 1 as libc::c_int) as usize]).is_null() {
            P_AllocMapHeader((cv_nextmap.value - 1 as libc::c_int) as int16_t);
        }
        if M_CanShowLevelOnPlatter(
            cv_nextmap.value - 1 as libc::c_int,
            cv_newgametype.value,
        ) == 0
        {
            CV_SetValue(&mut cv_nextmap, M_GetFirstLevelInList(cv_newgametype.value));
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn Screenshot_option_Onchange() {
    OP_ScreenshotOptionsMenu[op_screenshot_folder as libc::c_int as usize]
        .status = (if cv_screenshot_option.value == 3 as libc::c_int {
        8 as libc::c_int | 32 as libc::c_int | 1024 as libc::c_int
    } else {
        1 as libc::c_int + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
    }) as uint16_t;
}
#[no_mangle]
pub unsafe extern "C" fn Moviemode_mode_Onchange() {
    let mut i: int32_t = 0;
    let mut cstart: int32_t = 0;
    let mut cend: int32_t = 0;
    i = op_screenshot_gif_start as libc::c_int;
    while i <= op_screenshot_apng_end as libc::c_int {
        OP_ScreenshotOptionsMenu[i as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        i += 1;
        i;
    }
    match cv_moviemode.value {
        2 => {
            cstart = op_screenshot_gif_start as libc::c_int;
            cend = op_screenshot_gif_end as libc::c_int;
        }
        1 => {
            cstart = op_screenshot_apng_start as libc::c_int;
            cend = op_screenshot_apng_end as libc::c_int;
        }
        _ => return,
    }
    i = cstart;
    while i <= cend {
        OP_ScreenshotOptionsMenu[i as usize]
            .status = (32 as libc::c_int | 8 as libc::c_int) as uint16_t;
        i += 1;
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn Addons_option_Onchange() {
    OP_AddonsOptionsMenu[op_addons_folder as libc::c_int as usize]
        .status = (if cv_addons_option.value == 3 as libc::c_int {
        8 as libc::c_int | 32 as libc::c_int | 1024 as libc::c_int
    } else {
        1 as libc::c_int + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
    }) as uint16_t;
}
#[no_mangle]
pub unsafe extern "C" fn Moviemode_option_Onchange() {
    OP_ScreenshotOptionsMenu[op_movie_folder as libc::c_int as usize]
        .status = (if cv_movie_option.value == 3 as libc::c_int {
        8 as libc::c_int | 32 as libc::c_int | 1024 as libc::c_int
    } else {
        1 as libc::c_int + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
    }) as uint16_t;
}
#[no_mangle]
pub static mut currentMenu: *mut menu_t = unsafe {
    &MainDef as *const menu_t as *mut menu_t
};
#[no_mangle]
pub static mut prevMenuId: uint32_t = 0 as libc::c_int as uint32_t;
#[no_mangle]
pub static mut activeMenuId: uint32_t = 0 as libc::c_int as uint32_t;
#[no_mangle]
pub static mut menupres: [menupres_t; 58] = [menupres_t {
    bgname: [0; 8],
    fadestrength: 0,
    bgcolor: 0,
    titlescrollxspeed: 0,
    titlescrollyspeed: 0,
    bghide: 0,
    hidetitlepics: 0,
    ttmode: TTMODE_NONE,
    ttscale: 0,
    ttname: [0; 9],
    ttx: 0,
    tty: 0,
    ttloop: 0,
    tttics: 0,
    musname: [0; 7],
    mustrack: 0,
    muslooping: 0,
    musstop: 0,
    musignore: 0,
    enterbubble: 0,
    exitbubble: 0,
    entertag: 0,
    exittag: 0,
    enterwipe: 0,
    exitwipe: 0,
}; 58];
#[no_mangle]
pub unsafe extern "C" fn M_InitMenuPresTables() {
    let mut i: int32_t = 0;
    i = 0 as libc::c_int;
    while i < NUMMENUTYPES as libc::c_int {
        menupres[i as usize].fadestrength = -(1 as libc::c_int) as int8_t;
        menupres[i as usize].hidetitlepics = -(1 as libc::c_int) as int8_t;
        menupres[i as usize].ttmode = TTMODE_NONE;
        menupres[i as usize].ttscale = 255 as libc::c_int as uint8_t;
        menupres[i as usize]
            .ttname[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        menupres[i as usize].ttx = 32767 as libc::c_int as int16_t;
        menupres[i as usize].tty = 32767 as libc::c_int as int16_t;
        menupres[i as usize].ttloop = 32767 as libc::c_int as int16_t;
        menupres[i as usize].tttics = 65535 as libc::c_int as uint16_t;
        menupres[i as usize].enterwipe = -(1 as libc::c_int) as int16_t;
        menupres[i as usize].exitwipe = -(1 as libc::c_int) as int16_t;
        menupres[i as usize].bgcolor = -(1 as libc::c_int);
        menupres[i as usize].titlescrollxspeed = 2147483647 as libc::c_int;
        menupres[i as usize].titlescrollyspeed = 2147483647 as libc::c_int;
        menupres[i as usize].bghide = true_0 as libc::c_int;
        menupres[i as usize].enterbubble = true_0 as libc::c_int;
        menupres[i as usize].exitbubble = true_0 as libc::c_int;
        if i != MN_MAIN as libc::c_int {
            menupres[i as usize].muslooping = true_0 as libc::c_int;
        }
        if i == MN_SP_TIMEATTACK as libc::c_int {
            strncpy(
                (menupres[i as usize].musname).as_mut_ptr(),
                b"_recat\0" as *const u8 as *const libc::c_char,
                7 as libc::c_int as libc::c_ulong,
            );
        } else if i == MN_SP_NIGHTSATTACK as libc::c_int {
            strncpy(
                (menupres[i as usize].musname).as_mut_ptr(),
                b"_nitat\0" as *const u8 as *const libc::c_char,
                7 as libc::c_int as libc::c_ulong,
            );
        } else if i == MN_SP_MARATHON as libc::c_int {
            strncpy(
                (menupres[i as usize].musname).as_mut_ptr(),
                b"spec8\0" as *const u8 as *const libc::c_char,
                6 as libc::c_int as libc::c_ulong,
            );
        } else if i == MN_SP_PLAYER as libc::c_int || i == MN_SR_PLAYER as libc::c_int {
            strncpy(
                (menupres[i as usize].musname).as_mut_ptr(),
                b"_chsel\0" as *const u8 as *const libc::c_char,
                7 as libc::c_int as libc::c_ulong,
            );
        } else if i == MN_SR_SOUNDTEST as libc::c_int {
            *(menupres[i as usize].musname).as_mut_ptr() = '\0' as i32 as libc::c_char;
            menupres[i as usize].musstop = true_0 as libc::c_int;
        }
        i += 1;
        i;
    }
}
unsafe extern "C" fn M_IterateMenuTree(
    mut itfunc: menutree_iterator,
    mut input: *mut libc::c_void,
) -> int32_t {
    let mut i: int32_t = 0;
    let mut retval: int32_t = 0 as libc::c_int;
    let mut bitmask: uint32_t = 0;
    let mut menutype: uint32_t = 0;
    i = 3 as libc::c_int;
    while i >= 0 as libc::c_int {
        bitmask = ((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
            << 6 as libc::c_int * i) as uint32_t;
        menutype = (activeMenuId & bitmask) >> 6 as libc::c_int * i;
        if itfunc
            .expect(
                "non-null function pointer",
            )(menutype, i, &mut retval, &mut input, false_0 as libc::c_int) != 0
        {
            break;
        }
        i -= 1;
        i;
    }
    return retval;
}
unsafe extern "C" fn MIT_GetMenuAtLevel(
    mut menutype: uint32_t,
    mut level: int32_t,
    mut retval: *mut int32_t,
    mut input: *mut *mut libc::c_void,
    mut fromoldest: boolean,
) -> boolean {
    let mut inputptr: *mut int32_t = *input as *mut int32_t;
    let mut targetlevel: int32_t = *inputptr;
    if menutype != 0 {
        if level == targetlevel || targetlevel < 0 as libc::c_int {
            *retval = menutype as int32_t;
            return true_0 as libc::c_int;
        }
    } else if targetlevel >= 0 as libc::c_int {
        if fromoldest != 0 {
            *inputptr += 1;
            *inputptr;
        } else {
            *inputptr -= 1;
            *inputptr;
        }
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn MIT_SetCurBackground(
    mut menutype: uint32_t,
    mut level: int32_t,
    mut retval: *mut int32_t,
    mut input: *mut *mut libc::c_void,
    mut fromoldest: boolean,
) -> boolean {
    let mut defaultname: *mut libc::c_char = *input as *mut libc::c_char;
    if menutype == 0 {
        return false_0 as libc::c_int;
    }
    if menupres[menutype as usize].bgcolor >= 0 as libc::c_int {
        curbgcolor = menupres[menutype as usize].bgcolor;
        return true_0 as libc::c_int;
    } else if menupres[menutype as usize].bghide != 0
        && titlemapinaction as libc::c_int != 0
    {
        curbghide = true_0 as libc::c_int;
        return true_0 as libc::c_int;
    } else if menupres[menutype as usize].bgname[0 as libc::c_int as usize] != 0 {
        strncpy(
            curbgname.as_mut_ptr(),
            (menupres[menutype as usize].bgname).as_mut_ptr(),
            8 as libc::c_int as libc::c_ulong,
        );
        curbgxspeed = if menupres[menutype as usize].titlescrollxspeed
            != 2147483647 as libc::c_int
        {
            menupres[menutype as usize].titlescrollxspeed
        } else {
            titlescrollxspeed
        };
        curbgyspeed = if menupres[menutype as usize].titlescrollyspeed
            != 2147483647 as libc::c_int
        {
            menupres[menutype as usize].titlescrollyspeed
        } else {
            titlescrollyspeed
        };
        return true_0 as libc::c_int;
    } else if level == 0 {
        if M_GetYoungestChildMenu() as libc::c_int == MN_SP_PLAYER as libc::c_int
            || defaultname.is_null()
            || *defaultname.offset(0 as libc::c_int as isize) == 0
        {
            curbgcolor = 31 as libc::c_int;
        } else if titlemapinaction != 0 {
            curbghide = true_0 as libc::c_int;
        } else {
            strncpy(
                curbgname.as_mut_ptr(),
                defaultname,
                9 as libc::c_int as libc::c_ulong,
            );
            curbgxspeed = if gamestate as libc::c_uint
                == GS_TIMEATTACK as libc::c_int as libc::c_uint
            {
                0 as libc::c_int
            } else {
                titlescrollxspeed
            };
            curbgyspeed = if gamestate as libc::c_uint
                == GS_TIMEATTACK as libc::c_int as libc::c_uint
            {
                18 as libc::c_int
            } else {
                titlescrollyspeed
            };
        }
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn MIT_ChangeMusic(
    mut menutype: uint32_t,
    mut level: int32_t,
    mut retval: *mut int32_t,
    mut input: *mut *mut libc::c_void,
    mut fromoldest: boolean,
) -> boolean {
    let mut defaultmusic: *mut menupresmusic_t = *input as *mut menupresmusic_t;
    if menutype == 0 {
        return false_0 as libc::c_int;
    }
    if menupres[menutype as usize].musname[0 as libc::c_int as usize] != 0 {
        S_ChangeMusicEx(
            (menupres[menutype as usize].musname).as_mut_ptr(),
            menupres[menutype as usize].mustrack,
            menupres[menutype as usize].muslooping,
            0 as libc::c_int as uint32_t,
            0 as libc::c_int as uint32_t,
            0 as libc::c_int as uint32_t,
        );
        return true_0 as libc::c_int;
    } else if menupres[menutype as usize].musstop != 0 {
        S_StopMusic();
        return true_0 as libc::c_int;
    } else if menupres[menutype as usize].musignore != 0 {
        return true_0 as libc::c_int
    } else if level == 0 && !defaultmusic.is_null()
        && (*defaultmusic).musname[0 as libc::c_int as usize] as libc::c_int != 0
    {
        S_ChangeMusicEx(
            ((*defaultmusic).musname).as_mut_ptr(),
            (*defaultmusic).mustrack,
            (*defaultmusic).muslooping,
            0 as libc::c_int as uint32_t,
            0 as libc::c_int as uint32_t,
            0 as libc::c_int as uint32_t,
        );
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn MIT_SetCurFadeValue(
    mut menutype: uint32_t,
    mut level: int32_t,
    mut retval: *mut int32_t,
    mut input: *mut *mut libc::c_void,
    mut fromoldest: boolean,
) -> boolean {
    let mut defaultvalue: uint8_t = *(*input as *mut uint8_t);
    if menutype == 0 {
        return false_0 as libc::c_int;
    }
    if menupres[menutype as usize].fadestrength as libc::c_int >= 0 as libc::c_int {
        curfadevalue = (menupres[menutype as usize].fadestrength as libc::c_int
            % 32 as libc::c_int) as int8_t;
        return true_0 as libc::c_int;
    } else if level == 0 {
        curfadevalue = (if gamestate as libc::c_uint
            == GS_TIMEATTACK as libc::c_int as libc::c_uint
        {
            0 as libc::c_int
        } else {
            defaultvalue as libc::c_int % 32 as libc::c_int
        }) as int8_t;
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn MIT_SetCurTitlePics(
    mut menutype: uint32_t,
    mut level: int32_t,
    mut retval: *mut int32_t,
    mut input: *mut *mut libc::c_void,
    mut fromoldest: boolean,
) -> boolean {
    if menutype == 0 {
        return false_0 as libc::c_int;
    }
    if menupres[menutype as usize].hidetitlepics as libc::c_int >= 0 as libc::c_int {
        curhidepics = menupres[menutype as usize].hidetitlepics as boolean;
        return true_0 as libc::c_int;
    } else if menupres[menutype as usize].ttmode as libc::c_uint
        == TTMODE_USER as libc::c_int as libc::c_uint
    {
        if menupres[menutype as usize].ttname[0 as libc::c_int as usize] != 0 {
            curhidepics = menupres[menutype as usize].hidetitlepics as boolean;
            curttmode = menupres[menutype as usize].ttmode;
            curttscale = (if menupres[menutype as usize].ttscale as libc::c_int
                != 255 as libc::c_int
            {
                menupres[menutype as usize].ttscale as libc::c_int
            } else {
                ttscale as libc::c_int
            }) as uint8_t;
            strncpy(
                curttname.as_mut_ptr(),
                (menupres[menutype as usize].ttname).as_mut_ptr(),
                9 as libc::c_int as libc::c_ulong,
            );
            curttx = (if menupres[menutype as usize].ttx as libc::c_int
                != 32767 as libc::c_int
            {
                menupres[menutype as usize].ttx as libc::c_int
            } else {
                ttx as libc::c_int
            }) as int16_t;
            curtty = (if menupres[menutype as usize].tty as libc::c_int
                != 32767 as libc::c_int
            {
                menupres[menutype as usize].tty as libc::c_int
            } else {
                tty as libc::c_int
            }) as int16_t;
            curttloop = (if menupres[menutype as usize].ttloop as libc::c_int
                != 32767 as libc::c_int
            {
                menupres[menutype as usize].ttloop as libc::c_int
            } else {
                ttloop as libc::c_int
            }) as int16_t;
            curtttics = (if menupres[menutype as usize].tttics as libc::c_int
                != 65535 as libc::c_int
            {
                menupres[menutype as usize].tttics as libc::c_int
            } else {
                tttics as libc::c_int
            }) as uint16_t;
        } else {
            curhidepics = menupres[menutype as usize].hidetitlepics as boolean;
        }
        return true_0 as libc::c_int;
    } else if menupres[menutype as usize].ttmode as libc::c_uint
        != TTMODE_NONE as libc::c_int as libc::c_uint
    {
        curhidepics = menupres[menutype as usize].hidetitlepics as boolean;
        curttmode = menupres[menutype as usize].ttmode;
        curttscale = (if menupres[menutype as usize].ttscale as libc::c_int
            != 255 as libc::c_int
        {
            menupres[menutype as usize].ttscale as libc::c_int
        } else {
            ttscale as libc::c_int
        }) as uint8_t;
        return true_0 as libc::c_int;
    } else if level == 0 {
        curhidepics = hidetitlepics;
        curttmode = ttmode;
        curttscale = ttscale;
        strncpy(
            curttname.as_mut_ptr(),
            ttname.as_mut_ptr(),
            9 as libc::c_int as libc::c_ulong,
        );
        curttx = ttx;
        curtty = tty;
        curttloop = ttloop;
        curtttics = tttics;
    }
    return false_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn M_GetYoungestChildMenu() -> uint8_t {
    let mut targetlevel: int32_t = -(1 as libc::c_int);
    return M_IterateMenuTree(
        Some(
            MIT_GetMenuAtLevel
                as unsafe extern "C" fn(
                    uint32_t,
                    int32_t,
                    *mut int32_t,
                    *mut *mut libc::c_void,
                    boolean,
                ) -> boolean,
        ),
        &mut targetlevel as *mut int32_t as *mut libc::c_void,
    ) as uint8_t;
}
#[no_mangle]
pub unsafe extern "C" fn M_ChangeMenuMusic(
    mut defaultmusname: *const libc::c_char,
    mut defaultmuslooping: boolean,
) {
    let mut defaultmusic: menupresmusic_t = menupresmusic_t {
        musname: [0; 7],
        mustrack: 0,
        muslooping: 0,
    };
    if defaultmusname.is_null() {
        defaultmusname = b"\0" as *const u8 as *const libc::c_char;
    }
    strncpy(
        (defaultmusic.musname).as_mut_ptr(),
        defaultmusname,
        7 as libc::c_int as libc::c_ulong,
    );
    defaultmusic.musname[6 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    defaultmusic.mustrack = 0 as libc::c_int as uint16_t;
    defaultmusic.muslooping = defaultmuslooping;
    M_IterateMenuTree(
        Some(
            MIT_ChangeMusic
                as unsafe extern "C" fn(
                    uint32_t,
                    int32_t,
                    *mut int32_t,
                    *mut *mut libc::c_void,
                    boolean,
                ) -> boolean,
        ),
        &mut defaultmusic as *mut menupresmusic_t as *mut libc::c_void,
    );
}
#[no_mangle]
pub unsafe extern "C" fn M_SetMenuCurBackground(mut defaultname: *const libc::c_char) {
    let mut name: [libc::c_char; 9] = *::core::mem::transmute::<
        &[u8; 9],
        &mut [libc::c_char; 9],
    >(b"\0\0\0\0\0\0\0\0\0");
    strncpy(name.as_mut_ptr(), defaultname, 8 as libc::c_int as libc::c_ulong);
    M_IterateMenuTree(
        Some(
            MIT_SetCurBackground
                as unsafe extern "C" fn(
                    uint32_t,
                    int32_t,
                    *mut int32_t,
                    *mut *mut libc::c_void,
                    boolean,
                ) -> boolean,
        ),
        &mut name as *mut [libc::c_char; 9] as *mut libc::c_void,
    );
}
#[no_mangle]
pub unsafe extern "C" fn M_SetMenuCurFadeValue(mut defaultvalue: uint8_t) {
    M_IterateMenuTree(
        Some(
            MIT_SetCurFadeValue
                as unsafe extern "C" fn(
                    uint32_t,
                    int32_t,
                    *mut int32_t,
                    *mut *mut libc::c_void,
                    boolean,
                ) -> boolean,
        ),
        &mut defaultvalue as *mut uint8_t as *mut libc::c_void,
    );
}
#[no_mangle]
pub unsafe extern "C" fn M_SetMenuCurTitlePics() {
    M_IterateMenuTree(
        Some(
            MIT_SetCurTitlePics
                as unsafe extern "C" fn(
                    uint32_t,
                    int32_t,
                    *mut int32_t,
                    *mut *mut libc::c_void,
                    boolean,
                ) -> boolean,
        ),
        0 as *mut libc::c_void,
    );
}
static mut exitlevel: int32_t = 0;
static mut enterlevel: int32_t = 0;
static mut anceslevel: int32_t = 0;
static mut exittype: int16_t = 0;
static mut entertype: int16_t = 0;
static mut exitwipe: int16_t = 0;
static mut enterwipe: int16_t = 0;
static mut exitbubble: boolean = 0;
static mut enterbubble: boolean = 0;
static mut exittag: int16_t = 0;
static mut entertag: int16_t = 0;
unsafe extern "C" fn M_HandleMenuPresState(mut newMenu: *mut menu_t) {
    let mut i: int32_t = 0;
    let mut bitmask: uint32_t = 0;
    let mut prevtype: int8_t = 0;
    let mut activetype: int8_t = 0;
    let mut menutype: int8_t = 0;
    if newMenu.is_null() {
        return;
    }
    i = 0 as libc::c_int;
    while i <= 3 as libc::c_int {
        bitmask = ((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
            << 6 as libc::c_int * i) as uint32_t;
        menutype = (((*newMenu).menuid & bitmask) >> 6 as libc::c_int * i) as int8_t;
        prevtype = (((*currentMenu).menuid & bitmask) >> 6 as libc::c_int * i) as int8_t;
        if menutype as libc::c_int == MN_SPECIAL as libc::c_int
            || prevtype as libc::c_int == MN_SPECIAL as libc::c_int
        {
            return;
        }
        i += 1;
        i;
    }
    if !currentMenu.is_null() && !newMenu.is_null()
        && (*currentMenu).menuid == (*newMenu).menuid
    {
        return;
    }
    enterwipe = -(1 as libc::c_int) as int16_t;
    exitwipe = enterwipe;
    anceslevel = exitwipe as int32_t;
    enterlevel = anceslevel;
    exitlevel = enterlevel;
    entertype = exitlevel as int16_t;
    exittype = entertype;
    enterbubble = true_0 as libc::c_int;
    exitbubble = enterbubble;
    prevMenuId = if !currentMenu.is_null() {
        (*currentMenu).menuid
    } else {
        0 as libc::c_int as uint32_t
    };
    activeMenuId = if !newMenu.is_null() {
        (*newMenu).menuid
    } else {
        0 as libc::c_int as uint32_t
    };
    strncpy(
        curbgname.as_mut_ptr(),
        b"TITLESKY\0" as *const u8 as *const libc::c_char,
        9 as libc::c_int as libc::c_ulong,
    );
    curfadevalue = 16 as libc::c_int as int8_t;
    curhidepics = hidetitlepics;
    curbgcolor = -(1 as libc::c_int);
    curbgxspeed = if gamestate as libc::c_uint
        == GS_TIMEATTACK as libc::c_int as libc::c_uint
    {
        0 as libc::c_int
    } else {
        titlescrollxspeed
    };
    curbgyspeed = if gamestate as libc::c_uint
        == GS_TIMEATTACK as libc::c_int as libc::c_uint
    {
        18 as libc::c_int
    } else {
        titlescrollyspeed
    };
    curbghide = (gamestate as libc::c_uint
        != GS_TIMEATTACK as libc::c_int as libc::c_uint) as libc::c_int;
    curttmode = ttmode;
    curttscale = ttscale;
    strncpy(
        curttname.as_mut_ptr(),
        ttname.as_mut_ptr(),
        9 as libc::c_int as libc::c_ulong,
    );
    curttx = ttx;
    curtty = tty;
    curttloop = ttloop;
    curtttics = tttics;
    if gamestate as libc::c_uint != GS_TITLESCREEN as libc::c_int as libc::c_uint
        && gamestate as libc::c_uint != GS_TIMEATTACK as libc::c_int as libc::c_uint
    {
        return;
    }
    M_SetMenuCurFadeValue(16 as libc::c_int as uint8_t);
    M_SetMenuCurTitlePics();
    i = 3 as libc::c_int;
    while i >= 0 as libc::c_int {
        bitmask = ((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
            << 6 as libc::c_int * i) as uint32_t;
        prevtype = ((prevMenuId & bitmask) >> 6 as libc::c_int * i) as int8_t;
        activetype = ((activeMenuId & bitmask) >> 6 as libc::c_int * i) as int8_t;
        if prevtype as libc::c_int != 0 && (exittype as libc::c_int) < 0 as libc::c_int {
            exittype = prevtype as int16_t;
            exitlevel = i;
            exitwipe = menupres[exittype as usize].exitwipe;
            exitbubble = menupres[exittype as usize].exitbubble;
            exittag = menupres[exittype as usize].exittag as int16_t;
        }
        if activetype as libc::c_int != 0
            && (entertype as libc::c_int) < 0 as libc::c_int
        {
            entertype = activetype as int16_t;
            enterlevel = i;
            enterwipe = menupres[entertype as usize].enterwipe;
            enterbubble = menupres[entertype as usize].enterbubble;
            entertag = menupres[entertype as usize].entertag as int16_t;
        }
        if prevtype as libc::c_int != 0 && activetype as libc::c_int != 0
            && prevtype as libc::c_int == activetype as libc::c_int
            && anceslevel < 0 as libc::c_int
        {
            anceslevel = i;
            break;
        } else {
            i -= 1;
            i;
        }
    }
    if anceslevel < 0 as libc::c_int && (exitwipe as libc::c_int) < 0 as libc::c_int
        && newMenu != &mut MainDef as *mut menu_t
        && currentMenu != &mut MainDef as *mut menu_t
    {
        i = 3 as libc::c_int;
        while i >= 0 as libc::c_int {
            bitmask = ((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
                << 6 as libc::c_int * i) as uint32_t;
            prevtype = ((prevMenuId & bitmask) >> 6 as libc::c_int * i) as int8_t;
            if menupres[prevtype as usize].exitwipe as libc::c_int >= 0 as libc::c_int {
                exitwipe = menupres[prevtype as usize].exitwipe;
                break;
            } else {
                i -= 1;
                i;
            }
        }
        if (exitwipe as libc::c_int) < 0 as libc::c_int {
            exitwipe = menupres[MN_MAIN as libc::c_int as usize].exitwipe;
        }
    }
    if anceslevel < 0 as libc::c_int && (enterwipe as libc::c_int) < 0 as libc::c_int
        && newMenu != &mut MainDef as *mut menu_t
        && currentMenu != &mut MainDef as *mut menu_t
    {
        i = 3 as libc::c_int;
        while i >= 0 as libc::c_int {
            bitmask = ((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
                << 6 as libc::c_int * i) as uint32_t;
            activetype = ((activeMenuId & bitmask) >> 6 as libc::c_int * i) as int8_t;
            if menupres[activetype as usize].enterwipe as libc::c_int >= 0 as libc::c_int
            {
                exitwipe = menupres[activetype as usize].enterwipe;
                break;
            } else {
                i -= 1;
                i;
            }
        }
        if (enterwipe as libc::c_int) < 0 as libc::c_int {
            enterwipe = menupres[MN_MAIN as libc::c_int as usize].enterwipe;
        }
    }
    M_ChangeMenuMusic(
        b"_title\0" as *const u8 as *const libc::c_char,
        false_0 as libc::c_int,
    );
    if titlemapinaction != 0 {
        if enterlevel <= exitlevel {
            if exitbubble != 0 {
                i = exitlevel;
                while i > anceslevel {
                    bitmask = ((((1 as libc::c_int) << 6 as libc::c_int)
                        - 1 as libc::c_int) << 6 as libc::c_int * i) as uint32_t;
                    menutype = ((prevMenuId & bitmask) >> 6 as libc::c_int * i)
                        as int8_t;
                    if menupres[menutype as usize].exittag != 0 {
                        P_LinedefExecute(
                            menupres[menutype as usize].exittag as int16_t,
                            players[displayplayer as usize].mo,
                            0 as *mut sector_t,
                        );
                    }
                    i -= 1;
                    i;
                }
            } else if exittag != 0 {
                P_LinedefExecute(
                    exittag,
                    players[displayplayer as usize].mo,
                    0 as *mut sector_t,
                );
            }
        }
        if enterlevel >= exitlevel {
            if enterbubble != 0 {
                i = anceslevel + 1 as libc::c_int;
                while i <= enterlevel {
                    bitmask = ((((1 as libc::c_int) << 6 as libc::c_int)
                        - 1 as libc::c_int) << 6 as libc::c_int * i) as uint32_t;
                    menutype = ((activeMenuId & bitmask) >> 6 as libc::c_int * i)
                        as int8_t;
                    if menupres[menutype as usize].entertag != 0 {
                        P_LinedefExecute(
                            menupres[menutype as usize].entertag as int16_t,
                            players[displayplayer as usize].mo,
                            0 as *mut sector_t,
                        );
                    }
                    i += 1;
                    i;
                }
            } else if entertag != 0 {
                P_LinedefExecute(
                    entertag,
                    players[displayplayer as usize].mo,
                    0 as *mut sector_t,
                );
            }
        }
    }
    if exitwipe as libc::c_int >= 0 as libc::c_int && enterlevel <= exitlevel
        || enterwipe as libc::c_int >= 0 as libc::c_int && enterlevel >= exitlevel
        || anceslevel < 0 as libc::c_int && newMenu != &mut MainDef as *mut menu_t
            && currentMenu != &mut MainDef as *mut menu_t
    {
        if gamestate as libc::c_uint == GS_TIMEATTACK as libc::c_int as libc::c_uint {
            wipetypepre = (if exitwipe as libc::c_int != 0 && enterlevel <= exitlevel
                || anceslevel < 0 as libc::c_int
            {
                exitwipe as libc::c_int
            } else {
                -(1 as libc::c_int)
            }) as int16_t;
        } else {
            wipetypepre = (if exitwipe as libc::c_int != 0 && enterlevel <= exitlevel
                || anceslevel < 0 as libc::c_int
            {
                exitwipe as libc::c_int
            } else {
                32767 as libc::c_int
            }) as int16_t;
        }
        wipetypepost = (if enterwipe as libc::c_int != 0 && enterlevel >= exitlevel
            || anceslevel < 0 as libc::c_int
        {
            enterwipe as libc::c_int
        } else {
            32767 as libc::c_int
        }) as int16_t;
        wipegamestate = 4294967293 as gamestate_t;
        if wipetypepre as libc::c_int != 32767 as libc::c_int
            && wipetypepost as libc::c_int == 32767 as libc::c_int
        {
            wipetypepost = wipetypepre;
        } else if wipetypepost as libc::c_int != 32767 as libc::c_int
            && wipetypepre as libc::c_int == 32767 as libc::c_int
        {
            wipetypepre = wipetypepost;
        }
    }
}
unsafe extern "C" fn M_GoBack(mut choice: int32_t) {
    if !((*currentMenu).prevMenu).is_null() {
        if Playing() == 0 && netgame != 0 && multiplayer != 0 {
            multiplayer = false_0 as libc::c_int;
            netgame = multiplayer;
        }
        if (*currentMenu).prevMenu == &mut MainDef as *mut menu_t
            && (currentMenu == &mut SP_TimeAttackDef as *mut menu_t
                || currentMenu == &mut SP_NightsAttackDef as *mut menu_t
                || currentMenu == &mut SP_MarathonDef as *mut menu_t)
        {
            if !(levelselect.rows).is_null() {
                Z_Free(levelselect.rows as *mut libc::c_void);
                levelselect.rows = 0 as *mut levelselectrow_t;
            }
            menuactive = false_0 as libc::c_int;
            wipetypepre = menupres[M_GetYoungestChildMenu() as usize].exitwipe;
            I_UpdateMouseGrab();
            D_StartTitle();
        } else {
            M_SetupNextMenu((*currentMenu).prevMenu);
        }
    } else {
        M_ClearMenus(true_0 as libc::c_int);
    };
}
unsafe extern "C" fn M_ChangeCvar(mut choice: int32_t) {
    let mut cv: *mut consvar_t = (*((*currentMenu).menuitems).offset(itemOn as isize))
        .itemaction as *mut consvar_t;
    if choice == -(1 as libc::c_int) {
        if cv == &mut cv_playercolor as *mut consvar_t {
            let mut skinno: int8_t = R_SkinAvailable(cv_chooseskin.string) as int8_t;
            if skinno as libc::c_int != -(1 as libc::c_int) {
                CV_SetValue(cv, skins[skinno as usize].prefcolor as int32_t);
            }
            return;
        }
        CV_Set(cv, (*cv).defaultvalue);
        return;
    }
    choice = (choice << 1 as libc::c_int) - 1 as libc::c_int;
    if (*cv).flags & CV_FLOAT as libc::c_int != 0 {
        if (*((*currentMenu).menuitems).offset(itemOn as isize)).status as libc::c_int
            & 512 as libc::c_int + 1024 as libc::c_int + 2048 as libc::c_int
            == 512 as libc::c_int
            || (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                as libc::c_int
                & 512 as libc::c_int + 1024 as libc::c_int + 2048 as libc::c_int
                == 2560 as libc::c_int
            || (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                as libc::c_int
                & 512 as libc::c_int + 1024 as libc::c_int + 2048 as libc::c_int
                == 2048 as libc::c_int
            || (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                as libc::c_int & 4096 as libc::c_int == 0
        {
            let mut s: [libc::c_char; 20] = [0; 20];
            let mut n: libc::c_float = FixedToFloat((*cv).value)
                + choice as libc::c_float * (1.0f32 / 16.0f32);
            sprintf(
                s.as_mut_ptr(),
                b"%ld%s\0" as *const u8 as *const libc::c_char,
                n as libc::c_long,
                M_Ftrim(n as libc::c_double),
            );
            CV_Set(cv, s.as_mut_ptr());
        } else {
            CV_SetValue(
                cv,
                (FixedToFloat((*cv).value) + choice as libc::c_float) as int32_t,
            );
        }
    } else {
        CV_AddValue(cv, choice);
    };
}
unsafe extern "C" fn M_ChangeStringCvar(mut choice: int32_t) -> boolean {
    let mut cv: *mut consvar_t = (*((*currentMenu).menuitems).offset(itemOn as isize))
        .itemaction as *mut consvar_t;
    let mut buf: [libc::c_char; 32] = [0; 32];
    let mut len_0: size_t = 0;
    if shiftdown as libc::c_int != 0 && choice >= 32 as libc::c_int
        && choice <= 127 as libc::c_int
    {
        choice = *shiftxform.offset(choice as isize) as int32_t;
    }
    match choice {
        8 => {
            len_0 = strlen((*cv).string);
            if len_0 > 0 as libc::c_int as size_t {
                M_Memcpy
                    .expect(
                        "non-null function pointer",
                    )(
                    buf.as_mut_ptr() as *mut libc::c_void,
                    (*cv).string as *const libc::c_void,
                    len_0,
                );
                buf[len_0.wrapping_sub(1 as libc::c_int as size_t)
                    as usize] = 0 as libc::c_int as libc::c_char;
                CV_Set(cv, buf.as_mut_ptr());
            }
            return true_0 as libc::c_int;
        }
        _ => {
            if choice >= 32 as libc::c_int && choice <= 127 as libc::c_int {
                len_0 = strlen((*cv).string);
                if len_0 < (32 as libc::c_int - 1 as libc::c_int) as size_t {
                    M_Memcpy
                        .expect(
                            "non-null function pointer",
                        )(
                        buf.as_mut_ptr() as *mut libc::c_void,
                        (*cv).string as *const libc::c_void,
                        len_0,
                    );
                    let fresh0 = len_0;
                    len_0 = len_0.wrapping_add(1);
                    buf[fresh0 as usize] = choice as libc::c_char;
                    buf[len_0 as usize] = 0 as libc::c_int as libc::c_char;
                    CV_Set(cv, buf.as_mut_ptr());
                }
                return true_0 as libc::c_int;
            }
        }
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn M_ResetCvars() {
    let mut i: int32_t = 0;
    let mut cv: *mut consvar_t = 0 as *mut consvar_t;
    i = 0 as libc::c_int;
    while i < (*currentMenu).numitems as libc::c_int {
        if !((*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            & 8 as libc::c_int == 0
            || {
                cv = (*((*currentMenu).menuitems).offset(i as isize)).itemaction
                    as *mut consvar_t;
                cv.is_null()
            })
        {
            CV_SetValue(cv, atoi((*cv).defaultvalue));
        }
        i += 1;
        i;
    }
}
unsafe extern "C" fn M_NextOpt() {
    let mut oldItemOn: int16_t = itemOn;
    loop {
        if itemOn as libc::c_int + 1 as libc::c_int
            > (*currentMenu).numitems as libc::c_int - 1 as libc::c_int
        {
            itemOn = 0 as libc::c_int as int16_t;
        } else {
            itemOn += 1;
            itemOn;
        }
        if !(oldItemOn as libc::c_int != itemOn as libc::c_int
            && (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                as libc::c_int & 15 as libc::c_int & 1 as libc::c_int != 0)
        {
            break;
        }
    };
}
unsafe extern "C" fn M_PrevOpt() {
    let mut oldItemOn: int16_t = itemOn;
    loop {
        if itemOn == 0 {
            itemOn = ((*currentMenu).numitems as libc::c_int - 1 as libc::c_int)
                as int16_t;
        } else {
            itemOn -= 1;
            itemOn;
        }
        if !(oldItemOn as libc::c_int != itemOn as libc::c_int
            && (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                as libc::c_int & 15 as libc::c_int & 1 as libc::c_int != 0)
        {
            break;
        }
    };
}
static mut noFurtherInput: boolean = false_0 as libc::c_int;
unsafe extern "C" fn Command_Manual_f() {
    if modeattacking != 0 {
        return;
    }
    M_StartControlPanel();
    currentMenu = &mut MISC_HelpDef;
    itemOn = 0 as libc::c_int as int16_t;
}
#[no_mangle]
pub unsafe extern "C" fn M_Responder(mut ev: *mut event_t) -> boolean {
    let mut ch: int32_t = -(1 as libc::c_int);
    static mut joywait: tic_t = 0 as libc::c_int as tic_t;
    static mut mousewait: tic_t = 0 as libc::c_int as tic_t;
    static mut pjoyx: int32_t = 0 as libc::c_int;
    static mut pjoyy: int32_t = 0 as libc::c_int;
    static mut pmousex: int32_t = 0 as libc::c_int;
    static mut pmousey: int32_t = 0 as libc::c_int;
    static mut lastx: int32_t = 0 as libc::c_int;
    static mut lasty: int32_t = 0 as libc::c_int;
    let mut routine: Option::<unsafe extern "C" fn(int32_t) -> ()> = None;
    if dedicated != 0 || demoplayback != 0 && titledemo != 0
        || gamestate as libc::c_uint == GS_INTRO as libc::c_int as libc::c_uint
        || gamestate as libc::c_uint == GS_ENDING as libc::c_int as libc::c_uint
        || gamestate as libc::c_uint == GS_CUTSCENE as libc::c_int as libc::c_uint
        || gamestate as libc::c_uint == GS_CREDITS as libc::c_int as libc::c_uint
        || gamestate as libc::c_uint == GS_EVALUATION as libc::c_int as libc::c_uint
        || gamestate as libc::c_uint == GS_GAMEEND as libc::c_int as libc::c_uint
    {
        return false_0 as libc::c_int;
    }
    if gamestate as libc::c_uint == GS_TITLESCREEN as libc::c_int as libc::c_uint
        && finalecount
            < (if cv_tutorialprompt.value != 0 {
                35 as libc::c_int
            } else {
                0 as libc::c_int
            })
    {
        return false_0 as libc::c_int;
    }
    if CON_Ready() != 0
        && gamestate as libc::c_uint != GS_WAITINGPLAYERS as libc::c_int as libc::c_uint
    {
        return false_0 as libc::c_int;
    }
    if noFurtherInput != 0 {
        return false_0 as libc::c_int
    } else if menuactive != 0 {
        if (*ev).type_0 as libc::c_uint == ev_keydown as libc::c_int as libc::c_uint {
            keydown = keydown.wrapping_add(1);
            keydown;
            ch = (*ev).key;
            match ch {
                256 | 264 => {
                    ch = 13 as libc::c_int;
                }
                267 => {
                    ch = 'n' as i32;
                }
                257 | 265 => {
                    ch = 27 as libc::c_int;
                }
                266 => {
                    ch = 8 as libc::c_int;
                }
                296 => {
                    ch = 0x80 as libc::c_int + 102 as libc::c_int;
                }
                297 => {
                    ch = 0x80 as libc::c_int + 110 as libc::c_int;
                }
                298 => {
                    ch = 0x80 as libc::c_int + 105 as libc::c_int;
                }
                299 => {
                    ch = 0x80 as libc::c_int + 107 as libc::c_int;
                }
                _ => {}
            }
        } else if (*ev).type_0 as libc::c_uint
            == ev_joystick as libc::c_int as libc::c_uint
            && (*ev).key == 0 as libc::c_int && joywait < I_GetTime()
        {
            let jdeadzone: int32_t = 1023 as libc::c_int * cv_digitaldeadzone.value
                / ((1 as libc::c_int) << 16 as libc::c_int);
            if (*ev).y != 2147483647 as libc::c_int {
                if Joystick.bGamepadStyle != 0 || abs((*ev).y) > jdeadzone {
                    if (*ev).y < 0 as libc::c_int && pjoyy >= 0 as libc::c_int {
                        ch = 0x80 as libc::c_int + 102 as libc::c_int;
                        joywait = (I_GetTime())
                            .wrapping_add(
                                (35 as libc::c_int * 1 as libc::c_int / 7 as libc::c_int)
                                    as tic_t,
                            );
                    } else if (*ev).y > 0 as libc::c_int && pjoyy <= 0 as libc::c_int {
                        ch = 0x80 as libc::c_int + 110 as libc::c_int;
                        joywait = (I_GetTime())
                            .wrapping_add(
                                (35 as libc::c_int * 1 as libc::c_int / 7 as libc::c_int)
                                    as tic_t,
                            );
                    }
                    pjoyy = (*ev).y;
                } else {
                    pjoyy = 0 as libc::c_int;
                }
            }
            if (*ev).x != 2147483647 as libc::c_int {
                if Joystick.bGamepadStyle != 0 || abs((*ev).x) > jdeadzone {
                    if (*ev).x < 0 as libc::c_int && pjoyx >= 0 as libc::c_int {
                        ch = 0x80 as libc::c_int + 105 as libc::c_int;
                        joywait = (I_GetTime())
                            .wrapping_add(
                                (35 as libc::c_int * 1 as libc::c_int / 17 as libc::c_int)
                                    as tic_t,
                            );
                    } else if (*ev).x > 0 as libc::c_int && pjoyx <= 0 as libc::c_int {
                        ch = 0x80 as libc::c_int + 107 as libc::c_int;
                        joywait = (I_GetTime())
                            .wrapping_add(
                                (35 as libc::c_int * 1 as libc::c_int / 17 as libc::c_int)
                                    as tic_t,
                            );
                    }
                    pjoyx = (*ev).x;
                } else {
                    pjoyx = 0 as libc::c_int;
                }
            }
        } else if (*ev).type_0 as libc::c_uint == ev_mouse as libc::c_int as libc::c_uint
            && mousewait < I_GetTime()
        {
            pmousey -= (*ev).y;
            if pmousey < lasty - 30 as libc::c_int {
                ch = 0x80 as libc::c_int + 110 as libc::c_int;
                mousewait = (I_GetTime())
                    .wrapping_add(
                        (35 as libc::c_int * 1 as libc::c_int / 7 as libc::c_int)
                            as tic_t,
                    );
                lasty -= 30 as libc::c_int;
                pmousey = lasty;
            } else if pmousey > lasty + 30 as libc::c_int {
                ch = 0x80 as libc::c_int + 102 as libc::c_int;
                mousewait = (I_GetTime())
                    .wrapping_add(
                        (35 as libc::c_int * 1 as libc::c_int / 7 as libc::c_int)
                            as tic_t,
                    );
                lasty += 30 as libc::c_int;
                pmousey = lasty;
            }
            pmousex += (*ev).x;
            if pmousex < lastx - 30 as libc::c_int {
                ch = 0x80 as libc::c_int + 105 as libc::c_int;
                mousewait = (I_GetTime())
                    .wrapping_add(
                        (35 as libc::c_int * 1 as libc::c_int / 7 as libc::c_int)
                            as tic_t,
                    );
                lastx -= 30 as libc::c_int;
                pmousex = lastx;
            } else if pmousex > lastx + 30 as libc::c_int {
                ch = 0x80 as libc::c_int + 107 as libc::c_int;
                mousewait = (I_GetTime())
                    .wrapping_add(
                        (35 as libc::c_int * 1 as libc::c_int / 7 as libc::c_int)
                            as tic_t,
                    );
                lastx += 30 as libc::c_int;
                pmousex = lastx;
            }
        } else if (*ev).type_0 as libc::c_uint == ev_keyup as libc::c_int as libc::c_uint
        {
            keydown = 0 as libc::c_int as tic_t;
        }
    } else if (*ev).type_0 as libc::c_uint == ev_keydown as libc::c_int as libc::c_uint {
        ch = (*ev).key;
    }
    if ch == -(1 as libc::c_int) {
        return false_0 as libc::c_int
    } else if ch
        == gamecontrol[GC_SYSTEMMENU as libc::c_int as usize][0 as libc::c_int as usize]
        || ch
            == gamecontrol[GC_SYSTEMMENU as libc::c_int
                as usize][1 as libc::c_int as usize]
    {
        ch = 27 as libc::c_int;
    }
    if menuactive == 0 {
        noFurtherInput = true_0 as libc::c_int;
        match ch {
            187 => {
                Command_Manual_f();
                return true_0 as libc::c_int;
            }
            188 => return true_0 as libc::c_int,
            189 => {
                CV_SetValue(&mut cv_showhud, (cv_showhud.value == 0) as libc::c_int);
                return true_0 as libc::c_int;
            }
            190 => {
                if modeattacking != 0 {
                    return true_0 as libc::c_int;
                }
                M_StartControlPanel();
                M_Options(0 as libc::c_int);
                M_SetupNextMenu(&mut OP_SoundOptionsDef);
                return true_0 as libc::c_int;
            }
            191 => {
                if modeattacking != 0 {
                    return true_0 as libc::c_int;
                }
                M_StartControlPanel();
                M_Options(0 as libc::c_int);
                M_VideoModeMenu(0 as libc::c_int);
                return true_0 as libc::c_int;
            }
            192 => return true_0 as libc::c_int,
            193 => {
                if modeattacking != 0 {
                    return true_0 as libc::c_int;
                }
                M_StartControlPanel();
                M_Options(0 as libc::c_int);
                M_SetupNextMenu(&mut OP_MainDef);
                return true_0 as libc::c_int;
            }
            196 => {
                CV_AddValue(&mut cv_renderer, 1 as libc::c_int);
                return true_0 as libc::c_int;
            }
            215 => {
                CV_SetValue(
                    &mut cv_fullscreen,
                    (cv_fullscreen.value == 0) as libc::c_int,
                );
                return true_0 as libc::c_int;
            }
            27 => {
                if chat_on != 0 {
                    HU_clearChatChars();
                } else {
                    M_StartControlPanel();
                }
                return true_0 as libc::c_int;
            }
            _ => {}
        }
        noFurtherInput = false_0 as libc::c_int;
        return false_0 as libc::c_int;
    }
    routine = ::core::mem::transmute::<
        *mut libc::c_void,
        Option::<unsafe extern "C" fn(int32_t) -> ()>,
    >((*((*currentMenu).menuitems).offset(itemOn as isize)).itemaction);
    if routine.is_some()
        && (*((*currentMenu).menuitems).offset(itemOn as isize)).status as libc::c_int
            & 15 as libc::c_int == 4 as libc::c_int
    {
        if shiftdown as libc::c_int != 0 && ch >= 32 as libc::c_int
            && ch <= 127 as libc::c_int
        {
            ch = *shiftxform.offset(ch as isize) as int32_t;
        }
        routine.expect("non-null function pointer")(ch);
        return true_0 as libc::c_int;
    }
    if (*((*currentMenu).menuitems).offset(itemOn as isize)).status as libc::c_int
        == 12 as libc::c_int
    {
        if (*((*currentMenu).menuitems).offset(itemOn as isize)).alphaKey as libc::c_int
            != MM_EVENTHANDLER as libc::c_int
        {
            if ch == ' ' as i32 || ch == 'n' as i32 || ch == 'y' as i32
                || ch == 27 as libc::c_int || ch == 13 as libc::c_int
                || ch == 0x80 as libc::c_int + 113 as libc::c_int
            {
                if routine.is_some() {
                    routine.expect("non-null function pointer")(ch);
                }
                if stopstopmessage != 0 {
                    stopstopmessage = false_0 as libc::c_int;
                } else {
                    M_StopMessage(0 as libc::c_int);
                }
                noFurtherInput = true_0 as libc::c_int;
                return true_0 as libc::c_int;
            }
            return true_0 as libc::c_int;
        } else {
            if (*ev).type_0 as libc::c_uint == ev_mouse as libc::c_int as libc::c_uint
                || (*ev).type_0 as libc::c_uint
                    == ev_mouse2 as libc::c_int as libc::c_uint
                || (*ev).type_0 as libc::c_uint
                    == ev_joystick as libc::c_int as libc::c_uint
                || (*ev).type_0 as libc::c_uint
                    == ev_joystick2 as libc::c_int as libc::c_uint
            {
                return true_0 as libc::c_int;
            }
            if routine.is_some() {
                let mut otherroutine: Option::<
                    unsafe extern "C" fn(*mut event_t) -> (),
                > = ::core::mem::transmute::<
                    *mut libc::c_void,
                    Option::<unsafe extern "C" fn(*mut event_t) -> ()>,
                >((*((*currentMenu).menuitems).offset(itemOn as isize)).itemaction);
                otherroutine.expect("non-null function pointer")(ev);
            }
            return true_0 as libc::c_int;
        }
    }
    if routine.is_some()
        && (*((*currentMenu).menuitems).offset(itemOn as isize)).status as libc::c_int
            & 15 as libc::c_int == 8 as libc::c_int
    {
        if (*((*currentMenu).menuitems).offset(itemOn as isize)).status as libc::c_int
            & 512 as libc::c_int + 1024 as libc::c_int + 2048 as libc::c_int
            == 1024 as libc::c_int
        {
            if M_ChangeStringCvar(ch) != 0 {
                return true_0 as libc::c_int
            } else {
                routine = None;
            }
        } else {
            routine = Some(M_ChangeCvar as unsafe extern "C" fn(int32_t) -> ());
        }
    }
    match ch {
        238 => {
            M_NextOpt();
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            return true_0 as libc::c_int;
        }
        230 => {
            M_PrevOpt();
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            return true_0 as libc::c_int;
        }
        233 => {
            if routine.is_some()
                && ((*((*currentMenu).menuitems).offset(itemOn as isize)).status
                    as libc::c_int & 15 as libc::c_int == 2 as libc::c_int
                    || (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                        as libc::c_int & 15 as libc::c_int == 8 as libc::c_int)
            {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                routine.expect("non-null function pointer")(0 as libc::c_int);
            }
            return true_0 as libc::c_int;
        }
        235 => {
            if routine.is_some()
                && ((*((*currentMenu).menuitems).offset(itemOn as isize)).status
                    as libc::c_int & 15 as libc::c_int == 2 as libc::c_int
                    || (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                        as libc::c_int & 15 as libc::c_int == 8 as libc::c_int)
            {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                routine.expect("non-null function pointer")(1 as libc::c_int);
            }
            return true_0 as libc::c_int;
        }
        13 => {
            noFurtherInput = true_0 as libc::c_int;
            (*currentMenu).lastOn = itemOn;
            if routine.is_some() {
                if ((*((*currentMenu).menuitems).offset(itemOn as isize)).status
                    as libc::c_int & 15 as libc::c_int == 0 as libc::c_int
                    || (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                        as libc::c_int & 15 as libc::c_int == 6 as libc::c_int)
                    && (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                        as libc::c_int & 512 as libc::c_int + 1024 as libc::c_int != 0
                {
                    if (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                        as libc::c_int & 512 as libc::c_int + 1024 as libc::c_int
                        & 512 as libc::c_int != 0 && usedCheats != 0
                    {
                        S_StartSound(0 as *const libc::c_void, sfx_skid);
                        M_StartMessage(
                            b"This cannot be done in a cheated game.\n\n(Press a key)\n\0"
                                as *const u8 as *const libc::c_char,
                            0 as *mut libc::c_void,
                            MM_NOTHING,
                        );
                        return true_0 as libc::c_int;
                    }
                }
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                match (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                    as libc::c_int & 15 as libc::c_int
                {
                    8 | 2 => {
                        routine.expect("non-null function pointer")(1 as libc::c_int);
                    }
                    0 => {
                        routine.expect("non-null function pointer")(itemOn as int32_t);
                    }
                    6 => {
                        (*currentMenu).lastOn = itemOn;
                        M_SetupNextMenu(
                            (*((*currentMenu).menuitems).offset(itemOn as isize))
                                .itemaction as *mut menu_t,
                        );
                    }
                    _ => {}
                }
            }
            return true_0 as libc::c_int;
        }
        27 => {
            noFurtherInput = true_0 as libc::c_int;
            (*currentMenu).lastOn = itemOn;
            M_GoBack(0 as libc::c_int);
            return true_0 as libc::c_int;
        }
        8 => {
            if (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                as libc::c_int
                == 32 as libc::c_int + 64 as libc::c_int + 0 as libc::c_int
            {
                G_ClearControlKeys(
                    setupcontrols,
                    (*((*currentMenu).menuitems).offset(itemOn as isize)).alphaKey
                        as int32_t,
                );
                S_StartSound(0 as *const libc::c_void, sfx_shldls);
                return true_0 as libc::c_int;
            }
            if routine.is_some()
                && ((*((*currentMenu).menuitems).offset(itemOn as isize)).status
                    as libc::c_int & 15 as libc::c_int == 2 as libc::c_int
                    || (*((*currentMenu).menuitems).offset(itemOn as isize)).status
                        as libc::c_int & 15 as libc::c_int == 8 as libc::c_int)
            {
                let mut cv: *mut consvar_t = (*((*currentMenu).menuitems)
                    .offset(itemOn as isize))
                    .itemaction as *mut consvar_t;
                if cv == &mut cv_chooseskin as *mut consvar_t
                    || cv == &mut cv_nextmap as *mut consvar_t
                    || cv == &mut cv_newgametype as *mut consvar_t
                {
                    return true_0 as libc::c_int;
                }
                if currentMenu != &mut OP_SoundOptionsDef as *mut menu_t
                    || itemOn as libc::c_int > 3 as libc::c_int
                {
                    S_StartSound(0 as *const libc::c_void, sfx_menu1);
                }
                routine.expect("non-null function pointer")(-(1 as libc::c_int));
                return true_0 as libc::c_int;
            }
            return false_0 as libc::c_int;
        }
        196 => {
            CV_AddValue(&mut cv_renderer, 1 as libc::c_int);
            return true_0 as libc::c_int;
        }
        215 => {
            CV_SetValue(&mut cv_fullscreen, (cv_fullscreen.value == 0) as libc::c_int);
            return true_0 as libc::c_int;
        }
        _ => {
            CON_Responder(ev);
        }
    }
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn M_Drawer() {
    let mut wipe: boolean = WipeInAction;
    if currentMenu == &mut MessageDef as *mut menu_t {
        menuactive = true_0 as libc::c_int;
    }
    if menuactive != 0 {
        if wipe == 0
            && (curfadevalue as libc::c_int != 0
                || gamestate as libc::c_uint
                    != GS_TITLESCREEN as libc::c_int as libc::c_uint
                    && gamestate as libc::c_uint
                        != GS_TIMEATTACK as libc::c_int as libc::c_uint)
        {
            V_DrawFadeScreen(
                0xff00 as libc::c_int as uint16_t,
                (if gamestate as libc::c_uint
                    != GS_TITLESCREEN as libc::c_int as libc::c_uint
                    && gamestate as libc::c_uint
                        != GS_TIMEATTACK as libc::c_int as libc::c_uint
                {
                    16 as libc::c_int
                } else {
                    curfadevalue as libc::c_int
                }) as uint8_t,
            );
        }
        if ((*currentMenu).drawroutine).is_some() {
            ((*currentMenu).drawroutine).expect("non-null function pointer")();
        }
        if currentMenu == &mut MainDef as *mut menu_t {
            if customversionstring[0 as libc::c_int as usize] as libc::c_int
                != '\0' as i32
            {
                V_DrawThinString(
                    vid.dupx,
                    vid.height - 17 as libc::c_int * vid.dupy,
                    0x40000000 as libc::c_int | 0x50000 as libc::c_int,
                    b"Mod version:\0" as *const u8 as *const libc::c_char,
                );
                V_DrawThinString(
                    vid.dupx,
                    vid.height - 9 as libc::c_int * vid.dupy,
                    0x40000000 as libc::c_int | 0x50000 as libc::c_int
                        | 0x800000 as libc::c_int,
                    customversionstring.as_mut_ptr(),
                );
            } else {
                V_DrawThinString(
                    vid.dupx,
                    vid.height - 9 as libc::c_int * vid.dupy,
                    0x40000000 as libc::c_int | 0x50000 as libc::c_int
                        | 0x800000 as libc::c_int,
                    va(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        b"v2.2.13\0" as *const u8 as *const libc::c_char,
                    ),
                );
            }
        }
    }
    if window_notinfocus as libc::c_int != 0 && cv_showfocuslost.value != 0 {
        M_DrawTextBox(
            320 as libc::c_int / 2 as libc::c_int - 60 as libc::c_int,
            200 as libc::c_int / 2 as libc::c_int - 16 as libc::c_int,
            13 as libc::c_int,
            2 as libc::c_int,
        );
        if gamestate as libc::c_uint == GS_LEVEL as libc::c_int as libc::c_uint
            && (P_AutoPause() != 0 || paused as libc::c_int != 0)
        {
            V_DrawCenteredString(
                320 as libc::c_int / 2 as libc::c_int,
                200 as libc::c_int / 2 as libc::c_int - 4 as libc::c_int,
                0x2000 as libc::c_int,
                b"Game Paused\0" as *const u8 as *const libc::c_char,
            );
        } else {
            V_DrawCenteredString(
                320 as libc::c_int / 2 as libc::c_int,
                200 as libc::c_int / 2 as libc::c_int - 4 as libc::c_int,
                0x2000 as libc::c_int,
                b"Focus Lost\0" as *const u8 as *const libc::c_char,
            );
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn M_StartControlPanel() {
    if modeattacking as libc::c_int != 0 && demoplayback != 0 {
        G_CheckDemoStatus();
        return;
    }
    if menuactive != 0 {
        CON_ToggleOff();
        return;
    }
    menuactive = true_0 as libc::c_int;
    if Playing() == 0 {
        MainMenu[singleplr as libc::c_int as usize]
            .alphaKey = (if M_AnySecretUnlocked(clientGamedata) as libc::c_int != 0 {
            76 as libc::c_int
        } else {
            84 as libc::c_int
        }) as uint16_t;
        MainMenu[multiplr as libc::c_int as usize]
            .alphaKey = (if M_AnySecretUnlocked(clientGamedata) as libc::c_int != 0 {
            84 as libc::c_int
        } else {
            92 as libc::c_int
        }) as uint16_t;
        MainMenu[secrets as libc::c_int as usize]
            .status = (if M_AnySecretUnlocked(clientGamedata) as libc::c_int != 0 {
            32 as libc::c_int | 0 as libc::c_int
        } else {
            1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
        }) as uint16_t;
        currentMenu = &mut MainDef;
        itemOn = singleplr as libc::c_int as int16_t;
    } else if modeattacking != 0 {
        currentMenu = &mut MAPauseDef;
        MAPauseMenu[mapause_hints as libc::c_int as usize]
            .status = (if M_SecretUnlocked(-(4 as libc::c_int), clientGamedata)
            as libc::c_int != 0
        {
            32 as libc::c_int | 0 as libc::c_int
        } else {
            1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
        }) as uint16_t;
        itemOn = mapause_continue as libc::c_int as int16_t;
    } else if !(netgame != 0 || multiplayer != 0) {
        if gamestate as libc::c_uint != GS_LEVEL as libc::c_int as libc::c_uint
            || ultimatemode as libc::c_int != 0
        {
            SPauseMenu[spause_pandora as libc::c_int as usize]
                .status = (if M_SecretUnlocked(-(3 as libc::c_int), serverGamedata)
                as libc::c_int != 0
            {
                1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int)
            } else {
                1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
            }) as uint16_t;
            SPauseMenu[spause_retry as libc::c_int as usize]
                .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
                as uint16_t;
        } else {
            let mut numlives: int32_t = players[consoleplayer as usize].lives as int32_t;
            if players[consoleplayer as usize].playerstate as libc::c_uint
                != PST_LIVE as libc::c_int as libc::c_uint
            {
                numlives += 1;
                numlives;
            }
            SPauseMenu[spause_pandora as libc::c_int as usize]
                .status = (if M_SecretUnlocked(-(3 as libc::c_int), serverGamedata)
                as libc::c_int != 0 && marathonmode as u64 == 0
            {
                32 as libc::c_int | 0 as libc::c_int
            } else {
                1 as libc::c_int
                    + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
            }) as uint16_t;
            if numlives <= 1 as libc::c_int || G_IsSpecialStage(gamemap as int32_t) != 0
            {
                SPauseMenu[spause_retry as libc::c_int as usize]
                    .status = (1 as libc::c_int
                    + (16 as libc::c_int + 128 as libc::c_int)) as uint16_t;
            } else {
                SPauseMenu[spause_retry as libc::c_int as usize]
                    .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
            }
        }
        SPauseMenu[spause_levelselect as libc::c_int as usize]
            .status = (if maplistoption as libc::c_int != 0 as libc::c_int {
            32 as libc::c_int | 0 as libc::c_int
        } else {
            1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
        }) as uint16_t;
        SPauseMenu[spause_hints as libc::c_int as usize]
            .status = (if M_SecretUnlocked(-(4 as libc::c_int), clientGamedata)
            as libc::c_int != 0 && marathonmode as u64 == 0
        {
            32 as libc::c_int | 0 as libc::c_int
        } else {
            1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
        }) as uint16_t;
        currentMenu = &mut SPauseDef;
        itemOn = spause_continue as libc::c_int as int16_t;
    } else {
        MPauseMenu[mpause_switchmap as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        MPauseMenu[mpause_addons as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        MPauseMenu[mpause_scramble as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        MPauseMenu[mpause_psetupsplit as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        MPauseMenu[mpause_psetupsplit2 as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        MPauseMenu[mpause_spectate as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        MPauseMenu[mpause_entergame as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        MPauseMenu[mpause_switchteam as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        MPauseMenu[mpause_psetup as libc::c_int as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        if server != 0 || IsPlayerAdmin(consoleplayer) != 0 {
            MPauseMenu[mpause_switchmap as libc::c_int as usize]
                .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
            MPauseMenu[mpause_addons as libc::c_int as usize]
                .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
            if G_GametypeHasTeams() != 0 {
                MPauseMenu[mpause_scramble as libc::c_int as usize]
                    .status = (32 as libc::c_int | 6 as libc::c_int) as uint16_t;
            }
        }
        if splitscreen != 0 {
            MPauseMenu[mpause_psetupsplit2 as libc::c_int as usize]
                .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
            MPauseMenu[mpause_psetupsplit as libc::c_int as usize]
                .status = MPauseMenu[mpause_psetupsplit2 as libc::c_int as usize].status;
        } else {
            MPauseMenu[mpause_psetup as libc::c_int as usize]
                .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
            if G_GametypeHasTeams() != 0 {
                MPauseMenu[mpause_switchteam as libc::c_int as usize]
                    .status = (32 as libc::c_int | 6 as libc::c_int) as uint16_t;
            } else if G_GametypeHasSpectators() != 0 {
                MPauseMenu[(if players[consoleplayer as usize].spectator != 0 {
                        mpause_entergame as libc::c_int
                    } else {
                        mpause_spectate as libc::c_int
                    }) as usize]
                    .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
            } else {
                MPauseMenu[mpause_spectate as libc::c_int as usize]
                    .status = (1 as libc::c_int
                    + (16 as libc::c_int + 128 as libc::c_int)) as uint16_t;
            }
        }
        MPauseMenu[mpause_hints as libc::c_int as usize]
            .status = (if M_SecretUnlocked(-(4 as libc::c_int), clientGamedata)
            as libc::c_int != 0 && G_CoopGametype() != 0
        {
            32 as libc::c_int | 0 as libc::c_int
        } else {
            1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
        }) as uint16_t;
        currentMenu = &mut MPauseDef;
        itemOn = mpause_continue as libc::c_int as int16_t;
    }
    CON_ToggleOff();
}
#[no_mangle]
pub unsafe extern "C" fn M_EndModeAttackRun() {
    G_ClearModeAttackRetryFlag();
    M_ModeAttackEndGame(0 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn M_ClearMenus(mut callexitmenufunc: boolean) {
    if menuactive == 0 {
        return;
    }
    if ((*currentMenu).quitroutine).is_some() && callexitmenufunc != 0
        && ((*currentMenu).quitroutine).expect("non-null function pointer")() == 0
    {
        return;
    }
    COM_BufAddTextEx(
        va(
            b"saveconfig \"%s\" -silent\n\0" as *const u8 as *const libc::c_char,
            configfile.as_mut_ptr(),
        ),
        0 as com_flags_t,
    );
    if currentMenu == &mut MessageDef as *mut menu_t {
        currentMenu = &mut MainDef;
    }
    menuactive = false_0 as libc::c_int;
    hidetitlemap = false_0 as libc::c_int;
    I_UpdateMouseGrab();
}
#[no_mangle]
pub unsafe extern "C" fn M_SetupNextMenu(mut menudef: *mut menu_t) {
    let mut i: int16_t = 0;
    if ((*currentMenu).quitroutine).is_some() {
        if currentMenu != menudef
            && ((*currentMenu).quitroutine).expect("non-null function pointer")() == 0
        {
            return;
        }
    }
    M_HandleMenuPresState(menudef);
    currentMenu = menudef;
    itemOn = (*currentMenu).lastOn;
    if itemOn as libc::c_int >= (*currentMenu).numitems as libc::c_int {
        itemOn = ((*currentMenu).numitems as libc::c_int - 1 as libc::c_int) as int16_t;
    }
    if (*((*currentMenu).menuitems).offset(itemOn as isize)).status as libc::c_int
        & 15 as libc::c_int & 1 as libc::c_int != 0
    {
        i = 0 as libc::c_int as int16_t;
        while (i as libc::c_int) < (*currentMenu).numitems as libc::c_int {
            if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
                & 15 as libc::c_int & 1 as libc::c_int == 0
            {
                itemOn = i;
                break;
            } else {
                i += 1;
                i;
            }
        }
    }
    hidetitlemap = false_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn M_MouseNeeded() -> boolean {
    return (currentMenu == &mut MessageDef as *mut menu_t
        && (*currentMenu).prevMenu == &mut OP_ChangeControlsDef as *mut menu_t)
        as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn M_Ticker() {
    noFurtherInput = false_0 as libc::c_int;
    if dedicated != 0 {
        return;
    }
    skullAnimCounter -= 1;
    if skullAnimCounter as libc::c_int <= 0 as libc::c_int {
        skullAnimCounter = 8 as libc::c_int as int16_t;
    }
    if vidm_testingmode > 0 as libc::c_int {
        vidm_testingmode -= 1;
        if vidm_testingmode == 0 as libc::c_int {
            setmodeneeded = vidm_previousmode + 1 as libc::c_int;
        }
    }
    if currentMenu == &mut OP_ScreenshotOptionsDef as *mut menu_t {
        M_SetupScreenshotMenu();
    }
}
#[no_mangle]
pub unsafe extern "C" fn M_Init() {
    let mut i: libc::c_int = 0;
    COM_AddCommand(
        b"manual\0" as *const u8 as *const libc::c_char,
        Some(Command_Manual_f as unsafe extern "C" fn() -> ()),
        COM_LUA,
    );
    CV_RegisterVar(&mut cv_nextmap);
    CV_RegisterVar(&mut cv_newgametype);
    CV_RegisterVar(&mut cv_chooseskin);
    CV_RegisterVar(&mut cv_autorecord);
    if dedicated != 0 {
        return;
    }
    CV_RegisterVar(&mut cv_dummyteam);
    CV_RegisterVar(&mut cv_dummyscramble);
    CV_RegisterVar(&mut cv_dummyrings);
    CV_RegisterVar(&mut cv_dummylives);
    CV_RegisterVar(&mut cv_dummycontinues);
    CV_RegisterVar(&mut cv_dummymares);
    CV_RegisterVar(&mut cv_dummymarathon);
    CV_RegisterVar(&mut cv_dummyloadless);
    CV_RegisterVar(&mut cv_dummycutscenes);
    quitmsg[QUITMSG as libc::c_int
        as usize] = b"Eggman's tied explosives\nto your girlfriend, and\nwill activate them if\nyou press the 'Y' key!\nPress 'N' to save her!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUITMSG1 as libc::c_int
        as usize] = b"What would Tails say if\nhe saw you quitting the game?\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUITMSG2 as libc::c_int
        as usize] = b"Hey!\nWhere do ya think you're goin'?\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUITMSG3 as libc::c_int
        as usize] = b"Forget your studies!\nPlay some more!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUITMSG4 as libc::c_int
        as usize] = b"You're trying to say you\nlike Sonic 2K6 better than\nthis, right?\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUITMSG5 as libc::c_int
        as usize] = b"Don't leave yet -- there's a\nsuper emerald around that corner!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUITMSG6 as libc::c_int
        as usize] = b"You'd rather work than play?\n\n(Press 'Y' to quit)\0" as *const u8
        as *const libc::c_char;
    quitmsg[QUITMSG7 as libc::c_int
        as usize] = b"Go ahead and leave. See if I care...\n*sniffle*\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT2MSG as libc::c_int
        as usize] = b"If you leave now,\nEggman will take over the world!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT2MSG1 as libc::c_int
        as usize] = b"Don't quit!\nThere are animals\nto save!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT2MSG2 as libc::c_int
        as usize] = b"Aw c'mon, just bop\na few more robots!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT2MSG3 as libc::c_int
        as usize] = b"Did you get all those Chaos Emeralds?\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT2MSG4 as libc::c_int
        as usize] = b"If you leave, I'll use\nmy spin attack on you!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT2MSG5 as libc::c_int
        as usize] = b"Don't go!\nYou might find the hidden\nlevels!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT2MSG6 as libc::c_int
        as usize] = b"Hit the 'N' key, Sonic!\nThe 'N' key!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT3MSG as libc::c_int
        as usize] = b"Are you really going to give up?\nWe certainly would never give you up.\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT3MSG1 as libc::c_int
        as usize] = b"Come on, just ONE more netgame!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT3MSG2 as libc::c_int
        as usize] = b"Press 'N' to unlock\nthe Ultimate Cheat!\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT3MSG3 as libc::c_int
        as usize] = b"Why don't you go back and try\njumping on that house to\nsee what happens?\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT3MSG4 as libc::c_int
        as usize] = b"Every time you press 'Y', an\nSRB2 Developer cries...\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT3MSG5 as libc::c_int
        as usize] = b"You'll be back to play soon, though...\n......right?\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    quitmsg[QUIT3MSG6 as libc::c_int
        as usize] = b"Aww, is Egg Rock Zone too\ndifficult for you?\n\n(Press 'Y' to quit)\0"
        as *const u8 as *const libc::c_char;
    i = 0 as libc::c_int;
    while i <= 4 as libc::c_int {
        OP_JoystickSetMenu[i as usize]
            .status = (0 as libc::c_int | 0 as libc::c_int) as uint16_t;
        OP_JoystickSetMenu[i as usize]
            .itemaction = ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(int32_t) -> ()>,
            *mut libc::c_void,
        >(Some(M_AssignJoystick as unsafe extern "C" fn(int32_t) -> ()));
        i += 1;
        i;
    }
    CV_RegisterVar(&mut cv_serversort);
}
#[no_mangle]
pub unsafe extern "C" fn M_InitCharacterTables() {
    let mut i: uint8_t = 0;
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 32 as libc::c_int {
        description[i as usize].used = false_0 as libc::c_int;
        strcpy(
            (description[i as usize].notes).as_mut_ptr(),
            b"???\0" as *const u8 as *const libc::c_char,
        );
        strcpy(
            (description[i as usize].picname).as_mut_ptr(),
            b"\0" as *const u8 as *const libc::c_char,
        );
        strcpy(
            (description[i as usize].nametag).as_mut_ptr(),
            b"\0" as *const u8 as *const libc::c_char,
        );
        strcpy(
            (description[i as usize].skinname).as_mut_ptr(),
            b"\0" as *const u8 as *const libc::c_char,
        );
        strcpy(
            (description[i as usize].displayname).as_mut_ptr(),
            b"\0" as *const u8 as *const libc::c_char,
        );
        description[i as usize].next = 0 as libc::c_int as uint8_t;
        description[i as usize].prev = description[i as usize].next;
        description[i as usize].charpic = 0 as *mut patch_t;
        description[i as usize].namepic = 0 as *mut patch_t;
        description[i as usize].tagoutlinecolor = 0 as libc::c_int as uint16_t;
        description[i as usize].tagtextcolor = description[i as usize].tagoutlinecolor;
        description[i as usize].oppositecolor = description[i as usize].tagtextcolor;
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn M_CreateSecretMenuOption(
    mut str: *const libc::c_char,
) -> *const libc::c_char {
    static mut qbuf: [libc::c_char; 32] = [0; 32];
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 31 as libc::c_int {
        if *str.offset(i as isize) == 0 {
            qbuf[i as usize] = '\0' as i32 as libc::c_char;
            return qbuf.as_mut_ptr();
        } else if *str.offset(i as isize) as libc::c_int != ' ' as i32 {
            qbuf[i as usize] = '?' as i32 as libc::c_char;
        } else {
            qbuf[i as usize] = ' ' as i32 as libc::c_char;
        }
        i += 1;
        i;
    }
    qbuf[31 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    return qbuf.as_mut_ptr();
}
unsafe extern "C" fn M_DrawThermo(
    mut x: int32_t,
    mut y: int32_t,
    mut cv: *mut consvar_t,
) {
    let mut xx: int32_t = x;
    let mut i: int32_t = 0;
    let mut leftlump: lumpnum_t = 0;
    let mut rightlump: lumpnum_t = 0;
    let mut centerlump: [lumpnum_t; 2] = [0; 2];
    let mut cursorlump: lumpnum_t = 0;
    let mut p: *mut patch_t = 0 as *mut patch_t;
    leftlump = W_GetNumForName(b"M_THERML\0" as *const u8 as *const libc::c_char);
    rightlump = W_GetNumForName(b"M_THERMR\0" as *const u8 as *const libc::c_char);
    centerlump[0 as libc::c_int
        as usize] = W_GetNumForName(b"M_THERMM\0" as *const u8 as *const libc::c_char);
    centerlump[1 as libc::c_int
        as usize] = W_GetNumForName(b"M_THERMM\0" as *const u8 as *const libc::c_char);
    cursorlump = W_GetNumForName(b"M_THERMO\0" as *const u8 as *const libc::c_char);
    p = W_CachePatchNum(leftlump, PU_PATCH as libc::c_int) as *mut patch_t;
    V_DrawStretchyFixedPatch(
        xx * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        p,
        0 as *const uint8_t,
    );
    xx += (*p).width as libc::c_int - (*p).leftoffset as libc::c_int;
    i = 0 as libc::c_int;
    while i < 16 as libc::c_int {
        V_DrawStretchyFixedPatch(
            xx * ((1 as libc::c_int) << 16 as libc::c_int),
            y << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0 as libc::c_int,
            W_CachePatchNum(
                centerlump[(i & 1 as libc::c_int) as usize],
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
        xx += 8 as libc::c_int;
        i += 1;
        i;
    }
    V_DrawStretchyFixedPatch(
        xx * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchNum(rightlump, PU_PATCH as libc::c_int) as *mut patch_t,
        0 as *const uint8_t,
    );
    xx = ((*cv).value - (*((*cv).PossibleValue).offset(0 as libc::c_int as isize)).value)
        * (15 as libc::c_int * 8 as libc::c_int)
        / ((*((*cv).PossibleValue).offset(1 as libc::c_int as isize)).value
            - (*((*cv).PossibleValue).offset(0 as libc::c_int as isize)).value);
    V_DrawStretchyFixedPatch(
        (x + 8 as libc::c_int + xx) * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchNum(cursorlump, PU_PATCH as libc::c_int) as *mut patch_t,
        0 as *const uint8_t,
    );
}
unsafe extern "C" fn M_DrawSlider(
    mut x: int32_t,
    mut y: int32_t,
    mut cv: *const consvar_t,
    mut ontop: boolean,
) {
    let mut i: int32_t = 0;
    let mut range: int32_t = 0;
    let mut p: *mut patch_t = 0 as *mut patch_t;
    x = 320 as libc::c_int - x - 78 as libc::c_int;
    V_DrawStretchyFixedPatch(
        x * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchName(
            b"M_SLIDEL\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t,
        0 as *const uint8_t,
    );
    p = W_CachePatchName(
        b"M_SLIDEM\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    i = 1 as libc::c_int;
    while i < 9 as libc::c_int {
        V_DrawStretchyFixedPatch(
            (x + i * 8 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
            y << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0 as libc::c_int,
            p,
            0 as *const uint8_t,
        );
        i += 1;
        i;
    }
    p = W_CachePatchName(
        b"M_SLIDER\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    V_DrawStretchyFixedPatch(
        (x + i * 8 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        p,
        0 as *const uint8_t,
    );
    p = W_CachePatchName(
        b"M_SLIDEC\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    i = 0 as libc::c_int;
    while !((*((*cv).PossibleValue).offset((i + 1 as libc::c_int) as isize)).strvalue)
        .is_null()
    {
        i += 1;
        i;
    }
    if (*cv).flags & CV_FLOAT as libc::c_int != 0 {
        range = (atof((*cv).defaultvalue)
            * ((1 as libc::c_int) << 16 as libc::c_int) as libc::c_double) as int32_t;
    } else {
        range = atoi((*cv).defaultvalue);
    }
    if range != (*cv).value {
        range = (range
            - (*((*cv).PossibleValue).offset(0 as libc::c_int as isize)).value)
            * 100 as libc::c_int
            / ((*((*cv).PossibleValue).offset(i as isize)).value
                - (*((*cv).PossibleValue).offset(0 as libc::c_int as isize)).value);
        if range < 0 as libc::c_int {
            range = 0 as libc::c_int;
        } else if range > 100 as libc::c_int {
            range = 100 as libc::c_int;
        }
        V_DrawStretchyFixedPatch(
            (x + 2 as libc::c_int
                + 9 as libc::c_int * 8 as libc::c_int * range / 100 as libc::c_int)
                << 16 as libc::c_int,
            y << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0x50000 as libc::c_int,
            p,
            yellowmap,
        );
    }
    range = ((*cv).value
        - (*((*cv).PossibleValue).offset(0 as libc::c_int as isize)).value)
        * 100 as libc::c_int
        / ((*((*cv).PossibleValue).offset(i as isize)).value
            - (*((*cv).PossibleValue).offset(0 as libc::c_int as isize)).value);
    if range < 0 as libc::c_int {
        range = 0 as libc::c_int;
    } else if range > 100 as libc::c_int {
        range = 100 as libc::c_int;
    }
    V_DrawStretchyFixedPatch(
        (x + 2 as libc::c_int
            + 9 as libc::c_int * 8 as libc::c_int * range / 100 as libc::c_int)
            << 16 as libc::c_int,
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        p,
        yellowmap,
    );
    if ontop != 0 {
        V_DrawCharacter(
            x - 6 as libc::c_int - skullAnimCounter as libc::c_int / 5 as libc::c_int,
            y,
            '\u{1c}' as i32 | 0x2000 as libc::c_int,
            false_0 as libc::c_int,
        );
        V_DrawCharacter(
            x + 80 as libc::c_int + skullAnimCounter as libc::c_int / 5 as libc::c_int,
            y,
            '\u{1d}' as i32 | 0x2000 as libc::c_int,
            false_0 as libc::c_int,
        );
        V_DrawCenteredString(
            x + 40 as libc::c_int,
            y,
            0x30000 as libc::c_int,
            if (*cv).flags & CV_FLOAT as libc::c_int != 0 {
                va(
                    b"%.2f\0" as *const u8 as *const libc::c_char,
                    FixedToFloat((*cv).value) as libc::c_double,
                )
            } else {
                va(b"%d\0" as *const u8 as *const libc::c_char, (*cv).value)
            },
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn M_DrawTextBox(
    mut x: int32_t,
    mut y: int32_t,
    mut width: int32_t,
    mut boxlines: int32_t,
) {
    V_DrawFill(
        x + 5 as libc::c_int,
        y + 5 as libc::c_int,
        width * 8 as libc::c_int + 6 as libc::c_int,
        boxlines * 8 as libc::c_int + 6 as libc::c_int,
        159 as libc::c_int,
    );
}
static mut staticalong: fixed_t = 0 as libc::c_int;
unsafe extern "C" fn M_DrawStaticBox(
    mut x: fixed_t,
    mut y: fixed_t,
    mut flags: int32_t,
    mut w: fixed_t,
    mut h: fixed_t,
) {
    let mut patch: *mut patch_t = 0 as *mut patch_t;
    let mut sw: fixed_t = 0;
    let mut pw: fixed_t = 0;
    patch = W_CachePatchName(
        b"LSSTATIC\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    sw = w * 2 as libc::c_int;
    pw = (*patch).width as libc::c_int - sw;
    if staticalong > pw {
        staticalong -= pw;
    }
    V_DrawCroppedPatch(
        x << 16 as libc::c_int,
        y << 16 as libc::c_int,
        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
        flags,
        patch,
        0 as *const uint8_t,
        staticalong << 16 as libc::c_int,
        0 as libc::c_int,
        sw << 16 as libc::c_int,
        (h * 2 as libc::c_int) << 16 as libc::c_int,
    );
    staticalong += sw;
    W_UnlockCachedPatch(patch as *mut libc::c_void);
}
unsafe extern "C" fn M_DrawMapEmblems(
    mut mapnum: int32_t,
    mut x: int32_t,
    mut y: int32_t,
    mut norecordattack: boolean,
) {
    let mut lasttype: uint8_t = 255 as libc::c_int as uint8_t;
    let mut curtype: uint8_t = 0;
    let mut emblem: *mut emblem_t = M_GetLevelEmblems(mapnum);
    while !emblem.is_null() {
        match (*emblem).type_0 as libc::c_int {
            3 | 4 | 5 => {
                curtype = 1 as libc::c_int as uint8_t;
            }
            6 | 7 => {
                curtype = 2 as libc::c_int as uint8_t;
            }
            2 => {
                curtype = 3 as libc::c_int as uint8_t;
            }
            _ => {
                curtype = 0 as libc::c_int as uint8_t;
            }
        }
        if norecordattack != 0
            && (curtype as libc::c_int == 1 as libc::c_int
                || curtype as libc::c_int == 2 as libc::c_int)
        {
            emblem = M_GetLevelEmblems(-(1 as libc::c_int));
        } else {
            if lasttype as libc::c_int != 255 as libc::c_int
                && lasttype as libc::c_int != curtype as libc::c_int
            {
                x -= 4 as libc::c_int;
            }
            lasttype = curtype;
            if (*clientGamedata)
                .collected[emblem.offset_from(emblemlocations.as_mut_ptr())
                as libc::c_long as usize] != 0
            {
                V_DrawStretchyFixedPatch(
                    x << 16 as libc::c_int,
                    y << 16 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    0 as libc::c_int,
                    W_CachePatchName(
                        M_GetEmblemPatch(emblem, false_0 as libc::c_int),
                        PU_PATCH as libc::c_int,
                    ) as *mut patch_t,
                    R_GetTranslationColormap(
                        TC_DEFAULT as libc::c_int,
                        M_GetEmblemColor(emblem),
                        1 as libc::c_int as uint8_t,
                    ),
                );
            } else {
                V_DrawStretchyFixedPatch(
                    x << 16 as libc::c_int,
                    y << 16 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    0 as libc::c_int,
                    W_CachePatchName(
                        b"NEEDIT\0" as *const u8 as *const libc::c_char,
                        PU_PATCH as libc::c_int,
                    ) as *mut patch_t,
                    0 as *const uint8_t,
                );
            }
            emblem = M_GetLevelEmblems(-(1 as libc::c_int));
            x -= 12 as libc::c_int + 1 as libc::c_int;
        }
    }
}
unsafe extern "C" fn M_DrawMenuTitle() {
    if !((*currentMenu).menutitlepic).is_null() {
        let mut p: *mut patch_t = W_CachePatchName(
            (*currentMenu).menutitlepic,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t;
        if (*p).height as libc::c_int > 24 as libc::c_int {
            let mut xtitle: int32_t = (320 as libc::c_int
                - (*p).width as libc::c_int / 2 as libc::c_int) / 2 as libc::c_int;
            let mut ytitle: int32_t = (30 as libc::c_int
                - (*p).height as libc::c_int / 2 as libc::c_int) / 2 as libc::c_int;
            if xtitle < 0 as libc::c_int {
                xtitle = 0 as libc::c_int;
            }
            if ytitle < 0 as libc::c_int {
                ytitle = 0 as libc::c_int;
            }
            V_DrawStretchyFixedPatch(
                xtitle << 16 as libc::c_int,
                ytitle << 16 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0 as libc::c_int,
                p,
                0 as *const uint8_t,
            );
        } else {
            let mut xtitle_0: int32_t = (320 as libc::c_int - (*p).width as libc::c_int)
                / 2 as libc::c_int;
            let mut ytitle_0: int32_t = (30 as libc::c_int - (*p).height as libc::c_int)
                / 2 as libc::c_int;
            if xtitle_0 < 0 as libc::c_int {
                xtitle_0 = 0 as libc::c_int;
            }
            if ytitle_0 < 0 as libc::c_int {
                ytitle_0 = 0 as libc::c_int;
            }
            V_DrawStretchyFixedPatch(
                xtitle_0 * ((1 as libc::c_int) << 16 as libc::c_int),
                ytitle_0 << 16 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                0 as libc::c_int,
                p,
                0 as *const uint8_t,
            );
        }
    }
}
unsafe extern "C" fn M_DrawGenericMenu() {
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut i: int32_t = 0;
    let mut cursory: int32_t = 0 as libc::c_int;
    x = (*currentMenu).x as int32_t;
    y = (*currentMenu).y as int32_t;
    M_DrawMenuTitle();
    i = 0 as libc::c_int;
    while i < (*currentMenu).numitems as libc::c_int {
        if i == itemOn as libc::c_int {
            cursory = y;
        }
        let mut current_block_54: u64;
        match (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int
        {
            16 => {
                if !((*((*currentMenu).menuitems).offset(i as isize)).patch).is_null()
                    && *((*((*currentMenu).menuitems).offset(i as isize)).patch)
                        .offset(0 as libc::c_int as isize) as libc::c_int != 0
                {
                    if (*((*currentMenu).menuitems).offset(i as isize)).status
                        as libc::c_int & 256 as libc::c_int != 0
                    {
                        let mut p: *mut patch_t = 0 as *mut patch_t;
                        p = W_CachePatchName(
                            (*((*currentMenu).menuitems).offset(i as isize)).patch,
                            PU_PATCH as libc::c_int,
                        ) as *mut patch_t;
                        V_DrawStretchyFixedPatch(
                            (320 as libc::c_int - (*p).width as libc::c_int)
                                / 2 as libc::c_int
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                            y << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            0 as libc::c_int,
                            p,
                            0 as *const uint8_t,
                        );
                    } else {
                        V_DrawStretchyFixedPatch(
                            x * ((1 as libc::c_int) << 16 as libc::c_int),
                            y << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            0 as libc::c_int,
                            W_CachePatchName(
                                (*((*currentMenu).menuitems).offset(i as isize)).patch,
                                PU_PATCH as libc::c_int,
                            ) as *mut patch_t,
                            0 as *const uint8_t,
                        );
                    }
                }
                current_block_54 = 4992385555722172629;
            }
            0 | 64 => {
                current_block_54 = 4992385555722172629;
            }
            128 => {
                M_DrawThermo(
                    x,
                    y,
                    (*((*currentMenu).menuitems).offset(i as isize)).itemaction
                        as *mut consvar_t,
                );
                y += 16 as libc::c_int;
                current_block_54 = 9353995356876505083;
            }
            32 | 48 => {
                if (*((*currentMenu).menuitems).offset(i as isize)).alphaKey != 0 {
                    y = (*currentMenu).y as libc::c_int
                        + (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                            as libc::c_int;
                }
                if i == itemOn as libc::c_int {
                    cursory = y;
                }
                if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
                    & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int
                    == 32 as libc::c_int
                {
                    V_DrawString(
                        x,
                        y,
                        0 as libc::c_int,
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    );
                } else {
                    V_DrawString(
                        x,
                        y,
                        0x2000 as libc::c_int,
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    );
                }
                match (*((*currentMenu).menuitems).offset(i as isize)).status
                    as libc::c_int & 15 as libc::c_int
                {
                    8 => {
                        let mut cv: *mut consvar_t = (*((*currentMenu).menuitems)
                            .offset(i as isize))
                            .itemaction as *mut consvar_t;
                        let mut current_block_34: u64;
                        match (*((*currentMenu).menuitems).offset(i as isize)).status
                            as libc::c_int
                            & 512 as libc::c_int + 1024 as libc::c_int
                                + 2048 as libc::c_int
                        {
                            512 => {
                                M_DrawSlider(
                                    x,
                                    y,
                                    cv,
                                    (i == itemOn as libc::c_int) as libc::c_int,
                                );
                                current_block_34 = 9254648948509490476;
                            }
                            1536 => {
                                current_block_34 = 9254648948509490476;
                            }
                            2560 => {
                                current_block_34 = 7828949454673616476;
                            }
                            1024 => {
                                M_DrawTextBox(
                                    x,
                                    y + 4 as libc::c_int,
                                    32 as libc::c_int,
                                    1 as libc::c_int,
                                );
                                V_DrawString(
                                    x + 8 as libc::c_int,
                                    y + 12 as libc::c_int,
                                    0x800000 as libc::c_int,
                                    (*cv).string,
                                );
                                if (skullAnimCounter as libc::c_int) < 4 as libc::c_int
                                    && i == itemOn as libc::c_int
                                {
                                    V_DrawCharacter(
                                        x + 8 as libc::c_int
                                            + V_StringWidth((*cv).string, 0 as libc::c_int),
                                        y + 12 as libc::c_int,
                                        '_' as i32 | 0x80 as libc::c_int,
                                        false_0 as libc::c_int,
                                    );
                                }
                                y += 16 as libc::c_int;
                                current_block_34 = 7828949454673616476;
                            }
                            _ => {
                                V_DrawRightAlignedString(
                                    320 as libc::c_int - x,
                                    y,
                                    if (*cv).flags & CV_CHEAT as libc::c_int != 0
                                        && CV_IsSetToDefault(cv) == 0
                                    {
                                        0x5000 as libc::c_int
                                    } else {
                                        0x2000 as libc::c_int
                                    },
                                    (*cv).string,
                                );
                                if i == itemOn as libc::c_int {
                                    V_DrawCharacter(
                                        320 as libc::c_int - x - 10 as libc::c_int
                                            - V_StringWidth((*cv).string, 0 as libc::c_int)
                                            - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                                        y,
                                        '\u{1c}' as i32 | 0x2000 as libc::c_int,
                                        false_0 as libc::c_int,
                                    );
                                    V_DrawCharacter(
                                        320 as libc::c_int - x + 2 as libc::c_int
                                            + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                                        y,
                                        '\u{1d}' as i32 | 0x2000 as libc::c_int,
                                        false_0 as libc::c_int,
                                    );
                                }
                                current_block_34 = 7828949454673616476;
                            }
                        }
                        match current_block_34 {
                            9254648948509490476 => {}
                            _ => {}
                        }
                    }
                    _ => {}
                }
                y += 8 as libc::c_int;
                current_block_54 = 9353995356876505083;
            }
            96 => {
                V_DrawString(
                    x,
                    y,
                    0 as libc::c_int,
                    (*((*currentMenu).menuitems).offset(i as isize)).text,
                );
                current_block_54 = 12478818015745401284;
            }
            80 => {
                current_block_54 = 12478818015745401284;
            }
            112 => {
                if !((*((*currentMenu).menuitems).offset(i as isize)).patch).is_null()
                    && *((*((*currentMenu).menuitems).offset(i as isize)).patch)
                        .offset(0 as libc::c_int as isize) as libc::c_int != 0
                {
                    V_DrawStretchyFixedPatch(
                        x << 16 as libc::c_int,
                        y << 16 as libc::c_int,
                        (1 as libc::c_int) << 16 as libc::c_int,
                        (1 as libc::c_int) << 16 as libc::c_int,
                        0 as libc::c_int,
                        W_CachePatchName(
                            (*((*currentMenu).menuitems).offset(i as isize)).patch,
                            PU_PATCH as libc::c_int,
                        ) as *mut patch_t,
                        graymap,
                    );
                }
                y += 16 as libc::c_int;
                current_block_54 = 9353995356876505083;
            }
            144 => {
                if (*((*currentMenu).menuitems).offset(i as isize)).alphaKey != 0 {
                    y = (*currentMenu).y as libc::c_int
                        + (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                            as libc::c_int;
                }
                current_block_54 = 17749238027618021638;
            }
            160 => {
                current_block_54 = 17749238027618021638;
            }
            192 => {
                if (*((*currentMenu).menuitems).offset(i as isize)).alphaKey != 0 {
                    y = (*currentMenu).y as libc::c_int
                        + (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                            as libc::c_int;
                }
                V_DrawString(
                    x,
                    y,
                    0x50000 as libc::c_int | 0x800 as libc::c_int,
                    M_CreateSecretMenuOption(
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    ),
                );
                y += 8 as libc::c_int;
                current_block_54 = 9353995356876505083;
            }
            176 => {
                if (*((*currentMenu).menuitems).offset(i as isize)).alphaKey != 0 {
                    y = (*currentMenu).y as libc::c_int
                        + (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                            as libc::c_int;
                }
                M_DrawLevelPlatterHeader(
                    y - (16 as libc::c_int - 12 as libc::c_int),
                    (*((*currentMenu).menuitems).offset(i as isize)).text,
                    true_0 as libc::c_int,
                    false_0 as libc::c_int,
                );
                y += 8 as libc::c_int;
                current_block_54 = 9353995356876505083;
            }
            _ => {
                current_block_54 = 9353995356876505083;
            }
        }
        match current_block_54 {
            17749238027618021638 => {
                V_DrawString(
                    x,
                    y,
                    0x50000 as libc::c_int,
                    (*((*currentMenu).menuitems).offset(i as isize)).text,
                );
                y += 8 as libc::c_int;
            }
            4992385555722172629 => {
                y += 16 as libc::c_int;
            }
            12478818015745401284 => {
                y += 8 as libc::c_int;
            }
            _ => {}
        }
        i += 1;
        i;
    }
    if (*((*currentMenu).menuitems).offset(itemOn as isize)).status as libc::c_int
        & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int == 16 as libc::c_int
        || (*((*currentMenu).menuitems).offset(itemOn as isize)).status as libc::c_int
            & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int
            == 0 as libc::c_int
    {
        V_DrawStretchyFixedPatch(
            ((*currentMenu).x as libc::c_int + -(32 as libc::c_int))
                * ((1 as libc::c_int) << 16 as libc::c_int),
            (cursory - 5 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0 as libc::c_int,
            W_CachePatchName(
                b"M_CURSOR\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
    } else {
        V_DrawStretchyFixedPatch(
            ((*currentMenu).x as libc::c_int - 24 as libc::c_int)
                * ((1 as libc::c_int) << 16 as libc::c_int),
            cursory << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0 as libc::c_int,
            W_CachePatchName(
                b"M_CURSOR\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
        V_DrawString(
            (*currentMenu).x as int32_t,
            cursory,
            0x2000 as libc::c_int,
            (*((*currentMenu).menuitems).offset(itemOn as isize)).text,
        );
    };
}
#[no_mangle]
pub static mut PlaystyleNames: [*const libc::c_char; 4] = [
    b"\x86Strafe\x80\0" as *const u8 as *const libc::c_char,
    b"Manual\0" as *const u8 as *const libc::c_char,
    b"Automatic\0" as *const u8 as *const libc::c_char,
    b"Old Analog??\0" as *const u8 as *const libc::c_char,
];
#[no_mangle]
pub static mut PlaystyleDesc: [*const libc::c_char; 4] = [
    b"A play style resembling\nold-school SRB2 gameplay.\n\nThis play style is identical\nto Manual, except that the\nplayer always looks in the\ndirection of the camera.\0"
        as *const u8 as *const libc::c_char,
    b"A play style made for full control,\nusing a keyboard and mouse.\n\nThe camera rotates only when\nyou tell it to. The player\nlooks in the direction they're\nmoving, but acts in the direction\nthe camera is facing.\n\nMastery of this play style will\nopen up the highest level of play!\0"
        as *const u8 as *const libc::c_char,
    b"The default play style, designed for\ngamepads and hassle-free play.\n\nThe camera rotates automatically\nas you move, and the player faces\nand acts in the direction\nthey're moving.\n\nHold \x82Center View\x80 to lock the\ncamera behind the player, or target\nenemies, bosses and monitors!\n\0"
        as *const u8 as *const libc::c_char,
    b"I see.\n\nYou really liked the old analog mode,\nso when 2.2 came out, you opened up\nyour config file and brought it back.\n\nThat's absolutely valid, but I implore\nyou to try the new Automatic play style\ninstead!\0"
        as *const u8 as *const libc::c_char,
];
static mut playstyle_activeplayer: uint8_t = 0 as libc::c_int as uint8_t;
static mut playstyle_currentchoice: uint8_t = 0 as libc::c_int as uint8_t;
unsafe extern "C" fn M_DrawControlsDefMenu() {
    let mut opt: uint8_t = 0 as libc::c_int as uint8_t;
    M_DrawGenericMenu();
    if currentMenu == &mut OP_P1ControlsDef as *mut menu_t {
        opt = (if cv_directionchar[0 as libc::c_int as usize].value != 0 {
            1 as libc::c_int
        } else {
            0 as libc::c_int
        }) as uint8_t;
        playstyle_currentchoice = (if cv_useranalog[0 as libc::c_int as usize].value != 0
        {
            3 as libc::c_int - opt as libc::c_int
        } else {
            opt as libc::c_int
        }) as uint8_t;
        opt = playstyle_currentchoice;
        if opt as libc::c_int == 2 as libc::c_int {
            OP_CameraOptionsDef.menuitems = OP_CameraExtendedOptionsMenu.as_mut_ptr();
            OP_CameraOptionsDef
                .numitems = (::core::mem::size_of::<[menuitem_t; 22]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t;
        } else {
            OP_CameraOptionsDef.menuitems = OP_CameraOptionsMenu.as_mut_ptr();
            OP_CameraOptionsDef
                .numitems = (::core::mem::size_of::<[menuitem_t; 12]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t;
        }
    } else {
        opt = (if cv_directionchar[1 as libc::c_int as usize].value != 0 {
            1 as libc::c_int
        } else {
            0 as libc::c_int
        }) as uint8_t;
        playstyle_currentchoice = (if cv_useranalog[1 as libc::c_int as usize].value != 0
        {
            3 as libc::c_int - opt as libc::c_int
        } else {
            opt as libc::c_int
        }) as uint8_t;
        opt = playstyle_currentchoice;
        if opt as libc::c_int == 2 as libc::c_int {
            OP_Camera2OptionsDef.menuitems = OP_Camera2ExtendedOptionsMenu.as_mut_ptr();
            OP_Camera2OptionsDef
                .numitems = (::core::mem::size_of::<[menuitem_t; 22]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t;
        } else {
            OP_Camera2OptionsDef.menuitems = OP_Camera2OptionsMenu.as_mut_ptr();
            OP_Camera2OptionsDef
                .numitems = (::core::mem::size_of::<[menuitem_t; 12]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t;
        }
    }
    V_DrawRightAlignedString(
        320 as libc::c_int - (*currentMenu).x as libc::c_int,
        (*currentMenu).y as libc::c_int + 80 as libc::c_int,
        0x2000 as libc::c_int,
        PlaystyleNames[opt as usize],
    );
}
unsafe extern "C" fn M_DrawGenericScrollMenu() {
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut i: int32_t = 0;
    let mut max: int32_t = 0;
    let mut bottom: int32_t = 0;
    let mut tempcentery: int32_t = 0;
    let mut cursory: int32_t = 0 as libc::c_int;
    x = (*currentMenu).x as int32_t;
    y = (*currentMenu).y as int32_t;
    if ((*((*currentMenu).menuitems)
        .offset(((*currentMenu).numitems as libc::c_int - 1 as libc::c_int) as isize))
        .alphaKey as libc::c_int) < 72 as libc::c_int
    {
        tempcentery = (*currentMenu).y as int32_t;
    } else if (*((*currentMenu).menuitems).offset(itemOn as isize)).alphaKey
        as libc::c_int * 2 as libc::c_int
        - (*((*currentMenu).menuitems).offset(0 as libc::c_int as isize)).alphaKey
            as libc::c_int * 2 as libc::c_int <= 72 as libc::c_int
    {
        tempcentery = (*currentMenu).y as libc::c_int
            - (*((*currentMenu).menuitems).offset(0 as libc::c_int as isize)).alphaKey
                as libc::c_int * 2 as libc::c_int;
    } else if (*((*currentMenu).menuitems)
        .offset(((*currentMenu).numitems as libc::c_int - 1 as libc::c_int) as isize))
        .alphaKey as libc::c_int * 2 as libc::c_int
        - (*((*currentMenu).menuitems).offset(itemOn as isize)).alphaKey as libc::c_int
            * 2 as libc::c_int <= 72 as libc::c_int
    {
        tempcentery = (*currentMenu).y as libc::c_int
            - (*((*currentMenu).menuitems)
                .offset(
                    ((*currentMenu).numitems as libc::c_int - 1 as libc::c_int) as isize,
                ))
                .alphaKey as libc::c_int * 2 as libc::c_int
            + 2 as libc::c_int * 72 as libc::c_int;
    } else {
        tempcentery = (*currentMenu).y as libc::c_int
            - (*((*currentMenu).menuitems).offset(itemOn as isize)).alphaKey
                as libc::c_int * 2 as libc::c_int + 72 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*currentMenu).numitems as libc::c_int {
        if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            != 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
            && (*((*currentMenu).menuitems).offset(i as isize)).alphaKey as libc::c_int
                * 2 as libc::c_int + tempcentery >= (*currentMenu).y as libc::c_int
        {
            break;
        }
        i += 1;
        i;
    }
    bottom = (*currentMenu).numitems as int32_t;
    while bottom > 0 as libc::c_int {
        if (*((*currentMenu).menuitems).offset((bottom - 1 as libc::c_int) as isize))
            .status as libc::c_int
            != 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
        {
            break;
        }
        bottom -= 1;
        bottom;
    }
    max = bottom;
    while max > 0 as libc::c_int {
        if (*((*currentMenu).menuitems).offset((max - 1 as libc::c_int) as isize)).status
            as libc::c_int
            != 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
            && (*((*currentMenu).menuitems).offset((max - 1 as libc::c_int) as isize))
                .alphaKey as libc::c_int * 2 as libc::c_int + tempcentery
                <= (*currentMenu).y as libc::c_int + 2 as libc::c_int * 72 as libc::c_int
        {
            break;
        }
        max -= 1;
        max;
    }
    if i != 0 {
        V_DrawString(
            (*currentMenu).x as libc::c_int - 20 as libc::c_int,
            (*currentMenu).y as libc::c_int
                - skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1A\0" as *const u8 as *const libc::c_char,
        );
    }
    if max != bottom {
        V_DrawString(
            (*currentMenu).x as libc::c_int - 20 as libc::c_int,
            (*currentMenu).y as libc::c_int + 2 as libc::c_int * 72 as libc::c_int
                + skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1B\0" as *const u8 as *const libc::c_char,
        );
    }
    M_DrawMenuTitle();
    while i < max {
        y = (*((*currentMenu).menuitems).offset(i as isize)).alphaKey as libc::c_int
            * 2 as libc::c_int + tempcentery;
        if i == itemOn as libc::c_int {
            cursory = y;
        }
        match (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int
        {
            32 | 48 => {
                if i != itemOn as libc::c_int
                    && (*((*currentMenu).menuitems).offset(i as isize)).status
                        as libc::c_int
                        & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int
                        == 32 as libc::c_int
                {
                    V_DrawString(
                        x,
                        y,
                        0 as libc::c_int,
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    );
                } else {
                    V_DrawString(
                        x,
                        y,
                        0x2000 as libc::c_int,
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    );
                }
                match (*((*currentMenu).menuitems).offset(i as isize)).status
                    as libc::c_int & 15 as libc::c_int
                {
                    8 => {
                        let mut cv: *mut consvar_t = (*((*currentMenu).menuitems)
                            .offset(i as isize))
                            .itemaction as *mut consvar_t;
                        let mut current_block_35: u64;
                        match (*((*currentMenu).menuitems).offset(i as isize)).status
                            as libc::c_int
                            & 512 as libc::c_int + 1024 as libc::c_int
                                + 2048 as libc::c_int
                        {
                            512 => {
                                M_DrawSlider(
                                    x,
                                    y,
                                    cv,
                                    (i == itemOn as libc::c_int) as libc::c_int,
                                );
                                current_block_35 = 12017647216888998220;
                            }
                            1536 => {
                                current_block_35 = 12017647216888998220;
                            }
                            2560 => {
                                current_block_35 = 12946735491697102324;
                            }
                            1024 => {
                                if y + 12 as libc::c_int
                                    > (*currentMenu).y as libc::c_int
                                        + 2 as libc::c_int * 72 as libc::c_int
                                {
                                    current_block_35 = 15004371738079956865;
                                } else {
                                    M_DrawTextBox(
                                        x,
                                        y + 4 as libc::c_int,
                                        32 as libc::c_int,
                                        1 as libc::c_int,
                                    );
                                    V_DrawString(
                                        x + 8 as libc::c_int,
                                        y + 12 as libc::c_int,
                                        0x800000 as libc::c_int,
                                        (*cv).string,
                                    );
                                    if (skullAnimCounter as libc::c_int) < 4 as libc::c_int
                                        && i == itemOn as libc::c_int
                                    {
                                        V_DrawCharacter(
                                            x + 8 as libc::c_int
                                                + V_StringWidth((*cv).string, 0 as libc::c_int),
                                            y + 12 as libc::c_int,
                                            '_' as i32 | 0x80 as libc::c_int,
                                            false_0 as libc::c_int,
                                        );
                                    }
                                    current_block_35 = 15004371738079956865;
                                }
                            }
                            _ => {
                                V_DrawRightAlignedString(
                                    320 as libc::c_int - x,
                                    y,
                                    if (*cv).flags & CV_CHEAT as libc::c_int != 0
                                        && CV_IsSetToDefault(cv) == 0
                                    {
                                        0x5000 as libc::c_int
                                    } else {
                                        0x2000 as libc::c_int
                                    },
                                    (*cv).string,
                                );
                                if i == itemOn as libc::c_int {
                                    V_DrawCharacter(
                                        320 as libc::c_int - x - 10 as libc::c_int
                                            - V_StringWidth((*cv).string, 0 as libc::c_int)
                                            - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                                        y,
                                        '\u{1c}' as i32 | 0x2000 as libc::c_int,
                                        false_0 as libc::c_int,
                                    );
                                    V_DrawCharacter(
                                        320 as libc::c_int - x + 2 as libc::c_int
                                            + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                                        y,
                                        '\u{1d}' as i32 | 0x2000 as libc::c_int,
                                        false_0 as libc::c_int,
                                    );
                                }
                                current_block_35 = 15004371738079956865;
                            }
                        }
                        match current_block_35 {
                            12017647216888998220 => {
                                current_block_35 = 12946735491697102324;
                            }
                            _ => {}
                        }
                        match current_block_35 {
                            12946735491697102324 => {}
                            _ => {}
                        }
                    }
                    _ => {}
                }
            }
            144 => {
                match (*((*currentMenu).menuitems).offset(i as isize)).status
                    as libc::c_int & 15 as libc::c_int
                {
                    11 => {
                        V_DrawString(
                            x,
                            y,
                            0x50000 as libc::c_int,
                            (*((*currentMenu).menuitems).offset(i as isize)).patch,
                        );
                        V_DrawRightAlignedString(
                            320 as libc::c_int - x,
                            y,
                            0x50000 as libc::c_int,
                            (*((*currentMenu).menuitems).offset(i as isize)).text,
                        );
                    }
                    _ => {
                        V_DrawString(
                            x,
                            y,
                            0x50000 as libc::c_int,
                            (*((*currentMenu).menuitems).offset(i as isize)).text,
                        );
                    }
                }
            }
            192 => {
                V_DrawString(
                    x,
                    y,
                    0x50000 as libc::c_int | 0x800 as libc::c_int,
                    M_CreateSecretMenuOption(
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    ),
                );
            }
            176 => {
                M_DrawLevelPlatterHeader(
                    y - (16 as libc::c_int - 12 as libc::c_int),
                    (*((*currentMenu).menuitems).offset(i as isize)).text,
                    true_0 as libc::c_int,
                    false_0 as libc::c_int,
                );
            }
            16 | 64 | 128 | 96 | 80 | 112 | 160 | 0 | _ => {}
        }
        i += 1;
        i;
    }
    V_DrawStretchyFixedPatch(
        ((*currentMenu).x as libc::c_int - 24 as libc::c_int)
            * ((1 as libc::c_int) << 16 as libc::c_int),
        cursory << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchName(
            b"M_CURSOR\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t,
        0 as *const uint8_t,
    );
}
unsafe extern "C" fn M_DrawPauseMenu() {
    let mut current_block: u64;
    let mut data: *mut gamedata_t = clientGamedata;
    if gamestate as libc::c_uint == GS_LEVEL as libc::c_int as libc::c_uint
        || gamestate as libc::c_uint == GS_INTERMISSION as libc::c_int as libc::c_uint
    {
        let mut emblem_detail: [*mut emblem_t; 3] = [
            0 as *mut emblem_t,
            0 as *mut emblem_t,
            0 as *mut emblem_t,
        ];
        let mut emblem_text: [[libc::c_char; 20]; 3] = [[0; 20]; 3];
        let mut i: int32_t = 0;
        M_DrawTextBox(
            27 as libc::c_int,
            16 as libc::c_int,
            32 as libc::c_int,
            6 as libc::c_int,
        );
        M_DrawMapEmblems(
            gamemap as int32_t,
            272 as libc::c_int,
            28 as libc::c_int,
            true_0 as libc::c_int,
        );
        if (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize]).actnum
            as libc::c_int != 0 as libc::c_int
        {
            V_DrawString(
                40 as libc::c_int,
                28 as libc::c_int,
                0x2000 as libc::c_int,
                va(
                    b"%s %d\0" as *const u8 as *const libc::c_char,
                    ((*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int)
                        as usize])
                        .lvlttl)
                        .as_mut_ptr(),
                    (*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int)
                        as usize])
                        .actnum as libc::c_int,
                ),
            );
        } else {
            V_DrawString(
                40 as libc::c_int,
                28 as libc::c_int,
                0x2000 as libc::c_int,
                ((*mapheaderinfo[(gamemap as libc::c_int - 1 as libc::c_int) as usize])
                    .lvlttl)
                    .as_mut_ptr(),
            );
        }
        let mut emblem: *mut emblem_t = M_GetLevelEmblems(gamemap as int32_t);
        while !emblem.is_null() {
            let mut emblemslot: int32_t = 0;
            let mut targettext: [libc::c_char; 9] = [0; 9];
            let mut currenttext: [libc::c_char; 9] = [0; 9];
            match (*emblem).type_0 as libc::c_int {
                3 => {
                    snprintf(
                        targettext.as_mut_ptr(),
                        9 as libc::c_int as libc::c_ulong,
                        b"%d\0" as *const u8 as *const libc::c_char,
                        (*emblem).var,
                    );
                    snprintf(
                        currenttext.as_mut_ptr(),
                        9 as libc::c_int as libc::c_ulong,
                        b"%u\0" as *const u8 as *const libc::c_char,
                        G_GetBestScore(gamemap, data),
                    );
                    targettext[8 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    currenttext[8 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    emblemslot = 0 as libc::c_int;
                    current_block = 9853141518545631134;
                }
                4 => {
                    emblemslot = (*emblem).var;
                    snprintf(
                        targettext.as_mut_ptr(),
                        9 as libc::c_int as libc::c_ulong,
                        b"%i:%02i.%02i\0" as *const u8 as *const libc::c_char,
                        G_TicsToMinutes(emblemslot as tic_t, false_0 as libc::c_int),
                        G_TicsToSeconds(emblemslot as tic_t),
                        G_TicsToCentiseconds(emblemslot as tic_t),
                    );
                    emblemslot = G_GetBestTime(gamemap, data) as int32_t;
                    if emblemslot as tic_t == 4294967295 as libc::c_uint {
                        snprintf(
                            currenttext.as_mut_ptr(),
                            9 as libc::c_int as libc::c_ulong,
                            b"-:--.--\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        snprintf(
                            currenttext.as_mut_ptr(),
                            9 as libc::c_int as libc::c_ulong,
                            b"%i:%02i.%02i\0" as *const u8 as *const libc::c_char,
                            G_TicsToMinutes(emblemslot as tic_t, false_0 as libc::c_int),
                            G_TicsToSeconds(emblemslot as tic_t),
                            G_TicsToCentiseconds(emblemslot as tic_t),
                        );
                    }
                    targettext[8 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    currenttext[8 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    emblemslot = 1 as libc::c_int;
                    current_block = 9853141518545631134;
                }
                5 => {
                    snprintf(
                        targettext.as_mut_ptr(),
                        9 as libc::c_int as libc::c_ulong,
                        b"%d\0" as *const u8 as *const libc::c_char,
                        (*emblem).var,
                    );
                    snprintf(
                        currenttext.as_mut_ptr(),
                        9 as libc::c_int as libc::c_ulong,
                        b"%u\0" as *const u8 as *const libc::c_char,
                        G_GetBestRings(gamemap, data) as libc::c_int,
                    );
                    targettext[8 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    currenttext[8 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    emblemslot = 2 as libc::c_int;
                    current_block = 9853141518545631134;
                }
                6 => {
                    snprintf(
                        targettext.as_mut_ptr(),
                        9 as libc::c_int as libc::c_ulong,
                        b"%u\0" as *const u8 as *const libc::c_char,
                        P_GetScoreForGrade(
                            gamemap,
                            0 as libc::c_int as uint8_t,
                            (*emblem).var as uint8_t,
                        ),
                    );
                    snprintf(
                        currenttext.as_mut_ptr(),
                        9 as libc::c_int as libc::c_ulong,
                        b"%u\0" as *const u8 as *const libc::c_char,
                        G_GetBestNightsScore(gamemap, 0 as libc::c_int as uint8_t, data),
                    );
                    targettext[8 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    currenttext[8 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    emblemslot = 1 as libc::c_int;
                    current_block = 9853141518545631134;
                }
                7 => {
                    emblemslot = (*emblem).var;
                    snprintf(
                        targettext.as_mut_ptr(),
                        9 as libc::c_int as libc::c_ulong,
                        b"%i:%02i.%02i\0" as *const u8 as *const libc::c_char,
                        G_TicsToMinutes(emblemslot as tic_t, false_0 as libc::c_int),
                        G_TicsToSeconds(emblemslot as tic_t),
                        G_TicsToCentiseconds(emblemslot as tic_t),
                    );
                    emblemslot = G_GetBestNightsTime(
                        gamemap,
                        0 as libc::c_int as uint8_t,
                        data,
                    ) as int32_t;
                    if emblemslot as tic_t == 4294967295 as libc::c_uint {
                        snprintf(
                            currenttext.as_mut_ptr(),
                            9 as libc::c_int as libc::c_ulong,
                            b"-:--.--\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        snprintf(
                            currenttext.as_mut_ptr(),
                            9 as libc::c_int as libc::c_ulong,
                            b"%i:%02i.%02i\0" as *const u8 as *const libc::c_char,
                            G_TicsToMinutes(emblemslot as tic_t, false_0 as libc::c_int),
                            G_TicsToSeconds(emblemslot as tic_t),
                            G_TicsToCentiseconds(emblemslot as tic_t),
                        );
                    }
                    targettext[8 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    currenttext[8 as libc::c_int
                        as usize] = 0 as libc::c_int as libc::c_char;
                    emblemslot = 2 as libc::c_int;
                    current_block = 9853141518545631134;
                }
                _ => {
                    current_block = 13715711915647677483;
                }
            }
            match current_block {
                9853141518545631134 => {
                    if (emblem_detail[emblemslot as usize]).is_null() {
                        emblem_detail[emblemslot as usize] = emblem;
                        snprintf(
                            (emblem_text[emblemslot as usize]).as_mut_ptr(),
                            20 as libc::c_int as libc::c_ulong,
                            b"%8s /%8s\0" as *const u8 as *const libc::c_char,
                            currenttext.as_mut_ptr(),
                            targettext.as_mut_ptr(),
                        );
                        emblem_text[emblemslot
                            as usize][19 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                    }
                }
                _ => {}
            }
            emblem = M_GetLevelEmblems(-(1 as libc::c_int));
        }
        i = 0 as libc::c_int;
        while i < 3 as libc::c_int {
            let mut emblem_0: *mut emblem_t = emblem_detail[i as usize];
            if !emblem_0.is_null() {
                if (*data)
                    .collected[emblem_0.offset_from(emblemlocations.as_mut_ptr())
                    as libc::c_long as usize] != 0
                {
                    V_DrawStretchyFixedPatch(
                        (40 as libc::c_int) << 16 as libc::c_int,
                        (44 as libc::c_int + i * 8 as libc::c_int) << 16 as libc::c_int,
                        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                        0 as libc::c_int,
                        W_CachePatchName(
                            M_GetEmblemPatch(emblem_0, false_0 as libc::c_int),
                            PU_PATCH as libc::c_int,
                        ) as *mut patch_t,
                        R_GetTranslationColormap(
                            TC_DEFAULT as libc::c_int,
                            M_GetEmblemColor(emblem_0),
                            1 as libc::c_int as uint8_t,
                        ),
                    );
                } else {
                    V_DrawStretchyFixedPatch(
                        (40 as libc::c_int) << 16 as libc::c_int,
                        (44 as libc::c_int + i * 8 as libc::c_int) << 16 as libc::c_int,
                        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                        0 as libc::c_int,
                        W_CachePatchName(
                            b"NEEDIT\0" as *const u8 as *const libc::c_char,
                            PU_PATCH as libc::c_int,
                        ) as *mut patch_t,
                        0 as *const uint8_t,
                    );
                }
                match (*emblem_0).type_0 as libc::c_int {
                    3 | 6 => {
                        V_DrawString(
                            56 as libc::c_int,
                            44 as libc::c_int + i * 8 as libc::c_int,
                            0x2000 as libc::c_int,
                            b"SCORE:\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    4 | 7 => {
                        V_DrawString(
                            56 as libc::c_int,
                            44 as libc::c_int + i * 8 as libc::c_int,
                            0x2000 as libc::c_int,
                            b"TIME:\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    5 => {
                        V_DrawString(
                            56 as libc::c_int,
                            44 as libc::c_int + i * 8 as libc::c_int,
                            0x2000 as libc::c_int,
                            b"RINGS:\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {}
                }
                V_DrawRightAlignedString(
                    284 as libc::c_int,
                    44 as libc::c_int + i * 8 as libc::c_int,
                    0xc00 as libc::c_int,
                    (emblem_text[i as usize]).as_mut_ptr(),
                );
            }
            i += 1;
            i;
        }
    }
    M_DrawGenericMenu();
}
unsafe extern "C" fn M_DrawCenteredMenu() {
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut i: int32_t = 0;
    let mut cursory: int32_t = 0 as libc::c_int;
    x = (*currentMenu).x as int32_t;
    y = (*currentMenu).y as int32_t;
    M_DrawMenuTitle();
    i = 0 as libc::c_int;
    while i < (*currentMenu).numitems as libc::c_int {
        if i == itemOn as libc::c_int {
            cursory = y;
        }
        let mut current_block_46: u64;
        match (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int
        {
            16 => {
                if !((*((*currentMenu).menuitems).offset(i as isize)).patch).is_null()
                    && *((*((*currentMenu).menuitems).offset(i as isize)).patch)
                        .offset(0 as libc::c_int as isize) as libc::c_int != 0
                {
                    if (*((*currentMenu).menuitems).offset(i as isize)).status
                        as libc::c_int & 256 as libc::c_int != 0
                    {
                        let mut p: *mut patch_t = 0 as *mut patch_t;
                        p = W_CachePatchName(
                            (*((*currentMenu).menuitems).offset(i as isize)).patch,
                            PU_PATCH as libc::c_int,
                        ) as *mut patch_t;
                        V_DrawStretchyFixedPatch(
                            (320 as libc::c_int - (*p).width as libc::c_int)
                                / 2 as libc::c_int
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                            y << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            0 as libc::c_int,
                            p,
                            0 as *const uint8_t,
                        );
                    } else {
                        V_DrawStretchyFixedPatch(
                            x * ((1 as libc::c_int) << 16 as libc::c_int),
                            y << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            0 as libc::c_int,
                            W_CachePatchName(
                                (*((*currentMenu).menuitems).offset(i as isize)).patch,
                                PU_PATCH as libc::c_int,
                            ) as *mut patch_t,
                            0 as *const uint8_t,
                        );
                    }
                }
                current_block_46 = 4937017505496830167;
            }
            0 | 64 => {
                current_block_46 = 4937017505496830167;
            }
            128 => {
                M_DrawThermo(
                    x,
                    y,
                    (*((*currentMenu).menuitems).offset(i as isize)).itemaction
                        as *mut consvar_t,
                );
                y += 16 as libc::c_int;
                current_block_46 = 10399321362245223758;
            }
            32 | 48 => {
                if (*((*currentMenu).menuitems).offset(i as isize)).alphaKey != 0 {
                    y = (*currentMenu).y as libc::c_int
                        + (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                            as libc::c_int;
                }
                if i == itemOn as libc::c_int {
                    cursory = y;
                }
                if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
                    & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int
                    == 32 as libc::c_int
                {
                    V_DrawCenteredString(
                        x,
                        y,
                        0 as libc::c_int,
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    );
                } else {
                    V_DrawCenteredString(
                        x,
                        y,
                        0x2000 as libc::c_int,
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    );
                }
                match (*((*currentMenu).menuitems).offset(i as isize)).status
                    as libc::c_int & 15 as libc::c_int
                {
                    8 => {
                        let mut cv: *mut consvar_t = (*((*currentMenu).menuitems)
                            .offset(i as isize))
                            .itemaction as *mut consvar_t;
                        match (*((*currentMenu).menuitems).offset(i as isize)).status
                            as libc::c_int
                            & 512 as libc::c_int + 1024 as libc::c_int
                                + 2048 as libc::c_int
                        {
                            512 => {
                                M_DrawSlider(
                                    x,
                                    y,
                                    cv,
                                    (i == itemOn as libc::c_int) as libc::c_int,
                                );
                            }
                            1536 => {}
                            1024 => {
                                M_DrawTextBox(
                                    x,
                                    y + 4 as libc::c_int,
                                    32 as libc::c_int,
                                    1 as libc::c_int,
                                );
                                V_DrawString(
                                    x + 8 as libc::c_int,
                                    y + 12 as libc::c_int,
                                    0x800000 as libc::c_int,
                                    (*cv).string,
                                );
                                if (skullAnimCounter as libc::c_int) < 4 as libc::c_int
                                    && i == itemOn as libc::c_int
                                {
                                    V_DrawCharacter(
                                        x + 8 as libc::c_int
                                            + V_StringWidth((*cv).string, 0 as libc::c_int),
                                        y + 12 as libc::c_int,
                                        '_' as i32 | 0x80 as libc::c_int,
                                        false_0 as libc::c_int,
                                    );
                                }
                                y += 16 as libc::c_int;
                            }
                            _ => {
                                V_DrawString(
                                    320 as libc::c_int - x
                                        - V_StringWidth((*cv).string, 0 as libc::c_int),
                                    y,
                                    if (*cv).flags & CV_CHEAT as libc::c_int != 0
                                        && CV_IsSetToDefault(cv) == 0
                                    {
                                        0x5000 as libc::c_int
                                    } else {
                                        0x2000 as libc::c_int
                                    },
                                    (*cv).string,
                                );
                                if i == itemOn as libc::c_int {
                                    V_DrawCharacter(
                                        320 as libc::c_int - x - 10 as libc::c_int
                                            - V_StringWidth((*cv).string, 0 as libc::c_int)
                                            - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                                        y,
                                        '\u{1c}' as i32 | 0x2000 as libc::c_int,
                                        false_0 as libc::c_int,
                                    );
                                    V_DrawCharacter(
                                        320 as libc::c_int - x + 2 as libc::c_int
                                            + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                                        y,
                                        '\u{1d}' as i32 | 0x2000 as libc::c_int,
                                        false_0 as libc::c_int,
                                    );
                                }
                            }
                        }
                    }
                    _ => {}
                }
                y += 8 as libc::c_int;
                current_block_46 = 10399321362245223758;
            }
            96 => {
                V_DrawCenteredString(
                    x,
                    y,
                    0 as libc::c_int,
                    (*((*currentMenu).menuitems).offset(i as isize)).text,
                );
                current_block_46 = 12324157531993700725;
            }
            80 => {
                current_block_46 = 12324157531993700725;
            }
            192 => {
                if (*((*currentMenu).menuitems).offset(i as isize)).alphaKey != 0 {
                    y = (*currentMenu).y as libc::c_int
                        + (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                            as libc::c_int;
                }
                V_DrawCenteredString(
                    x,
                    y,
                    0x50000 as libc::c_int | 0x800 as libc::c_int,
                    M_CreateSecretMenuOption(
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    ),
                );
                y += 8 as libc::c_int;
                current_block_46 = 10399321362245223758;
            }
            112 => {
                if !((*((*currentMenu).menuitems).offset(i as isize)).patch).is_null()
                    && *((*((*currentMenu).menuitems).offset(i as isize)).patch)
                        .offset(0 as libc::c_int as isize) as libc::c_int != 0
                {
                    V_DrawStretchyFixedPatch(
                        x << 16 as libc::c_int,
                        y << 16 as libc::c_int,
                        (1 as libc::c_int) << 16 as libc::c_int,
                        (1 as libc::c_int) << 16 as libc::c_int,
                        0 as libc::c_int,
                        W_CachePatchName(
                            (*((*currentMenu).menuitems).offset(i as isize)).patch,
                            PU_PATCH as libc::c_int,
                        ) as *mut patch_t,
                        graymap,
                    );
                }
                y += 16 as libc::c_int;
                current_block_46 = 10399321362245223758;
            }
            _ => {
                current_block_46 = 10399321362245223758;
            }
        }
        match current_block_46 {
            4937017505496830167 => {
                y += 16 as libc::c_int;
            }
            12324157531993700725 => {
                y += 8 as libc::c_int;
            }
            _ => {}
        }
        i += 1;
        i;
    }
    if (*((*currentMenu).menuitems).offset(itemOn as isize)).status as libc::c_int
        & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int == 16 as libc::c_int
        || (*((*currentMenu).menuitems).offset(itemOn as isize)).status as libc::c_int
            & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int
            == 0 as libc::c_int
    {
        V_DrawStretchyFixedPatch(
            (x + -(32 as libc::c_int)) * ((1 as libc::c_int) << 16 as libc::c_int),
            (cursory - 5 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0 as libc::c_int,
            W_CachePatchName(
                b"M_CURSOR\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
    } else {
        V_DrawStretchyFixedPatch(
            (x
                - V_StringWidth(
                    (*((*currentMenu).menuitems).offset(itemOn as isize)).text,
                    0 as libc::c_int,
                ) / 2 as libc::c_int - 24 as libc::c_int)
                * ((1 as libc::c_int) << 16 as libc::c_int),
            cursory << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0 as libc::c_int,
            W_CachePatchName(
                b"M_CURSOR\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
        V_DrawCenteredString(
            x,
            cursory,
            0x2000 as libc::c_int,
            (*((*currentMenu).menuitems).offset(itemOn as isize)).text,
        );
    };
}
#[inline]
unsafe extern "C" fn M_StringHeight(mut string: *const libc::c_char) -> size_t {
    let mut h: size_t = 8 as libc::c_int as size_t;
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < strlen(string) {
        if *string.offset(i as isize) as libc::c_int == '\n' as i32 {
            h = h.wrapping_add(8 as libc::c_int as size_t);
        }
        i = i.wrapping_add(1);
        i;
    }
    return h;
}
unsafe extern "C" fn M_PatchSkinNameTable() {
    let mut j: int32_t = 0;
    memset(
        skins_cons_t.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[CV_PossibleValue_t; 33]>() as libc::c_ulong,
    );
    j = 0 as libc::c_int;
    while j < 32 as libc::c_int {
        if skins[j as usize].name[0 as libc::c_int as usize] as libc::c_int
            != '\0' as i32 && R_SkinUsable(-(1 as libc::c_int), j) != 0
        {
            skins_cons_t[j as usize]
                .strvalue = (skins[j as usize].realname).as_mut_ptr();
            skins_cons_t[j as usize].value = j + 1 as libc::c_int;
        } else {
            skins_cons_t[j as usize].strvalue = 0 as *const libc::c_char;
            skins_cons_t[j as usize].value = 0 as libc::c_int;
        }
        j += 1;
        j;
    }
    CV_SetValue(&mut cv_chooseskin, 1 as libc::c_int);
    Nextmap_OnChange();
}
unsafe extern "C" fn M_LevelAvailableOnPlatter(mut mapnum: int32_t) -> boolean {
    let mut data: *mut gamedata_t = serverGamedata;
    if M_MapLocked(mapnum + 1 as libc::c_int, data) != 0 {
        return false_0 as libc::c_int;
    }
    match levellistmode as libc::c_uint {
        0 => {
            if (*mapheaderinfo[mapnum as usize]).typeoflevel
                & TOL_COOP as libc::c_int as uint32_t == 0
            {
                return true_0 as libc::c_int;
            }
            if mapnum + 1 as libc::c_int == spstage_start as libc::c_int {
                return true_0 as libc::c_int;
            }
            if (*data).mapvisited[mapnum as usize] != 0 {
                return true_0 as libc::c_int;
            }
        }
        2 | 3 => {}
        1 | _ => return true_0 as libc::c_int,
    }
    if (*data).mapvisited[mapnum as usize] != 0 {
        return true_0 as libc::c_int;
    }
    if (*mapheaderinfo[mapnum as usize]).menuflags as libc::c_int & 16 as libc::c_int
        != 0
    {
        return true_0 as libc::c_int;
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn M_CanShowLevelOnPlatter(
    mut mapnum: int32_t,
    mut gt: int32_t,
) -> boolean {
    if (mapheaderinfo[mapnum as usize]).is_null() {
        return false_0 as libc::c_int;
    }
    if (*mapheaderinfo[mapnum as usize]).lvlttl[0 as libc::c_int as usize] == 0 {
        return false_0 as libc::c_int;
    }
    match levellistmode as libc::c_uint {
        0 => {
            if (*mapheaderinfo[mapnum as usize]).menuflags as libc::c_int
                & 1 as libc::c_int != 0
            {
                return false_0 as libc::c_int;
            }
            if G_IsSpecialStage(mapnum + 1 as libc::c_int) != 0 {
                return false_0 as libc::c_int;
            }
            if gt == GT_COOP as libc::c_int
                && (*mapheaderinfo[mapnum as usize]).typeoflevel
                    & TOL_COOP as libc::c_int as uint32_t != 0
            {
                return true_0 as libc::c_int;
            }
            if gt == GT_COMPETITION as libc::c_int
                && (*mapheaderinfo[mapnum as usize]).typeoflevel
                    & TOL_COMPETITION as libc::c_int as uint32_t != 0
            {
                return true_0 as libc::c_int;
            }
            if gt == GT_CTF as libc::c_int
                && (*mapheaderinfo[mapnum as usize]).typeoflevel
                    & TOL_CTF as libc::c_int as uint32_t != 0
            {
                return true_0 as libc::c_int;
            }
            if (gt == GT_MATCH as libc::c_int || gt == GT_TEAMMATCH as libc::c_int)
                && (*mapheaderinfo[mapnum as usize]).typeoflevel
                    & TOL_MATCH as libc::c_int as uint32_t != 0
            {
                return true_0 as libc::c_int;
            }
            if (gt == GT_TAG as libc::c_int || gt == GT_HIDEANDSEEK as libc::c_int)
                && (*mapheaderinfo[mapnum as usize]).typeoflevel
                    & TOL_TAG as libc::c_int as uint32_t != 0
            {
                return true_0 as libc::c_int;
            }
            if gt == GT_RACE as libc::c_int
                && (*mapheaderinfo[mapnum as usize]).typeoflevel
                    & TOL_RACE as libc::c_int as uint32_t != 0
            {
                return true_0 as libc::c_int;
            }
            if gt >= 0 as libc::c_int && gt < gametypecount as libc::c_int
                && (*mapheaderinfo[mapnum as usize]).typeoflevel
                    & gametypetol[gt as usize] != 0
            {
                return true_0 as libc::c_int;
            }
            return false_0 as libc::c_int;
        }
        1 => {
            if (*mapheaderinfo[mapnum as usize]).levelselect as libc::c_int
                & maplistoption as libc::c_int == 0
            {
                return false_0 as libc::c_int;
            }
            return true_0 as libc::c_int;
        }
        2 => {
            if (*mapheaderinfo[mapnum as usize]).menuflags as libc::c_int
                & 4 as libc::c_int == 0
            {
                return false_0 as libc::c_int;
            }
            return true_0 as libc::c_int;
        }
        3 => {
            if (*mapheaderinfo[mapnum as usize]).menuflags as libc::c_int
                & 8 as libc::c_int == 0
            {
                return false_0 as libc::c_int;
            }
            return true_0 as libc::c_int;
        }
        _ => {}
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn M_GametypeHasLevels(mut gt: int32_t) -> boolean {
    let mut mapnum: int32_t = 0;
    mapnum = 0 as libc::c_int;
    while mapnum < 1035 as libc::c_int {
        if M_CanShowLevelOnPlatter(mapnum, gt) != 0 {
            return true_0 as libc::c_int;
        }
        mapnum += 1;
        mapnum;
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn M_CountRowsToShowOnPlatter(mut gt: int32_t) -> int32_t {
    let mut col: int32_t = 0 as libc::c_int;
    let mut rows: int32_t = 0 as libc::c_int;
    let mut mapIterate: int32_t = 0 as libc::c_int;
    let mut headingIterate: int32_t = 0 as libc::c_int;
    let mut mapAddedAlready: [boolean; 1035] = [0; 1035];
    memset(
        mapAddedAlready.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[boolean; 1035]>() as libc::c_ulong,
    );
    mapIterate = 0 as libc::c_int;
    while mapIterate < 1035 as libc::c_int {
        let mut forceNewRow: boolean = true_0 as libc::c_int;
        if !(mapAddedAlready[mapIterate as usize] == true_0 as libc::c_int) {
            if !(M_CanShowLevelOnPlatter(mapIterate, gt) == false_0 as libc::c_int) {
                headingIterate = mapIterate;
                while headingIterate < 1035 as libc::c_int {
                    let mut wide: boolean = false_0 as libc::c_int;
                    if !(mapAddedAlready[headingIterate as usize]
                        == true_0 as libc::c_int)
                    {
                        if !(M_CanShowLevelOnPlatter(headingIterate, gt)
                            == false_0 as libc::c_int)
                        {
                            if !(fastcmp(
                                ((*mapheaderinfo[mapIterate as usize]).selectheading)
                                    .as_mut_ptr(),
                                ((*mapheaderinfo[headingIterate as usize]).selectheading)
                                    .as_mut_ptr(),
                            ) == 0)
                            {
                                wide = (*mapheaderinfo[headingIterate as usize]).menuflags
                                    as libc::c_int & 32 as libc::c_int;
                                if col == 2 as libc::c_int || wide != 0 || forceNewRow != 0
                                {
                                    col = 0 as libc::c_int;
                                    rows += 1;
                                    rows;
                                } else {
                                    col += 1;
                                    col;
                                }
                                mapAddedAlready[headingIterate
                                    as usize] = true_0 as libc::c_int;
                                forceNewRow = wide;
                            }
                        }
                    }
                    headingIterate += 1;
                    headingIterate;
                }
            }
        }
        mapIterate += 1;
        mapIterate;
    }
    if levellistmode as libc::c_uint == LLM_CREATESERVER as libc::c_int as libc::c_uint {
        rows += 1;
        rows;
    }
    return rows;
}
unsafe extern "C" fn M_CacheLevelPlatter() {
    levselp[0 as libc::c_int
        as usize][0 as libc::c_int
        as usize] = W_CachePatchName(
        b"SLCT1LVL\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    levselp[0 as libc::c_int
        as usize][1 as libc::c_int
        as usize] = W_CachePatchName(
        b"SLCT2LVL\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    levselp[0 as libc::c_int
        as usize][2 as libc::c_int
        as usize] = W_CachePatchName(
        b"BLANKLVL\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    levselp[1 as libc::c_int
        as usize][0 as libc::c_int
        as usize] = W_CachePatchName(
        b"SLCT1LVW\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    levselp[1 as libc::c_int
        as usize][1 as libc::c_int
        as usize] = W_CachePatchName(
        b"SLCT2LVW\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    levselp[1 as libc::c_int
        as usize][2 as libc::c_int
        as usize] = W_CachePatchName(
        b"BLANKLVW\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
}
unsafe extern "C" fn M_PrepareLevelPlatter(
    mut gt: int32_t,
    mut nextmappick: boolean,
) -> boolean {
    let mut numrows: int32_t = M_CountRowsToShowOnPlatter(gt);
    let mut col: int32_t = 0 as libc::c_int;
    let mut row: int32_t = 0 as libc::c_int;
    let mut startrow: int32_t = 0 as libc::c_int;
    let mut mapIterate: int32_t = 0 as libc::c_int;
    let mut headingIterate: int32_t = 0 as libc::c_int;
    let mut mapAddedAlready: [boolean; 1035] = [0; 1035];
    if numrows == 0 {
        return false_0 as libc::c_int;
    }
    if !(levelselect.rows).is_null() {
        Z_Free(levelselect.rows as *mut libc::c_void);
    }
    levelselect.rows = 0 as *mut levelselectrow_t;
    levelselect.numrows = numrows as uint8_t;
    levelselect
        .rows = Z_ReallocAlign(
        levelselect.rows as *mut libc::c_void,
        (numrows as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<levelselectrow_t>() as libc::c_ulong),
        PU_STATIC as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut levelselectrow_t;
    if (levelselect.rows).is_null() {
        I_Error(
            b"Insufficient memory to prepare level platter\0" as *const u8
                as *const libc::c_char,
        );
    }
    lsoffs[1 as libc::c_int as usize] = 0 as libc::c_int;
    lsoffs[0 as libc::c_int as usize] = lsoffs[1 as libc::c_int as usize];
    levelselectselect[2 as libc::c_int
        as usize] = lsoffs[0 as libc::c_int as usize] as uint8_t;
    levelselectselect[1 as libc::c_int
        as usize] = levelselectselect[2 as libc::c_int as usize];
    levelselectselect[0 as libc::c_int
        as usize] = levelselectselect[1 as libc::c_int as usize];
    memset(
        mapAddedAlready.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[boolean; 1035]>() as libc::c_ulong,
    );
    if levellistmode as libc::c_uint == LLM_CREATESERVER as libc::c_int as libc::c_uint {
        sprintf(
            ((*(levelselect.rows).offset(0 as libc::c_int as isize)).header)
                .as_mut_ptr(),
            b"Gametype\0" as *const u8 as *const libc::c_char,
        );
        (*(levelselect.rows).offset(0 as libc::c_int as isize))
            .mapavailable[3 as libc::c_int as usize] = true_0 as libc::c_int;
        let ref mut fresh1 = (*(levelselect.rows).offset(row as isize))
            .mapavailable[0 as libc::c_int as usize];
        *fresh1 = false_0 as libc::c_int;
        let ref mut fresh2 = (*(levelselect.rows).offset(row as isize))
            .mapavailable[1 as libc::c_int as usize];
        *fresh2 = *fresh1;
        (*(levelselect.rows).offset(row as isize))
            .mapavailable[2 as libc::c_int as usize] = *fresh2;
        row = 1 as libc::c_int;
        startrow = row;
        Z_Free(char_notes as *mut libc::c_void);
        char_notes = 0 as *mut libc::c_char;
    }
    mapIterate = 0 as libc::c_int;
    while mapIterate < 1035 as libc::c_int {
        let mut headerRow: int32_t = -(1 as libc::c_int);
        let mut anyAvailable: boolean = false_0 as libc::c_int;
        let mut forceNewRow: boolean = true_0 as libc::c_int;
        if !(mapAddedAlready[mapIterate as usize] == true_0 as libc::c_int) {
            if !(M_CanShowLevelOnPlatter(mapIterate, gt) == false_0 as libc::c_int) {
                headingIterate = mapIterate;
                while headingIterate < 1035 as libc::c_int {
                    let mut actnum: uint8_t = 0 as libc::c_int as uint8_t;
                    let mut headingisname: boolean = false_0 as libc::c_int;
                    let mut wide: boolean = false_0 as libc::c_int;
                    if !(mapAddedAlready[headingIterate as usize]
                        == true_0 as libc::c_int)
                    {
                        if !(M_CanShowLevelOnPlatter(headingIterate, gt)
                            == false_0 as libc::c_int)
                        {
                            if !(fastcmp(
                                ((*mapheaderinfo[mapIterate as usize]).selectheading)
                                    .as_mut_ptr(),
                                ((*mapheaderinfo[headingIterate as usize]).selectheading)
                                    .as_mut_ptr(),
                            ) == 0)
                            {
                                actnum = (*mapheaderinfo[headingIterate as usize]).actnum;
                                headingisname = fastcmp(
                                    ((*mapheaderinfo[headingIterate as usize]).selectheading)
                                        .as_mut_ptr(),
                                    ((*mapheaderinfo[headingIterate as usize]).lvlttl)
                                        .as_mut_ptr(),
                                );
                                wide = (*mapheaderinfo[headingIterate as usize]).menuflags
                                    as libc::c_int & 32 as libc::c_int;
                                if (*(levelselect.rows).offset(startrow as isize))
                                    .maplist[0 as libc::c_int as usize] != 0
                                {
                                    if col == 2 as libc::c_int || wide != 0 || forceNewRow != 0
                                    {
                                        col = 0 as libc::c_int;
                                        row += 1;
                                        row;
                                    } else {
                                        col += 1;
                                        col;
                                    }
                                }
                                if headerRow == -(1 as libc::c_int) {
                                    headerRow = row;
                                }
                                (*(levelselect.rows).offset(row as isize))
                                    .maplist[col as usize] = headingIterate + 1 as libc::c_int;
                                (*(levelselect.rows).offset(row as isize))
                                    .mapavailable[col
                                    as usize] = M_LevelAvailableOnPlatter(headingIterate);
                                let ref mut fresh3 = (*(levelselect.rows)
                                    .offset(row as isize))
                                    .mapavailable[3 as libc::c_int as usize];
                                *fresh3 = wide;
                                if *fresh3 != 0 {
                                    let ref mut fresh4 = (*(levelselect.rows)
                                        .offset(row as isize))
                                        .maplist[1 as libc::c_int as usize];
                                    *fresh4 = (*(levelselect.rows).offset(row as isize))
                                        .maplist[0 as libc::c_int as usize];
                                    (*(levelselect.rows).offset(row as isize))
                                        .maplist[2 as libc::c_int as usize] = *fresh4;
                                    let ref mut fresh5 = (*(levelselect.rows)
                                        .offset(row as isize))
                                        .mapavailable[1 as libc::c_int as usize];
                                    *fresh5 = (*(levelselect.rows).offset(row as isize))
                                        .mapavailable[0 as libc::c_int as usize];
                                    (*(levelselect.rows).offset(row as isize))
                                        .mapavailable[2 as libc::c_int as usize] = *fresh5;
                                }
                                if nextmappick != 0
                                    && cv_nextmap.value == headingIterate + 1 as libc::c_int
                                {
                                    levelselectselect[0 as libc::c_int
                                        as usize] = row as uint8_t;
                                    levelselectselect[1 as libc::c_int
                                        as usize] = col as uint8_t;
                                }
                                if (*(levelselect.rows).offset(row as isize))
                                    .mapavailable[col as usize] != 0
                                {
                                    anyAvailable = true_0 as libc::c_int;
                                    if headingisname != 0 {
                                        if actnum != 0 {
                                            sprintf(
                                                ((*(levelselect.rows).offset(row as isize))
                                                    .mapnames[col as usize])
                                                    .as_mut_ptr(),
                                                b"ACT %d\0" as *const u8 as *const libc::c_char,
                                                actnum as libc::c_int,
                                            );
                                        } else {
                                            sprintf(
                                                ((*(levelselect.rows).offset(row as isize))
                                                    .mapnames[col as usize])
                                                    .as_mut_ptr(),
                                                b"THE ACT\0" as *const u8 as *const libc::c_char,
                                            );
                                        }
                                    } else if wide != 0 {
                                        let mut mapname: *mut libc::c_char = G_BuildMapTitle(
                                            headingIterate + 1 as libc::c_int,
                                        );
                                        strcpy(
                                            ((*(levelselect.rows).offset(row as isize))
                                                .mapnames[col as usize])
                                                .as_mut_ptr(),
                                            mapname as *const libc::c_char,
                                        );
                                        Z_Free(mapname as *mut libc::c_void);
                                    } else {
                                        let mut mapname_0: [libc::c_char; 34] = [0; 34];
                                        if actnum != 0 {
                                            sprintf(
                                                mapname_0.as_mut_ptr(),
                                                b"%s %d\0" as *const u8 as *const libc::c_char,
                                                ((*mapheaderinfo[headingIterate as usize]).lvlttl)
                                                    .as_mut_ptr(),
                                                actnum as libc::c_int,
                                            );
                                        } else if V_ThinStringWidth(
                                            ((*mapheaderinfo[headingIterate as usize]).lvlttl)
                                                .as_mut_ptr(),
                                            0 as libc::c_int,
                                        ) <= 80 as libc::c_int
                                        {
                                            strlcpy(
                                                mapname_0.as_mut_ptr(),
                                                ((*mapheaderinfo[headingIterate as usize]).lvlttl)
                                                    .as_mut_ptr(),
                                                22 as libc::c_int as libc::c_ulong,
                                            );
                                        } else {
                                            strlcpy(
                                                mapname_0.as_mut_ptr(),
                                                ((*mapheaderinfo[headingIterate as usize]).lvlttl)
                                                    .as_mut_ptr(),
                                                15 as libc::c_int as libc::c_ulong,
                                            );
                                            strcat(
                                                mapname_0.as_mut_ptr(),
                                                b"...\0" as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        strcpy(
                                            ((*(levelselect.rows).offset(row as isize))
                                                .mapnames[col as usize])
                                                .as_mut_ptr(),
                                            mapname_0.as_mut_ptr() as *const libc::c_char,
                                        );
                                    }
                                } else {
                                    sprintf(
                                        ((*(levelselect.rows).offset(row as isize))
                                            .mapnames[col as usize])
                                            .as_mut_ptr(),
                                        b"???\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                mapAddedAlready[headingIterate
                                    as usize] = true_0 as libc::c_int;
                                forceNewRow = wide;
                            }
                        }
                    }
                    headingIterate += 1;
                    headingIterate;
                }
                if !(headerRow == -(1 as libc::c_int)) {
                    if anyAvailable == false_0 as libc::c_int {
                        sprintf(
                            ((*(levelselect.rows).offset(headerRow as isize)).header)
                                .as_mut_ptr(),
                            b"???\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        sprintf(
                            ((*(levelselect.rows).offset(headerRow as isize)).header)
                                .as_mut_ptr(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*mapheaderinfo[mapIterate as usize]).selectheading)
                                .as_mut_ptr(),
                        );
                        if (*mapheaderinfo[mapIterate as usize]).levelflags
                            as libc::c_int & (1 as libc::c_int) << 4 as libc::c_int == 0
                            && fastcmp(
                                ((*mapheaderinfo[mapIterate as usize]).selectheading)
                                    .as_mut_ptr(),
                                ((*mapheaderinfo[mapIterate as usize]).lvlttl).as_mut_ptr(),
                            ) != 0
                        {
                            sprintf(
                                ((*(levelselect.rows).offset(headerRow as isize)).header)
                                    .as_mut_ptr()
                                    .offset(
                                        strlen(
                                            ((*(levelselect.rows).offset(headerRow as isize)).header)
                                                .as_mut_ptr(),
                                        ) as isize,
                                    ),
                                b" ZONE\0" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                }
            }
        }
        mapIterate += 1;
        mapIterate;
    }
    M_CacheLevelPlatter();
    return true_0 as libc::c_int;
}
unsafe extern "C" fn M_HandleLevelPlatter(mut choice: int32_t) {
    let mut exitmenu: boolean = false_0 as libc::c_int;
    let mut selectval: int32_t = 0;
    let mut iter: uint8_t = 0;
    let mut current_block_118: u64;
    match choice {
        238 => {
            if levelselectselect[0 as libc::c_int as usize] as libc::c_int
                == levelselect.numrows as libc::c_int - 1 as libc::c_int
            {
                if (levelselect.numrows as libc::c_int) < 3 as libc::c_int {
                    if lsoffs[0 as libc::c_int as usize] == 0 {
                        lsoffs[0 as libc::c_int
                            as usize] = -(8 as libc::c_int)
                            * ((1 as libc::c_int) << 16 as libc::c_int);
                        S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
                    }
                    return;
                }
                levelselectselect[0 as libc::c_int
                    as usize] = 255 as libc::c_int as uint8_t;
            }
            levelselectselect[0 as libc::c_int
                as usize] = (levelselectselect[0 as libc::c_int as usize])
                .wrapping_add(1);
            levelselectselect[0 as libc::c_int as usize];
            lsoffs[0 as libc::c_int
                as usize] = (62 as libc::c_int * vid.height
                / (200 as libc::c_int * vid.dupy)
                + (if (*(levelselect.rows)
                    .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                    .header[0 as libc::c_int as usize] as libc::c_int != 0
                {
                    16 as libc::c_int
                } else {
                    0 as libc::c_int
                })) * ((1 as libc::c_int) << 16 as libc::c_int);
            if (*(levelselect.rows)
                .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                .header[0 as libc::c_int as usize] != 0
            {
                levelselectselect[2 as libc::c_int
                    as usize] = levelselectselect[0 as libc::c_int as usize];
            }
            S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
            selectval = (*(levelselect.rows)
                .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                .maplist[levelselectselect[1 as libc::c_int as usize] as usize];
            if selectval != 0
                && (*(levelselect.rows)
                    .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                    .mapavailable[levelselectselect[1 as libc::c_int as usize] as usize]
                    != 0
            {
                CV_SetValue(&mut cv_nextmap, selectval);
            } else {
                selectval = (*(levelselect.rows)
                    .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                    .maplist[0 as libc::c_int as usize];
                if selectval != 0
                    && (*(levelselect.rows)
                        .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                        .mapavailable[0 as libc::c_int as usize] != 0
                {
                    CV_SetValue(&mut cv_nextmap, selectval);
                }
            }
            current_block_118 = 1658462350791934405;
        }
        230 => {
            iter = levelselectselect[0 as libc::c_int as usize];
            if levelselectselect[0 as libc::c_int as usize] == 0 {
                if (levelselect.numrows as libc::c_int) < 3 as libc::c_int {
                    if lsoffs[0 as libc::c_int as usize] == 0 {
                        lsoffs[0 as libc::c_int
                            as usize] = 8 as libc::c_int
                            * ((1 as libc::c_int) << 16 as libc::c_int);
                        S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
                    }
                    return;
                }
                levelselectselect[0 as libc::c_int as usize] = levelselect.numrows;
            }
            levelselectselect[0 as libc::c_int
                as usize] = (levelselectselect[0 as libc::c_int as usize])
                .wrapping_sub(1);
            levelselectselect[0 as libc::c_int as usize];
            lsoffs[0 as libc::c_int
                as usize] = -(62 as libc::c_int * vid.height
                / (200 as libc::c_int * vid.dupy)
                + (if (*(levelselect.rows).offset(iter as isize))
                    .header[0 as libc::c_int as usize] as libc::c_int != 0
                {
                    16 as libc::c_int
                } else {
                    0 as libc::c_int
                })) * ((1 as libc::c_int) << 16 as libc::c_int);
            if (*(levelselect.rows)
                .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                .header[0 as libc::c_int as usize] != 0
            {
                levelselectselect[2 as libc::c_int
                    as usize] = levelselectselect[0 as libc::c_int as usize];
            } else {
                iter = levelselectselect[0 as libc::c_int as usize];
                loop {
                    iter = (if iter as libc::c_int == 0 as libc::c_int {
                        levelselect.numrows as libc::c_int - 1 as libc::c_int
                    } else {
                        iter as libc::c_int - 1 as libc::c_int
                    }) as uint8_t;
                    if !(iter as libc::c_int
                        != levelselectselect[0 as libc::c_int as usize] as libc::c_int
                        && (*(levelselect.rows).offset(iter as isize))
                            .header[0 as libc::c_int as usize] == 0)
                    {
                        break;
                    }
                }
                levelselectselect[2 as libc::c_int as usize] = iter;
            }
            S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
            selectval = (*(levelselect.rows)
                .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                .maplist[levelselectselect[1 as libc::c_int as usize] as usize];
            if selectval != 0
                && (*(levelselect.rows)
                    .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                    .mapavailable[levelselectselect[1 as libc::c_int as usize] as usize]
                    != 0
            {
                CV_SetValue(&mut cv_nextmap, selectval);
            } else {
                selectval = (*(levelselect.rows)
                    .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                    .maplist[0 as libc::c_int as usize];
                if selectval != 0
                    && (*(levelselect.rows)
                        .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                        .mapavailable[0 as libc::c_int as usize] != 0
                {
                    CV_SetValue(&mut cv_nextmap, selectval);
                }
            }
            current_block_118 = 1658462350791934405;
        }
        13 => {
            if !(levellistmode as libc::c_uint
                == LLM_CREATESERVER as libc::c_int as libc::c_uint
                && levelselectselect[0 as libc::c_int as usize] == 0)
            {
                selectval = (*(levelselect.rows)
                    .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                    .maplist[levelselectselect[1 as libc::c_int as usize] as usize];
                if selectval != 0
                    && (*(levelselect.rows)
                        .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                        .mapavailable[levelselectselect[1 as libc::c_int as usize]
                        as usize] != 0
                {
                    CV_SetValue(&mut cv_nextmap, selectval);
                    lsoffs[1 as libc::c_int as usize] = 0 as libc::c_int;
                    lsoffs[0 as libc::c_int
                        as usize] = lsoffs[1 as libc::c_int as usize];
                    S_StartSound(0 as *const libc::c_void, sfx_menu1);
                    if gamestate as libc::c_uint
                        == GS_TIMEATTACK as libc::c_int as libc::c_uint
                    {
                        M_SetupNextMenu((*currentMenu).prevMenu);
                    } else if currentMenu == &mut MISC_ChangeLevelDef as *mut menu_t {
                        if !((*currentMenu).prevMenu).is_null()
                            && (*currentMenu).prevMenu != &mut MPauseDef as *mut menu_t
                        {
                            M_SetupNextMenu((*currentMenu).prevMenu);
                        } else {
                            M_ChangeLevel(0 as libc::c_int);
                        }
                        Z_Free(levelselect.rows as *mut libc::c_void);
                        levelselect.rows = 0 as *mut levelselectrow_t;
                    } else {
                        M_LevelSelectWarp(0 as libc::c_int);
                    }
                    Nextmap_OnChange();
                } else if lsoffs[0 as libc::c_int as usize] == 0 {
                    lsoffs[0 as libc::c_int
                        as usize] = -(8 as libc::c_int)
                        * ((1 as libc::c_int) << 16 as libc::c_int);
                    S_StartSound(0 as *const libc::c_void, sfx_s3kb2);
                }
                current_block_118 = 1658462350791934405;
            } else {
                current_block_118 = 309380752356786726;
            }
        }
        235 => {
            current_block_118 = 309380752356786726;
        }
        233 => {
            if levellistmode as libc::c_uint
                == LLM_CREATESERVER as libc::c_int as libc::c_uint
                && levelselectselect[0 as libc::c_int as usize] == 0
            {
                let mut startinggametype_0: int32_t = cv_newgametype.value;
                loop {
                    CV_AddValue(&mut cv_newgametype, -(1 as libc::c_int));
                    if !(cv_newgametype.value != startinggametype_0
                        && M_GametypeHasLevels(cv_newgametype.value) == 0)
                    {
                        break;
                    }
                }
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                levelselectselect[1 as libc::c_int
                    as usize] = 0 as libc::c_int as uint8_t;
                Z_Free(char_notes as *mut libc::c_void);
                char_notes = 0 as *mut libc::c_char;
                if M_PrepareLevelPlatter(cv_newgametype.value, false_0 as libc::c_int)
                    == 0
                {
                    I_Error(
                        b"Unidentified level platter failure!\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            } else if levelselectselect[1 as libc::c_int as usize] as libc::c_int
                > 0 as libc::c_int
            {
                levelselectselect[1 as libc::c_int
                    as usize] = (levelselectselect[1 as libc::c_int as usize])
                    .wrapping_sub(1);
                levelselectselect[1 as libc::c_int as usize];
                lsoffs[1 as libc::c_int
                    as usize] = (if (*(levelselect.rows)
                    .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                    .mapavailable[3 as libc::c_int as usize] != 0
                {
                    -(8 as libc::c_int)
                } else {
                    101 as libc::c_int
                }) * ((1 as libc::c_int) << 16 as libc::c_int);
                S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
                selectval = (*(levelselect.rows)
                    .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                    .maplist[levelselectselect[1 as libc::c_int as usize] as usize];
                if selectval != 0
                    && (*(levelselect.rows)
                        .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                        .mapavailable[levelselectselect[1 as libc::c_int as usize]
                        as usize] != 0
                {
                    CV_SetValue(&mut cv_nextmap, selectval);
                } else {
                    selectval = (*(levelselect.rows)
                        .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                        .maplist[0 as libc::c_int as usize];
                    if selectval != 0
                        && (*(levelselect.rows)
                            .offset(
                                levelselectselect[0 as libc::c_int as usize] as isize,
                            ))
                            .mapavailable[0 as libc::c_int as usize] != 0
                    {
                        CV_SetValue(&mut cv_nextmap, selectval);
                    }
                }
            } else if lsoffs[1 as libc::c_int as usize] == 0 {
                lsoffs[1 as libc::c_int
                    as usize] = -(8 as libc::c_int)
                    * ((1 as libc::c_int) << 16 as libc::c_int);
                S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
            }
            current_block_118 = 1658462350791934405;
        }
        27 => {
            exitmenu = true_0 as libc::c_int;
            current_block_118 = 1658462350791934405;
        }
        _ => {
            current_block_118 = 1658462350791934405;
        }
    }
    match current_block_118 {
        309380752356786726 => {
            if levellistmode as libc::c_uint
                == LLM_CREATESERVER as libc::c_int as libc::c_uint
                && levelselectselect[0 as libc::c_int as usize] == 0
            {
                let mut startinggametype: int32_t = cv_newgametype.value;
                loop {
                    CV_AddValue(&mut cv_newgametype, 1 as libc::c_int);
                    if !(cv_newgametype.value != startinggametype
                        && M_GametypeHasLevels(cv_newgametype.value) == 0)
                    {
                        break;
                    }
                }
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                levelselectselect[1 as libc::c_int
                    as usize] = 0 as libc::c_int as uint8_t;
                Z_Free(char_notes as *mut libc::c_void);
                char_notes = 0 as *mut libc::c_char;
                if M_PrepareLevelPlatter(cv_newgametype.value, false_0 as libc::c_int)
                    == 0
                {
                    I_Error(
                        b"Unidentified level platter failure!\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            } else if (levelselectselect[1 as libc::c_int as usize] as libc::c_int)
                < 2 as libc::c_int
            {
                levelselectselect[1 as libc::c_int
                    as usize] = (levelselectselect[1 as libc::c_int as usize])
                    .wrapping_add(1);
                levelselectselect[1 as libc::c_int as usize];
                lsoffs[1 as libc::c_int
                    as usize] = (if (*(levelselect.rows)
                    .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                    .mapavailable[3 as libc::c_int as usize] != 0
                {
                    8 as libc::c_int
                } else {
                    -(101 as libc::c_int)
                }) * ((1 as libc::c_int) << 16 as libc::c_int);
                S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
                selectval = (*(levelselect.rows)
                    .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                    .maplist[levelselectselect[1 as libc::c_int as usize] as usize];
                if selectval != 0
                    && (*(levelselect.rows)
                        .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                        .mapavailable[levelselectselect[1 as libc::c_int as usize]
                        as usize] != 0
                {
                    CV_SetValue(&mut cv_nextmap, selectval);
                } else {
                    selectval = (*(levelselect.rows)
                        .offset(levelselectselect[0 as libc::c_int as usize] as isize))
                        .maplist[0 as libc::c_int as usize];
                    if selectval != 0
                        && (*(levelselect.rows)
                            .offset(
                                levelselectselect[0 as libc::c_int as usize] as isize,
                            ))
                            .mapavailable[0 as libc::c_int as usize] != 0
                    {
                        CV_SetValue(&mut cv_nextmap, selectval);
                    }
                }
            } else if lsoffs[1 as libc::c_int as usize] == 0 {
                lsoffs[1 as libc::c_int
                    as usize] = 8 as libc::c_int
                    * ((1 as libc::c_int) << 16 as libc::c_int);
                S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
            }
        }
        _ => {}
    }
    if exitmenu != 0 {
        if gamestate as libc::c_uint != GS_TIMEATTACK as libc::c_int as libc::c_uint {
            Z_Free(levelselect.rows as *mut libc::c_void);
            levelselect.rows = 0 as *mut levelselectrow_t;
        }
        if !((*currentMenu).prevMenu).is_null() {
            M_SetupNextMenu((*currentMenu).prevMenu);
            Nextmap_OnChange();
        } else {
            M_ClearMenus(true_0 as libc::c_int);
        }
        Z_Free(char_notes as *mut libc::c_void);
        char_notes = 0 as *mut libc::c_char;
    }
}
unsafe extern "C" fn M_DrawLevelPlatterHeader(
    mut y: int32_t,
    mut header: *const libc::c_char,
    mut headerhighlight: boolean,
    mut allowlowercase: boolean,
) {
    y += 16 as libc::c_int - 12 as libc::c_int;
    V_DrawString(
        19 as libc::c_int,
        y,
        (if headerhighlight != 0 { 0x2000 as libc::c_int } else { 0 as libc::c_int })
            | (if allowlowercase != 0 {
                0x800000 as libc::c_int
            } else {
                0 as libc::c_int
            }),
        header,
    );
    y += 9 as libc::c_int;
    V_DrawFill(
        19 as libc::c_int,
        y,
        281 as libc::c_int,
        1 as libc::c_int,
        if headerhighlight != 0 {
            *yellowmap.offset(3 as libc::c_int as isize) as libc::c_int
        } else {
            3 as libc::c_int
        },
    );
    V_DrawFill(
        300 as libc::c_int,
        y,
        1 as libc::c_int,
        1 as libc::c_int,
        26 as libc::c_int,
    );
    y += 1;
    y;
    V_DrawFill(
        19 as libc::c_int,
        y,
        282 as libc::c_int,
        1 as libc::c_int,
        26 as libc::c_int,
    );
}
unsafe extern "C" fn M_DrawLevelPlatterWideMap(
    mut row: uint8_t,
    mut col: uint8_t,
    mut x: int32_t,
    mut y: int32_t,
    mut highlight: boolean,
) {
    let mut patch: *mut patch_t = 0 as *mut patch_t;
    let mut map: int32_t = (*(levelselect.rows).offset(row as isize))
        .maplist[col as usize];
    if map <= 0 as libc::c_int {
        return;
    }
    if (*(levelselect.rows).offset(row as isize)).mapavailable[col as usize] == 0 {
        V_DrawStretchyFixedPatch(
            x << 16 as libc::c_int,
            y << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            levselp[1 as libc::c_int as usize][2 as libc::c_int as usize],
            0 as *const uint8_t,
        );
        M_DrawStaticBox(
            x,
            y,
            0x80000 as libc::c_int,
            282 as libc::c_int,
            50 as libc::c_int,
        );
    } else {
        if W_CheckNumForName(
            va(b"%sW\0" as *const u8 as *const libc::c_char, G_BuildMapName(map)),
        ) != 4294967295 as libc::c_uint
        {
            patch = W_CachePatchName(
                va(b"%sW\0" as *const u8 as *const libc::c_char, G_BuildMapName(map)),
                PU_PATCH as libc::c_int,
            ) as *mut patch_t;
        } else {
            patch = levselp[1 as libc::c_int as usize][2 as libc::c_int as usize];
        }
        V_DrawStretchyFixedPatch(
            x << 16 as libc::c_int,
            y << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            patch,
            0 as *const uint8_t,
        );
    }
    V_DrawFill(
        x,
        y + 50 as libc::c_int,
        282 as libc::c_int,
        8 as libc::c_int,
        if ((*mapheaderinfo[(map - 1 as libc::c_int) as usize]).unlockrequired
            as libc::c_int) < 0 as libc::c_int
        {
            159 as libc::c_int
        } else {
            63 as libc::c_int
        },
    );
    V_DrawString(
        x,
        y + 50 as libc::c_int,
        if highlight != 0 { 0x2000 as libc::c_int } else { 0 as libc::c_int },
        ((*(levelselect.rows).offset(row as isize)).mapnames[col as usize]).as_mut_ptr(),
    );
}
unsafe extern "C" fn M_DrawLevelPlatterMap(
    mut row: uint8_t,
    mut col: uint8_t,
    mut x: int32_t,
    mut y: int32_t,
    mut highlight: boolean,
) {
    let mut patch: *mut patch_t = 0 as *mut patch_t;
    let mut map: int32_t = (*(levelselect.rows).offset(row as isize))
        .maplist[col as usize];
    if map <= 0 as libc::c_int {
        return;
    }
    if (*(levelselect.rows).offset(row as isize)).mapavailable[col as usize] == 0 {
        V_DrawStretchyFixedPatch(
            x << 16 as libc::c_int,
            y << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            levselp[0 as libc::c_int as usize][2 as libc::c_int as usize],
            0 as *const uint8_t,
        );
        M_DrawStaticBox(
            x,
            y,
            0x80000 as libc::c_int,
            80 as libc::c_int,
            50 as libc::c_int,
        );
    } else {
        if W_CheckNumForName(
            va(b"%sP\0" as *const u8 as *const libc::c_char, G_BuildMapName(map)),
        ) != 4294967295 as libc::c_uint
        {
            patch = W_CachePatchName(
                va(b"%sP\0" as *const u8 as *const libc::c_char, G_BuildMapName(map)),
                PU_PATCH as libc::c_int,
            ) as *mut patch_t;
        } else {
            patch = levselp[0 as libc::c_int as usize][2 as libc::c_int as usize];
        }
        V_DrawStretchyFixedPatch(
            x << 16 as libc::c_int,
            y << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            patch,
            0 as *const uint8_t,
        );
    }
    V_DrawFill(
        x,
        y + 50 as libc::c_int,
        80 as libc::c_int,
        8 as libc::c_int,
        if ((*mapheaderinfo[(map - 1 as libc::c_int) as usize]).unlockrequired
            as libc::c_int) < 0 as libc::c_int
        {
            159 as libc::c_int
        } else {
            63 as libc::c_int
        },
    );
    if strlen(
        ((*(levelselect.rows).offset(row as isize)).mapnames[col as usize]).as_mut_ptr(),
    ) > 6 as libc::c_int as libc::c_ulong
    {
        V_DrawThinString(
            x,
            y + 50 as libc::c_int + 1 as libc::c_int,
            if highlight != 0 { 0x2000 as libc::c_int } else { 0 as libc::c_int },
            ((*(levelselect.rows).offset(row as isize)).mapnames[col as usize])
                .as_mut_ptr(),
        );
    } else {
        V_DrawString(
            x,
            y + 50 as libc::c_int,
            if highlight != 0 { 0x2000 as libc::c_int } else { 0 as libc::c_int },
            ((*(levelselect.rows).offset(row as isize)).mapnames[col as usize])
                .as_mut_ptr(),
        );
    };
}
unsafe extern "C" fn M_DrawLevelPlatterRow(mut row: uint8_t, mut y: int32_t) {
    let mut col: uint8_t = 0;
    let rowhighlight: boolean = (row as libc::c_int
        == levelselectselect[0 as libc::c_int as usize] as libc::c_int) as libc::c_int;
    if (*(levelselect.rows).offset(row as isize)).header[0 as libc::c_int as usize] != 0
    {
        M_DrawLevelPlatterHeader(
            y,
            ((*(levelselect.rows).offset(row as isize)).header).as_mut_ptr(),
            (rowhighlight != 0
                || row as libc::c_int
                    == levelselectselect[2 as libc::c_int as usize] as libc::c_int)
                as libc::c_int,
            false_0 as libc::c_int,
        );
        y += 16 as libc::c_int;
    }
    if levellistmode as libc::c_uint == LLM_CREATESERVER as libc::c_int as libc::c_uint
        && row == 0
    {
        if char_notes.is_null() {
            char_notes = V_WordWrap(
                0 as libc::c_int,
                282 as libc::c_int - 8 as libc::c_int,
                0x800000 as libc::c_int,
                (gametypedesc[cv_newgametype.value as usize].notes).as_mut_ptr(),
            );
        }
        V_DrawFill(
            19 as libc::c_int,
            y,
            282 as libc::c_int,
            50 as libc::c_int,
            27 as libc::c_int,
        );
        V_DrawString(
            19 as libc::c_int + 4 as libc::c_int,
            y + 4 as libc::c_int,
            0x20000000 as libc::c_int | 0x800000 as libc::c_int,
            char_notes,
        );
        V_DrawFill(
            19 as libc::c_int,
            y + 50 as libc::c_int,
            141 as libc::c_int,
            8 as libc::c_int,
            gametypedesc[cv_newgametype.value as usize].col[0 as libc::c_int as usize]
                as int32_t,
        );
        V_DrawFill(
            19 as libc::c_int + 141 as libc::c_int,
            y + 50 as libc::c_int,
            141 as libc::c_int,
            8 as libc::c_int,
            gametypedesc[cv_newgametype.value as usize].col[1 as libc::c_int as usize]
                as int32_t,
        );
        V_DrawString(
            19 as libc::c_int,
            y + 50 as libc::c_int,
            0 as libc::c_int,
            gametype_cons_t[cv_newgametype.value as usize].strvalue,
        );
        if levelselectselect[0 as libc::c_int as usize] == 0 {
            V_DrawCharacter(
                19 as libc::c_int - 10 as libc::c_int
                    - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                y + 25 as libc::c_int,
                '\u{1c}' as i32 | 0x2000 as libc::c_int,
                false_0 as libc::c_int,
            );
            V_DrawCharacter(
                19 as libc::c_int + 282 as libc::c_int + 2 as libc::c_int
                    + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                y + 25 as libc::c_int,
                '\u{1d}' as i32 | 0x2000 as libc::c_int,
                false_0 as libc::c_int,
            );
        }
    } else if (*(levelselect.rows).offset(row as isize))
        .mapavailable[3 as libc::c_int as usize] != 0
    {
        M_DrawLevelPlatterWideMap(
            row,
            0 as libc::c_int as uint8_t,
            19 as libc::c_int,
            y,
            rowhighlight,
        );
    } else {
        col = 0 as libc::c_int as uint8_t;
        while (col as libc::c_int) < 3 as libc::c_int {
            M_DrawLevelPlatterMap(
                row,
                col,
                19 as libc::c_int + col as libc::c_int * 101 as libc::c_int,
                y,
                (rowhighlight != 0
                    && col as libc::c_int
                        == levelselectselect[1 as libc::c_int as usize] as libc::c_int)
                    as libc::c_int,
            );
            col = col.wrapping_add(1);
            col;
        }
    };
}
unsafe extern "C" fn M_DrawRecordAttackForeground() {
    let mut fg: *mut patch_t = W_CachePatchName(
        b"RECATKFG\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    let mut clock: *mut patch_t = W_CachePatchName(
        b"RECCLOCK\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    let mut fa: angle_t = 0;
    let mut i: int32_t = 0;
    let mut height: int32_t = (*fg).height as libc::c_int / 2 as libc::c_int;
    let mut dupz: int32_t = if vid.dupx < vid.dupy { vid.dupx } else { vid.dupy };
    i = -(12 as libc::c_int);
    while i < 200 as libc::c_int / height + 12 as libc::c_int {
        let mut y: int32_t = i * height
            - (height - FixedInt(recatkdrawtimer * 2 as libc::c_int) % height);
        let mut sy: int32_t = FixedMul(y, dupz << 16 as libc::c_int)
            >> 16 as libc::c_int;
        if vid.height != 200 as libc::c_int * dupz {
            sy += (vid.height - 200 as libc::c_int * dupz) / 2 as libc::c_int;
        }
        if !(sy + height < 0 as libc::c_int) {
            V_DrawStretchyFixedPatch(
                0 as libc::c_int,
                y << 16 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0x4000000 as libc::c_int,
                fg,
                0 as *const uint8_t,
            );
            V_DrawStretchyFixedPatch(
                (320 as libc::c_int) << 16 as libc::c_int,
                y << 16 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0x8000000 as libc::c_int | 0x800000 as libc::c_int,
                fg,
                0 as *const uint8_t,
            );
            if y > vid.height {
                break;
            }
        }
        i += 1;
        i;
    }
    fa = FixedAngle(
        (FixedInt(recatkdrawtimer * 4 as libc::c_int) % 360 as libc::c_int)
            << 16 as libc::c_int,
    ) >> 19 as libc::c_int & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
    V_DrawStretchyFixedPatch(
        (160 as libc::c_int) << 16 as libc::c_int,
        ((80 as libc::c_int) << 16 as libc::c_int)
            + 4 as libc::c_int
                * (finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int),
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        clock,
        0 as *const uint8_t,
    );
    recatkdrawtimer += renderdeltatics;
    if recatkdrawtimer < 0 as libc::c_int {
        recatkdrawtimer = 0 as libc::c_int;
    }
}
unsafe extern "C" fn M_DrawNightsAttackMountains() {
    static mut bgscrollx: fixed_t = 0;
    let mut dupz: int32_t = if vid.dupx < vid.dupy { vid.dupx } else { vid.dupy };
    let mut background: *mut patch_t = W_CachePatchName(
        curbgname.as_mut_ptr(),
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    let mut w: int16_t = (*background).width;
    let mut x: int32_t = FixedInt(-bgscrollx) % w as libc::c_int;
    let mut y: int32_t = 200 as libc::c_int
        - (*background).height as libc::c_int * 2 as libc::c_int;
    if vid.height != 200 as libc::c_int * dupz {
        V_DrawFill(
            0 as libc::c_int,
            0 as libc::c_int,
            320 as libc::c_int,
            200 as libc::c_int,
            158 as libc::c_int,
        );
    }
    V_DrawFill(
        0 as libc::c_int,
        y + 50 as libc::c_int,
        vid.width,
        200 as libc::c_int,
        0x4000000 as libc::c_int | 31 as libc::c_int,
    );
    V_DrawStretchyFixedPatch(
        x * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0x4000000 as libc::c_int,
        background,
        0 as *const uint8_t,
    );
    x += w as libc::c_int;
    if x < 320 as libc::c_int {
        V_DrawStretchyFixedPatch(
            x * ((1 as libc::c_int) << 16 as libc::c_int),
            y << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0x4000000 as libc::c_int,
            background,
            0 as *const uint8_t,
        );
    }
    bgscrollx
        += FixedMul(
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            renderdeltatics,
        );
    if bgscrollx > (w as libc::c_int) << 16 as libc::c_int {
        bgscrollx &= 0xffff as libc::c_int;
    }
}
unsafe extern "C" fn M_DrawNightsAttackBackground() {
    let mut x: int32_t = 0;
    let mut y: int32_t = 0 as libc::c_int;
    let mut i: int32_t = 0;
    let mut backtopfg: *mut patch_t = W_CachePatchName(
        b"NTSATKT1\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    let mut fronttopfg: *mut patch_t = W_CachePatchName(
        b"NTSATKT2\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    let mut backtopwidth: int32_t = (*backtopfg).width as int32_t;
    let mut fronttopwidth: int32_t = (*fronttopfg).width as int32_t;
    let mut backbottomfg: *mut patch_t = W_CachePatchName(
        b"NTSATKB1\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    let mut frontbottomfg: *mut patch_t = W_CachePatchName(
        b"NTSATKB2\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    let mut backbottomwidth: int32_t = (*backbottomfg).width as int32_t;
    let mut backbottomheight: int32_t = (*backbottomfg).height as int32_t;
    let mut frontbottomwidth: int32_t = (*frontbottomfg).width as int32_t;
    let mut frontbottomheight: int32_t = (*frontbottomfg).height as int32_t;
    M_DrawNightsAttackMountains();
    x = 0 as libc::c_int - FixedInt(ntsatkdrawtimer) % backtopwidth;
    V_DrawStretchyFixedPatch(
        x * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0x1000000 as libc::c_int | 0x4000000 as libc::c_int,
        backtopfg,
        0 as *const uint8_t,
    );
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        x += backtopwidth;
        if x >= vid.width {
            break;
        }
        V_DrawStretchyFixedPatch(
            x * ((1 as libc::c_int) << 16 as libc::c_int),
            y << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0x1000000 as libc::c_int | 0x4000000 as libc::c_int,
            backtopfg,
            0 as *const uint8_t,
        );
        i += 1;
        i;
    }
    x = 0 as libc::c_int - FixedInt(ntsatkdrawtimer * 2 as libc::c_int) % fronttopwidth;
    V_DrawStretchyFixedPatch(
        x * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0x1000000 as libc::c_int | 0x4000000 as libc::c_int,
        fronttopfg,
        0 as *const uint8_t,
    );
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        x += fronttopwidth;
        if x >= vid.width {
            break;
        }
        V_DrawStretchyFixedPatch(
            x * ((1 as libc::c_int) << 16 as libc::c_int),
            y << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0x1000000 as libc::c_int | 0x4000000 as libc::c_int,
            fronttopfg,
            0 as *const uint8_t,
        );
        i += 1;
        i;
    }
    x = 0 as libc::c_int - FixedInt(ntsatkdrawtimer) % backbottomwidth;
    y = 200 as libc::c_int - backbottomheight;
    V_DrawStretchyFixedPatch(
        x * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0x2000000 as libc::c_int | 0x4000000 as libc::c_int,
        backbottomfg,
        0 as *const uint8_t,
    );
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        x += backbottomwidth;
        if x >= vid.width {
            break;
        }
        V_DrawStretchyFixedPatch(
            x * ((1 as libc::c_int) << 16 as libc::c_int),
            y << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0x2000000 as libc::c_int | 0x4000000 as libc::c_int,
            backbottomfg,
            0 as *const uint8_t,
        );
        i += 1;
        i;
    }
    x = 0 as libc::c_int
        - FixedInt(ntsatkdrawtimer * 2 as libc::c_int) % frontbottomwidth;
    y = 200 as libc::c_int - frontbottomheight;
    V_DrawStretchyFixedPatch(
        x * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0x2000000 as libc::c_int | 0x4000000 as libc::c_int,
        frontbottomfg,
        0 as *const uint8_t,
    );
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        x += frontbottomwidth;
        if x >= vid.width {
            break;
        }
        V_DrawStretchyFixedPatch(
            x * ((1 as libc::c_int) << 16 as libc::c_int),
            y << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0x2000000 as libc::c_int | 0x4000000 as libc::c_int,
            frontbottomfg,
            0 as *const uint8_t,
        );
        i += 1;
        i;
    }
    ntsatkdrawtimer += renderdeltatics;
    if ntsatkdrawtimer < 0 as libc::c_int {
        ntsatkdrawtimer = 0 as libc::c_int;
    }
}
static mut ntssupersonic: [*mut patch_t; 2] = [0 as *const patch_t as *mut patch_t; 2];
unsafe extern "C" fn M_DrawNightsAttackSuperSonic() {
    let mut colormap: *const uint8_t = R_GetTranslationColormap(
        TC_DEFAULT as libc::c_int,
        SKINCOLOR_YELLOW,
        1 as libc::c_int as uint8_t,
    );
    let mut timer: int32_t = FixedInt(ntsatkdrawtimer / 4 as libc::c_int)
        % 2 as libc::c_int;
    let mut fa: angle_t = FixedAngle(
        (FixedInt(ntsatkdrawtimer * 4 as libc::c_int) % 360 as libc::c_int)
            << 16 as libc::c_int,
    ) >> 19 as libc::c_int & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
    V_DrawStretchyFixedPatch(
        (235 as libc::c_int) << 16 as libc::c_int,
        ((120 as libc::c_int) << 16 as libc::c_int)
            - 8 as libc::c_int
                * (finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int),
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        ntssupersonic[timer as usize],
        colormap,
    );
}
unsafe extern "C" fn M_DrawLevelPlatterMenu() {
    let mut iter: uint8_t = levelselectselect[0 as libc::c_int as usize];
    let mut sizeselect: uint8_t = (if (*(levelselect.rows)
        .offset(levelselectselect[0 as libc::c_int as usize] as isize))
        .mapavailable[3 as libc::c_int as usize] != 0
    {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    }) as uint8_t;
    let mut y: int32_t = 59 as libc::c_int + 16 as libc::c_int
        + FixedInt(lsoffs[0 as libc::c_int as usize])
        - (if (*(levelselect.rows)
            .offset(levelselectselect[0 as libc::c_int as usize] as isize))
            .header[0 as libc::c_int as usize] as libc::c_int != 0
        {
            16 as libc::c_int
        } else {
            0 as libc::c_int
        });
    let cursorx: int32_t = if sizeselect as libc::c_int != 0 {
        0 as libc::c_int
    } else {
        levelselectselect[1 as libc::c_int as usize] as libc::c_int * 101 as libc::c_int
    };
    if (*currentMenu).prevMenu == &mut SP_TimeAttackDef as *mut menu_t {
        M_SetMenuCurBackground(b"RECATKBG\0" as *const u8 as *const libc::c_char);
        curbgxspeed = 0 as libc::c_int;
        curbgyspeed = 18 as libc::c_int;
        if curbgcolor >= 0 as libc::c_int {
            V_DrawFill(
                0 as libc::c_int,
                0 as libc::c_int,
                320 as libc::c_int,
                200 as libc::c_int,
                curbgcolor,
            );
        } else if curbghide == 0 || titlemapinaction == 0 {
            F_SkyScroll(curbgname.as_mut_ptr());
            if strncmp(
                b"RECATKBG\0" as *const u8 as *const libc::c_char,
                curbgname.as_mut_ptr(),
                8 as libc::c_int as libc::c_ulong,
            ) == 0
            {
                M_DrawRecordAttackForeground();
            }
        }
        if curfadevalue != 0 {
            V_DrawFadeScreen(0xff00 as libc::c_int as uint16_t, curfadevalue as uint8_t);
        }
    }
    if (*currentMenu).prevMenu == &mut SP_NightsAttackDef as *mut menu_t {
        M_SetMenuCurBackground(b"NTSATKBG\0" as *const u8 as *const libc::c_char);
        if curbgcolor >= 0 as libc::c_int {
            V_DrawFill(
                0 as libc::c_int,
                0 as libc::c_int,
                320 as libc::c_int,
                200 as libc::c_int,
                curbgcolor,
            );
        } else if curbghide == 0 || titlemapinaction == 0 {
            V_DrawFill(
                0 as libc::c_int,
                0 as libc::c_int,
                320 as libc::c_int,
                200 as libc::c_int,
                158 as libc::c_int,
            );
            M_DrawNightsAttackMountains();
        }
        if curfadevalue != 0 {
            V_DrawFadeScreen(0xff00 as libc::c_int as uint16_t, curfadevalue as uint8_t);
        }
    }
    while y > -(8 as libc::c_int) {
        if iter as libc::c_int == 0 as libc::c_int {
            if (levelselect.numrows as libc::c_int) < 3 as libc::c_int {
                break;
            }
            iter = levelselect.numrows;
        }
        iter = iter.wrapping_sub(1);
        iter;
        y
            -= 62 as libc::c_int * vid.height / (200 as libc::c_int * vid.dupy)
                + (if (*(levelselect.rows).offset(iter as isize))
                    .header[0 as libc::c_int as usize] as libc::c_int != 0
                {
                    16 as libc::c_int
                } else {
                    0 as libc::c_int
                });
    }
    while y < vid.height / vid.dupy {
        M_DrawLevelPlatterRow(iter, y);
        y
            += 62 as libc::c_int * vid.height / (200 as libc::c_int * vid.dupy)
                + (if (*(levelselect.rows).offset(iter as isize))
                    .header[0 as libc::c_int as usize] as libc::c_int != 0
                {
                    16 as libc::c_int
                } else {
                    0 as libc::c_int
                });
        if iter as libc::c_int == levelselect.numrows as libc::c_int - 1 as libc::c_int {
            if (levelselect.numrows as libc::c_int) < 3 as libc::c_int {
                break;
            }
            iter = 255 as libc::c_int as uint8_t;
        }
        iter = iter.wrapping_add(1);
        iter;
    }
    if levellistmode as libc::c_uint != LLM_CREATESERVER as libc::c_int as libc::c_uint
        || levelselectselect[0 as libc::c_int as usize] as libc::c_int != 0
    {
        V_DrawStretchyFixedPatch(
            19 as libc::c_int + cursorx + FixedInt(lsoffs[1 as libc::c_int as usize])
                << 16 as libc::c_int,
            59 as libc::c_int + 16 as libc::c_int
                + FixedInt(lsoffs[0 as libc::c_int as usize]) << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            levselp[sizeselect
                as usize][(if skullAnimCounter as libc::c_int / 4 as libc::c_int != 0 {
                1 as libc::c_int
            } else {
                0 as libc::c_int
            }) as usize],
            0 as *const uint8_t,
        );
    }
    let mut cursormovefrac: fixed_t = FixedDiv(2 as libc::c_int, 3 as libc::c_int);
    if lsoffs[0 as libc::c_int as usize] > (1 as libc::c_int) << 16 as libc::c_int
        || lsoffs[0 as libc::c_int as usize] < -((1 as libc::c_int) << 16 as libc::c_int)
    {
        let mut offs: fixed_t = lsoffs[0 as libc::c_int as usize];
        let mut newoffs: fixed_t = FixedMul(offs, cursormovefrac);
        let mut deltaoffs: fixed_t = newoffs - offs;
        newoffs = offs + FixedMul(deltaoffs, renderdeltatics);
        lsoffs[0 as libc::c_int as usize] = newoffs;
    } else {
        lsoffs[0 as libc::c_int as usize] = 0 as libc::c_int;
    }
    if lsoffs[1 as libc::c_int as usize] > (1 as libc::c_int) << 16 as libc::c_int
        || lsoffs[1 as libc::c_int as usize] < -((1 as libc::c_int) << 16 as libc::c_int)
    {
        let mut offs_0: fixed_t = lsoffs[1 as libc::c_int as usize];
        let mut newoffs_0: fixed_t = FixedMul(offs_0, cursormovefrac);
        let mut deltaoffs_0: fixed_t = newoffs_0 - offs_0;
        newoffs_0 = offs_0 + FixedMul(deltaoffs_0, renderdeltatics);
        lsoffs[1 as libc::c_int as usize] = newoffs_0;
    } else {
        lsoffs[1 as libc::c_int as usize] = 0 as libc::c_int;
    }
    M_DrawMenuTitle();
}
#[no_mangle]
pub unsafe extern "C" fn M_CanShowLevelInList(
    mut mapnum: int32_t,
    mut gt: int32_t,
) -> boolean {
    return (M_CanShowLevelOnPlatter(mapnum, gt) != 0
        && M_LevelAvailableOnPlatter(mapnum) != 0) as libc::c_int;
}
unsafe extern "C" fn M_GetFirstLevelInList(mut gt: int32_t) -> int32_t {
    let mut mapnum: int32_t = 0;
    mapnum = 0 as libc::c_int;
    while mapnum < 1035 as libc::c_int {
        if M_CanShowLevelInList(mapnum, gt) != 0 {
            return mapnum + 1 as libc::c_int;
        }
        mapnum += 1;
        mapnum;
    }
    return 1 as libc::c_int;
}
static mut MessageMenu: [menuitem_t; 1] = [
    {
        let mut init = menuitem_s {
            status: 0 as libc::c_int as uint16_t,
            patch: 0 as *const libc::c_char,
            text: 0 as *const libc::c_char,
            itemaction: 0 as *const libc::c_void as *mut libc::c_void,
            alphaKey: 0 as libc::c_int as uint16_t,
        };
        init
    },
];
#[no_mangle]
pub static mut MessageDef: menu_t = unsafe {
    {
        let mut init = menu_s {
            menuid: MN_SPECIAL as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: 1 as libc::c_int as int16_t,
            prevMenu: 0 as *const menu_s as *mut menu_s,
            menuitems: MessageMenu.as_ptr() as *mut _,
            drawroutine: Some(M_DrawMessageMenu as unsafe extern "C" fn() -> ()),
            x: 0 as libc::c_int as int16_t,
            y: 0 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn M_StartMessage(
    mut string: *const libc::c_char,
    mut routine: *mut libc::c_void,
    mut itemtype: menumessagetype_t,
) {
    let mut max: size_t = 0 as libc::c_int as size_t;
    let mut start: size_t = 0 as libc::c_int as size_t;
    let mut i: size_t = 0;
    let mut strlines: size_t = 0;
    static mut message: *mut libc::c_char = 0 as *const libc::c_char
        as *mut libc::c_char;
    Z_Free(message as *mut libc::c_void);
    message = Z_StrDup(string);
    if !debugfile.is_null() {
        fputs(message, debugfile);
        fflush(debugfile);
    }
    strlines = 0 as libc::c_int as size_t;
    let mut current_block_22: u64;
    i = 0 as libc::c_int as size_t;
    while *message.offset(i as isize) != 0 {
        if *message.offset(i as isize) as libc::c_int == ' ' as i32 {
            start = i;
            max = max.wrapping_add(4 as libc::c_int as size_t);
            current_block_22 = 17407779659766490442;
        } else if *message.offset(i as isize) as libc::c_int == '\n' as i32 {
            strlines = i;
            start = 0 as libc::c_int as size_t;
            max = 0 as libc::c_int as size_t;
            current_block_22 = 7815301370352969686;
        } else {
            max = max.wrapping_add(8 as libc::c_int as size_t);
            current_block_22 = 17407779659766490442;
        }
        match current_block_22 {
            17407779659766490442 => {
                if max >= 320 as libc::c_int as size_t
                    && start > 0 as libc::c_int as size_t
                {
                    *message.offset(start as isize) = '\n' as i32 as libc::c_char;
                    max = max
                        .wrapping_sub(
                            start.wrapping_sub(strlines) * 8 as libc::c_int as size_t,
                        );
                    strlines = start;
                    start = 0 as libc::c_int as size_t;
                }
            }
            _ => {}
        }
        i = i.wrapping_add(1);
        i;
    }
    start = 0 as libc::c_int as size_t;
    max = 0 as libc::c_int as size_t;
    M_StartControlPanel();
    if currentMenu == &mut MessageDef as *mut menu_t {
        MessageDef.prevMenu = &mut MainDef;
    } else {
        MessageDef.prevMenu = currentMenu;
    }
    let ref mut fresh6 = (*(MessageDef.menuitems).offset(0 as libc::c_int as isize))
        .text;
    *fresh6 = message;
    (*(MessageDef.menuitems).offset(0 as libc::c_int as isize))
        .alphaKey = itemtype as uint8_t as uint16_t;
    if routine.is_null()
        && itemtype as libc::c_uint != MM_NOTHING as libc::c_int as libc::c_uint
    {
        itemtype = MM_NOTHING;
    }
    match itemtype as libc::c_uint {
        0 => {
            (*(MessageDef.menuitems).offset(0 as libc::c_int as isize))
                .status = 12 as libc::c_int as uint16_t;
            let ref mut fresh7 = (*(MessageDef.menuitems)
                .offset(0 as libc::c_int as isize))
                .itemaction;
            *fresh7 = ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(int32_t) -> ()>,
                *mut libc::c_void,
            >(Some(M_StopMessage as unsafe extern "C" fn(int32_t) -> ()));
        }
        1 => {
            (*(MessageDef.menuitems).offset(0 as libc::c_int as isize))
                .status = 12 as libc::c_int as uint16_t;
            let ref mut fresh8 = (*(MessageDef.menuitems)
                .offset(0 as libc::c_int as isize))
                .itemaction;
            *fresh8 = routine;
        }
        2 => {
            (*(MessageDef.menuitems).offset(0 as libc::c_int as isize))
                .status = 12 as libc::c_int as uint16_t;
            let ref mut fresh9 = (*(MessageDef.menuitems)
                .offset(0 as libc::c_int as isize))
                .itemaction;
            *fresh9 = routine;
        }
        _ => {}
    }
    strlines = 0 as libc::c_int as size_t;
    while *message.offset(start as isize) != 0 {
        i = 0 as libc::c_int as size_t;
        while i < strlen(message.offset(start as isize)) {
            if *message.offset(start as isize).offset(i as isize) as libc::c_int
                == '\n' as i32
            {
                if i > max {
                    max = i;
                }
                start = start.wrapping_add(i);
                i = -(1 as libc::c_int) as size_t;
                start = start.wrapping_add(1);
                start;
                break;
            } else {
                i = i.wrapping_add(1);
                i;
            }
        }
        if i == strlen(message.offset(start as isize)) {
            start = start.wrapping_add(i);
        }
        strlines = strlines.wrapping_add(1);
        strlines;
    }
    MessageDef
        .x = ((320 as libc::c_int as size_t)
        .wrapping_sub(8 as libc::c_int as size_t * max)
        .wrapping_sub(16 as libc::c_int as size_t) / 2 as libc::c_int as size_t)
        as int16_t;
    MessageDef
        .y = ((200 as libc::c_int as size_t).wrapping_sub(M_StringHeight(message))
        / 2 as libc::c_int as size_t) as int16_t;
    MessageDef.lastOn = (strlines << 8 as libc::c_int).wrapping_add(max) as int16_t;
    currentMenu = &mut MessageDef;
    itemOn = 0 as libc::c_int as int16_t;
}
unsafe extern "C" fn M_DrawMessageMenu() {
    let mut y: int32_t = (*currentMenu).y as int32_t;
    let mut i: size_t = 0;
    let mut start: size_t = 0 as libc::c_int as size_t;
    let mut max: int16_t = 0;
    let mut string: [libc::c_char; 256] = [0; 256];
    let mut mlines: int32_t = 0;
    let mut msg: *const libc::c_char = (*((*currentMenu).menuitems)
        .offset(0 as libc::c_int as isize))
        .text;
    mlines = (*currentMenu).lastOn as libc::c_int >> 8 as libc::c_int;
    max = (((*currentMenu).lastOn as libc::c_int & 0xff as libc::c_int) as uint8_t
        as libc::c_int * 8 as libc::c_int) as int16_t;
    if gamestate as libc::c_uint == GS_TIMEATTACK as libc::c_int as libc::c_uint {
        if curbgcolor >= 0 as libc::c_int {
            V_DrawFill(
                0 as libc::c_int,
                0 as libc::c_int,
                320 as libc::c_int,
                200 as libc::c_int,
                curbgcolor,
            );
        } else if curbghide == 0 || titlemapinaction == 0 {
            if levellistmode as libc::c_uint
                == LLM_NIGHTSATTACK as libc::c_int as libc::c_uint
            {
                V_DrawFill(
                    0 as libc::c_int,
                    0 as libc::c_int,
                    320 as libc::c_int,
                    200 as libc::c_int,
                    158 as libc::c_int,
                );
                M_DrawNightsAttackMountains();
            } else {
                F_SkyScroll(curbgname.as_mut_ptr());
                if strncmp(
                    b"RECATKBG\0" as *const u8 as *const libc::c_char,
                    curbgname.as_mut_ptr(),
                    8 as libc::c_int as libc::c_ulong,
                ) == 0
                {
                    M_DrawRecordAttackForeground();
                }
            }
        }
        if curfadevalue != 0 {
            V_DrawFadeScreen(0xff00 as libc::c_int as uint16_t, curfadevalue as uint8_t);
        }
    }
    M_DrawTextBox(
        (*currentMenu).x as int32_t,
        y - 8 as libc::c_int,
        max as libc::c_int + 7 as libc::c_int >> 3 as libc::c_int,
        mlines,
    );
    while *msg.offset(start as isize) != 0 {
        let mut len_0: size_t = strlen(msg.offset(start as isize));
        i = 0 as libc::c_int as size_t;
        while i < len_0 {
            if *msg.offset(start as isize).offset(i as isize) as libc::c_int
                == '\n' as i32
            {
                memset(
                    string.as_mut_ptr() as *mut libc::c_void,
                    0 as libc::c_int,
                    256 as libc::c_int as libc::c_ulong,
                );
                if i >= 256 as libc::c_int as size_t {
                    CONS_Printf(
                        b"M_DrawMessageMenu: too long segment in %s\n\0" as *const u8
                            as *const libc::c_char,
                        msg,
                    );
                    return;
                } else {
                    strncpy(string.as_mut_ptr(), msg.offset(start as isize), i);
                    string[i as usize] = '\0' as i32 as libc::c_char;
                    start = start.wrapping_add(i);
                    i = -(1 as libc::c_int) as size_t;
                    start = start.wrapping_add(1);
                    start;
                }
                break;
            } else {
                i = i.wrapping_add(1);
                i;
            }
        }
        if i == strlen(msg.offset(start as isize)) {
            if i >= 256 as libc::c_int as size_t {
                CONS_Printf(
                    b"M_DrawMessageMenu: too long segment in %s\n\0" as *const u8
                        as *const libc::c_char,
                    msg,
                );
                return;
            } else {
                strcpy(string.as_mut_ptr(), msg.offset(start as isize));
                start = start.wrapping_add(i);
            }
        }
        V_DrawString(
            (320 as libc::c_int - V_StringWidth(string.as_mut_ptr(), 0 as libc::c_int))
                / 2 as libc::c_int,
            y,
            0x800000 as libc::c_int,
            string.as_mut_ptr(),
        );
        y += 8 as libc::c_int;
    }
}
unsafe extern "C" fn M_StopMessage(mut choice: int32_t) {
    if menuactive != 0 {
        M_SetupNextMenu(MessageDef.prevMenu);
    }
}
unsafe extern "C" fn M_DrawImageDef() {
    let mut pictest: *mut pic_t = W_CacheLumpName(
        (*((*currentMenu).menuitems).offset(itemOn as isize)).text,
        PU_CACHE as libc::c_int,
    ) as *mut pic_t;
    if (*pictest).zero == 0 {
        V_DrawScaledPic(
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
            W_GetNumForName((*((*currentMenu).menuitems).offset(itemOn as isize)).text)
                as int32_t,
        );
    } else {
        let mut patch: *mut patch_t = W_CachePatchName(
            (*((*currentMenu).menuitems).offset(itemOn as isize)).text,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t;
        if (*patch).width as libc::c_int <= 320 as libc::c_int {
            V_DrawStretchyFixedPatch(
                0 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (0 as libc::c_int) << 16 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                0 as libc::c_int,
                patch,
                0 as *const uint8_t,
            );
        } else {
            V_DrawStretchyFixedPatch(
                (0 as libc::c_int) << 16 as libc::c_int,
                (0 as libc::c_int) << 16 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0 as libc::c_int,
                patch,
                0 as *const uint8_t,
            );
        }
    }
    if (*currentMenu).numitems as libc::c_int > 1 as libc::c_int {
        V_DrawString(
            0 as libc::c_int,
            192 as libc::c_int,
            0x50000 as libc::c_int,
            va(
                b"PAGE %d of %hd\0" as *const u8 as *const libc::c_char,
                itemOn as libc::c_int + 1 as libc::c_int,
                (*currentMenu).numitems as libc::c_int,
            ),
        );
    }
}
unsafe extern "C" fn M_HandleImageDef(mut choice: int32_t) {
    match choice {
        235 => {
            if !((*currentMenu).numitems as libc::c_int == 1 as libc::c_int) {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                if itemOn as libc::c_int
                    >= ((*currentMenu).numitems as libc::c_int - 1 as libc::c_int)
                        as int16_t as libc::c_int
                {
                    itemOn = 0 as libc::c_int as int16_t;
                } else {
                    itemOn += 1;
                    itemOn;
                }
            }
        }
        233 => {
            if !((*currentMenu).numitems as libc::c_int == 1 as libc::c_int) {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                if itemOn == 0 {
                    itemOn = ((*currentMenu).numitems as libc::c_int - 1 as libc::c_int)
                        as int16_t;
                } else {
                    itemOn -= 1;
                    itemOn;
                }
            }
        }
        27 | 13 => {
            M_ClearMenus(true_0 as libc::c_int);
        }
        _ => {}
    };
}
unsafe extern "C" fn M_AddonsOptions(mut choice: int32_t) {
    Addons_option_Onchange();
    M_SetupNextMenu(&mut OP_AddonsOptionsDef);
}
unsafe extern "C" fn M_LoadAddonsPatches() {
    addonsp[EXT_FOLDER as libc::c_int
        as usize] = W_CachePatchName(
        b"M_FFLDR\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[EXT_UP as libc::c_int
        as usize] = W_CachePatchName(
        b"M_FBACK\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[EXT_NORESULTS as libc::c_int
        as usize] = W_CachePatchName(
        b"M_FNOPE\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[EXT_TXT as libc::c_int
        as usize] = W_CachePatchName(
        b"M_FTXT\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[EXT_CFG as libc::c_int
        as usize] = W_CachePatchName(
        b"M_FCFG\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[EXT_WAD as libc::c_int
        as usize] = W_CachePatchName(
        b"M_FWAD\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[EXT_PK3 as libc::c_int
        as usize] = W_CachePatchName(
        b"M_FPK3\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[EXT_SOC as libc::c_int
        as usize] = W_CachePatchName(
        b"M_FSOC\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[EXT_LUA as libc::c_int
        as usize] = W_CachePatchName(
        b"M_FLUA\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[NUM_EXT as libc::c_int
        as usize] = W_CachePatchName(
        b"M_FUNKN\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[(NUM_EXT as libc::c_int + 1 as libc::c_int)
        as usize] = W_CachePatchName(
        b"M_FSEL\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[(NUM_EXT as libc::c_int + 2 as libc::c_int)
        as usize] = W_CachePatchName(
        b"M_FLOAD\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[(NUM_EXT as libc::c_int + 3 as libc::c_int)
        as usize] = W_CachePatchName(
        b"M_FSRCH\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    addonsp[(NUM_EXT as libc::c_int + 4 as libc::c_int)
        as usize] = W_CachePatchName(
        b"M_FSAVE\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
}
unsafe extern "C" fn M_Addons(mut choice: int32_t) {
    let mut pathname: *const libc::c_char = b".\0" as *const u8 as *const libc::c_char;
    highlightflags = 0x2000 as libc::c_int;
    recommendedflags = 0x3000 as libc::c_int;
    warningflags = 0x5000 as libc::c_int;
    if cv_addons_option.value == 0 as libc::c_int {
        pathname = if usehome != 0 {
            srb2home.as_mut_ptr()
        } else {
            srb2path.as_mut_ptr()
        };
    } else if cv_addons_option.value == 1 as libc::c_int {
        pathname = srb2home.as_mut_ptr();
    } else if cv_addons_option.value == 2 as libc::c_int {
        pathname = srb2path.as_mut_ptr();
    } else if cv_addons_option.value == 3 as libc::c_int
        && *cv_addons_folder.string as libc::c_int != '\0' as i32
    {
        pathname = cv_addons_folder.string;
    }
    strlcpy(menupath.as_mut_ptr(), pathname, 1024 as libc::c_int as libc::c_ulong);
    menudepthleft = (20 as libc::c_int - 1 as libc::c_int) as size_t;
    menupathindex[menudepthleft
        as usize] = (strlen(menupath.as_mut_ptr()))
        .wrapping_add(1 as libc::c_int as libc::c_ulong);
    if menupath[(menupathindex[menudepthleft as usize])
        .wrapping_sub(2 as libc::c_int as size_t) as usize] as libc::c_int
        != (*::core::mem::transmute::<
            &[u8; 2],
            &[libc::c_char; 2],
        >(b"/\0"))[0 as libc::c_int as usize] as libc::c_int
    {
        menupath[(menupathindex[menudepthleft as usize])
            .wrapping_sub(1 as libc::c_int as size_t)
            as usize] = (*::core::mem::transmute::<
            &[u8; 2],
            &[libc::c_char; 2],
        >(b"/\0"))[0 as libc::c_int as usize];
        menupath[menupathindex[menudepthleft as usize]
            as usize] = 0 as libc::c_int as libc::c_char;
    } else {
        menupathindex[menudepthleft
            as usize] = (menupathindex[menudepthleft as usize]).wrapping_sub(1);
        menupathindex[menudepthleft as usize];
    }
    if preparefilemenu(false_0 as libc::c_int) == 0 {
        M_StartMessage(
            va(
                b"No files/folders found.\n\n%s\n\n(Press a key)\n\0" as *const u8
                    as *const libc::c_char,
                b"Visit \x83SRB2.ORG/ADDONS\x80 to get & make addons!\0" as *const u8
                    as *const libc::c_char,
            ),
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    } else {
        dir_on[menudepthleft as usize] = 0 as libc::c_int as size_t;
    }
    M_LoadAddonsPatches();
    MISC_AddonsDef.prevMenu = currentMenu;
    M_SetupNextMenu(&mut MISC_AddonsDef);
}
unsafe extern "C" fn M_AddonsHeaderPath() -> *mut libc::c_char {
    let mut len_0: uint32_t = 0;
    static mut header: [libc::c_char; 1024] = [0; 1024];
    strlcpy(
        header.as_mut_ptr(),
        va(
            b"%s folder%s\0" as *const u8 as *const libc::c_char,
            cv_addons_option.string,
            menupath
                .as_mut_ptr()
                .offset(
                    menupathindex[(20 as libc::c_int - 1 as libc::c_int) as usize]
                        as isize,
                )
                .offset(-(1 as libc::c_int as isize)),
        ),
        1024 as libc::c_int as libc::c_ulong,
    );
    len_0 = strlen(header.as_mut_ptr()) as uint32_t;
    if len_0 > 34 as libc::c_int as uint32_t {
        len_0 = len_0.wrapping_sub(34 as libc::c_int as uint32_t);
        header[len_0.wrapping_add(2 as libc::c_int as uint32_t)
            as usize] = '.' as i32 as libc::c_char;
        header[len_0.wrapping_add(1 as libc::c_int as uint32_t)
            as usize] = header[len_0.wrapping_add(2 as libc::c_int as uint32_t)
            as usize];
        header[len_0
            as usize] = header[len_0.wrapping_add(1 as libc::c_int as uint32_t)
            as usize];
    } else {
        len_0 = 0 as libc::c_int as uint32_t;
    }
    return header.as_mut_ptr().offset(len_0 as isize);
}
unsafe extern "C" fn M_AddonsClearName(mut choice: int32_t) {
    Z_Free(refreshdirname as *mut libc::c_void);
    refreshdirname = 0 as *mut libc::c_char;
}
unsafe extern "C" fn M_AddonsRefresh() -> boolean {
    if refreshdirmenu as libc::c_int & REFRESHDIR_NORMAL as libc::c_int != 0
        && preparefilemenu(true_0 as libc::c_int) == 0
    {
        S_StartSound(0 as *const libc::c_void, sfx_lose);
        M_SetupNextMenu(MISC_AddonsDef.prevMenu);
        M_StartMessage(
            va(
                b"\x82%s\x80\nThis folder no longer exists!\nAborting to main menu.\n\n(Press a key)\n\0"
                    as *const u8 as *const libc::c_char,
                M_AddonsHeaderPath(),
            ),
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return true_0 as libc::c_int;
    }
    if refreshdirmenu as libc::c_int & REFRESHDIR_ADDFILE as libc::c_int != 0 {
        let mut message: *mut libc::c_char = 0 as *mut libc::c_char;
        if refreshdirmenu as libc::c_int & REFRESHDIR_NOTLOADED as libc::c_int != 0 {
            S_StartSound(0 as *const libc::c_void, sfx_lose);
            if refreshdirmenu as libc::c_int & REFRESHDIR_MAX as libc::c_int != 0 {
                message = va(
                    b"%c%s\x80\nMaximum number of add-ons reached.\nA file could not be loaded.\nIf you wish to play with this add-on, restart the game to clear existing ones.\n\n(Press a key)\n\0"
                        as *const u8 as *const libc::c_char,
                    -128i32 + (highlightflags >> 12 as libc::c_int),
                    refreshdirname,
                );
            } else {
                message = va(
                    b"%c%s\x80\nA file was not loaded.\nCheck the console log for more information.\n\n(Press a key)\n\0"
                        as *const u8 as *const libc::c_char,
                    -128i32 + (highlightflags >> 12 as libc::c_int),
                    refreshdirname,
                );
            }
        } else if refreshdirmenu as libc::c_int
            & (REFRESHDIR_WARNING as libc::c_int | REFRESHDIR_ERROR as libc::c_int) != 0
        {
            S_StartSound(0 as *const libc::c_void, sfx_skid);
            message = va(
                b"%c%s\x80\nA file was loaded with %s.\nCheck the console log for more information.\n\n(Press a key)\n\0"
                    as *const u8 as *const libc::c_char,
                -128i32 + (highlightflags >> 12 as libc::c_int),
                refreshdirname,
                if refreshdirmenu as libc::c_int & REFRESHDIR_ERROR as libc::c_int != 0 {
                    b"errors\0" as *const u8 as *const libc::c_char
                } else {
                    b"warnings\0" as *const u8 as *const libc::c_char
                },
            );
        }
        if !message.is_null() {
            M_StartMessage(
                message,
                ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_AddonsClearName as unsafe extern "C" fn(int32_t) -> ())),
                MM_NOTHING,
            );
            return true_0 as libc::c_int;
        }
        S_StartSound(0 as *const libc::c_void, sfx_strpst);
        Z_Free(refreshdirname as *mut libc::c_void);
        refreshdirname = 0 as *mut libc::c_char;
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn M_DrawAddons() {
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut i: size_t = 0;
    let mut m: size_t = 0;
    let mut t: size_t = 0;
    let mut b: size_t = 0;
    let mut flashcol: *const uint8_t = 0 as *const uint8_t;
    let mut hilicol: uint8_t = 0;
    if refreshdirmenu as libc::c_int & M_AddonsRefresh() != 0 {
        M_DrawMessageMenu();
        return;
    }
    if Playing() != 0 {
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            5 as libc::c_int,
            warningflags,
            b"Adding files mid-game may cause problems.\0" as *const u8
                as *const libc::c_char,
        );
    } else {
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            5 as libc::c_int,
            0 as libc::c_int,
            b"Visit \x83SRB2.ORG/ADDONS\x80 to get & make addons!\0" as *const u8
                as *const libc::c_char,
        );
    }
    x = (*currentMenu).x as int32_t;
    y = (*currentMenu).y as libc::c_int + 1 as libc::c_int;
    hilicol = 0 as libc::c_int as uint8_t;
    V_DrawString(
        x - 21 as libc::c_int,
        y - 16 as libc::c_int + (16 as libc::c_int - 12 as libc::c_int),
        highlightflags | 0x800000 as libc::c_int,
        M_AddonsHeaderPath(),
    );
    V_DrawFill(
        x - 21 as libc::c_int,
        y - 16 as libc::c_int + (16 as libc::c_int - 3 as libc::c_int),
        32 as libc::c_int * 8 as libc::c_int + 6 as libc::c_int,
        1 as libc::c_int,
        hilicol as int32_t,
    );
    V_DrawFill(
        x - 21 as libc::c_int,
        y - 16 as libc::c_int + (16 as libc::c_int - 2 as libc::c_int),
        32 as libc::c_int * 8 as libc::c_int + 6 as libc::c_int,
        1 as libc::c_int,
        30 as libc::c_int,
    );
    m = (200 as libc::c_int - (*currentMenu).y as libc::c_int + 2 as libc::c_int
        - (y - 1 as libc::c_int)) as size_t;
    V_DrawFill(
        x - 21 as libc::c_int,
        y - 1 as libc::c_int,
        32 as libc::c_int * 8 as libc::c_int + 6 as libc::c_int,
        m as int32_t,
        159 as libc::c_int,
    );
    if sizedirmenu <= 9 as libc::c_int as size_t {
        t = 0 as libc::c_int as size_t;
        b = sizedirmenu.wrapping_sub(1 as libc::c_int as size_t);
        i = 0 as libc::c_int as size_t;
    } else {
        let mut q: size_t = m;
        m = 9 as libc::c_int as size_t * m / sizedirmenu;
        if dir_on[menudepthleft as usize] <= 4 as libc::c_int as size_t {
            t = 0 as libc::c_int as size_t;
            b = (9 as libc::c_int - 1 as libc::c_int) as size_t;
            i = 0 as libc::c_int as size_t;
        } else if dir_on[menudepthleft as usize]
            >= sizedirmenu.wrapping_sub((4 as libc::c_int + 1 as libc::c_int) as size_t)
        {
            t = sizedirmenu.wrapping_sub(9 as libc::c_int as size_t);
            b = sizedirmenu.wrapping_sub(1 as libc::c_int as size_t);
            i = q.wrapping_sub(m);
        } else {
            t = (dir_on[menudepthleft as usize])
                .wrapping_sub(4 as libc::c_int as size_t);
            b = (dir_on[menudepthleft as usize])
                .wrapping_add(4 as libc::c_int as size_t);
            i = t * q.wrapping_sub(m)
                / sizedirmenu.wrapping_sub(9 as libc::c_int as size_t);
        }
    }
    V_DrawFill(
        x - 21 as libc::c_int + (32 as libc::c_int * 8 as libc::c_int + 6 as libc::c_int)
            - 1 as libc::c_int,
        ((y - 1 as libc::c_int) as size_t).wrapping_add(i) as int32_t,
        1 as libc::c_int,
        m as int32_t,
        hilicol as int32_t,
    );
    if t != 0 as libc::c_int as size_t {
        V_DrawString(
            19 as libc::c_int,
            y + 4 as libc::c_int - skullAnimCounter as libc::c_int / 5 as libc::c_int,
            highlightflags,
            b"\x1A\0" as *const u8 as *const libc::c_char,
        );
    }
    if (skullAnimCounter as libc::c_int) < 4 as libc::c_int {
        flashcol = V_GetStringColormap(highlightflags);
    }
    i = t;
    while i <= b {
        let mut flags: uint32_t = 0x800000 as libc::c_int as uint32_t;
        if y > 200 as libc::c_int {
            break;
        }
        if !(*dirmenu.offset(i as isize)).is_null() {
            if *(*dirmenu.offset(i as isize)).offset(DIR_TYPE as libc::c_int as isize)
                as uint8_t as libc::c_int & EXT_LOADED as libc::c_int != 0
            {
                flags |= 0x50000 as libc::c_int as uint32_t;
                V_DrawStretchyFixedPatch(
                    x - (16 as libc::c_int + 4 as libc::c_int) << 16 as libc::c_int,
                    y << 16 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    0x50000 as libc::c_int,
                    addonsp[(*(*dirmenu.offset(i as isize))
                        .offset(DIR_TYPE as libc::c_int as isize) as uint8_t
                        as libc::c_int & !(EXT_LOADED as libc::c_int)) as usize],
                    0 as *const uint8_t,
                );
                V_DrawStretchyFixedPatch(
                    x - (16 as libc::c_int + 4 as libc::c_int) << 16 as libc::c_int,
                    y << 16 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    0 as libc::c_int,
                    addonsp[(NUM_EXT as libc::c_int + 2 as libc::c_int) as usize],
                    0 as *const uint8_t,
                );
            } else {
                V_DrawStretchyFixedPatch(
                    x - (16 as libc::c_int + 4 as libc::c_int) << 16 as libc::c_int,
                    y << 16 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    0 as libc::c_int,
                    addonsp[(*(*dirmenu.offset(i as isize))
                        .offset(DIR_TYPE as libc::c_int as isize) as uint8_t
                        as libc::c_int & !(EXT_LOADED as libc::c_int)) as usize],
                    0 as *const uint8_t,
                );
            }
            if i == dir_on[menudepthleft as usize] {
                V_DrawStretchyFixedPatch(
                    x - (16 as libc::c_int + 4 as libc::c_int) << 16 as libc::c_int,
                    y << 16 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    0 as libc::c_int,
                    addonsp[(NUM_EXT as libc::c_int + 1 as libc::c_int) as usize],
                    flashcol,
                );
                flags = (0x800000 as libc::c_int | highlightflags) as uint32_t;
            }
            if *(*dirmenu.offset(i as isize)).offset(DIR_LEN as libc::c_int as isize)
                as libc::c_int > 14 as libc::c_int * 2 as libc::c_int + 3 as libc::c_int
            {
                V_DrawString(
                    x,
                    y + 4 as libc::c_int,
                    flags as int32_t,
                    va(
                        b"%.*s...%s\0" as *const u8 as *const libc::c_char,
                        14 as libc::c_int,
                        (*dirmenu.offset(i as isize))
                            .offset(DIR_STRING as libc::c_int as isize),
                        (*dirmenu.offset(i as isize))
                            .offset(DIR_STRING as libc::c_int as isize)
                            .offset(
                                *(*dirmenu.offset(i as isize))
                                    .offset(DIR_LEN as libc::c_int as isize) as libc::c_int
                                    as isize,
                            )
                            .offset(-((14 as libc::c_int + 1 as libc::c_int) as isize)),
                    ),
                );
            } else {
                V_DrawString(
                    x,
                    y + 4 as libc::c_int,
                    flags as int32_t,
                    (*dirmenu.offset(i as isize))
                        .offset(DIR_STRING as libc::c_int as isize),
                );
            }
        }
        y += 16 as libc::c_int;
        i = i.wrapping_add(1);
        i;
    }
    if b != sizedirmenu.wrapping_sub(1 as libc::c_int as size_t) {
        V_DrawString(
            19 as libc::c_int,
            y - 12 as libc::c_int + skullAnimCounter as libc::c_int / 5 as libc::c_int,
            highlightflags,
            b"\x1B\0" as *const u8 as *const libc::c_char,
        );
    }
    y = 200 as libc::c_int - (*currentMenu).y as libc::c_int + 1 as libc::c_int;
    M_DrawTextBox(
        x - (21 as libc::c_int + 5 as libc::c_int),
        y,
        32 as libc::c_int,
        1 as libc::c_int,
    );
    if menusearch[0 as libc::c_int as usize] != 0 {
        V_DrawString(
            x - 18 as libc::c_int,
            y + 8 as libc::c_int,
            0x800000 as libc::c_int,
            menusearch.as_mut_ptr().offset(1 as libc::c_int as isize),
        );
    } else {
        V_DrawString(
            x - 18 as libc::c_int,
            y + 8 as libc::c_int,
            0x800000 as libc::c_int | 0x50000 as libc::c_int,
            b"Type to search...\0" as *const u8 as *const libc::c_char,
        );
    }
    if (skullAnimCounter as libc::c_int) < 4 as libc::c_int {
        V_DrawCharacter(
            x - 18 as libc::c_int
                + V_StringWidth(
                    menusearch.as_mut_ptr().offset(1 as libc::c_int as isize),
                    0 as libc::c_int,
                ),
            y + 8 as libc::c_int,
            '_' as i32 | 0x80 as libc::c_int,
            false_0 as libc::c_int,
        );
    }
    x -= 21 as libc::c_int + 5 as libc::c_int + 16 as libc::c_int;
    V_DrawStretchyFixedPatch(
        x << 16 as libc::c_int,
        (y + 4 as libc::c_int) << 16 as libc::c_int,
        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
        if menusearch[0 as libc::c_int as usize] as libc::c_int != 0 {
            0 as libc::c_int
        } else {
            0x50000 as libc::c_int
        },
        addonsp[(NUM_EXT as libc::c_int + 3 as libc::c_int) as usize],
        0 as *const uint8_t,
    );
    x = 320 as libc::c_int - x - 16 as libc::c_int;
    V_DrawStretchyFixedPatch(
        x << 16 as libc::c_int,
        (y + 4 as libc::c_int) << 16 as libc::c_int,
        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
        if usedCheats == 0 { 0 as libc::c_int } else { 0x50000 as libc::c_int },
        addonsp[(NUM_EXT as libc::c_int + 4 as libc::c_int) as usize],
        0 as *const uint8_t,
    );
    if modifiedgame != 0 {
        V_DrawStretchyFixedPatch(
            x << 16 as libc::c_int,
            (y + 4 as libc::c_int) << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            addonsp[(NUM_EXT as libc::c_int + 2 as libc::c_int) as usize],
            0 as *const uint8_t,
        );
    }
}
unsafe extern "C" fn M_AddonExec(mut ch: int32_t) {
    if ch != 'y' as i32 && ch != 13 as libc::c_int {
        return;
    }
    S_StartSound(0 as *const libc::c_void, sfx_zoom);
    COM_BufAddTextEx(
        va(
            b"exec \"%s%s\"\0" as *const u8 as *const libc::c_char,
            menupath.as_mut_ptr(),
            (*dirmenu.offset(dir_on[menudepthleft as usize] as isize))
                .offset(DIR_STRING as libc::c_int as isize),
        ),
        0 as com_flags_t,
    );
}
unsafe extern "C" fn M_ChangeStringAddons(mut choice: int32_t) -> boolean {
    if shiftdown as libc::c_int != 0 && choice >= 32 as libc::c_int
        && choice <= 127 as libc::c_int
    {
        choice = *shiftxform.offset(choice as isize) as int32_t;
    }
    match choice {
        241 => {
            if menusearch[0 as libc::c_int as usize] != 0 {
                menusearch[1 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
                menusearch[0 as libc::c_int
                    as usize] = menusearch[1 as libc::c_int as usize];
                return true_0 as libc::c_int;
            }
        }
        8 => {
            if menusearch[0 as libc::c_int as usize] != 0 {
                menusearch[0 as libc::c_int as usize] -= 1;
                menusearch[(1 as libc::c_int
                    + menusearch[0 as libc::c_int as usize] as libc::c_int)
                    as usize] = 0 as libc::c_int as libc::c_char;
                return true_0 as libc::c_int;
            }
        }
        _ => {
            if choice >= 32 as libc::c_int && choice <= 127 as libc::c_int {
                if (menusearch[0 as libc::c_int as usize] as libc::c_int)
                    < 32 as libc::c_int - 1 as libc::c_int
                {
                    let fresh10 = menusearch[0 as libc::c_int as usize];
                    menusearch[0 as libc::c_int
                        as usize] = menusearch[0 as libc::c_int as usize] + 1;
                    menusearch[(1 as libc::c_int + fresh10 as libc::c_int)
                        as usize] = choice as libc::c_char;
                    menusearch[(1 as libc::c_int
                        + menusearch[0 as libc::c_int as usize] as libc::c_int)
                        as usize] = 0 as libc::c_int as libc::c_char;
                    return true_0 as libc::c_int;
                }
            }
        }
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn M_HandleAddons(mut choice: int32_t) {
    let mut exitmenu: boolean = false_0 as libc::c_int;
    if M_ChangeStringAddons(choice) != 0 {
        let mut tempname: *mut libc::c_char = 0 as *mut libc::c_char;
        if !dirmenu.is_null()
            && !(*dirmenu.offset(dir_on[menudepthleft as usize] as isize)).is_null()
        {
            tempname = Z_StrDup(
                (*dirmenu.offset(dir_on[menudepthleft as usize] as isize))
                    .offset(DIR_STRING as libc::c_int as isize),
            );
        }
        searchfilemenu(tempname);
    }
    match choice {
        238 => {
            if dir_on[menudepthleft as usize]
                < sizedirmenu.wrapping_sub(1 as libc::c_int as size_t)
            {
                dir_on[menudepthleft
                    as usize] = (dir_on[menudepthleft as usize]).wrapping_add(1);
                dir_on[menudepthleft as usize];
            } else if dir_on[menudepthleft as usize]
                == sizedirmenu.wrapping_sub(1 as libc::c_int as size_t)
            {
                dir_on[menudepthleft as usize] = 0 as libc::c_int as size_t;
            }
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
        }
        230 => {
            if dir_on[menudepthleft as usize] != 0 {
                dir_on[menudepthleft
                    as usize] = (dir_on[menudepthleft as usize]).wrapping_sub(1);
                dir_on[menudepthleft as usize];
            } else if dir_on[menudepthleft as usize] == 0 {
                dir_on[menudepthleft
                    as usize] = sizedirmenu.wrapping_sub(1 as libc::c_int as size_t);
            }
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
        }
        239 => {
            let mut i: uint8_t = 0;
            i = 4 as libc::c_int as uint8_t;
            while i as libc::c_int != 0
                && dir_on[menudepthleft as usize]
                    < sizedirmenu.wrapping_sub(1 as libc::c_int as size_t)
            {
                dir_on[menudepthleft
                    as usize] = (dir_on[menudepthleft as usize]).wrapping_add(1);
                dir_on[menudepthleft as usize];
                i = i.wrapping_sub(1);
                i;
            }
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
        }
        231 => {
            let mut i_0: uint8_t = 0;
            i_0 = 4 as libc::c_int as uint8_t;
            while i_0 as libc::c_int != 0 && dir_on[menudepthleft as usize] != 0 {
                dir_on[menudepthleft
                    as usize] = (dir_on[menudepthleft as usize]).wrapping_sub(1);
                dir_on[menudepthleft as usize];
                i_0 = i_0.wrapping_sub(1);
                i_0;
            }
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
        }
        13 => {
            let mut refresh: boolean = true_0 as libc::c_int;
            if (*dirmenu.offset(dir_on[menudepthleft as usize] as isize)).is_null() {
                S_StartSound(0 as *const libc::c_void, sfx_lose);
            } else {
                match *(*dirmenu.offset(dir_on[menudepthleft as usize] as isize))
                    .offset(DIR_TYPE as libc::c_int as isize) as libc::c_int
                {
                    0 => {
                        strcpy(
                            &mut *menupath
                                .as_mut_ptr()
                                .offset(
                                    *menupathindex.as_mut_ptr().offset(menudepthleft as isize)
                                        as isize,
                                ),
                            (*dirmenu.offset(dir_on[menudepthleft as usize] as isize))
                                .offset(DIR_STRING as libc::c_int as isize),
                        );
                        if menudepthleft != 0 {
                            menudepthleft = menudepthleft.wrapping_sub(1);
                            menupathindex[menudepthleft
                                as usize] = strlen(menupath.as_mut_ptr());
                            menupath[menupathindex[menudepthleft as usize]
                                as usize] = 0 as libc::c_int as libc::c_char;
                            if preparefilemenu(false_0 as libc::c_int) == 0 {
                                S_StartSound(0 as *const libc::c_void, sfx_skid);
                                M_StartMessage(
                                    va(
                                        b"%c%s\x80\nThis folder is empty.\n\n(Press a key)\n\0"
                                            as *const u8 as *const libc::c_char,
                                        -128i32 + (highlightflags >> 12 as libc::c_int),
                                        M_AddonsHeaderPath(),
                                    ),
                                    0 as *mut libc::c_void,
                                    MM_NOTHING,
                                );
                                menudepthleft = menudepthleft.wrapping_add(1);
                                menupath[menupathindex[menudepthleft as usize]
                                    as usize] = 0 as libc::c_int as libc::c_char;
                                if preparefilemenu(true_0 as libc::c_int) == 0 {
                                    S_StartSound(0 as *const libc::c_void, sfx_lose);
                                    M_SetupNextMenu(MISC_AddonsDef.prevMenu);
                                    M_StartMessage(
                                        va(
                                            b"\x82%s\x80\nThis folder no longer exists!\nAborting to main menu.\n\n(Press a key)\n\0"
                                                as *const u8 as *const libc::c_char,
                                            M_AddonsHeaderPath(),
                                        ),
                                        0 as *mut libc::c_void,
                                        MM_NOTHING,
                                    );
                                    return;
                                }
                            } else {
                                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                                dir_on[menudepthleft as usize] = 1 as libc::c_int as size_t;
                            }
                            refresh = false_0 as libc::c_int;
                        } else {
                            S_StartSound(0 as *const libc::c_void, sfx_lose);
                            M_StartMessage(
                                va(
                                    b"%c%s\x80\nThis folder is too deep to navigate to!\n\n(Press a key)\n\0"
                                        as *const u8 as *const libc::c_char,
                                    -128i32 + (highlightflags >> 12 as libc::c_int),
                                    M_AddonsHeaderPath(),
                                ),
                                0 as *mut libc::c_void,
                                MM_NOTHING,
                            );
                            menupath[menupathindex[menudepthleft as usize]
                                as usize] = 0 as libc::c_int as libc::c_char;
                        }
                    }
                    1 => {
                        S_StartSound(0 as *const libc::c_void, sfx_menu1);
                        menudepthleft = menudepthleft.wrapping_add(1);
                        menupath[menupathindex[menudepthleft as usize]
                            as usize] = 0 as libc::c_int as libc::c_char;
                        if preparefilemenu(false_0 as libc::c_int) == 0 {
                            S_StartSound(0 as *const libc::c_void, sfx_lose);
                            M_SetupNextMenu(MISC_AddonsDef.prevMenu);
                            M_StartMessage(
                                va(
                                    b"\x82%s\x80\nThis folder no longer exists!\nAborting to main menu.\n\n(Press a key)\n\0"
                                        as *const u8 as *const libc::c_char,
                                    M_AddonsHeaderPath(),
                                ),
                                0 as *mut libc::c_void,
                                MM_NOTHING,
                            );
                            return;
                        }
                    }
                    3 => {
                        M_StartMessage(
                            va(
                                b"%c%s\x80\nThis file may not be a console script.\nAttempt to run anyways? \n\n(Press 'Y' to confirm)\n\0"
                                    as *const u8 as *const libc::c_char,
                                -128i32 + (highlightflags >> 12 as libc::c_int),
                                (*dirmenu.offset(dir_on[menudepthleft as usize] as isize))
                                    .offset(DIR_STRING as libc::c_int as isize),
                            ),
                            ::core::mem::transmute::<
                                Option::<unsafe extern "C" fn(int32_t) -> ()>,
                                *mut libc::c_void,
                            >(Some(M_AddonExec as unsafe extern "C" fn(int32_t) -> ())),
                            MM_YESNO,
                        );
                    }
                    4 => {
                        M_AddonExec(13 as libc::c_int);
                    }
                    8 | 7 | 5 | 6 => {
                        COM_BufAddTextEx(
                            va(
                                b"addfile \"%s%s\"\0" as *const u8 as *const libc::c_char,
                                menupath.as_mut_ptr(),
                                (*dirmenu.offset(dir_on[menudepthleft as usize] as isize))
                                    .offset(DIR_STRING as libc::c_int as isize),
                            ),
                            0 as com_flags_t,
                        );
                    }
                    _ => {
                        S_StartSound(0 as *const libc::c_void, sfx_lose);
                    }
                }
            }
            if refresh != 0 {
                refreshdirmenu = (refreshdirmenu as libc::c_int
                    | REFRESHDIR_NORMAL as libc::c_int) as uint8_t;
            }
        }
        27 => {
            exitmenu = true_0 as libc::c_int;
        }
        _ => {}
    }
    if exitmenu != 0 {
        closefilemenu(true_0 as libc::c_int);
        MainMenu[secrets as libc::c_int as usize]
            .status = (if M_AnySecretUnlocked(clientGamedata) as libc::c_int != 0 {
            32 as libc::c_int | 0 as libc::c_int
        } else {
            1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
        }) as uint16_t;
        if !((*currentMenu).prevMenu).is_null() {
            M_SetupNextMenu((*currentMenu).prevMenu);
        } else {
            M_ClearMenus(true_0 as libc::c_int);
        }
    }
}
unsafe extern "C" fn M_PandorasBox(mut choice: int32_t) {
    if maptol & TOL_NIGHTS as libc::c_int as uint32_t != 0 {
        CV_StealthSetValue(
            &mut cv_dummyrings,
            if players[consoleplayer as usize].spheres as libc::c_int > 0 as libc::c_int
            {
                players[consoleplayer as usize].spheres as libc::c_int
            } else {
                0 as libc::c_int
            },
        );
    } else {
        CV_StealthSetValue(
            &mut cv_dummyrings,
            if players[consoleplayer as usize].rings as libc::c_int > 0 as libc::c_int {
                players[consoleplayer as usize].rings as libc::c_int
            } else {
                0 as libc::c_int
            },
        );
    }
    if players[consoleplayer as usize].lives as libc::c_int == 0x7f as libc::c_int {
        CV_StealthSet(
            &mut cv_dummylives,
            b"Infinite\0" as *const u8 as *const libc::c_char,
        );
    } else {
        CV_StealthSetValue(
            &mut cv_dummylives,
            if players[consoleplayer as usize].lives as libc::c_int > 1 as libc::c_int {
                players[consoleplayer as usize].lives as libc::c_int
            } else {
                1 as libc::c_int
            },
        );
    }
    CV_StealthSetValue(
        &mut cv_dummycontinues,
        players[consoleplayer as usize].continues as int32_t,
    );
    SR_PandorasBox[3 as libc::c_int as usize]
        .status = (if multiplayer == 0
        && (ultimatemode as libc::c_int != 0
            || useContinues as libc::c_int != 0 && marathonmode as u64 == 0
            || modeattacking == 0 && !(cursaveslot > 0 as libc::c_int))
    {
        32 as libc::c_int | 8 as libc::c_int
    } else {
        1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int)
    }) as uint16_t;
    SR_PandorasBox[6 as libc::c_int as usize]
        .status = (if players[consoleplayer as usize].charflags
        & SF_SUPER as libc::c_int as uint32_t != 0
    {
        1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int)
    } else {
        32 as libc::c_int | 0 as libc::c_int
    }) as uint16_t;
    SR_PandorasBox[7 as libc::c_int as usize]
        .status = (if emeralds as libc::c_int
        == 64 as libc::c_int * 2 as libc::c_int - 1 as libc::c_int
    {
        1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int)
    } else {
        32 as libc::c_int | 0 as libc::c_int
    }) as uint16_t;
    M_SetupNextMenu(&mut SR_PandoraDef);
}
unsafe extern "C" fn M_ExitPandorasBox() -> boolean {
    if cv_dummyrings.value
        != (if players[consoleplayer as usize].rings as libc::c_int > 0 as libc::c_int {
            players[consoleplayer as usize].rings as libc::c_int
        } else {
            0 as libc::c_int
        })
    {
        if maptol & TOL_NIGHTS as libc::c_int as uint32_t != 0 {
            COM_ImmedExecute(
                va(
                    b"setspheres %d\0" as *const u8 as *const libc::c_char,
                    cv_dummyrings.value,
                ),
            );
        } else {
            COM_ImmedExecute(
                va(
                    b"setrings %d\0" as *const u8 as *const libc::c_char,
                    cv_dummyrings.value,
                ),
            );
        }
    }
    if cv_dummylives.value != players[consoleplayer as usize].lives as libc::c_int {
        COM_ImmedExecute(
            va(b"setlives %d\0" as *const u8 as *const libc::c_char, cv_dummylives.value),
        );
    }
    if multiplayer == 0
        && (ultimatemode as libc::c_int != 0
            || useContinues as libc::c_int != 0 && marathonmode as u64 == 0
            || modeattacking == 0 && !(cursaveslot > 0 as libc::c_int))
        && cv_dummycontinues.value
            != players[consoleplayer as usize].continues as libc::c_int
    {
        COM_ImmedExecute(
            va(
                b"setcontinues %d\0" as *const u8 as *const libc::c_char,
                cv_dummycontinues.value,
            ),
        );
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn M_ChangeLevel(mut choice: int32_t) {
    let mut mapname: [libc::c_char; 6] = [0; 6];
    strlcpy(
        mapname.as_mut_ptr(),
        G_BuildMapName(cv_nextmap.value),
        ::core::mem::size_of::<[libc::c_char; 6]>() as libc::c_ulong,
    );
    strlwr(mapname.as_mut_ptr());
    mapname[5 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    M_ClearMenus(true_0 as libc::c_int);
    COM_BufAddTextEx(
        va(
            b"map %s -gametype \"%s\"\n\0" as *const u8 as *const libc::c_char,
            mapname.as_mut_ptr(),
            cv_newgametype.string,
        ),
        0 as com_flags_t,
    );
}
unsafe extern "C" fn M_ConfirmSpectate(mut choice: int32_t) {
    M_ClearMenus(true_0 as libc::c_int);
    COM_ImmedExecute(b"changeteam spectator\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn M_ConfirmEnterGame(mut choice: int32_t) {
    if cv_allowteamchange.value == 0 {
        M_StartMessage(
            b"The server is not allowing\nteam changes at this time.\nPress a key.\n\0"
                as *const u8 as *const libc::c_char,
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    }
    M_ClearMenus(true_0 as libc::c_int);
    COM_ImmedExecute(b"changeteam playing\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn M_ConfirmTeamScramble(mut choice: int32_t) {
    M_ClearMenus(true_0 as libc::c_int);
    match cv_dummyscramble.value {
        0 => {
            COM_ImmedExecute(b"teamscramble 1\0" as *const u8 as *const libc::c_char);
        }
        1 => {
            COM_ImmedExecute(b"teamscramble 2\0" as *const u8 as *const libc::c_char);
        }
        _ => {}
    };
}
unsafe extern "C" fn M_ConfirmTeamChange(mut choice: int32_t) {
    if cv_allowteamchange.value == 0 && cv_dummyteam.value != 0 {
        M_StartMessage(
            b"The server is not allowing\nteam changes at this time.\nPress a key.\n\0"
                as *const u8 as *const libc::c_char,
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    }
    M_ClearMenus(true_0 as libc::c_int);
    match cv_dummyteam.value {
        0 => {
            COM_ImmedExecute(
                b"changeteam spectator\0" as *const u8 as *const libc::c_char,
            );
        }
        1 => {
            COM_ImmedExecute(b"changeteam red\0" as *const u8 as *const libc::c_char);
        }
        2 => {
            COM_ImmedExecute(b"changeteam blue\0" as *const u8 as *const libc::c_char);
        }
        _ => {}
    };
}
unsafe extern "C" fn M_Options(mut choice: int32_t) {
    OP_MainMenu[5 as libc::c_int as usize]
        .status = (if Playing() != 0
        && !(server != 0 || IsPlayerAdmin(consoleplayer) != 0)
    {
        1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int)
    } else {
        32 as libc::c_int | 0 as libc::c_int
    }) as uint16_t;
    OP_DataOptionsMenu[2 as libc::c_int as usize]
        .status = (if Playing() != 0 {
        1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int)
    } else {
        32 as libc::c_int | 6 as libc::c_int
    }) as uint16_t;
    OP_MainDef.prevMenu = currentMenu;
    M_SetupNextMenu(&mut OP_MainDef);
}
unsafe extern "C" fn M_RetryResponse(mut ch: int32_t) {
    if ch != 'y' as i32 && ch != 13 as libc::c_int {
        return;
    }
    if netgame != 0 || multiplayer != 0 {
        return;
    }
    M_ClearMenus(true_0 as libc::c_int);
    G_SetRetryFlag();
}
unsafe extern "C" fn M_Retry(mut choice: int32_t) {
    if marathonmode as u64 != 0 {
        M_RetryResponse(13 as libc::c_int);
        return;
    }
    M_StartMessage(
        b"Retry this act from the last starpost?\n\n(Press 'Y' to confirm)\n\0"
            as *const u8 as *const libc::c_char,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(int32_t) -> ()>,
            *mut libc::c_void,
        >(Some(M_RetryResponse as unsafe extern "C" fn(int32_t) -> ())),
        MM_YESNO,
    );
}
unsafe extern "C" fn M_SelectableClearMenus(mut choice: int32_t) {
    M_ClearMenus(true_0 as libc::c_int);
}
unsafe extern "C" fn M_UltimateCheat(mut choice: int32_t) -> ! {
    LUA_HookBool(true_0 as libc::c_int, hook_GameQuit as libc::c_int);
    I_Quit();
}
unsafe extern "C" fn M_AllowSuper(mut choice: int32_t) {
    players[consoleplayer as usize].charflags |= SF_SUPER as libc::c_int as uint32_t;
    M_StartMessage(
        b"You are now capable of turning super.\nRemember to get all the emeralds!\n\0"
            as *const u8 as *const libc::c_char,
        0 as *mut libc::c_void,
        MM_NOTHING,
    );
    SR_PandorasBox[6 as libc::c_int as usize]
        .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    G_SetUsedCheats(false_0 as libc::c_int);
}
unsafe extern "C" fn M_GetAllEmeralds(mut choice: int32_t) {
    emeralds = (64 as libc::c_int * 2 as libc::c_int - 1 as libc::c_int) as uint16_t;
    M_StartMessage(
        b"You now have all 7 emeralds.\nUse them wisely.\nWith great power comes great ring drain.\n\0"
            as *const u8 as *const libc::c_char,
        0 as *mut libc::c_void,
        MM_NOTHING,
    );
    SR_PandorasBox[7 as libc::c_int as usize]
        .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    G_SetUsedCheats(false_0 as libc::c_int);
}
unsafe extern "C" fn M_DestroyRobotsResponse(mut ch: int32_t) {
    if ch != 'y' as i32 && ch != 13 as libc::c_int {
        return;
    }
    P_DestroyRobots();
    G_SetUsedCheats(false_0 as libc::c_int);
}
unsafe extern "C" fn M_DestroyRobots(mut choice: int32_t) {
    M_StartMessage(
        b"Do you want to destroy all\nrobots in the current level?\n\n(Press 'Y' to confirm)\n\0"
            as *const u8 as *const libc::c_char,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(int32_t) -> ()>,
            *mut libc::c_void,
        >(Some(M_DestroyRobotsResponse as unsafe extern "C" fn(int32_t) -> ())),
        MM_YESNO,
    );
}
unsafe extern "C" fn M_LevelSelectWarp(mut choice: int32_t) {
    if W_CheckNumForName(G_BuildMapName(cv_nextmap.value)) == 4294967295 as libc::c_uint
    {
        CONS_Alert(
            CONS_WARNING,
            b"Internal game map '%s' not found\n\0" as *const u8 as *const libc::c_char,
            G_BuildMapName(cv_nextmap.value),
        );
        return;
    }
    startmap = cv_nextmap.value as int16_t;
    fromlevelselect = true_0 as libc::c_int;
    if currentMenu == &mut SP_LevelSelectDef as *mut menu_t
        || currentMenu == &mut SP_PauseLevelSelectDef as *mut menu_t
    {
        if cursaveslot > 0 as libc::c_int {
            G_LoadGame(cursaveslot as uint32_t, startmap);
        } else {
            M_ClearMenus(true_0 as libc::c_int);
            G_DeferedInitNew(
                false_0 as libc::c_int,
                G_BuildMapName(startmap as int32_t),
                cv_skin.value,
                false_0 as libc::c_int,
                fromlevelselect,
            );
            COM_BufAddTextEx(
                b"dummyconsvar 1\n\0" as *const u8 as *const libc::c_char,
                0 as com_flags_t,
            );
            if !(levelselect.rows).is_null() {
                Z_Free(levelselect.rows as *mut libc::c_void);
            }
            levelselect.rows = 0 as *mut levelselectrow_t;
        }
    } else {
        cursaveslot = 0 as libc::c_int;
        M_SetupChoosePlayer(0 as libc::c_int);
    };
}
#[no_mangle]
pub static mut skyRoomMenuTranslations: [uint8_t; 80] = [0; 80];
static mut checklist_cangodown: boolean = 0;
unsafe extern "C" fn M_HandleChecklist(mut choice: int32_t) {
    let mut data: *mut gamedata_t = clientGamedata;
    let mut j: int32_t = 0;
    match choice {
        238 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            if check_on as libc::c_int != 80 as libc::c_int && checklist_cangodown != 0 {
                j = check_on as libc::c_int + 1 as libc::c_int;
                while j < 80 as libc::c_int {
                    if !(unlockables[j as usize].name[0 as libc::c_int as usize] == 0) {
                        if !(unlockables[j as usize].conditionset == 0) {
                            if !(unlockables[j as usize].conditionset as libc::c_int
                                > 128 as libc::c_int)
                            {
                                if !((*data).unlocked[j as usize] == 0
                                    && unlockables[j as usize].showconditionset as libc::c_int
                                        != 0
                                    && !(unlockables[j as usize].showconditionset as libc::c_int
                                        >= 128 as libc::c_int
                                        || (*data)
                                            .achieved[unlockables[j as usize].showconditionset as usize]
                                            != 0))
                                {
                                    if !(unlockables[j as usize].conditionset as libc::c_int
                                        == unlockables[check_on as usize].conditionset
                                            as libc::c_int)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    j += 1;
                    j;
                }
                if j != 80 as libc::c_int {
                    check_on = j as uint8_t;
                }
            }
            return;
        }
        230 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            if check_on != 0 {
                j = check_on as libc::c_int - 1 as libc::c_int;
                while j > -(1 as libc::c_int) {
                    if !(unlockables[j as usize].name[0 as libc::c_int as usize] == 0) {
                        if !(unlockables[j as usize].conditionset == 0) {
                            if !(unlockables[j as usize].conditionset as libc::c_int
                                > 128 as libc::c_int)
                            {
                                if !((*data).unlocked[j as usize] == 0
                                    && unlockables[j as usize].showconditionset as libc::c_int
                                        != 0
                                    && !(unlockables[j as usize].showconditionset as libc::c_int
                                        >= 128 as libc::c_int
                                        || (*data)
                                            .achieved[unlockables[j as usize].showconditionset as usize]
                                            != 0))
                                {
                                    if !(j != 0
                                        && unlockables[j as usize].conditionset as libc::c_int
                                            == unlockables[(j - 1 as libc::c_int) as usize].conditionset
                                                as libc::c_int)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    j -= 1;
                    j;
                }
                if j != -(1 as libc::c_int) {
                    check_on = j as uint8_t;
                }
            }
            return;
        }
        27 => {
            if !((*currentMenu).prevMenu).is_null() {
                M_SetupNextMenu((*currentMenu).prevMenu);
            } else {
                M_ClearMenus(true_0 as libc::c_int);
            }
            return;
        }
        _ => {}
    };
}
unsafe extern "C" fn M_DrawChecklist() {
    let mut data: *mut gamedata_t = clientGamedata;
    let mut emblemCount: int32_t = M_CountEmblems(data);
    let mut i: int32_t = check_on as int32_t;
    let mut j: int32_t = 0 as libc::c_int;
    let mut y: int32_t = (*currentMenu).y as int32_t;
    let mut emblems: int32_t = numemblems + numextraemblems;
    let mut condnum: uint32_t = 0;
    let mut previd: uint32_t = 0;
    let mut maxcond: uint32_t = 0;
    let mut cond: *mut condition_t = 0 as *mut condition_t;
    M_DrawMenuTitle();
    if emblems > 0 as libc::c_int {
        V_DrawString(
            42 as libc::c_int,
            20 as libc::c_int,
            if emblems == emblemCount {
                0x3000 as libc::c_int
            } else {
                0 as libc::c_int
            },
            va(b"%d/%d\0" as *const u8 as *const libc::c_char, emblemCount, emblems),
        );
        V_DrawStretchyFixedPatch(
            (28 as libc::c_int) << 16 as libc::c_int,
            (20 as libc::c_int) << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            W_CachePatchName(
                b"EMBLICON\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
    }
    if check_on != 0 {
        V_DrawString(
            10 as libc::c_int,
            y - skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1A\0" as *const u8 as *const libc::c_char,
        );
    }
    's_37: while i < 80 as libc::c_int {
        if unlockables[i as usize].name[0 as libc::c_int as usize] as libc::c_int
            == 0 as libc::c_int || unlockables[i as usize].conditionset == 0
            || unlockables[i as usize].conditionset as libc::c_int > 128 as libc::c_int
            || (*data).unlocked[i as usize] == 0
                && unlockables[i as usize].showconditionset as libc::c_int != 0
                && !(unlockables[i as usize].showconditionset as libc::c_int
                    >= 128 as libc::c_int
                    || (*data)
                        .achieved[unlockables[i as usize].showconditionset as usize]
                        != 0)
        {
            i += 1 as libc::c_int;
        } else {
            V_DrawString(
                (*currentMenu).x as int32_t,
                y,
                (if (*data).unlocked[i as usize] != 0 {
                    0x3000 as libc::c_int
                } else {
                    0x50000 as libc::c_int
                }) | 0x800000 as libc::c_int,
                if (*data).unlocked[i as usize] != 0
                    || unlockables[i as usize].nochecklist == 0
                {
                    (unlockables[i as usize].name).as_mut_ptr() as *const libc::c_char
                } else {
                    M_CreateSecretMenuOption((unlockables[i as usize].name).as_mut_ptr())
                },
            );
            j = i + 1 as libc::c_int;
            while j < 80 as libc::c_int {
                if !(unlockables[j as usize].name[0 as libc::c_int as usize]
                    as libc::c_int == 0 as libc::c_int
                    || unlockables[j as usize].conditionset == 0
                    || unlockables[j as usize].conditionset as libc::c_int
                        > 128 as libc::c_int)
                {
                    break;
                }
                j += 1;
                j;
            }
            if j != 80 as libc::c_int
                && unlockables[i as usize].conditionset as libc::c_int
                    == unlockables[j as usize].conditionset as libc::c_int
            {
                y += 8 as libc::c_int;
                if y - (*currentMenu).y as libc::c_int
                    > 72 as libc::c_int * 2 as libc::c_int
                {
                    break;
                }
            } else {
                maxcond = conditionSets[(unlockables[i as usize].conditionset
                        as libc::c_int - 1 as libc::c_int) as usize]
                    .numconditions;
                if maxcond != 0 {
                    cond = conditionSets[(unlockables[i as usize].conditionset
                            as libc::c_int - 1 as libc::c_int) as usize]
                        .condition;
                    previd = (*cond.offset(0 as libc::c_int as isize)).id;
                    y += 2 as libc::c_int;
                    if y - (*currentMenu).y as libc::c_int
                        > 72 as libc::c_int * 2 as libc::c_int
                    {
                        break;
                    }
                    if unlockables[i as usize].objective[0 as libc::c_int as usize]
                        as libc::c_int != '/' as i32
                    {
                        y += 16 as libc::c_int;
                        if y - (*currentMenu).y as libc::c_int
                            > 72 as libc::c_int * 2 as libc::c_int
                        {
                            break;
                        }
                        V_DrawString(
                            (*currentMenu).x as int32_t,
                            y - 8 as libc::c_int,
                            0x800000 as libc::c_int,
                            va(
                                b"\x1E %s\0" as *const u8 as *const libc::c_char,
                                (unlockables[i as usize].objective).as_mut_ptr(),
                            ),
                        );
                        y -= 8 as libc::c_int;
                    } else {
                        condnum = 0 as libc::c_int as uint32_t;
                        while condnum < maxcond {
                            let mut beat: *const libc::c_char = b"!\0" as *const u8
                                as *const libc::c_char;
                            if (*cond.offset(condnum as isize)).id != previd {
                                y += 8 as libc::c_int;
                                if y - (*currentMenu).y as libc::c_int
                                    > 72 as libc::c_int * 2 as libc::c_int
                                {
                                    break 's_37;
                                }
                                V_DrawString(
                                    (*currentMenu).x as libc::c_int + 4 as libc::c_int,
                                    y,
                                    0x2000 as libc::c_int,
                                    b"OR\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            y += 8 as libc::c_int;
                            if y - (*currentMenu).y as libc::c_int
                                > 72 as libc::c_int * 2 as libc::c_int
                            {
                                break 's_37;
                            }
                            match (*cond.offset(condnum as isize)).type_0 as libc::c_uint
                            {
                                0 => {
                                    let mut hours: uint32_t = G_TicsToHours(
                                        (*cond.offset(condnum as isize)).requirement as tic_t,
                                    ) as uint32_t;
                                    let mut minutes: uint32_t = G_TicsToMinutes(
                                        (*cond.offset(condnum as isize)).requirement as tic_t,
                                        false_0 as libc::c_int,
                                    ) as uint32_t;
                                    let mut seconds: uint32_t = G_TicsToSeconds(
                                        (*cond.offset(condnum as isize)).requirement as tic_t,
                                    ) as uint32_t;
                                    if hours != 0 {
                                        if minutes != 0 {
                                            beat = va(
                                                b"Play the game for %d hour%s %d minute%s\0" as *const u8
                                                    as *const libc::c_char,
                                                hours,
                                                if hours == 1 as libc::c_int as uint32_t {
                                                    b"\0" as *const u8 as *const libc::c_char
                                                } else {
                                                    b"s\0" as *const u8 as *const libc::c_char
                                                },
                                                minutes,
                                                if minutes == 1 as libc::c_int as uint32_t {
                                                    b"\0" as *const u8 as *const libc::c_char
                                                } else {
                                                    b"s\0" as *const u8 as *const libc::c_char
                                                },
                                            );
                                        } else {
                                            beat = va(
                                                b"Play the game for %d hour%s\0" as *const u8
                                                    as *const libc::c_char,
                                                hours,
                                                if hours == 1 as libc::c_int as uint32_t {
                                                    b"\0" as *const u8 as *const libc::c_char
                                                } else {
                                                    b"s\0" as *const u8 as *const libc::c_char
                                                },
                                            );
                                        }
                                    } else if minutes != 0 && seconds != 0 {
                                        beat = va(
                                            b"Play the game for %d minute%s %d second%s\0" as *const u8
                                                as *const libc::c_char,
                                            minutes,
                                            if minutes == 1 as libc::c_int as uint32_t {
                                                b"\0" as *const u8 as *const libc::c_char
                                            } else {
                                                b"s\0" as *const u8 as *const libc::c_char
                                            },
                                            seconds,
                                            if seconds == 1 as libc::c_int as uint32_t {
                                                b"\0" as *const u8 as *const libc::c_char
                                            } else {
                                                b"s\0" as *const u8 as *const libc::c_char
                                            },
                                        );
                                    } else if minutes != 0 {
                                        beat = va(
                                            b"Play the game for %d minute%s\0" as *const u8
                                                as *const libc::c_char,
                                            minutes,
                                            if minutes == 1 as libc::c_int as uint32_t {
                                                b"\0" as *const u8 as *const libc::c_char
                                            } else {
                                                b"s\0" as *const u8 as *const libc::c_char
                                            },
                                        );
                                    } else {
                                        beat = va(
                                            b"Play the game for %d second%s\0" as *const u8
                                                as *const libc::c_char,
                                            seconds,
                                            if seconds == 1 as libc::c_int as uint32_t {
                                                b"\0" as *const u8 as *const libc::c_char
                                            } else {
                                                b"s\0" as *const u8 as *const libc::c_char
                                            },
                                        );
                                    }
                                }
                                7 | 8 | 9 | 10 | 11 => {
                                    let mut title: *mut libc::c_char = G_BuildMapTitle(
                                        (*cond.offset(condnum as isize)).requirement,
                                    );
                                    if !title.is_null() {
                                        let mut level: *const libc::c_char = if M_MapLocked(
                                            (*cond.offset(condnum as isize)).requirement,
                                            data,
                                        ) as libc::c_int != 0
                                            || !((*mapheaderinfo[((*cond.offset(condnum as isize))
                                                .requirement - 1 as libc::c_int) as usize])
                                                .menuflags as libc::c_int & 16 as libc::c_int != 0
                                                || (*data)
                                                    .mapvisited[((*cond.offset(condnum as isize)).requirement
                                                    - 1 as libc::c_int) as usize] as libc::c_int
                                                    & 63 as libc::c_int != 0)
                                        {
                                            M_CreateSecretMenuOption(title)
                                        } else {
                                            title as *const libc::c_char
                                        };
                                        match (*cond.offset(condnum as isize)).type_0
                                            as libc::c_uint
                                        {
                                            7 => {
                                                beat = va(
                                                    b"Visit %s\0" as *const u8 as *const libc::c_char,
                                                    level,
                                                );
                                            }
                                            9 => {
                                                beat = va(
                                                    b"Beat %s with all emeralds\0" as *const u8
                                                        as *const libc::c_char,
                                                    level,
                                                );
                                            }
                                            10 => {
                                                beat = va(
                                                    b"Beat %s in Ultimate mode\0" as *const u8
                                                        as *const libc::c_char,
                                                    level,
                                                );
                                            }
                                            11 => {
                                                beat = va(
                                                    b"Get all rings in %s\0" as *const u8
                                                        as *const libc::c_char,
                                                    level,
                                                );
                                            }
                                            8 | _ => {
                                                beat = va(
                                                    b"Beat %s\0" as *const u8 as *const libc::c_char,
                                                    level,
                                                );
                                            }
                                        }
                                        Z_Free(title as *mut libc::c_void);
                                    }
                                }
                                12 | 13 | 14 => {
                                    let mut title_0: *mut libc::c_char = G_BuildMapTitle(
                                        (*cond.offset(condnum as isize)).extrainfo1 as int32_t,
                                    );
                                    if !title_0.is_null() {
                                        let mut level_0: *const libc::c_char = if M_MapLocked(
                                            (*cond.offset(condnum as isize)).extrainfo1 as int32_t,
                                            data,
                                        ) as libc::c_int != 0
                                            || !((*mapheaderinfo[((*cond.offset(condnum as isize))
                                                .extrainfo1 as libc::c_int - 1 as libc::c_int) as usize])
                                                .menuflags as libc::c_int & 16 as libc::c_int != 0
                                                || (*data)
                                                    .mapvisited[((*cond.offset(condnum as isize)).extrainfo1
                                                    as libc::c_int - 1 as libc::c_int) as usize] as libc::c_int
                                                    & 63 as libc::c_int != 0)
                                        {
                                            M_CreateSecretMenuOption(title_0)
                                        } else {
                                            title_0 as *const libc::c_char
                                        };
                                        match (*cond.offset(condnum as isize)).type_0
                                            as libc::c_uint
                                        {
                                            12 => {
                                                beat = va(
                                                    b"Get %d points in %s\0" as *const u8
                                                        as *const libc::c_char,
                                                    (*cond.offset(condnum as isize)).requirement,
                                                    level_0,
                                                );
                                            }
                                            13 => {
                                                beat = va(
                                                    b"Beat %s in %d:%02d.%02d\0" as *const u8
                                                        as *const libc::c_char,
                                                    level_0,
                                                    G_TicsToMinutes(
                                                        (*cond.offset(condnum as isize)).requirement as tic_t,
                                                        true_0 as libc::c_int,
                                                    ),
                                                    G_TicsToSeconds(
                                                        (*cond.offset(condnum as isize)).requirement as tic_t,
                                                    ),
                                                    G_TicsToCentiseconds(
                                                        (*cond.offset(condnum as isize)).requirement as tic_t,
                                                    ),
                                                );
                                            }
                                            14 => {
                                                beat = va(
                                                    b"Get %d rings in %s\0" as *const u8 as *const libc::c_char,
                                                    (*cond.offset(condnum as isize)).requirement,
                                                    level_0,
                                                );
                                            }
                                            _ => {}
                                        }
                                        Z_Free(title_0 as *mut libc::c_void);
                                    }
                                }
                                4 | 5 | 6 => {
                                    match (*cond.offset(condnum as isize)).type_0
                                        as libc::c_uint
                                    {
                                        4 => {
                                            beat = va(
                                                b"Get %d points over all maps\0" as *const u8
                                                    as *const libc::c_char,
                                                (*cond.offset(condnum as isize)).requirement,
                                            );
                                        }
                                        5 => {
                                            beat = va(
                                                b"Get a total time of less than %d:%02d.%02d\0" as *const u8
                                                    as *const libc::c_char,
                                                G_TicsToMinutes(
                                                    (*cond.offset(condnum as isize)).requirement as tic_t,
                                                    true_0 as libc::c_int,
                                                ),
                                                G_TicsToSeconds(
                                                    (*cond.offset(condnum as isize)).requirement as tic_t,
                                                ),
                                                G_TicsToCentiseconds(
                                                    (*cond.offset(condnum as isize)).requirement as tic_t,
                                                ),
                                            );
                                        }
                                        6 => {
                                            beat = va(
                                                b"Get %d rings over all maps\0" as *const u8
                                                    as *const libc::c_char,
                                                (*cond.offset(condnum as isize)).requirement,
                                            );
                                        }
                                        _ => {}
                                    }
                                }
                                1 | 2 => {
                                    let mut emeraldtext: *const libc::c_char = if (*cond
                                        .offset(condnum as isize))
                                        .type_0 as libc::c_uint
                                        == UC_ALLEMERALDS as libc::c_int as libc::c_uint
                                    {
                                        b" with all emeralds\0" as *const u8 as *const libc::c_char
                                    } else {
                                        b"\0" as *const u8 as *const libc::c_char
                                    };
                                    if (*cond.offset(condnum as isize)).requirement
                                        != 1 as libc::c_int
                                    {
                                        beat = va(
                                            b"Beat the game %d times%s\0" as *const u8
                                                as *const libc::c_char,
                                            (*cond.offset(condnum as isize)).requirement,
                                            emeraldtext,
                                        );
                                    } else {
                                        beat = va(
                                            b"Beat the game%s\0" as *const u8 as *const libc::c_char,
                                            emeraldtext,
                                        );
                                    }
                                }
                                19 => {
                                    beat = va(
                                        b"Collect %s%d emblems\0" as *const u8
                                            as *const libc::c_char,
                                        if numemblems + numextraemblems
                                            == (*cond.offset(condnum as isize)).requirement
                                        {
                                            b"all \0" as *const u8 as *const libc::c_char
                                        } else {
                                            b"\0" as *const u8 as *const libc::c_char
                                        },
                                        (*cond.offset(condnum as isize)).requirement,
                                    );
                                }
                                16 | 15 | 17 => {
                                    let mut title_1: *mut libc::c_char = G_BuildMapTitle(
                                        (*cond.offset(condnum as isize)).extrainfo1 as int32_t,
                                    );
                                    if !title_1.is_null() {
                                        let mut level_1: *const libc::c_char = if M_MapLocked(
                                            (*cond.offset(condnum as isize)).extrainfo1 as int32_t,
                                            data,
                                        ) as libc::c_int != 0
                                            || !((*mapheaderinfo[((*cond.offset(condnum as isize))
                                                .extrainfo1 as libc::c_int - 1 as libc::c_int) as usize])
                                                .menuflags as libc::c_int & 16 as libc::c_int != 0
                                                || (*data)
                                                    .mapvisited[((*cond.offset(condnum as isize)).extrainfo1
                                                    as libc::c_int - 1 as libc::c_int) as usize] as libc::c_int
                                                    & 63 as libc::c_int != 0)
                                        {
                                            M_CreateSecretMenuOption(title_1)
                                        } else {
                                            title_1 as *const libc::c_char
                                        };
                                        match (*cond.offset(condnum as isize)).type_0
                                            as libc::c_uint
                                        {
                                            15 => {
                                                if (*cond.offset(condnum as isize)).extrainfo2 != 0 {
                                                    beat = va(
                                                        b"Get %d points in %s, mare %d\0" as *const u8
                                                            as *const libc::c_char,
                                                        (*cond.offset(condnum as isize)).requirement,
                                                        level_1,
                                                        (*cond.offset(condnum as isize)).extrainfo2 as libc::c_int,
                                                    );
                                                } else {
                                                    beat = va(
                                                        b"Get %d points in %s\0" as *const u8
                                                            as *const libc::c_char,
                                                        (*cond.offset(condnum as isize)).requirement,
                                                        level_1,
                                                    );
                                                }
                                            }
                                            16 => {
                                                if (*cond.offset(condnum as isize)).extrainfo2 != 0 {
                                                    beat = va(
                                                        b"Beat %s, mare %d in %d:%02d.%02d\0" as *const u8
                                                            as *const libc::c_char,
                                                        level_1,
                                                        (*cond.offset(condnum as isize)).extrainfo2 as libc::c_int,
                                                        G_TicsToMinutes(
                                                            (*cond.offset(condnum as isize)).requirement as tic_t,
                                                            true_0 as libc::c_int,
                                                        ),
                                                        G_TicsToSeconds(
                                                            (*cond.offset(condnum as isize)).requirement as tic_t,
                                                        ),
                                                        G_TicsToCentiseconds(
                                                            (*cond.offset(condnum as isize)).requirement as tic_t,
                                                        ),
                                                    );
                                                } else {
                                                    beat = va(
                                                        b"Beat %s in %d:%02d.%02d\0" as *const u8
                                                            as *const libc::c_char,
                                                        level_1,
                                                        G_TicsToMinutes(
                                                            (*cond.offset(condnum as isize)).requirement as tic_t,
                                                            true_0 as libc::c_int,
                                                        ),
                                                        G_TicsToSeconds(
                                                            (*cond.offset(condnum as isize)).requirement as tic_t,
                                                        ),
                                                        G_TicsToCentiseconds(
                                                            (*cond.offset(condnum as isize)).requirement as tic_t,
                                                        ),
                                                    );
                                                }
                                            }
                                            17 => {
                                                let mut grade: libc::c_char = ('F' as i32
                                                    - (*cond.offset(condnum as isize)).requirement
                                                        as libc::c_char as libc::c_int) as libc::c_char;
                                                if (grade as libc::c_int) < 'A' as i32 {
                                                    grade = 'A' as i32 as libc::c_char;
                                                }
                                                if (*cond.offset(condnum as isize)).extrainfo2 != 0 {
                                                    beat = va(
                                                        b"Get grade %c in %s, mare %d\0" as *const u8
                                                            as *const libc::c_char,
                                                        grade as libc::c_int,
                                                        level_1,
                                                        (*cond.offset(condnum as isize)).extrainfo2 as libc::c_int,
                                                    );
                                                } else {
                                                    beat = va(
                                                        b"Get grade %c in %s\0" as *const u8 as *const libc::c_char,
                                                        grade as libc::c_int,
                                                        level_1,
                                                    );
                                                }
                                            }
                                            _ => {}
                                        }
                                        Z_Free(title_1 as *mut libc::c_void);
                                    }
                                }
                                18 | 20 | 22 | _ => {
                                    y -= 8 as libc::c_int;
                                }
                            }
                            if *beat.offset(0 as libc::c_int as isize) as libc::c_int
                                != '!' as i32
                            {
                                V_DrawString(
                                    (*currentMenu).x as int32_t,
                                    y,
                                    0 as libc::c_int,
                                    b"\x1E\0" as *const u8 as *const libc::c_char,
                                );
                                V_DrawString(
                                    (*currentMenu).x as libc::c_int + 12 as libc::c_int,
                                    y,
                                    0x800000 as libc::c_int,
                                    beat,
                                );
                            }
                            previd = (*cond.offset(condnum as isize)).id;
                            condnum = condnum.wrapping_add(1);
                            condnum;
                        }
                    }
                }
                y += 12 as libc::c_int;
                if y - (*currentMenu).y as libc::c_int
                    > 72 as libc::c_int * 2 as libc::c_int
                {
                    break;
                }
            }
            i = j;
        }
    }
    checklist_cangodown = (y - (*currentMenu).y as libc::c_int
        > 72 as libc::c_int * 2 as libc::c_int) as libc::c_int;
    if checklist_cangodown != 0 {
        V_DrawString(
            10 as libc::c_int,
            (*currentMenu).y as libc::c_int + 72 as libc::c_int * 2 as libc::c_int
                + skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1B\0" as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn M_EmblemHints(mut choice: int32_t) {
    let mut i: int32_t = 0;
    let mut local: uint32_t = 0 as libc::c_int as uint32_t;
    let mut emblem: *mut emblem_t = 0 as *mut emblem_t;
    i = 0 as libc::c_int;
    while i < numemblems {
        emblem = &mut *emblemlocations.as_mut_ptr().offset(i as isize) as *mut emblem_t;
        if !((*emblem).level as libc::c_int != gamemap as libc::c_int
            || (*emblem).type_0 as libc::c_int > 1 as libc::c_int)
        {
            local = local.wrapping_add(1);
            if local > (5 as libc::c_int * 2 as libc::c_int) as uint32_t {
                break;
            }
        }
        i += 1;
        i;
    }
    SR_EmblemHintMenu[0 as libc::c_int as usize]
        .status = (if local > (5 as libc::c_int * 2 as libc::c_int) as uint32_t {
        32 as libc::c_int | 2 as libc::c_int
    } else {
        1 as libc::c_int + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
    }) as uint16_t;
    SR_EmblemHintMenu[1 as libc::c_int as usize]
        .status = (if M_SecretUnlocked(-(5 as libc::c_int), clientGamedata)
        as libc::c_int != 0
    {
        8 as libc::c_int | 32 as libc::c_int
    } else {
        1 as libc::c_int + (64 as libc::c_int + 128 as libc::c_int)
    }) as uint16_t;
    hintpage = 1 as libc::c_int as uint32_t;
    SR_EmblemHintDef.prevMenu = currentMenu;
    M_SetupNextMenu(&mut SR_EmblemHintDef);
    itemOn = 2 as libc::c_int as int16_t;
}
unsafe extern "C" fn M_DrawEmblemHints() {
    let mut i: int32_t = 0;
    let mut j: int32_t = 0 as libc::c_int;
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut left_hints: int32_t = 5 as libc::c_int;
    let mut pageflag: int32_t = 0 as libc::c_int;
    let mut collected: uint32_t = 0 as libc::c_int as uint32_t;
    let mut totalemblems: uint32_t = 0 as libc::c_int as uint32_t;
    let mut local: uint32_t = 0 as libc::c_int as uint32_t;
    let mut emblem: *mut emblem_t = 0 as *mut emblem_t;
    let mut hint: *const libc::c_char = 0 as *const libc::c_char;
    i = 0 as libc::c_int;
    while i < numemblems {
        emblem = &mut *emblemlocations.as_mut_ptr().offset(i as isize) as *mut emblem_t;
        if !((*emblem).level as libc::c_int != gamemap as libc::c_int
            || (*emblem).type_0 as libc::c_int > 1 as libc::c_int)
        {
            local = local.wrapping_add(1);
            local;
        }
        i += 1;
        i;
    }
    x = if local > 5 as libc::c_int as uint32_t {
        4 as libc::c_int
    } else {
        12 as libc::c_int
    };
    y = 8 as libc::c_int;
    if local > 5 as libc::c_int as uint32_t {
        if local
            > hintpage.wrapping_sub(1 as libc::c_int as uint32_t)
                * 5 as libc::c_int as uint32_t * 2 as libc::c_int as uint32_t
            && local
                < hintpage * 5 as libc::c_int as uint32_t * 2 as libc::c_int as uint32_t
        {
            if 5 as libc::c_int % 2 as libc::c_int == 1 as libc::c_int {
                left_hints = (local
                    .wrapping_sub(
                        hintpage.wrapping_sub(1 as libc::c_int as uint32_t)
                            * 5 as libc::c_int as uint32_t * 2 as libc::c_int as uint32_t,
                    )
                    .wrapping_add(1 as libc::c_int as uint32_t)
                    / 2 as libc::c_int as uint32_t) as int32_t;
            } else {
                left_hints = (local
                    .wrapping_sub(
                        hintpage.wrapping_sub(1 as libc::c_int as uint32_t)
                            * 5 as libc::c_int as uint32_t * 2 as libc::c_int as uint32_t,
                    ) / 2 as libc::c_int as uint32_t) as int32_t;
            }
        } else {
            left_hints = 5 as libc::c_int;
        }
    }
    if local > (5 as libc::c_int * 2 as libc::c_int) as uint32_t {
        if itemOn as libc::c_int == 0 as libc::c_int {
            pageflag = 0x2000 as libc::c_int;
        }
        V_DrawString(
            (*currentMenu).x as libc::c_int + 40 as libc::c_int,
            (*currentMenu).y as libc::c_int + 10 as libc::c_int,
            pageflag,
            va(
                b"%d of %d\0" as *const u8 as *const libc::c_char,
                hintpage,
                (local / (5 as libc::c_int * 2 as libc::c_int) as uint32_t)
                    .wrapping_add(1 as libc::c_int as uint32_t),
            ),
        );
    }
    if local == 0 {
        V_DrawCenteredString(
            160 as libc::c_int,
            48 as libc::c_int,
            0x2000 as libc::c_int,
            b"No hidden emblems on this map.\0" as *const u8 as *const libc::c_char,
        );
    } else {
        i = 0 as libc::c_int;
        while i < numemblems {
            emblem = &mut *emblemlocations.as_mut_ptr().offset(i as isize)
                as *mut emblem_t;
            if !((*emblem).level as libc::c_int != gamemap as libc::c_int
                || (*emblem).type_0 as libc::c_int > 1 as libc::c_int)
            {
                totalemblems = totalemblems.wrapping_add(1);
                totalemblems;
                if totalemblems
                    >= (hintpage.wrapping_sub(1 as libc::c_int as uint32_t)
                        * (5 as libc::c_int * 2 as libc::c_int) as uint32_t)
                        .wrapping_add(1 as libc::c_int as uint32_t)
                    && totalemblems
                        < (hintpage * 5 as libc::c_int as uint32_t
                            * 2 as libc::c_int as uint32_t)
                            .wrapping_add(1 as libc::c_int as uint32_t)
                {
                    if (*clientGamedata).collected[i as usize] != 0 {
                        collected = 0x3000 as libc::c_int as uint32_t;
                        V_DrawStretchyFixedPatch(
                            x << 16 as libc::c_int,
                            (y + 4 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            0 as libc::c_int,
                            W_CachePatchName(
                                M_GetEmblemPatch(emblem, false_0 as libc::c_int),
                                PU_PATCH as libc::c_int,
                            ) as *mut patch_t,
                            R_GetTranslationColormap(
                                TC_DEFAULT as libc::c_int,
                                M_GetEmblemColor(emblem),
                                1 as libc::c_int as uint8_t,
                            ),
                        );
                    } else {
                        collected = 0 as libc::c_int as uint32_t;
                        V_DrawStretchyFixedPatch(
                            x * ((1 as libc::c_int) << 16 as libc::c_int),
                            (y + 4 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            0 as libc::c_int,
                            W_CachePatchName(
                                b"NEEDIT\0" as *const u8 as *const libc::c_char,
                                PU_PATCH as libc::c_int,
                            ) as *mut patch_t,
                            0 as *const uint8_t,
                        );
                    }
                    if (*emblem).hint[0 as libc::c_int as usize] != 0 {
                        hint = ((*emblem).hint).as_mut_ptr();
                    } else {
                        hint = b"No hint available for this emblem.\0" as *const u8
                            as *const libc::c_char;
                    }
                    hint = V_WordWrap(
                        40 as libc::c_int,
                        320 as libc::c_int - 12 as libc::c_int,
                        0 as libc::c_int,
                        hint,
                    );
                    if local > 5 as libc::c_int as uint32_t {
                        V_DrawThinString(
                            x + 28 as libc::c_int,
                            y,
                            ((0x20000000 as libc::c_int | 0x800000 as libc::c_int)
                                as uint32_t | collected) as int32_t,
                            hint,
                        );
                    } else {
                        V_DrawString(
                            x + 28 as libc::c_int,
                            y,
                            ((0x20000000 as libc::c_int | 0x800000 as libc::c_int)
                                as uint32_t | collected) as int32_t,
                            hint,
                        );
                    }
                    y += 28 as libc::c_int;
                    j += 1;
                    if j == left_hints {
                        x = 4 as libc::c_int + 320 as libc::c_int / 2 as libc::c_int;
                        y = 8 as libc::c_int;
                    } else if j >= 5 as libc::c_int * 2 as libc::c_int {
                        break;
                    }
                }
            }
            i += 1;
            i;
        }
    }
    M_DrawGenericMenu();
}
unsafe extern "C" fn M_HandleEmblemHints(mut choice: int32_t) {
    let mut i: int32_t = 0;
    let mut emblem: *mut emblem_t = 0 as *mut emblem_t;
    let mut stageemblems: uint32_t = 0 as libc::c_int as uint32_t;
    i = 0 as libc::c_int;
    while i < numemblems {
        emblem = &mut *emblemlocations.as_mut_ptr().offset(i as isize) as *mut emblem_t;
        if !((*emblem).level as libc::c_int != gamemap as libc::c_int
            || (*emblem).type_0 as libc::c_int > 1 as libc::c_int)
        {
            stageemblems = stageemblems.wrapping_add(1);
            stageemblems;
        }
        i += 1;
        i;
    }
    if choice == 0 as libc::c_int {
        if hintpage > 1 as libc::c_int as uint32_t {
            hintpage = hintpage.wrapping_sub(1);
            hintpage;
        }
    } else if hintpage
        < (stageemblems.wrapping_sub(1 as libc::c_int as uint32_t)
            / (5 as libc::c_int * 2 as libc::c_int) as uint32_t)
            .wrapping_add(1 as libc::c_int as uint32_t)
    {
        hintpage = hintpage.wrapping_add(1);
        hintpage;
    }
}
unsafe extern "C" fn M_PauseLevelSelect(mut choice: int32_t) {
    SP_PauseLevelSelectDef.prevMenu = currentMenu;
    levellistmode = LLM_LEVELSELECT;
    if M_PrepareLevelPlatter(-(1 as libc::c_int), true_0 as libc::c_int) == 0 {
        M_StartMessage(
            b"No selectable levels found.\n\0" as *const u8 as *const libc::c_char,
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    }
    M_SetupNextMenu(&mut SP_PauseLevelSelectDef);
}
static mut curplaying: *mut musicdef_t = 0 as *const musicdef_t as *mut musicdef_t;
static mut st_sel: int32_t = 0 as libc::c_int;
static mut st_cc: int32_t = 0 as libc::c_int;
static mut st_time: fixed_t = 0 as libc::c_int;
static mut st_radio: [*mut patch_t; 9] = [0 as *const patch_t as *mut patch_t; 9];
static mut st_launchpad: [*mut patch_t; 4] = [0 as *const patch_t as *mut patch_t; 4];
unsafe extern "C" fn M_CacheSoundTest() {
    let mut i: uint8_t = 0;
    let mut buf: [libc::c_char; 8] = [0; 8];
    strlcpy(
        buf.as_mut_ptr(),
        b"M_RADIOn\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong,
    );
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 9 as libc::c_int {
        buf[7 as libc::c_int as usize] = ('0' as i32 + i as libc::c_int) as libc::c_char;
        st_radio[i
            as usize] = W_CachePatchName(buf.as_mut_ptr(), PU_PATCH as libc::c_int)
            as *mut patch_t;
        i = i.wrapping_add(1);
        i;
    }
    strlcpy(
        buf.as_mut_ptr(),
        b"M_LPADn\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<[libc::c_char; 8]>() as libc::c_ulong,
    );
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 4 as libc::c_int {
        buf[6 as libc::c_int as usize] = ('0' as i32 + i as libc::c_int) as libc::c_char;
        st_launchpad[i
            as usize] = W_CachePatchName(buf.as_mut_ptr(), PU_PATCH as libc::c_int)
            as *mut patch_t;
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn M_SoundTest(mut choice: int32_t) {
    let mut ul: int32_t = skyRoomMenuTranslations[(choice - 1 as libc::c_int) as usize]
        as int32_t;
    soundtestpage = unlockables[ul as usize].variable as uint8_t;
    if soundtestpage == 0 {
        soundtestpage = 1 as libc::c_int as uint8_t;
    }
    if S_PrepareSoundTest() == 0 {
        M_StartMessage(
            b"No selectable tracks found.\n\0" as *const u8 as *const libc::c_char,
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    }
    M_CacheSoundTest();
    curplaying = 0 as *mut musicdef_t;
    st_time = 0 as libc::c_int;
    st_sel = 0 as libc::c_int;
    st_cc = cv_closedcaptioning.value;
    cv_closedcaptioning.value = 1 as libc::c_int;
    M_SetupNextMenu(&mut SR_SoundTestDef);
}
unsafe extern "C" fn M_DrawSoundTest() {
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut i: int32_t = 0;
    let mut hscale: fixed_t = ((1 as libc::c_int) << 16 as libc::c_int)
        / 2 as libc::c_int;
    let mut vscale: fixed_t = ((1 as libc::c_int) << 16 as libc::c_int)
        / 2 as libc::c_int;
    let mut bounce: fixed_t = 0 as libc::c_int;
    let mut frame: [uint8_t; 4] = [
        0 as libc::c_int as uint8_t,
        0 as libc::c_int as uint8_t,
        -(1 as libc::c_int) as uint8_t,
        SKINCOLOR_RUBY as libc::c_int as uint8_t,
    ];
    if !curplaying.is_null() {
        if curplaying == &mut soundtestsfx as *mut musicdef_t {
            if cv_soundtest.value != 0 {
                frame[1 as libc::c_int
                    as usize] = (2 as libc::c_int - (st_time >> 16 as libc::c_int))
                    as uint8_t;
                frame[2 as libc::c_int
                    as usize] = ((cv_soundtest.value - 1 as libc::c_int)
                    % 9 as libc::c_int) as uint8_t;
                frame[3 as libc::c_int
                    as usize] = (frame[3 as libc::c_int as usize] as libc::c_int
                    + (cv_soundtest.value - 1 as libc::c_int) / 9 as libc::c_int
                        % (FIRSTSUPERCOLOR as libc::c_int
                            - frame[3 as libc::c_int as usize] as libc::c_int))
                    as uint8_t;
                if st_time < (2 as libc::c_int) << 16 as libc::c_int {
                    st_time += renderdeltatics;
                }
                if st_time >= (2 as libc::c_int) << 16 as libc::c_int {
                    st_time = (2 as libc::c_int) << 16 as libc::c_int;
                }
            }
        } else {
            let mut stoppingtics: fixed_t = ((*curplaying).stoppingtics as fixed_t)
                << 16 as libc::c_int;
            if stoppingtics != 0 && st_time >= stoppingtics {
                curplaying = 0 as *mut musicdef_t;
                st_time = 0 as libc::c_int;
            } else {
                let mut work: fixed_t = 0;
                let mut bpm: fixed_t = (*curplaying).bpm;
                let mut ang: angle_t = 0;
                work = st_time;
                work %= bpm;
                if st_time
                    >= ((1 as libc::c_int) << 16 as libc::c_int)
                        << 16 as libc::c_int - 2 as libc::c_int
                {
                    st_time = work;
                }
                work = FixedDiv(work * 180 as libc::c_int, bpm);
                frame[0 as libc::c_int
                    as usize] = (8 as libc::c_int
                    - work / ((20 as libc::c_int) << 16 as libc::c_int)) as uint8_t;
                if frame[0 as libc::c_int as usize] as libc::c_int > 8 as libc::c_int {
                    frame[0 as libc::c_int as usize] = 0 as libc::c_int as uint8_t;
                }
                ang = FixedAngle(work) >> 19 as libc::c_int
                    & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
                bounce = (finesine[ang as usize]
                    >> 16 as libc::c_int - 16 as libc::c_int)
                    - ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int;
                hscale -= bounce / 16 as libc::c_int;
                vscale += bounce / 16 as libc::c_int;
                st_time += renderdeltatics;
            }
        }
    }
    x = (90 as libc::c_int) << 16 as libc::c_int;
    y = (200 as libc::c_int - 32 as libc::c_int) << 16 as libc::c_int;
    V_DrawStretchyFixedPatch(
        x,
        y,
        hscale,
        vscale,
        0 as libc::c_int,
        st_radio[frame[0 as libc::c_int as usize] as usize],
        0 as *const uint8_t,
    );
    V_DrawStretchyFixedPatch(
        x,
        y,
        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
        0 as libc::c_int,
        st_launchpad[0 as libc::c_int as usize],
        0 as *const uint8_t,
    );
    i = 0 as libc::c_int;
    while i < 9 as libc::c_int {
        if i == frame[2 as libc::c_int as usize] as libc::c_int {
            let mut colmap: *mut uint8_t = R_GetTranslationColormap(
                TC_RAINBOW as libc::c_int,
                frame[3 as libc::c_int as usize] as skincolornum_t,
                1 as libc::c_int as uint8_t,
            );
            V_DrawStretchyFixedPatch(
                x,
                y
                    + ((frame[1 as libc::c_int as usize] as libc::c_int)
                        << 16 as libc::c_int),
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0 as libc::c_int,
                st_launchpad[(frame[1 as libc::c_int as usize] as libc::c_int
                    + 1 as libc::c_int) as usize],
                colmap,
            );
        } else {
            V_DrawStretchyFixedPatch(
                x,
                y,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0 as libc::c_int,
                st_launchpad[1 as libc::c_int as usize],
                0 as *const uint8_t,
            );
        }
        if i % 3 as libc::c_int == 2 as libc::c_int {
            x
                -= (2 as libc::c_int * 28 as libc::c_int + 25 as libc::c_int)
                    << 16 as libc::c_int - 1 as libc::c_int;
            y
                -= (2 as libc::c_int * 7 as libc::c_int - 11 as libc::c_int)
                    << 16 as libc::c_int - 1 as libc::c_int;
        } else {
            x += (28 as libc::c_int) << 16 as libc::c_int - 1 as libc::c_int;
            y += (7 as libc::c_int) << 16 as libc::c_int - 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    y = (320 as libc::c_int - vid.width / vid.dupx) / 2 as libc::c_int;
    V_DrawFill(
        y,
        20 as libc::c_int,
        vid.width / vid.dupx,
        24 as libc::c_int,
        159 as libc::c_int,
    );
    static mut st_scroll: fixed_t = -((1 as libc::c_int) << 16 as libc::c_int);
    let mut titl: *const libc::c_char = 0 as *const libc::c_char;
    x = 16 as libc::c_int;
    V_DrawString(
        x,
        10 as libc::c_int,
        0 as libc::c_int,
        b"NOW PLAYING:\0" as *const u8 as *const libc::c_char,
    );
    if !curplaying.is_null() {
        if (*curplaying).alttitle[0 as libc::c_int as usize] != 0 {
            titl = va(
                b"%s - %s - \0" as *const u8 as *const libc::c_char,
                ((*curplaying).title).as_mut_ptr(),
                ((*curplaying).alttitle).as_mut_ptr(),
            );
        } else {
            titl = va(
                b"%s - \0" as *const u8 as *const libc::c_char,
                ((*curplaying).title).as_mut_ptr(),
            );
        }
    } else {
        titl = b"None - \0" as *const u8 as *const libc::c_char;
    }
    i = V_LevelNameWidth(titl);
    st_scroll += renderdeltatics;
    while st_scroll >= i << 16 as libc::c_int {
        st_scroll -= i << 16 as libc::c_int;
    }
    x -= st_scroll >> 16 as libc::c_int;
    while x < 320 as libc::c_int - y {
        x += i;
    }
    while x > y {
        x -= i;
        V_DrawLevelTitle(x, 22 as libc::c_int, 0 as libc::c_int, titl);
    }
    if !curplaying.is_null() {
        V_DrawRightAlignedThinString(
            320 as libc::c_int - 16 as libc::c_int,
            46 as libc::c_int,
            0x800000 as libc::c_int,
            ((*curplaying).authors).as_mut_ptr(),
        );
    }
    V_DrawFill(
        165 as libc::c_int,
        60 as libc::c_int,
        140 as libc::c_int,
        112 as libc::c_int,
        159 as libc::c_int,
    );
    let mut t: int32_t = 0;
    let mut b: int32_t = 0;
    let mut q: int32_t = 0;
    let mut m: int32_t = 112 as libc::c_int;
    if numsoundtestdefs <= 7 as libc::c_int {
        t = 0 as libc::c_int;
        b = numsoundtestdefs - 1 as libc::c_int;
        i = 0 as libc::c_int;
    } else {
        q = m;
        m = 5 as libc::c_int * m / numsoundtestdefs;
        if st_sel < 3 as libc::c_int {
            t = 0 as libc::c_int;
            b = 6 as libc::c_int;
            i = 0 as libc::c_int;
        } else if st_sel >= numsoundtestdefs - 4 as libc::c_int {
            t = numsoundtestdefs - 7 as libc::c_int;
            b = numsoundtestdefs - 1 as libc::c_int;
            i = q - m;
        } else {
            t = st_sel - 3 as libc::c_int;
            b = st_sel + 3 as libc::c_int;
            i = t * (q - m) / (numsoundtestdefs - 7 as libc::c_int);
        }
    }
    V_DrawFill(
        165 as libc::c_int + 140 as libc::c_int - 1 as libc::c_int,
        60 as libc::c_int + i,
        1 as libc::c_int,
        m,
        0 as libc::c_int,
    );
    if t != 0 as libc::c_int {
        V_DrawString(
            165 as libc::c_int + 140 as libc::c_int + 4 as libc::c_int,
            60 as libc::c_int + 4 as libc::c_int
                - skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1A\0" as *const u8 as *const libc::c_char,
        );
    }
    if b != numsoundtestdefs - 1 as libc::c_int {
        V_DrawString(
            165 as libc::c_int + 140 as libc::c_int + 4 as libc::c_int,
            60 as libc::c_int + 112 as libc::c_int - 12 as libc::c_int
                + skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1B\0" as *const u8 as *const libc::c_char,
        );
    }
    x = 169 as libc::c_int;
    y = 64 as libc::c_int;
    while t <= b {
        if t == st_sel {
            V_DrawFill(
                165 as libc::c_int,
                y - 4 as libc::c_int,
                140 as libc::c_int - 1 as libc::c_int,
                16 as libc::c_int,
                155 as libc::c_int,
            );
        }
        if (**soundtestdefs.offset(t as isize)).allowed == 0 {
            V_DrawString(
                x,
                y,
                (if t == st_sel { 0x2000 as libc::c_int } else { 0 as libc::c_int })
                    | 0x800000 as libc::c_int,
                b"???\0" as *const u8 as *const libc::c_char,
            );
        } else if *soundtestdefs.offset(t as isize)
            == &mut soundtestsfx as *mut musicdef_t
        {
            let mut sfxstr: *const libc::c_char = va(
                b"SFX %s\0" as *const u8 as *const libc::c_char,
                cv_soundtest.string,
            );
            V_DrawString(
                x,
                y,
                if t == st_sel { 0x2000 as libc::c_int } else { 0 as libc::c_int },
                sfxstr,
            );
            if t == st_sel {
                V_DrawCharacter(
                    x - 10 as libc::c_int
                        - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                    y,
                    '\u{1c}' as i32 | 0x2000 as libc::c_int,
                    false_0 as libc::c_int,
                );
                V_DrawCharacter(
                    x + 2 as libc::c_int + V_StringWidth(sfxstr, 0 as libc::c_int)
                        + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                    y,
                    '\u{1d}' as i32 | 0x2000 as libc::c_int,
                    false_0 as libc::c_int,
                );
            }
            if curplaying == *soundtestdefs.offset(t as isize) {
                sfxstr = if cv_soundtest.value != 0 {
                    (*S_sfx.as_mut_ptr().offset(cv_soundtest.value as isize)).name
                } else {
                    b"N/A\0" as *const u8 as *const libc::c_char
                };
                i = V_StringWidth(sfxstr, 0 as libc::c_int);
                V_DrawFill(
                    165 as libc::c_int + 140 as libc::c_int - 9 as libc::c_int - i,
                    y - 4 as libc::c_int,
                    i + 8 as libc::c_int,
                    16 as libc::c_int,
                    150 as libc::c_int,
                );
                V_DrawRightAlignedString(
                    165 as libc::c_int + 140 as libc::c_int - 5 as libc::c_int,
                    y,
                    0x2000 as libc::c_int,
                    sfxstr,
                );
            }
        } else {
            V_DrawString(
                x,
                y,
                (if t == st_sel { 0x2000 as libc::c_int } else { 0 as libc::c_int })
                    | 0x800000 as libc::c_int,
                ((**soundtestdefs.offset(t as isize)).title).as_mut_ptr(),
            );
            if curplaying == *soundtestdefs.offset(t as isize) {
                V_DrawFill(
                    165 as libc::c_int + 140 as libc::c_int - 9 as libc::c_int,
                    y - 4 as libc::c_int,
                    8 as libc::c_int,
                    16 as libc::c_int,
                    150 as libc::c_int,
                );
                V_DrawStretchyFixedPatch(
                    (165 as libc::c_int + 140 as libc::c_int - 9 as libc::c_int)
                        << 16 as libc::c_int,
                    (y << 16 as libc::c_int) - bounce * 4 as libc::c_int,
                    (1 as libc::c_int) << 16 as libc::c_int,
                    (1 as libc::c_int) << 16 as libc::c_int,
                    0 as libc::c_int,
                    hu_font[('\u{19}' as i32 - '\u{16}' as i32) as usize],
                    V_GetStringColormap(0x2000 as libc::c_int),
                );
            }
        }
        t += 1;
        t;
        y += 16 as libc::c_int;
    }
}
unsafe extern "C" fn M_HandleSoundTest(mut choice: int32_t) {
    let mut exitmenu: boolean = false_0 as libc::c_int;
    match choice {
        238 => {
            let fresh11 = st_sel;
            st_sel = st_sel + 1;
            if fresh11 >= numsoundtestdefs - 1 as libc::c_int {
                st_sel = 0 as libc::c_int;
            }
            cv_closedcaptioning.value = st_cc;
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            cv_closedcaptioning.value = 1 as libc::c_int;
        }
        230 => {
            let fresh12 = st_sel;
            st_sel = st_sel - 1;
            if fresh12 == 0 {
                st_sel = numsoundtestdefs - 1 as libc::c_int;
            }
            cv_closedcaptioning.value = st_cc;
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            cv_closedcaptioning.value = 1 as libc::c_int;
        }
        239 => {
            if st_sel < numsoundtestdefs - 1 as libc::c_int {
                st_sel += 3 as libc::c_int;
                if st_sel >= numsoundtestdefs - 1 as libc::c_int {
                    st_sel = numsoundtestdefs - 1 as libc::c_int;
                }
                cv_closedcaptioning.value = st_cc;
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                cv_closedcaptioning.value = 1 as libc::c_int;
            }
        }
        231 => {
            if st_sel != 0 {
                st_sel -= 3 as libc::c_int;
                if st_sel < 0 as libc::c_int {
                    st_sel = 0 as libc::c_int;
                }
                cv_closedcaptioning.value = st_cc;
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                cv_closedcaptioning.value = 1 as libc::c_int;
            }
        }
        8 => {
            if !curplaying.is_null() {
                S_StopSounds();
                S_StopMusic();
                curplaying = 0 as *mut musicdef_t;
                st_time = 0 as libc::c_int;
                cv_closedcaptioning.value = st_cc;
                S_StartSound(0 as *const libc::c_void, sfx_skid);
                cv_closedcaptioning.value = 1 as libc::c_int;
            }
        }
        27 => {
            exitmenu = true_0 as libc::c_int;
        }
        235 => {
            if *soundtestdefs.offset(st_sel as isize)
                == &mut soundtestsfx as *mut musicdef_t
                && (**soundtestdefs.offset(st_sel as isize)).allowed != 0
            {
                S_StopSounds();
                S_StopMusic();
                curplaying = *soundtestdefs.offset(st_sel as isize);
                st_time = 0 as libc::c_int;
                CV_AddValue(&mut cv_soundtest, 1 as libc::c_int);
            }
        }
        233 => {
            if *soundtestdefs.offset(st_sel as isize)
                == &mut soundtestsfx as *mut musicdef_t
                && (**soundtestdefs.offset(st_sel as isize)).allowed != 0
            {
                S_StopSounds();
                S_StopMusic();
                curplaying = *soundtestdefs.offset(st_sel as isize);
                st_time = 0 as libc::c_int;
                CV_AddValue(&mut cv_soundtest, -(1 as libc::c_int));
            }
        }
        13 => {
            S_StopSounds();
            S_StopMusic();
            st_time = 0 as libc::c_int;
            if (**soundtestdefs.offset(st_sel as isize)).allowed != 0 {
                curplaying = *soundtestdefs.offset(st_sel as isize);
                if curplaying == &mut soundtestsfx as *mut musicdef_t {
                    if cv_soundtest.value != 0 {
                        S_StartSound(
                            0 as *const libc::c_void,
                            cv_soundtest.value as sfxenum_t,
                        );
                    }
                } else {
                    S_ChangeMusicEx(
                        ((*curplaying).name).as_mut_ptr(),
                        0 as libc::c_int as uint16_t,
                        ((*curplaying).stoppingtics == 0) as libc::c_int,
                        0 as libc::c_int as uint32_t,
                        0 as libc::c_int as uint32_t,
                        0 as libc::c_int as uint32_t,
                    );
                }
            } else {
                curplaying = 0 as *mut musicdef_t;
                S_StartSound(0 as *const libc::c_void, sfx_lose);
            }
        }
        _ => {}
    }
    if exitmenu != 0 {
        Z_Free(soundtestdefs as *mut libc::c_void);
        soundtestdefs = 0 as *mut *mut musicdef_t;
        cv_closedcaptioning.value = st_cc;
        if !((*currentMenu).prevMenu).is_null() {
            M_SetupNextMenu((*currentMenu).prevMenu);
        } else {
            M_ClearMenus(true_0 as libc::c_int);
        }
    }
}
unsafe extern "C" fn M_SecretsMenu(mut choice: int32_t) {
    let mut i: int32_t = 0;
    let mut j: int32_t = 0;
    let mut ul: int32_t = 0;
    let mut done: [uint8_t; 80] = [0; 80];
    let mut curheight: uint16_t = 0;
    let mut placeholder: menuitem_t = {
        let mut init = menuitem_s {
            status: (1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
                as uint16_t,
            patch: 0 as *const libc::c_char,
            text: b"\0" as *const u8 as *const libc::c_char,
            itemaction: 0 as *mut libc::c_void,
            alphaKey: 0 as libc::c_int as uint16_t,
        };
        init
    };
    i = 1 as libc::c_int;
    while i <= 80 as libc::c_int {
        SR_MainMenu[i as usize] = placeholder;
        i += 1;
        i;
    }
    memset(
        skyRoomMenuTranslations.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[uint8_t; 80]>() as libc::c_ulong,
    );
    memset(
        done.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[uint8_t; 80]>() as libc::c_ulong,
    );
    i = 1 as libc::c_int;
    while i <= 80 as libc::c_int {
        curheight = 65535 as libc::c_int as uint16_t;
        ul = -(1 as libc::c_int);
        j = 0 as libc::c_int;
        while j < 80 as libc::c_int {
            if !(unlockables[j as usize].height == 0
                || done[j as usize] as libc::c_int != 0
                || (unlockables[j as usize].type_0 as libc::c_int) < 0 as libc::c_int)
            {
                if (unlockables[j as usize].height as libc::c_int)
                    < curheight as libc::c_int
                {
                    curheight = unlockables[j as usize].height;
                    ul = j;
                }
            }
            j += 1;
            j;
        }
        if ul < 0 as libc::c_int {
            break;
        }
        done[ul as usize] = true_0 as libc::c_int as uint8_t;
        skyRoomMenuTranslations[(i - 1 as libc::c_int) as usize] = ul as uint8_t;
        SR_MainMenu[i as usize].text = (unlockables[ul as usize].name).as_mut_ptr();
        SR_MainMenu[i as usize].alphaKey = unlockables[ul as usize].height;
        if unlockables[ul as usize].type_0 as libc::c_int == 0 as libc::c_int {
            SR_MainMenu[i as usize]
                .status = (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                as uint16_t;
        } else {
            SR_MainMenu[i as usize]
                .status = (1 as libc::c_int + (64 as libc::c_int + 128 as libc::c_int))
                as uint16_t;
            if (*clientGamedata).unlocked[ul as usize] != 0 {
                match unlockables[ul as usize].type_0 as libc::c_int {
                    1 => {
                        SR_MainMenu[i as usize]
                            .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
                        SR_MainMenu[i as usize]
                            .itemaction = ::core::mem::transmute::<
                            Option::<unsafe extern "C" fn(int32_t) -> ()>,
                            *mut libc::c_void,
                        >(
                            Some(
                                M_CustomLevelSelect as unsafe extern "C" fn(int32_t) -> (),
                            ),
                        );
                    }
                    2 => {
                        SR_MainMenu[i as usize]
                            .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
                        SR_MainMenu[i as usize]
                            .itemaction = ::core::mem::transmute::<
                            Option::<unsafe extern "C" fn(int32_t) -> ()>,
                            *mut libc::c_void,
                        >(Some(M_CustomWarp as unsafe extern "C" fn(int32_t) -> ()));
                    }
                    4 => {
                        SR_MainMenu[i as usize]
                            .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
                        SR_MainMenu[i as usize]
                            .itemaction = ::core::mem::transmute::<
                            Option::<unsafe extern "C" fn(int32_t) -> ()>,
                            *mut libc::c_void,
                        >(Some(M_Credits as unsafe extern "C" fn(int32_t) -> ()));
                    }
                    3 => {
                        SR_MainMenu[i as usize]
                            .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
                        SR_MainMenu[i as usize]
                            .itemaction = ::core::mem::transmute::<
                            Option::<unsafe extern "C" fn(int32_t) -> ()>,
                            *mut libc::c_void,
                        >(Some(M_SoundTest as unsafe extern "C" fn(int32_t) -> ()));
                    }
                    _ => {}
                }
            }
        }
        i += 1;
        i;
    }
    M_SetupNextMenu(&mut SR_MainDef);
}
#[no_mangle]
pub static mut ultimate_selectable: int32_t = false_0 as libc::c_int;
unsafe extern "C" fn M_NewGame() {
    fromlevelselect = false_0 as libc::c_int;
    maplistoption = 0 as libc::c_int as uint8_t;
    startmap = spstage_start;
    CV_SetValue(&mut cv_newgametype, GT_COOP as libc::c_int);
    M_SetupChoosePlayer(0 as libc::c_int);
}
unsafe extern "C" fn M_CustomWarp(mut choice: int32_t) {
    let mut ul: int32_t = skyRoomMenuTranslations[(choice - 1 as libc::c_int) as usize]
        as int32_t;
    maplistoption = 0 as libc::c_int as uint8_t;
    startmap = unlockables[ul as usize].variable;
    M_SetupChoosePlayer(0 as libc::c_int);
}
unsafe extern "C" fn M_Credits(mut choice: int32_t) {
    cursaveslot = -(1 as libc::c_int);
    M_ClearMenus(true_0 as libc::c_int);
    F_StartCredits();
}
unsafe extern "C" fn M_CustomLevelSelect(mut choice: int32_t) {
    let mut ul: int32_t = skyRoomMenuTranslations[(choice - 1 as libc::c_int) as usize]
        as int32_t;
    SR_LevelSelectDef.prevMenu = currentMenu;
    levellistmode = LLM_LEVELSELECT;
    maplistoption = unlockables[ul as usize].variable as uint8_t;
    if M_PrepareLevelPlatter(-(1 as libc::c_int), true_0 as libc::c_int) == 0 {
        M_StartMessage(
            b"No selectable levels found.\n\0" as *const u8 as *const libc::c_char,
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    }
    M_SetupNextMenu(&mut SR_LevelSelectDef);
}
unsafe extern "C" fn M_SinglePlayerMenu(mut choice: int32_t) {
    SP_MainMenu[spstartgame as libc::c_int as usize]
        .alphaKey = 76 as libc::c_int as uint16_t;
    SP_MainMenu[sprecordattack as libc::c_int as usize]
        .alphaKey = 84 as libc::c_int as uint16_t;
    SP_MainMenu[spnightsmode as libc::c_int as usize]
        .alphaKey = 92 as libc::c_int as uint16_t;
    SP_MainMenu[spmarathon as libc::c_int as usize]
        .alphaKey = 100 as libc::c_int as uint16_t;
    levellistmode = LLM_RECORDATTACK;
    if M_GametypeHasLevels(-(1 as libc::c_int)) != 0 {
        SP_MainMenu[sprecordattack as libc::c_int as usize]
            .status = (if M_SecretUnlocked(-(2 as libc::c_int), clientGamedata)
            as libc::c_int != 0
        {
            0 as libc::c_int | 32 as libc::c_int
        } else {
            1 as libc::c_int + (64 as libc::c_int + 128 as libc::c_int)
        }) as uint16_t;
    } else {
        SP_MainMenu[sprecordattack as libc::c_int as usize]
            .status = (0 as libc::c_int
            | 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
            as uint16_t;
        SP_MainMenu[spstartgame as libc::c_int as usize]
            .alphaKey = (SP_MainMenu[spstartgame as libc::c_int as usize].alphaKey
            as libc::c_int + 8 as libc::c_int) as uint16_t;
    }
    levellistmode = LLM_NIGHTSATTACK;
    if M_GametypeHasLevels(-(1 as libc::c_int)) != 0 {
        SP_MainMenu[spnightsmode as libc::c_int as usize]
            .status = (if M_SecretUnlocked(-(1 as libc::c_int), clientGamedata)
            as libc::c_int != 0
        {
            0 as libc::c_int | 32 as libc::c_int
        } else {
            1 as libc::c_int + (64 as libc::c_int + 128 as libc::c_int)
        }) as uint16_t;
    } else {
        SP_MainMenu[spnightsmode as libc::c_int as usize]
            .status = (0 as libc::c_int
            | 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
            as uint16_t;
        SP_MainMenu[spstartgame as libc::c_int as usize]
            .alphaKey = (SP_MainMenu[spstartgame as libc::c_int as usize].alphaKey
            as libc::c_int + 8 as libc::c_int) as uint16_t;
        SP_MainMenu[sprecordattack as libc::c_int as usize]
            .alphaKey = (SP_MainMenu[sprecordattack as libc::c_int as usize].alphaKey
            as libc::c_int + 8 as libc::c_int) as uint16_t;
    }
    if !(mapheaderinfo[(spmarathon_start as libc::c_int - 1 as libc::c_int) as usize])
        .is_null()
        && (*mapheaderinfo[(spmarathon_start as libc::c_int - 1 as libc::c_int)
            as usize])
            .marathonnext == 0
        && ((*mapheaderinfo[(spmarathon_start as libc::c_int - 1 as libc::c_int)
            as usize])
            .nextlevel as libc::c_int == spmarathon_start as libc::c_int
            || (*mapheaderinfo[(spmarathon_start as libc::c_int - 1 as libc::c_int)
                as usize])
                .nextlevel as libc::c_int >= 1100 as libc::c_int)
    {
        SP_MainMenu[spmarathon as libc::c_int as usize]
            .status = (0 as libc::c_int
            | 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
            as uint16_t;
        SP_MainMenu[spstartgame as libc::c_int as usize]
            .alphaKey = (SP_MainMenu[spstartgame as libc::c_int as usize].alphaKey
            as libc::c_int + 8 as libc::c_int) as uint16_t;
        SP_MainMenu[sprecordattack as libc::c_int as usize]
            .alphaKey = (SP_MainMenu[sprecordattack as libc::c_int as usize].alphaKey
            as libc::c_int + 8 as libc::c_int) as uint16_t;
        SP_MainMenu[spnightsmode as libc::c_int as usize]
            .alphaKey = (SP_MainMenu[spnightsmode as libc::c_int as usize].alphaKey
            as libc::c_int + 8 as libc::c_int) as uint16_t;
    } else {
        SP_MainMenu[spmarathon as libc::c_int as usize]
            .status = (if M_SecretUnlocked(-(2 as libc::c_int), clientGamedata)
            as libc::c_int != 0
        {
            0 as libc::c_int | 32 as libc::c_int | 512 as libc::c_int
        } else {
            1 as libc::c_int + (64 as libc::c_int + 128 as libc::c_int)
        }) as uint16_t;
    }
    if tutorialmap != 0 {
        SP_MainMenu[sptutorial as libc::c_int as usize]
            .status = (0 as libc::c_int | 32 as libc::c_int) as uint16_t;
    } else {
        SP_MainMenu[sptutorial as libc::c_int as usize]
            .status = (0 as libc::c_int
            | 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int))
            as uint16_t;
        SP_MainMenu[spstartgame as libc::c_int as usize]
            .alphaKey = (SP_MainMenu[spstartgame as libc::c_int as usize].alphaKey
            as libc::c_int + 8 as libc::c_int) as uint16_t;
        SP_MainMenu[sprecordattack as libc::c_int as usize]
            .alphaKey = (SP_MainMenu[sprecordattack as libc::c_int as usize].alphaKey
            as libc::c_int + 8 as libc::c_int) as uint16_t;
        SP_MainMenu[spnightsmode as libc::c_int as usize]
            .alphaKey = (SP_MainMenu[spnightsmode as libc::c_int as usize].alphaKey
            as libc::c_int + 8 as libc::c_int) as uint16_t;
        SP_MainMenu[spmarathon as libc::c_int as usize]
            .alphaKey = (SP_MainMenu[spmarathon as libc::c_int as usize].alphaKey
            as libc::c_int + 8 as libc::c_int) as uint16_t;
    }
    M_SetupNextMenu(&mut SP_MainDef);
}
unsafe extern "C" fn M_LoadGameLevelSelect(mut choice: int32_t) {
    SP_LevelSelectDef.prevMenu = currentMenu;
    levellistmode = LLM_LEVELSELECT;
    maplistoption = (1 as libc::c_int + 2 as libc::c_int) as uint8_t;
    if M_PrepareLevelPlatter(-(1 as libc::c_int), true_0 as libc::c_int) == 0 {
        M_StartMessage(
            b"No selectable levels found.\n\0" as *const u8 as *const libc::c_char,
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    }
    M_SetupNextMenu(&mut SP_LevelSelectDef);
}
#[no_mangle]
pub unsafe extern "C" fn M_TutorialSaveControlResponse(mut ch: int32_t) {
    if ch == 'y' as i32 || ch == 13 as libc::c_int {
        G_CopyControls(
            gamecontrol.as_mut_ptr(),
            (gamecontroldefault[tutorialgcs as usize]).as_mut_ptr(),
            gcl_tutorial_full.as_ptr(),
            13 as libc::c_int,
        );
        CV_Set(&mut cv_usemouse, cv_usemouse.defaultvalue);
        CV_Set(&mut cv_alwaysfreelook, cv_alwaysfreelook.defaultvalue);
        CV_Set(&mut cv_mousemove, cv_mousemove.defaultvalue);
        CV_Set(
            &mut *cv_analog.as_mut_ptr().offset(0 as libc::c_int as isize),
            cv_analog[0 as libc::c_int as usize].defaultvalue,
        );
        S_StartSound(0 as *const libc::c_void, sfx_itemup);
    } else {
        S_StartSound(0 as *const libc::c_void, sfx_menu1);
    };
}
unsafe extern "C" fn M_TutorialControlResponse(mut ch: int32_t) {
    if ch != 27 as libc::c_int {
        G_CopyControls(
            (gamecontroldefault[gcs_custom as libc::c_int as usize]).as_mut_ptr(),
            gamecontrol.as_mut_ptr(),
            0 as *const int32_t,
            0 as libc::c_int,
        );
        if ch == 'y' as i32 || ch == 13 as libc::c_int {
            tutorialgcs = gcs_fps as libc::c_int;
            tutorialusemouse = cv_usemouse.value;
            tutorialfreelook = cv_alwaysfreelook.value;
            tutorialmousemove = cv_mousemove.value;
            tutorialanalog = cv_analog[0 as libc::c_int as usize].value;
            G_CopyControls(
                gamecontrol.as_mut_ptr(),
                (gamecontroldefault[tutorialgcs as usize]).as_mut_ptr(),
                gcl_tutorial_full.as_ptr(),
                13 as libc::c_int,
            );
            CV_Set(&mut cv_usemouse, cv_usemouse.defaultvalue);
            CV_Set(&mut cv_alwaysfreelook, cv_alwaysfreelook.defaultvalue);
            CV_Set(&mut cv_mousemove, cv_mousemove.defaultvalue);
            CV_Set(
                &mut *cv_analog.as_mut_ptr().offset(0 as libc::c_int as isize),
                cv_analog[0 as libc::c_int as usize].defaultvalue,
            );
        } else {
            tutorialgcs = gcs_custom as libc::c_int;
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
        }
        M_StartTutorial(2147483647 as libc::c_int);
    } else {
        S_StartSound(0 as *const libc::c_void, sfx_menu1);
    }
    MessageDef.prevMenu = &mut SP_MainDef;
}
unsafe extern "C" fn M_StartTutorial(mut choice: int32_t) {
    if tutorialmap == 0 {
        return;
    }
    if choice != 2147483647 as libc::c_int
        && G_GetControlScheme(
            gamecontrol.as_mut_ptr(),
            gcl_tutorial_check.as_ptr(),
            6 as libc::c_int,
        ) != gcs_fps as libc::c_int
    {
        M_StartMessage(
            b"Do you want to try the \x82recommended \x82movement controls\x80?\n\nWe will set them just for this tutorial.\n\nPress 'Y' or 'Enter' to confirm\nPress 'N' or any key to keep \nyour current controls.\n\0"
                as *const u8 as *const libc::c_char,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(int32_t) -> ()>,
                *mut libc::c_void,
            >(Some(M_TutorialControlResponse as unsafe extern "C" fn(int32_t) -> ())),
            MM_YESNO,
        );
        return;
    } else if choice != 2147483647 as libc::c_int {
        tutorialgcs = gcs_custom as libc::c_int;
    }
    CV_SetValue(&mut cv_tutorialprompt, 0 as libc::c_int);
    tutorialmode = true_0 as libc::c_int;
    emeralds = 0 as libc::c_int as uint16_t;
    memset(
        &mut luabanks as *mut [int32_t; 16] as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[int32_t; 16]>() as libc::c_ulong,
    );
    M_ClearMenus(true_0 as libc::c_int);
    gamecomplete = 0 as libc::c_int as uint8_t;
    cursaveslot = 0 as libc::c_int;
    maplistoption = 0 as libc::c_int as uint8_t;
    G_DeferedInitNew(
        false_0 as libc::c_int,
        G_BuildMapName(tutorialmap as int32_t),
        0 as libc::c_int,
        false_0 as libc::c_int,
        false_0 as libc::c_int,
    );
}
static mut saveSlotSelected: int32_t = 1 as libc::c_int;
static mut loadgamescroll: fixed_t = 0 as libc::c_int;
static mut loadgameoffset: fixed_t = 0 as libc::c_int;
unsafe extern "C" fn M_CacheLoadGameData() {
    savselp[0 as libc::c_int
        as usize] = W_CachePatchName(
        b"SAVEBACK\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    savselp[1 as libc::c_int
        as usize] = W_CachePatchName(
        b"SAVENONE\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    savselp[2 as libc::c_int
        as usize] = W_CachePatchName(
        b"ULTIMATE\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    savselp[3 as libc::c_int
        as usize] = W_CachePatchName(
        b"GAMEDONE\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    savselp[4 as libc::c_int
        as usize] = W_CachePatchName(
        b"BLACXLVL\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    savselp[5 as libc::c_int
        as usize] = W_CachePatchName(
        b"BLANKLVL\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
}
unsafe extern "C" fn M_DrawLoadGameData() {
    let mut i: int32_t = 0;
    let mut prev_i: int32_t = 1 as libc::c_int;
    let mut savetodraw: int32_t = 0;
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut hsep: int32_t = 90 as libc::c_int;
    let mut charskin: *mut skin_t = 0 as *mut skin_t;
    if vid.width != 320 as libc::c_int * vid.dupx {
        hsep = hsep * vid.width / (320 as libc::c_int * vid.dupx);
    }
    i = 2 as libc::c_int;
    while prev_i != 0 {
        prev_i = i;
        savetodraw = (saveSlotSelected + i + numsaves as libc::c_int)
            % numsaves as libc::c_int;
        x = 320 as libc::c_int / 2 as libc::c_int - 42 as libc::c_int
            + FixedInt(loadgamescroll) + i * hsep;
        y = 33 as libc::c_int + 9 as libc::c_int;
        let mut diff: int32_t = x
            - (320 as libc::c_int / 2 as libc::c_int - 42 as libc::c_int);
        if diff < 0 as libc::c_int {
            diff = -diff;
        }
        diff = (42 as libc::c_int - diff) / 3 as libc::c_int - FixedInt(loadgameoffset);
        if diff < 0 as libc::c_int {
            diff = 0 as libc::c_int;
        }
        y -= diff;
        if savetodraw == 0 as libc::c_int {
            V_DrawStretchyFixedPatch(
                x << 16 as libc::c_int,
                y << 16 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0 as libc::c_int,
                savselp[(if ultimate_selectable != 0 {
                    2 as libc::c_int
                } else {
                    1 as libc::c_int
                }) as usize],
                0 as *const uint8_t,
            );
            x += 2 as libc::c_int;
            y += 1 as libc::c_int;
            V_DrawString(
                x,
                y,
                if savetodraw == saveSlotSelected {
                    0x2000 as libc::c_int
                } else {
                    0 as libc::c_int
                },
                b"NO FILE\0" as *const u8 as *const libc::c_char,
            );
            if savetodraw == saveSlotSelected {
                V_DrawFill(
                    x,
                    y + 9 as libc::c_int,
                    80 as libc::c_int,
                    1 as libc::c_int,
                    *yellowmap.offset(3 as libc::c_int as isize) as int32_t,
                );
            }
            y += 11 as libc::c_int;
            V_DrawStretchyFixedPatch(
                x << 16 as libc::c_int,
                y << 16 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0 as libc::c_int,
                savselp[4 as libc::c_int as usize],
                0 as *const uint8_t,
            );
            M_DrawStaticBox(
                x,
                y,
                0x80000 as libc::c_int,
                80 as libc::c_int,
                50 as libc::c_int,
            );
            y += 41 as libc::c_int;
            if ultimate_selectable != 0 {
                V_DrawRightAlignedThinString(
                    x + 79 as libc::c_int,
                    y,
                    0x5000 as libc::c_int,
                    b"ULTIMATE.\0" as *const u8 as *const libc::c_char,
                );
            } else {
                V_DrawRightAlignedThinString(
                    x + 79 as libc::c_int,
                    y,
                    0x6000 as libc::c_int,
                    b"DON'T SAVE!\0" as *const u8 as *const libc::c_char,
                );
            }
        } else {
            savetodraw -= 1;
            savetodraw;
            if (*savegameinfo.offset(savetodraw as isize)).lives != 0 as libc::c_int {
                charskin = &mut *skins
                    .as_mut_ptr()
                    .offset((*savegameinfo.offset(savetodraw as isize)).skinnum as isize)
                    as *mut skin_t;
            }
            let mut col: uint8_t = 0;
            if (*savegameinfo.offset(savetodraw as isize)).lives == -(666 as libc::c_int)
            {
                V_DrawStretchyFixedPatch(
                    (x + 2 as libc::c_int) << 16 as libc::c_int,
                    (y + 64 as libc::c_int) << 16 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    0 as libc::c_int,
                    savselp[5 as libc::c_int as usize],
                    0 as *const uint8_t,
                );
            } else {
                if (*savegameinfo.offset(savetodraw as isize)).lives
                    == -(42 as libc::c_int)
                {
                    col = 26 as libc::c_int as uint8_t;
                } else if (*savegameinfo.offset(savetodraw as isize)).botskin
                    as libc::c_int == 3 as libc::c_int
                {
                    col = 105 as libc::c_int as uint8_t;
                } else if (*savegameinfo.offset(savetodraw as isize)).botskin != 0 {
                    col = 134 as libc::c_int as uint8_t;
                } else if (*charskin).prefoppositecolor != 0 {
                    col = (*charskin).prefoppositecolor as uint8_t;
                    col = skincolors[col as usize]
                        .ramp[skincolors[(*charskin).prefcolor as usize].invshade
                        as usize];
                } else {
                    col = (*charskin).prefcolor as uint8_t;
                    col = skincolors[skincolors[col as usize].invcolor as usize]
                        .ramp[skincolors[col as usize].invshade as usize];
                }
                V_DrawFill(
                    x + 6 as libc::c_int,
                    y + 64 as libc::c_int,
                    72 as libc::c_int,
                    50 as libc::c_int,
                    col as int32_t,
                );
            }
            V_DrawStretchyFixedPatch(
                x << 16 as libc::c_int,
                y << 16 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0 as libc::c_int,
                savselp[0 as libc::c_int as usize],
                0 as *const uint8_t,
            );
            x += 2 as libc::c_int;
            y += 1 as libc::c_int;
            V_DrawString(
                x,
                y,
                if savetodraw == saveSlotSelected - 1 as libc::c_int {
                    0x2000 as libc::c_int
                } else {
                    0 as libc::c_int
                },
                va(
                    b"FILE %d\0" as *const u8 as *const libc::c_char,
                    savetodraw + 1 as libc::c_int,
                ),
            );
            if savetodraw == saveSlotSelected - 1 as libc::c_int {
                V_DrawFill(
                    x,
                    y + 9 as libc::c_int,
                    80 as libc::c_int,
                    1 as libc::c_int,
                    *yellowmap.offset(3 as libc::c_int as isize) as int32_t,
                );
            }
            y += 11 as libc::c_int;
            if (*savegameinfo.offset(savetodraw as isize)).lives == -(42 as libc::c_int)
                || (*savegameinfo.offset(savetodraw as isize)).lives
                    == -(666 as libc::c_int)
            {
                V_DrawFill(
                    x,
                    y,
                    80 as libc::c_int,
                    50 as libc::c_int,
                    31 as libc::c_int,
                );
                M_DrawStaticBox(
                    x,
                    y,
                    0x80000 as libc::c_int,
                    80 as libc::c_int,
                    50 as libc::c_int,
                );
            } else {
                let mut patch: *mut patch_t = 0 as *mut patch_t;
                if (*savegameinfo.offset(savetodraw as isize)).gamemap
                    & 8192 as libc::c_int != 0
                {
                    patch = savselp[3 as libc::c_int as usize];
                } else {
                    let mut lumpnum: lumpnum_t = W_CheckNumForName(
                        va(
                            b"%sP\0" as *const u8 as *const libc::c_char,
                            G_BuildMapName(
                                (*savegameinfo.offset(savetodraw as isize)).gamemap
                                    & 8191 as libc::c_int,
                            ),
                        ),
                    );
                    if lumpnum != 4294967295 as libc::c_uint {
                        patch = W_CachePatchNum(lumpnum, PU_PATCH as libc::c_int)
                            as *mut patch_t;
                    } else {
                        patch = savselp[5 as libc::c_int as usize];
                    }
                }
                V_DrawStretchyFixedPatch(
                    x << 16 as libc::c_int,
                    y << 16 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    0 as libc::c_int,
                    patch,
                    0 as *const uint8_t,
                );
            }
            y += 41 as libc::c_int;
            if (*savegameinfo.offset(savetodraw as isize)).lives == -(42 as libc::c_int)
            {
                V_DrawRightAlignedThinString(
                    x + 79 as libc::c_int,
                    y,
                    0x6000 as libc::c_int,
                    b"NEW GAME\0" as *const u8 as *const libc::c_char,
                );
            } else if (*savegameinfo.offset(savetodraw as isize)).lives
                == -(666 as libc::c_int)
            {
                V_DrawRightAlignedThinString(
                    x + 79 as libc::c_int,
                    y,
                    0x5000 as libc::c_int,
                    b"CAN'T LOAD!\0" as *const u8 as *const libc::c_char,
                );
            } else if (*savegameinfo.offset(savetodraw as isize)).gamemap
                & 8192 as libc::c_int != 0
            {
                V_DrawRightAlignedThinString(
                    x + 79 as libc::c_int,
                    y,
                    0x3000 as libc::c_int,
                    b"CLEAR!\0" as *const u8 as *const libc::c_char,
                );
            } else {
                V_DrawRightAlignedThinString(
                    x + 79 as libc::c_int,
                    y,
                    0x2000 as libc::c_int,
                    ((*savegameinfo.offset(savetodraw as isize)).levelname).as_mut_ptr(),
                );
            }
            if (*savegameinfo.offset(savetodraw as isize)).lives == -(42 as libc::c_int)
            {
                if useContinues == 0 {
                    V_DrawRightAlignedThinString(
                        x + 80 as libc::c_int,
                        y + 1 as libc::c_int + 60 as libc::c_int + 16 as libc::c_int,
                        0x6000 as libc::c_int,
                        b"00000000\0" as *const u8 as *const libc::c_char,
                    );
                }
            } else if (*savegameinfo.offset(savetodraw as isize)).lives
                == -(666 as libc::c_int)
            {
                if useContinues == 0 {
                    V_DrawRightAlignedThinString(
                        x + 80 as libc::c_int,
                        y + 1 as libc::c_int + 60 as libc::c_int + 16 as libc::c_int,
                        0x5000 as libc::c_int,
                        b"????????\0" as *const u8 as *const libc::c_char,
                    );
                }
            } else {
                y += 64 as libc::c_int;
                let mut j: int32_t = 0;
                let mut workx: int32_t = x + 6 as libc::c_int;
                j = 0 as libc::c_int;
                while j < 7 as libc::c_int {
                    if (*savegameinfo.offset(savetodraw as isize)).numemeralds
                        as libc::c_int & (1 as libc::c_int) << j != 0
                    {
                        V_DrawStretchyFixedPatch(
                            workx * ((1 as libc::c_int) << 16 as libc::c_int),
                            y << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            0 as libc::c_int,
                            emeraldpics[1 as libc::c_int as usize][j as usize],
                            0 as *const uint8_t,
                        );
                    }
                    workx += 10 as libc::c_int;
                    j += 1;
                    j;
                }
                y -= 4 as libc::c_int;
                let mut sprdef: *mut spritedef_t = 0 as *mut spritedef_t;
                let mut sprframe: *mut spriteframe_t = 0 as *mut spriteframe_t;
                let mut patch_0: *mut patch_t = 0 as *mut patch_t;
                let mut colormap: *mut uint8_t = 0 as *mut uint8_t;
                let mut tempx: int32_t = (x + 40 as libc::c_int) << 16 as libc::c_int;
                let mut flip: int32_t = 0 as libc::c_int;
                if (*savegameinfo.offset(savetodraw as isize)).botskin != 0 {
                    let mut charbotskin: *mut skin_t = &mut *skins
                        .as_mut_ptr()
                        .offset(
                            ((*savegameinfo.offset(savetodraw as isize)).botskin
                                as libc::c_int - 1 as libc::c_int) as isize,
                        ) as *mut skin_t;
                    sprdef = &mut *((*charbotskin).sprites)
                        .as_mut_ptr()
                        .offset(SPR2_SIGN as libc::c_int as isize) as *mut spritedef_t;
                    if !((*sprdef).numframes == 0) {
                        colormap = R_GetTranslationColormap(
                            (*savegameinfo.offset(savetodraw as isize)).botskin
                                as libc::c_int - 1 as libc::c_int,
                            (*charbotskin).prefcolor as skincolornum_t,
                            1 as libc::c_int as uint8_t,
                        );
                        sprframe = &mut *((*sprdef).spriteframes)
                            .offset(0 as libc::c_int as isize) as *mut spriteframe_t;
                        patch_0 = W_CachePatchNum(
                            (*sprframe).lumppat[0 as libc::c_int as usize],
                            PU_PATCH as libc::c_int,
                        ) as *mut patch_t;
                        V_DrawStretchyFixedPatch(
                            tempx + ((18 as libc::c_int) << 16 as libc::c_int),
                            y << 16 as libc::c_int,
                            (*charbotskin).highresscale,
                            (*charbotskin).highresscale,
                            0 as libc::c_int,
                            patch_0,
                            colormap,
                        );
                        tempx -= (20 as libc::c_int) << 16 as libc::c_int;
                    }
                }
                if !charskin.is_null() {
                    sprdef = &mut *((*charskin).sprites)
                        .as_mut_ptr()
                        .offset(SPR2_SIGN as libc::c_int as isize) as *mut spritedef_t;
                    colormap = R_GetTranslationColormap(
                        (*savegameinfo.offset(savetodraw as isize)).skinnum as int32_t,
                        (*charskin).prefcolor as skincolornum_t,
                        1 as libc::c_int as uint8_t,
                    );
                    if !((*sprdef).numframes == 0) {
                        sprframe = &mut *((*sprdef).spriteframes)
                            .offset(0 as libc::c_int as isize) as *mut spriteframe_t;
                        patch_0 = W_CachePatchNum(
                            (*sprframe).lumppat[0 as libc::c_int as usize],
                            PU_PATCH as libc::c_int,
                        ) as *mut patch_t;
                        V_DrawStretchyFixedPatch(
                            tempx,
                            y << 16 as libc::c_int,
                            (*charskin).highresscale,
                            (*charskin).highresscale,
                            flip,
                            patch_0,
                            colormap,
                        );
                    }
                }
                y += 16 as libc::c_int;
                tempx = x;
                if useContinues != 0 {
                    tempx += 10 as libc::c_int;
                    if (*savegameinfo.offset(savetodraw as isize)).lives
                        != 0x7f as libc::c_int
                        && (*savegameinfo.offset(savetodraw as isize)).lives
                            > 9 as libc::c_int
                    {
                        tempx -= 4 as libc::c_int;
                    }
                }
                if !charskin.is_null() {
                    sprdef = &mut *((*charskin).sprites)
                        .as_mut_ptr()
                        .offset(SPR2_LIFE as libc::c_int as isize) as *mut spritedef_t;
                    if !((*sprdef).numframes == 0) {
                        sprframe = &mut *((*sprdef).spriteframes)
                            .offset(0 as libc::c_int as isize) as *mut spriteframe_t;
                        patch_0 = W_CachePatchNum(
                            (*sprframe).lumppat[0 as libc::c_int as usize],
                            PU_PATCH as libc::c_int,
                        ) as *mut patch_t;
                        V_DrawStretchyFixedPatch(
                            (tempx + 4 as libc::c_int) << 16 as libc::c_int,
                            (y + 6 as libc::c_int) << 16 as libc::c_int,
                            (*charskin).highresscale / 2 as libc::c_int,
                            (*charskin).highresscale / 2 as libc::c_int,
                            0 as libc::c_int,
                            patch_0,
                            colormap,
                        );
                    }
                }
                patch_0 = W_CachePatchName(
                    b"STLIVEX\0" as *const u8 as *const libc::c_char,
                    PU_PATCH as libc::c_int,
                ) as *mut patch_t;
                V_DrawStretchyFixedPatch(
                    (tempx + 9 as libc::c_int)
                        * ((1 as libc::c_int) << 16 as libc::c_int),
                    (y + 2 as libc::c_int) << 16 as libc::c_int,
                    (1 as libc::c_int) << 16 as libc::c_int,
                    (1 as libc::c_int) << 16 as libc::c_int,
                    0 as libc::c_int,
                    patch_0,
                    0 as *const uint8_t,
                );
                tempx += 16 as libc::c_int;
                if (*savegameinfo.offset(savetodraw as isize)).lives
                    == 0x7f as libc::c_int
                {
                    V_DrawCharacter(
                        tempx,
                        y + 1 as libc::c_int,
                        '\u{16}' as i32,
                        false_0 as libc::c_int,
                    );
                } else {
                    V_DrawString(
                        tempx,
                        y,
                        0 as libc::c_int,
                        va(
                            b"%d\0" as *const u8 as *const libc::c_char,
                            (*savegameinfo.offset(savetodraw as isize)).lives,
                        ),
                    );
                }
                if useContinues == 0 {
                    let mut workingscorenum: int32_t = (*savegameinfo
                        .offset(savetodraw as isize))
                        .continuescore;
                    let mut workingscorestr: [libc::c_char; 11] = *::core::mem::transmute::<
                        &[u8; 11],
                        &mut [libc::c_char; 11],
                    >(b" 000000000\0");
                    let mut j_0: int8_t = 9 as libc::c_int as int8_t;
                    workingscorestr[0 as libc::c_int as usize] = -122i32 as libc::c_char;
                    if workingscorenum == 0 {
                        j_0 -= 1;
                        j_0;
                    } else {
                        while workingscorenum != 0 {
                            let fresh13 = j_0;
                            j_0 = j_0 - 1;
                            workingscorestr[fresh13
                                as usize] = ('0' as i32
                                + workingscorenum % 10 as libc::c_int) as libc::c_char;
                            workingscorenum /= 10 as libc::c_int;
                        }
                    }
                    workingscorestr[j_0
                        as usize] = (if (*savegameinfo.offset(savetodraw as isize))
                        .continuescore == 99999990 as libc::c_int
                    {
                        -125i32
                    } else {
                        -128i32
                    }) as libc::c_char;
                    V_DrawRightAlignedThinString(
                        x + 80 as libc::c_int,
                        y + 1 as libc::c_int,
                        0 as libc::c_int,
                        workingscorestr.as_mut_ptr(),
                    );
                } else {
                    tempx = x + 47 as libc::c_int;
                    if (*savegameinfo.offset(savetodraw as isize)).continuescore
                        > 9 as libc::c_int
                    {
                        tempx -= 4 as libc::c_int;
                    }
                    if (*savegameinfo.offset(savetodraw as isize)).continuescore
                        > 0 as libc::c_int
                    {
                        V_DrawStretchyFixedPatch(
                            tempx << 16 as libc::c_int,
                            y << 16 as libc::c_int,
                            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                            0 as libc::c_int,
                            W_CachePatchName(
                                b"CONTSAVE\0" as *const u8 as *const libc::c_char,
                                PU_PATCH as libc::c_int,
                            ) as *mut patch_t,
                            0 as *const uint8_t,
                        );
                        V_DrawStretchyFixedPatch(
                            (tempx + 9 as libc::c_int)
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                            (y + 2 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            0 as libc::c_int,
                            patch_0,
                            0 as *const uint8_t,
                        );
                        V_DrawString(
                            tempx + 16 as libc::c_int,
                            y,
                            0 as libc::c_int,
                            va(
                                b"%d\0" as *const u8 as *const libc::c_char,
                                (*savegameinfo.offset(savetodraw as isize)).continuescore,
                            ),
                        );
                    } else {
                        V_DrawStretchyFixedPatch(
                            tempx << 16 as libc::c_int,
                            y << 16 as libc::c_int,
                            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                            0 as libc::c_int,
                            W_CachePatchName(
                                b"CONTNONE\0" as *const u8 as *const libc::c_char,
                                PU_PATCH as libc::c_int,
                            ) as *mut patch_t,
                            0 as *const uint8_t,
                        );
                        V_DrawStretchyFixedPatch(
                            (tempx + 9 as libc::c_int)
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                            (y + 2 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            (1 as libc::c_int) << 16 as libc::c_int,
                            0 as libc::c_int,
                            W_CachePatchName(
                                b"STNONEX\0" as *const u8 as *const libc::c_char,
                                PU_PATCH as libc::c_int,
                            ) as *mut patch_t,
                            0 as *const uint8_t,
                        );
                        V_DrawString(
                            tempx + 16 as libc::c_int,
                            y,
                            0x6000 as libc::c_int,
                            b"0\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
            }
        }
        i = (i as uint32_t)
            .wrapping_add(i as uint32_t >> 31 as libc::c_int)
            .wrapping_neg() as int32_t;
    }
}
unsafe extern "C" fn M_DrawLoad() {
    M_DrawMenuTitle();
    let mut scrollfrac: fixed_t = FixedDiv(2 as libc::c_int, 3 as libc::c_int);
    if loadgamescroll > (1 as libc::c_int) << 16 as libc::c_int
        || loadgamescroll < -((1 as libc::c_int) << 16 as libc::c_int)
    {
        let mut newscroll: fixed_t = FixedMul(loadgamescroll, scrollfrac);
        let mut deltascroll: fixed_t = FixedMul(
            newscroll - loadgamescroll,
            renderdeltatics,
        );
        loadgamescroll += deltascroll;
    } else {
        loadgamescroll = 0 as libc::c_int;
    }
    if loadgameoffset > (1 as libc::c_int) << 16 as libc::c_int {
        let mut newoffs: fixed_t = FixedMul(loadgameoffset, scrollfrac);
        let mut deltaoffs: fixed_t = FixedMul(newoffs - loadgameoffset, renderdeltatics);
        loadgameoffset += deltaoffs;
    } else {
        loadgameoffset = 0 as libc::c_int;
    }
    M_DrawLoadGameData();
    if usedCheats != 0 {
        V_DrawCenteredThinString(
            320 as libc::c_int / 2 as libc::c_int,
            184 as libc::c_int,
            0 as libc::c_int,
            b"\x85WARNING:\x80 Cheats have been activated.\0" as *const u8
                as *const libc::c_char,
        );
        V_DrawCenteredThinString(
            320 as libc::c_int / 2 as libc::c_int,
            192 as libc::c_int,
            0 as libc::c_int,
            b"Progress will not be saved.\0" as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn M_LoadSelect(mut choice: int32_t) {
    maplistoption = 0 as libc::c_int as uint8_t;
    if saveSlotSelected == 0 as libc::c_int {
        M_NewGame();
        cursaveslot = 0 as libc::c_int;
        return;
    }
    if FIL_ReadFileOK(va(savegamename.as_mut_ptr(), saveSlotSelected)) == 0 {
        M_NewGame();
    } else if (*savegameinfo.offset((saveSlotSelected - 1 as libc::c_int) as isize))
        .gamemap & 8192 as libc::c_int != 0
    {
        M_LoadGameLevelSelect(0 as libc::c_int);
    } else {
        G_LoadGame(saveSlotSelected as uint32_t, 0 as libc::c_int as int16_t);
    }
    cursaveslot = saveSlotSelected;
}
unsafe extern "C" fn M_ReadSavegameInfo(mut slot: uint32_t) {
    let mut length: size_t = 0;
    let mut savename: [libc::c_char; 255] = [0; 255];
    let mut savebuffer: *mut uint8_t = 0 as *mut uint8_t;
    let mut end_p: *mut uint8_t = 0 as *mut uint8_t;
    let mut sav_p: *mut uint8_t = 0 as *mut uint8_t;
    let mut fake: int32_t = 0;
    let mut temp: [libc::c_char; 64] = [0; 64];
    let mut vcheck: [libc::c_char; 16] = [0; 16];
    let mut backwardsCompat: int16_t = 0 as libc::c_int as int16_t;
    sprintf(savename.as_mut_ptr(), savegamename.as_mut_ptr(), slot);
    slot = slot.wrapping_sub(1);
    slot;
    length = FIL_ReadFileTag(
        savename.as_mut_ptr(),
        &mut savebuffer,
        PU_STATIC as libc::c_int,
    );
    if length == 0 as libc::c_int as size_t {
        (*savegameinfo.offset(slot as isize)).lives = -(42 as libc::c_int);
        return;
    }
    end_p = savebuffer.offset(length as isize);
    sav_p = savebuffer;
    memset(
        vcheck.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
    );
    sprintf(
        vcheck.as_mut_ptr(),
        b"version %d\0" as *const u8 as *const libc::c_char,
        VERSION,
    );
    if strcmp(sav_p as *const libc::c_char, vcheck.as_mut_ptr() as *const libc::c_char)
        != 0
    {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    sav_p = sav_p.offset(16 as libc::c_int as isize);
    if sav_p >= end_p {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    fake = ({
        let mut p_tmp: *mut int16_t = sav_p as *mut libc::c_void as *mut int16_t;
        let mut b: int16_t = 0;
        memcpy(
            &mut b as *mut int16_t as *mut libc::c_void,
            sav_p as *const libc::c_void,
            ::core::mem::size_of::<int16_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    }) as int32_t;
    if fake - 1 as libc::c_int & 8191 as libc::c_int >= 1035 as libc::c_int {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    if (mapheaderinfo[(fake - 1 as libc::c_int & 8191 as libc::c_int) as usize])
        .is_null()
    {
        (*savegameinfo.offset(slot as isize))
            .levelname[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    } else if V_ThinStringWidth(
        ((*mapheaderinfo[(fake - 1 as libc::c_int & 8191 as libc::c_int) as usize])
            .lvlttl)
            .as_mut_ptr(),
        0 as libc::c_int,
    ) <= 78 as libc::c_int
    {
        strlcpy(
            ((*savegameinfo.offset(slot as isize)).levelname).as_mut_ptr(),
            ((*mapheaderinfo[(fake - 1 as libc::c_int & 8191 as libc::c_int) as usize])
                .lvlttl)
                .as_mut_ptr(),
            22 as libc::c_int as libc::c_ulong,
        );
    } else {
        strlcpy(
            ((*savegameinfo.offset(slot as isize)).levelname).as_mut_ptr(),
            ((*mapheaderinfo[(fake - 1 as libc::c_int & 8191 as libc::c_int) as usize])
                .lvlttl)
                .as_mut_ptr(),
            15 as libc::c_int as libc::c_ulong,
        );
        strcat(
            ((*savegameinfo.offset(slot as isize)).levelname).as_mut_ptr(),
            b"...\0" as *const u8 as *const libc::c_char,
        );
    }
    (*savegameinfo.offset(slot as isize)).gamemap = fake;
    if sav_p >= end_p {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    (*savegameinfo.offset(slot as isize))
        .numemeralds = (({
        let mut p_tmp: *mut uint16_t = sav_p as *mut libc::c_void as *mut uint16_t;
        let mut b: uint16_t = 0;
        memcpy(
            &mut b as *mut uint16_t as *mut libc::c_void,
            sav_p as *const libc::c_void,
            ::core::mem::size_of::<uint16_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    }) as libc::c_int - 357 as libc::c_int) as uint8_t;
    if sav_p >= end_p {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    let mut tmp_i: size_t = 0 as libc::c_int as size_t;
    while tmp_i < ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong
        && {
            temp[tmp_i
                as usize] = ({
                let mut p_tmp: *mut libc::c_char = sav_p as *mut libc::c_void
                    as *mut libc::c_char;
                let mut b: libc::c_char = 0;
                memcpy(
                    &mut b as *mut libc::c_char as *mut libc::c_void,
                    sav_p as *const libc::c_void,
                    ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            });
            temp[tmp_i as usize] as libc::c_int != '\0' as i32
        }
    {
        tmp_i = tmp_i.wrapping_add(1);
        tmp_i;
    }
    temp[tmp_i as usize] = '\0' as i32 as libc::c_char;
    if strcmp(temp.as_mut_ptr(), timeattackfolder.as_mut_ptr()) != 0 {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    if sav_p >= end_p {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    backwardsCompat = ({
        let mut p_tmp: *mut uint16_t = sav_p as *mut libc::c_void as *mut uint16_t;
        let mut b: uint16_t = 0;
        memcpy(
            &mut b as *mut uint16_t as *mut libc::c_void,
            sav_p as *const libc::c_void,
            ::core::mem::size_of::<uint16_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    }) as int16_t;
    if backwardsCompat as libc::c_int != 32767 as libc::c_int {
        (*savegameinfo.offset(slot as isize))
            .skinnum = (backwardsCompat as libc::c_int
            & ((1 as libc::c_int) << 5 as libc::c_int) - 1 as libc::c_int) as uint8_t;
        if (*savegameinfo.offset(slot as isize)).skinnum as libc::c_int >= numskins
            || R_SkinUsable(
                -(1 as libc::c_int),
                (*savegameinfo.offset(slot as isize)).skinnum as int32_t,
            ) == 0
        {
            (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
            Z_Free(savebuffer as *mut libc::c_void);
            return;
        }
        (*savegameinfo.offset(slot as isize))
            .botskin = (backwardsCompat as libc::c_int >> 5 as libc::c_int) as uint8_t;
        if (*savegameinfo.offset(slot as isize)).botskin as libc::c_int
            - 1 as libc::c_int >= numskins
            || R_SkinUsable(
                -(1 as libc::c_int),
                (*savegameinfo.offset(slot as isize)).botskin as libc::c_int
                    - 1 as libc::c_int,
            ) == 0
        {
            (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
            Z_Free(savebuffer as *mut libc::c_void);
            return;
        }
    } else {
        let mut ourSkinName: [libc::c_char; 17] = [0; 17];
        let mut botSkinName: [libc::c_char; 17] = [0; 17];
        if sav_p >= end_p {
            (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
            Z_Free(savebuffer as *mut libc::c_void);
            return;
        }
        let mut tmp_i_0: size_t = 0 as libc::c_int as size_t;
        while tmp_i_0 < 16 as libc::c_int as size_t
            && {
                ourSkinName[tmp_i_0
                    as usize] = ({
                    let mut p_tmp: *mut libc::c_char = sav_p as *mut libc::c_void
                        as *mut libc::c_char;
                    let mut b: libc::c_char = 0;
                    memcpy(
                        &mut b as *mut libc::c_char as *mut libc::c_void,
                        sav_p as *const libc::c_void,
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    );
                    p_tmp = p_tmp.offset(1);
                    p_tmp;
                    sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
                    b
                });
                ourSkinName[tmp_i_0 as usize] as libc::c_int != '\0' as i32
            }
        {
            tmp_i_0 = tmp_i_0.wrapping_add(1);
            tmp_i_0;
        }
        ourSkinName[tmp_i_0 as usize] = '\0' as i32 as libc::c_char;
        (*savegameinfo.offset(slot as isize))
            .skinnum = R_SkinAvailable(ourSkinName.as_mut_ptr()) as uint8_t;
        if (*savegameinfo.offset(slot as isize)).skinnum as libc::c_int >= numskins
            || R_SkinUsable(
                -(1 as libc::c_int),
                (*savegameinfo.offset(slot as isize)).skinnum as int32_t,
            ) == 0
        {
            (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
            Z_Free(savebuffer as *mut libc::c_void);
            return;
        }
        if sav_p >= end_p {
            (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
            Z_Free(savebuffer as *mut libc::c_void);
            return;
        }
        let mut tmp_i_1: size_t = 0 as libc::c_int as size_t;
        while tmp_i_1 < 16 as libc::c_int as size_t
            && {
                botSkinName[tmp_i_1
                    as usize] = ({
                    let mut p_tmp: *mut libc::c_char = sav_p as *mut libc::c_void
                        as *mut libc::c_char;
                    let mut b: libc::c_char = 0;
                    memcpy(
                        &mut b as *mut libc::c_char as *mut libc::c_void,
                        sav_p as *const libc::c_void,
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    );
                    p_tmp = p_tmp.offset(1);
                    p_tmp;
                    sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
                    b
                });
                botSkinName[tmp_i_1 as usize] as libc::c_int != '\0' as i32
            }
        {
            tmp_i_1 = tmp_i_1.wrapping_add(1);
            tmp_i_1;
        }
        botSkinName[tmp_i_1 as usize] = '\0' as i32 as libc::c_char;
        (*savegameinfo.offset(slot as isize))
            .botskin = (R_SkinAvailable(botSkinName.as_mut_ptr()) + 1 as libc::c_int)
            as uint8_t;
        if (*savegameinfo.offset(slot as isize)).botskin as libc::c_int
            - 1 as libc::c_int >= numskins
            || R_SkinUsable(
                -(1 as libc::c_int),
                (*savegameinfo.offset(slot as isize)).botskin as libc::c_int
                    - 1 as libc::c_int,
            ) == 0
        {
            (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
            Z_Free(savebuffer as *mut libc::c_void);
            return;
        }
    }
    if sav_p >= end_p {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    (*savegameinfo.offset(slot as isize))
        .numgameovers = ({
        let mut p_tmp: *mut uint8_t = sav_p as *mut libc::c_void as *mut uint8_t;
        let mut b: uint8_t = 0;
        memcpy(
            &mut b as *mut uint8_t as *mut libc::c_void,
            sav_p as *const libc::c_void,
            ::core::mem::size_of::<uint8_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    });
    if sav_p >= end_p {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    (*savegameinfo.offset(slot as isize))
        .lives = ({
        let mut p_tmp: *mut int8_t = sav_p as *mut libc::c_void as *mut int8_t;
        let mut b: int8_t = 0;
        memcpy(
            &mut b as *mut int8_t as *mut libc::c_void,
            sav_p as *const libc::c_void,
            ::core::mem::size_of::<int8_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    }) as int32_t;
    if sav_p >= end_p {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    (*savegameinfo.offset(slot as isize))
        .continuescore = ({
        let mut p_tmp: *mut int32_t = sav_p as *mut libc::c_void as *mut int32_t;
        let mut b: int32_t = 0;
        memcpy(
            &mut b as *mut int32_t as *mut libc::c_void,
            sav_p as *const libc::c_void,
            ::core::mem::size_of::<int32_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    });
    if sav_p >= end_p {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    fake = ({
        let mut p_tmp: *mut int32_t = sav_p as *mut libc::c_void as *mut int32_t;
        let mut b: int32_t = 0;
        memcpy(
            &mut b as *mut int32_t as *mut libc::c_void,
            sav_p as *const libc::c_void,
            ::core::mem::size_of::<int32_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    });
    if useContinues != 0 {
        (*savegameinfo.offset(slot as isize)).continuescore = fake;
    }
    if sav_p >= end_p {
        (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
        Z_Free(savebuffer as *mut libc::c_void);
        return;
    }
    match ({
        let mut p_tmp: *mut uint8_t = sav_p as *mut libc::c_void as *mut uint8_t;
        let mut b: uint8_t = 0;
        memcpy(
            &mut b as *mut uint8_t as *mut libc::c_void,
            sav_p as *const libc::c_void,
            ::core::mem::size_of::<uint8_t>() as libc::c_ulong,
        );
        p_tmp = p_tmp.offset(1);
        p_tmp;
        sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
        b
    }) as libc::c_int
    {
        183 => {
            let mut i: uint8_t = 0;
            let mut banksinuse: uint8_t = 0;
            if sav_p >= end_p {
                (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
                Z_Free(savebuffer as *mut libc::c_void);
                return;
            }
            banksinuse = ({
                let mut p_tmp: *mut uint8_t = sav_p as *mut libc::c_void as *mut uint8_t;
                let mut b: uint8_t = 0;
                memcpy(
                    &mut b as *mut uint8_t as *mut libc::c_void,
                    sav_p as *const libc::c_void,
                    ::core::mem::size_of::<uint8_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            });
            if sav_p >= end_p {
                (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
                Z_Free(savebuffer as *mut libc::c_void);
                return;
            }
            if banksinuse as libc::c_int > 16 as libc::c_int {
                (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
                Z_Free(savebuffer as *mut libc::c_void);
                return;
            }
            i = 0 as libc::c_int as uint8_t;
            while (i as libc::c_int) < banksinuse as libc::c_int {
                ({
                    let mut p_tmp: *mut int32_t = sav_p as *mut libc::c_void
                        as *mut int32_t;
                    let mut b: int32_t = 0;
                    memcpy(
                        &mut b as *mut int32_t as *mut libc::c_void,
                        sav_p as *const libc::c_void,
                        ::core::mem::size_of::<int32_t>() as libc::c_ulong,
                    );
                    p_tmp = p_tmp.offset(1);
                    p_tmp;
                    sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
                    b
                });
                if sav_p >= end_p {
                    (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
                    Z_Free(savebuffer as *mut libc::c_void);
                    return;
                }
                i = i.wrapping_add(1);
                i;
            }
            if ({
                let mut p_tmp: *mut uint8_t = sav_p as *mut libc::c_void as *mut uint8_t;
                let mut b: uint8_t = 0;
                memcpy(
                    &mut b as *mut uint8_t as *mut libc::c_void,
                    sav_p as *const libc::c_void,
                    ::core::mem::size_of::<uint8_t>() as libc::c_ulong,
                );
                p_tmp = p_tmp.offset(1);
                p_tmp;
                sav_p = p_tmp as *mut libc::c_void as *mut uint8_t;
                b
            }) as libc::c_int != 0x1d as libc::c_int
            {
                (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
                Z_Free(savebuffer as *mut libc::c_void);
                return;
            }
        }
        29 => {}
        _ => {
            (*savegameinfo.offset(slot as isize)).lives = -(666 as libc::c_int);
            Z_Free(savebuffer as *mut libc::c_void);
            return;
        }
    }
    Z_Free(savebuffer as *mut libc::c_void);
}
unsafe extern "C" fn M_ReadSaveStrings() {
    let mut handle: *mut FILE = 0 as *mut FILE;
    let mut i: int8_t = 0;
    let mut name: [libc::c_char; 256] = [0; 256];
    let mut nofile: [boolean; 30] = [0; 30];
    let mut tolerance: int8_t = 3 as libc::c_int as int8_t;
    let mut lastseen: uint8_t = 0 as libc::c_int as uint8_t;
    loadgamescroll = 0 as libc::c_int;
    loadgameoffset = 14 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
    i = 1 as libc::c_int as int8_t;
    while (i as libc::c_int) < 31 as libc::c_int {
        snprintf(
            name.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            savegamename.as_mut_ptr(),
            i as libc::c_int,
        );
        name[(::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            as usize] = '\0' as i32 as libc::c_char;
        handle = fopen(name.as_mut_ptr(), b"rb\0" as *const u8 as *const libc::c_char);
        nofile[(i as libc::c_int - 1 as libc::c_int)
            as usize] = (handle == 0 as *mut libc::c_void as *mut FILE) as libc::c_int;
        if !(nofile[(i as libc::c_int - 1 as libc::c_int) as usize] != 0) {
            fclose(handle);
            lastseen = i as uint8_t;
        }
        i += 1;
        i;
    }
    if !savegameinfo.is_null() {
        Z_Free(savegameinfo as *mut libc::c_void);
    }
    savegameinfo = 0 as *mut saveinfo_t;
    if (lastseen as libc::c_int) < saveSlotSelected {
        lastseen = saveSlotSelected as uint8_t;
    }
    i = lastseen as int8_t;
    while lastseen as libc::c_int > 0 as libc::c_int && tolerance as libc::c_int != 0 {
        if nofile[(lastseen as libc::c_int - 1 as libc::c_int) as usize] != 0 {
            tolerance -= 1;
            tolerance;
        }
        lastseen = lastseen.wrapping_sub(1);
        lastseen;
    }
    i = (i as libc::c_int + (tolerance as libc::c_int + 1 as libc::c_int)) as int8_t;
    if i as libc::c_int > 31 as libc::c_int {
        i = 31 as libc::c_int as int8_t;
    }
    numsaves = i as uint8_t;
    savegameinfo = Z_ReallocAlign(
        savegameinfo as *mut libc::c_void,
        (numsaves as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<saveinfo_t>() as libc::c_ulong),
        PU_STATIC as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut saveinfo_t;
    if savegameinfo.is_null() {
        I_Error(
            b"Insufficient memory to prepare save platter\0" as *const u8
                as *const libc::c_char,
        );
    }
    while i as libc::c_int > 0 as libc::c_int {
        if nofile[(i as libc::c_int - 1 as libc::c_int) as usize]
            == true_0 as libc::c_int
        {
            (*savegameinfo.offset((i as libc::c_int - 1 as libc::c_int) as isize))
                .lives = -(42 as libc::c_int);
        } else {
            M_ReadSavegameInfo(i as uint32_t);
        }
        i -= 1;
        i;
    }
    M_CacheLoadGameData();
}
unsafe extern "C" fn M_SaveGameDeleteResponse(mut ch: int32_t) {
    let mut name: [libc::c_char; 256] = [0; 256];
    if ch != 'y' as i32 && ch != 13 as libc::c_int {
        return;
    }
    snprintf(
        name.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        savegamename.as_mut_ptr(),
        saveSlotSelected,
    );
    name[(::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as usize] = '\0' as i32 as libc::c_char;
    remove(name.as_mut_ptr());
    S_StartSound(
        0 as *const libc::c_void,
        (sfx_bewar1 as libc::c_int + M_RandomKey(4 as libc::c_int)) as sfxenum_t,
    );
    M_ReadSaveStrings();
}
unsafe extern "C" fn M_SaveGameUltimateResponse(mut ch: int32_t) {
    if ch != 'y' as i32 && ch != 13 as libc::c_int {
        return;
    }
    S_StartSound(0 as *const libc::c_void, sfx_menu1);
    M_LoadSelect(saveSlotSelected);
    SP_PlayerDef.prevMenu = MessageDef.prevMenu;
    MessageDef.prevMenu = &mut SP_PlayerDef;
}
unsafe extern "C" fn M_HandleLoadSave(mut choice: int32_t) {
    let mut exitmenu: boolean = false_0 as libc::c_int;
    match choice {
        235 => {
            S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
            saveSlotSelected += 1;
            saveSlotSelected;
            if saveSlotSelected >= numsaves as libc::c_int {
                saveSlotSelected -= numsaves as libc::c_int;
            }
            loadgamescroll = 90 as libc::c_int
                * ((1 as libc::c_int) << 16 as libc::c_int);
        }
        233 => {
            S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
            saveSlotSelected -= 1;
            saveSlotSelected;
            if saveSlotSelected < 0 as libc::c_int {
                saveSlotSelected += numsaves as libc::c_int;
            }
            loadgamescroll = -(90 as libc::c_int)
                * ((1 as libc::c_int) << 16 as libc::c_int);
        }
        13 => {
            if ultimate_selectable != 0 && saveSlotSelected == 0 as libc::c_int
                && savemoddata == 0
            {
                loadgamescroll = 0 as libc::c_int;
                S_StartSound(0 as *const libc::c_void, sfx_skid);
                M_StartMessage(
                    b"Are you sure you want to play\n\x85ultimate mode\x80? It isn't remotely fair,\nand you don't even get an emblem for it.\n\n(Press 'Y' to confirm)\n\0"
                        as *const u8 as *const libc::c_char,
                    ::core::mem::transmute::<
                        Option::<unsafe extern "C" fn(int32_t) -> ()>,
                        *mut libc::c_void,
                    >(
                        Some(
                            M_SaveGameUltimateResponse
                                as unsafe extern "C" fn(int32_t) -> (),
                        ),
                    ),
                    MM_YESNO,
                );
            } else if saveSlotSelected != 0 as libc::c_int
                && (*savegameinfo.offset((saveSlotSelected - 1 as libc::c_int) as isize))
                    .lives == -(42 as libc::c_int) && usedCheats != 0
            {
                loadgamescroll = 0 as libc::c_int;
                S_StartSound(0 as *const libc::c_void, sfx_skid);
                M_StartMessage(
                    b"This cannot be done in a cheated game.\n\n(Press a key)\n\0"
                        as *const u8 as *const libc::c_char,
                    0 as *mut libc::c_void,
                    MM_NOTHING,
                );
            } else if saveSlotSelected == 0 as libc::c_int
                || (*savegameinfo.offset((saveSlotSelected - 1 as libc::c_int) as isize))
                    .lives != -(666 as libc::c_int)
            {
                loadgamescroll = 0 as libc::c_int;
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                M_LoadSelect(saveSlotSelected);
            } else if loadgameoffset == 0 {
                S_StartSound(0 as *const libc::c_void, sfx_lose);
                loadgameoffset = 14 as libc::c_int
                    * ((1 as libc::c_int) << 16 as libc::c_int);
            }
        }
        27 => {
            exitmenu = true_0 as libc::c_int;
        }
        8 => {
            if saveSlotSelected != 0 as libc::c_int
                && (*savegameinfo.offset((saveSlotSelected - 1 as libc::c_int) as isize))
                    .lives != -(42 as libc::c_int)
            {
                loadgamescroll = 0 as libc::c_int;
                S_StartSound(0 as *const libc::c_void, sfx_skid);
                M_StartMessage(
                    va(
                        b"Are you sure you want to delete\nsave file %d?\n\n(Press 'Y' to confirm)\n\0"
                            as *const u8 as *const libc::c_char,
                        saveSlotSelected,
                    ),
                    ::core::mem::transmute::<
                        Option::<unsafe extern "C" fn(int32_t) -> ()>,
                        *mut libc::c_void,
                    >(
                        Some(
                            M_SaveGameDeleteResponse
                                as unsafe extern "C" fn(int32_t) -> (),
                        ),
                    ),
                    MM_YESNO,
                );
            } else if loadgameoffset == 0 {
                if saveSlotSelected == 0 as libc::c_int && ultimate_selectable != 0 {
                    ultimate_selectable = false_0 as libc::c_int;
                    S_StartSound(0 as *const libc::c_void, sfx_strpst);
                } else {
                    S_StartSound(0 as *const libc::c_void, sfx_lose);
                }
                loadgameoffset = 14 as libc::c_int
                    * ((1 as libc::c_int) << 16 as libc::c_int);
            }
        }
        _ => {}
    }
    if exitmenu != 0 {
        charseltimer = 0 as libc::c_int;
        if !((*currentMenu).prevMenu).is_null() {
            M_SetupNextMenu((*currentMenu).prevMenu);
        } else {
            M_ClearMenus(true_0 as libc::c_int);
        }
        Z_Free(savegameinfo as *mut libc::c_void);
        savegameinfo = 0 as *mut saveinfo_t;
    }
}
unsafe extern "C" fn M_FirstTimeResponse(mut ch: int32_t) {
    S_StartSound(0 as *const libc::c_void, sfx_menu1);
    if ch == 27 as libc::c_int {
        return;
    }
    if ch != 'y' as i32 && ch != 13 as libc::c_int {
        CV_SetValue(&mut cv_tutorialprompt, 0 as libc::c_int);
        M_ReadSaveStrings();
        MessageDef.prevMenu = &mut SP_LoadDef;
    } else {
        M_StartTutorial(0 as libc::c_int);
        MessageDef.prevMenu = &mut MessageDef;
    };
}
unsafe extern "C" fn M_LoadGame(mut choice: int32_t) {
    if tutorialmap as libc::c_int != 0 && cv_tutorialprompt.value != 0 {
        M_StartMessage(
            b"Do you want to \x82play a brief Tutorial\x80?\n\nWe highly recommend this because \nthe controls are slightly different \nfrom other games.\n\nPress the\x82 Y\x80 key or the\x83 A button\x80 to go\nPress the\x82 N\x80 key or the\x83 Y button\x80 to skip\n\0"
                as *const u8 as *const libc::c_char,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(int32_t) -> ()>,
                *mut libc::c_void,
            >(Some(M_FirstTimeResponse as unsafe extern "C" fn(int32_t) -> ())),
            MM_YESNO,
        );
        return;
    }
    M_ReadSaveStrings();
    M_SetupNextMenu(&mut SP_LoadDef);
}
#[no_mangle]
pub unsafe extern "C" fn M_ForceSaveSlotSelected(mut sslot: int32_t) {
    loadgameoffset = 14 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
    if sslot == saveSlotSelected {
        return;
    }
    loadgamescroll = 90 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
    if saveSlotSelected <= numsaves as libc::c_int / 2 as libc::c_int {
        loadgamescroll = -loadgamescroll;
    }
    saveSlotSelected = sslot;
}
unsafe extern "C" fn M_CacheCharacterSelectEntry(mut i: int32_t, mut skinnum: int32_t) {
    if description[i as usize].picname[0 as libc::c_int as usize] == 0 {
        if skins[skinnum as usize].sprites[SPR2_XTRA as libc::c_int as usize].numframes
            > 1 as libc::c_int as size_t
        {
            let mut sprdef: *mut spritedef_t = &mut *((*skins
                .as_mut_ptr()
                .offset(skinnum as isize))
                .sprites)
                .as_mut_ptr()
                .offset(SPR2_XTRA as libc::c_int as isize) as *mut spritedef_t;
            let mut sprframe: *mut spriteframe_t = &mut *((*sprdef).spriteframes)
                .offset(1 as libc::c_int as isize) as *mut spriteframe_t;
            description[i as usize]
                .charpic = W_CachePatchNum(
                (*sprframe).lumppat[0 as libc::c_int as usize],
                PU_PATCH as libc::c_int,
            ) as *mut patch_t;
        } else {
            description[i as usize]
                .charpic = W_CachePatchName(
                b"MISSING\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t;
        }
    } else {
        description[i as usize]
            .charpic = W_CachePatchName(
            (description[i as usize].picname).as_mut_ptr(),
            PU_PATCH as libc::c_int,
        ) as *mut patch_t;
    }
    if description[i as usize].nametag[0 as libc::c_int as usize] != 0 {
        description[i as usize]
            .namepic = W_CachePatchName(
            (description[i as usize].nametag).as_mut_ptr(),
            PU_PATCH as libc::c_int,
        ) as *mut patch_t;
    }
}
unsafe extern "C" fn M_SetupChoosePlayerDirect(mut choice: int32_t) -> uint8_t {
    let mut skinnum: int32_t = 0;
    let mut botskinnum: int32_t = 0;
    let mut i: uint8_t = 0;
    let mut firstvalid: uint8_t = 255 as libc::c_int as uint8_t;
    let mut lastvalid: uint8_t = 255 as libc::c_int as uint8_t;
    let mut allowed: boolean = false_0 as libc::c_int;
    let mut and: *mut libc::c_char = 0 as *mut libc::c_char;
    if (mapheaderinfo[(startmap as libc::c_int - 1 as libc::c_int) as usize]).is_null()
        || (*mapheaderinfo[(startmap as libc::c_int - 1 as libc::c_int) as usize])
            .forcecharacter[0 as libc::c_int as usize] as libc::c_int == '\0' as i32
    {
        let mut current_block_20: u64;
        i = 0 as libc::c_int as uint8_t;
        while (i as libc::c_int) < 32 as libc::c_int {
            if description[i as usize].used != 0 {
                and = strchr(
                    (description[i as usize].skinname).as_mut_ptr(),
                    '&' as i32,
                );
                if !and.is_null() {
                    let mut firstskin: [libc::c_char; 17] = [0; 17];
                    if !(mapheaderinfo[(startmap as libc::c_int - 1 as libc::c_int)
                        as usize])
                        .is_null()
                        && (*mapheaderinfo[(startmap as libc::c_int - 1 as libc::c_int)
                            as usize])
                            .typeoflevel & TOL_NIGHTS as libc::c_int as uint32_t != 0
                    {
                        current_block_20 = 4644295000439058019;
                    } else {
                        strncpy(
                            firstskin.as_mut_ptr(),
                            (description[i as usize].skinname).as_mut_ptr(),
                            and
                                .offset_from(
                                    (description[i as usize].skinname).as_mut_ptr(),
                                ) as libc::c_long as libc::c_ulong,
                        );
                        firstskin[and
                            .offset_from((description[i as usize].skinname).as_mut_ptr())
                            as libc::c_long as usize] = '\0' as i32 as libc::c_char;
                        description[i as usize]
                            .skinnum[0 as libc::c_int
                            as usize] = R_SkinAvailable(firstskin.as_mut_ptr())
                            as int8_t;
                        description[i as usize]
                            .skinnum[1 as libc::c_int
                            as usize] = R_SkinAvailable(
                            and.offset(1 as libc::c_int as isize),
                        ) as int8_t;
                        current_block_20 = 12800627514080957624;
                    }
                } else {
                    description[i as usize]
                        .skinnum[0 as libc::c_int
                        as usize] = R_SkinAvailable(
                        (description[i as usize].skinname).as_mut_ptr(),
                    ) as int8_t;
                    description[i as usize]
                        .skinnum[1 as libc::c_int
                        as usize] = -(1 as libc::c_int) as int8_t;
                    current_block_20 = 12800627514080957624;
                }
                match current_block_20 {
                    4644295000439058019 => {}
                    _ => {
                        skinnum = description[i as usize]
                            .skinnum[0 as libc::c_int as usize] as int32_t;
                        if skinnum != -(1 as libc::c_int)
                            && R_SkinUsable(-(1 as libc::c_int), skinnum) != 0
                        {
                            botskinnum = description[i as usize]
                                .skinnum[1 as libc::c_int as usize] as int32_t;
                            if !(botskinnum != -(1 as libc::c_int)
                                && R_SkinUsable(-(1 as libc::c_int), botskinnum) == 0)
                            {
                                if firstvalid as libc::c_int == 255 as libc::c_int {
                                    firstvalid = i;
                                } else {
                                    description[i as usize].prev = lastvalid;
                                    description[lastvalid as usize].next = i;
                                }
                                lastvalid = i;
                                if i as libc::c_int == char_on as libc::c_int {
                                    allowed = true_0 as libc::c_int;
                                }
                                M_CacheCharacterSelectEntry(i as int32_t, skinnum);
                            }
                        }
                    }
                }
            }
            i = i.wrapping_add(1);
            i;
        }
    }
    if firstvalid as libc::c_int == lastvalid as libc::c_int {
        return firstvalid;
    }
    description[firstvalid as usize].prev = lastvalid;
    description[lastvalid as usize].next = firstvalid;
    if allowed == 0 {
        char_on = firstvalid as int16_t;
        if startchar as libc::c_int > 0 as libc::c_int
            && (startchar as libc::c_int) < 32 as libc::c_int
        {
            let mut workchar: int16_t = startchar;
            loop {
                let fresh14 = workchar;
                workchar = workchar - 1;
                if !(fresh14 != 0) {
                    break;
                }
                char_on = description[char_on as usize].next as int16_t;
            }
        }
    }
    return 32 as libc::c_int as uint8_t;
}
unsafe extern "C" fn M_SetupChoosePlayer(mut choice: int32_t) {
    let mut skinset: uint8_t = M_SetupChoosePlayerDirect(choice);
    if skinset as libc::c_int != 32 as libc::c_int {
        M_ChoosePlayer(skinset as int32_t);
        return;
    }
    M_ChangeMenuMusic(
        b"_chsel\0" as *const u8 as *const libc::c_char,
        true_0 as libc::c_int,
    );
    if currentMenu == &mut SP_LoadDef as *mut menu_t {
        SP_PlayerDef
            .menuid = (MN_SP_MAIN as libc::c_int
            | (MN_SP_LOAD as libc::c_int
                | (MN_SP_PLAYER as libc::c_int) << 6 as libc::c_int) << 6 as libc::c_int)
            as uint32_t;
    } else {
        SP_PlayerDef
            .menuid = (MN_SR_MAIN as libc::c_int
            | (MN_SR_PLAYER as libc::c_int) << 6 as libc::c_int) as uint32_t;
    }
    SP_PlayerDef.prevMenu = currentMenu;
    M_SetupNextMenu(&mut SP_PlayerDef);
    char_scroll = 0 as libc::c_int;
    charseltimer = 0 as libc::c_int;
    Z_Free(char_notes as *mut libc::c_void);
    char_notes = V_WordWrap(
        0 as libc::c_int,
        21 as libc::c_int * 8 as libc::c_int,
        0x800000 as libc::c_int,
        (description[char_on as usize].notes).as_mut_ptr(),
    );
}
unsafe extern "C" fn M_HandleChoosePlayerMenu(mut choice: int32_t) {
    let mut exitmenu: boolean = false_0 as libc::c_int;
    let mut selectval: int32_t = 0;
    if keydown > 1 as libc::c_int as tic_t {
        return;
    }
    match choice {
        238 => {
            selectval = description[char_on as usize].next as int32_t;
            if selectval != char_on as libc::c_int {
                S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
                char_on = selectval as int16_t;
                char_scroll = -(128 as libc::c_int)
                    * ((1 as libc::c_int) << 16 as libc::c_int);
                Z_Free(char_notes as *mut libc::c_void);
                char_notes = V_WordWrap(
                    0 as libc::c_int,
                    21 as libc::c_int * 8 as libc::c_int,
                    0x800000 as libc::c_int,
                    (description[char_on as usize].notes).as_mut_ptr(),
                );
            } else if char_scroll == 0 {
                S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
                char_scroll = 16 as libc::c_int
                    * ((1 as libc::c_int) << 16 as libc::c_int);
            }
        }
        230 => {
            selectval = description[char_on as usize].prev as int32_t;
            if selectval != char_on as libc::c_int {
                S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
                char_on = selectval as int16_t;
                char_scroll = 128 as libc::c_int
                    * ((1 as libc::c_int) << 16 as libc::c_int);
                Z_Free(char_notes as *mut libc::c_void);
                char_notes = V_WordWrap(
                    0 as libc::c_int,
                    21 as libc::c_int * 8 as libc::c_int,
                    0x800000 as libc::c_int,
                    (description[char_on as usize].notes).as_mut_ptr(),
                );
            } else if char_scroll == 0 {
                S_StartSound(0 as *const libc::c_void, sfx_s3kb7);
                char_scroll = -(16 as libc::c_int)
                    * ((1 as libc::c_int) << 16 as libc::c_int);
            }
        }
        13 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            char_scroll = 0 as libc::c_int;
            M_DrawSetupChoosePlayerMenu();
            charseltimer = 0 as libc::c_int;
            M_ChoosePlayer(char_on as int32_t);
        }
        27 => {
            exitmenu = true_0 as libc::c_int;
        }
        _ => {}
    }
    if exitmenu != 0 {
        charseltimer = 0 as libc::c_int;
        if !((*currentMenu).prevMenu).is_null() {
            M_SetupNextMenu((*currentMenu).prevMenu);
        } else {
            M_ClearMenus(true_0 as libc::c_int);
        }
    }
}
unsafe extern "C" fn M_DrawSetupChoosePlayerMenu() {
    let my: int32_t = 16 as libc::c_int;
    let mut charskin: *mut skin_t = &mut *skins
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize) as *mut skin_t;
    let mut skinnum: int32_t = 0 as libc::c_int;
    let mut col: uint16_t = 0;
    let mut colormap: *mut uint8_t = 0 as *mut uint8_t;
    let mut prev: int32_t = -(1 as libc::c_int);
    let mut next: int32_t = -(1 as libc::c_int);
    let mut charbg: *mut patch_t = W_CachePatchName(
        b"CHARBG\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    let mut charfg: *mut patch_t = W_CachePatchName(
        b"CHARFG\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    let mut bgheight: int16_t = (*charbg).height;
    let mut fgheight: int16_t = (*charfg).height;
    let mut bgwidth: int16_t = (*charbg).width;
    let mut fgwidth: int16_t = (*charfg).width;
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut w: int32_t = vid.width / vid.dupx;
    if abs(char_scroll) > ((1 as libc::c_int) << 16 as libc::c_int) / 4 as libc::c_int {
        char_scroll -= FixedMul(char_scroll >> 2 as libc::c_int, renderdeltatics);
    } else {
        char_scroll = 0 as libc::c_int;
    }
    prev = description[char_on as usize].prev as int32_t;
    if prev != char_on as libc::c_int {
        next = description[char_on as usize].next as int32_t;
    } else {
        prev = -(1 as libc::c_int);
    }
    skinnum = description[char_on as usize].skinnum[0 as libc::c_int as usize]
        as int32_t;
    charskin = &mut *skins.as_mut_ptr().offset(skinnum as isize) as *mut skin_t;
    col = description[char_on as usize].oppositecolor;
    if col == 0 {
        col = skincolors[(*charskin).prefcolor as usize].invcolor;
    }
    colormap = R_GetTranslationColormap(
        TC_DEFAULT as libc::c_int,
        col as skincolornum_t,
        1 as libc::c_int as uint8_t,
    );
    hidetitlemap = true_0 as libc::c_int;
    charseltimer += renderdeltatics;
    V_DrawFill(
        0 as libc::c_int,
        0 as libc::c_int,
        bgwidth as int32_t,
        vid.height,
        0x1000000 as libc::c_int
            | *colormap.offset(101 as libc::c_int as isize) as libc::c_int,
    );
    let mut sw: int32_t = 320 as libc::c_int * vid.dupx;
    let mut bw: int32_t = (vid.width - sw) / 2 as libc::c_int;
    col = *colormap.offset(106 as libc::c_int as isize) as uint16_t;
    if bw != 0 {
        V_DrawFill(
            0 as libc::c_int,
            0 as libc::c_int,
            bw,
            vid.height,
            0x40000000 as libc::c_int | col as libc::c_int,
        );
    }
    y = charseltimer / ((1 as libc::c_int) << 16 as libc::c_int) % 32 as libc::c_int;
    V_DrawStretchyFixedPatch(
        (0 as libc::c_int) << 16 as libc::c_int,
        (y - bgheight as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0x1000000 as libc::c_int,
        charbg,
        colormap,
    );
    V_DrawStretchyFixedPatch(
        (0 as libc::c_int) << 16 as libc::c_int,
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0x1000000 as libc::c_int,
        charbg,
        colormap,
    );
    V_DrawStretchyFixedPatch(
        (0 as libc::c_int) << 16 as libc::c_int,
        (y + bgheight as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0x1000000 as libc::c_int,
        charbg,
        colormap,
    );
    V_DrawStretchyFixedPatch(
        (0 as libc::c_int) << 16 as libc::c_int,
        -y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0x1000000 as libc::c_int,
        charfg,
        colormap,
    );
    V_DrawStretchyFixedPatch(
        (0 as libc::c_int) << 16 as libc::c_int,
        (-y + fgheight as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0x1000000 as libc::c_int,
        charfg,
        colormap,
    );
    V_DrawFill(
        fgwidth as int32_t,
        0 as libc::c_int,
        vid.width,
        vid.height,
        0x1000000 as libc::c_int
            | *colormap.offset(106 as libc::c_int as isize) as libc::c_int,
    );
    x = 8 as libc::c_int;
    y = my + 16 as libc::c_int - FixedInt(char_scroll);
    V_DrawStretchyFixedPatch(
        x * ((1 as libc::c_int) << 16 as libc::c_int),
        y << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        description[char_on as usize].charpic,
        0 as *const uint8_t,
    );
    if prev != -(1 as libc::c_int) {
        V_DrawStretchyFixedPatch(
            x * ((1 as libc::c_int) << 16 as libc::c_int),
            (y - 144 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0 as libc::c_int,
            description[prev as usize].charpic,
            0 as *const uint8_t,
        );
    }
    if next != -(1 as libc::c_int) {
        V_DrawStretchyFixedPatch(
            x * ((1 as libc::c_int) << 16 as libc::c_int),
            (y + 144 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0 as libc::c_int,
            description[next as usize].charpic,
            0 as *const uint8_t,
        );
    }
    let mut flags: int32_t = 0x800000 as libc::c_int | 0x20000000 as libc::c_int;
    x = 146 as libc::c_int;
    y = my + 9 as libc::c_int;
    V_DrawString(x, y, flags, char_notes);
    let mut ox: int32_t = 0;
    let mut oxsh: int32_t = FixedInt(
        FixedMul(
            320 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
            FixedDiv(
                char_scroll,
                128 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
            ),
        ),
    );
    let mut txsh: int32_t = 0;
    let mut curpatch: *mut patch_t = 0 as *mut patch_t;
    let mut prevpatch: *mut patch_t = 0 as *mut patch_t;
    let mut nextpatch: *mut patch_t = 0 as *mut patch_t;
    let mut curtext: *const libc::c_char = 0 as *const libc::c_char;
    let mut prevtext: *const libc::c_char = 0 as *const libc::c_char;
    let mut nexttext: *const libc::c_char = 0 as *const libc::c_char;
    let mut curtextcolor: uint16_t = 0 as libc::c_int as uint16_t;
    let mut prevtextcolor: uint16_t = 0 as libc::c_int as uint16_t;
    let mut nexttextcolor: uint16_t = 0 as libc::c_int as uint16_t;
    let mut curoutlinecolor: uint16_t = 0 as libc::c_int as uint16_t;
    let mut prevoutlinecolor: uint16_t = 0 as libc::c_int as uint16_t;
    let mut nextoutlinecolor: uint16_t = 0 as libc::c_int as uint16_t;
    curtext = (description[char_on as usize].displayname).as_mut_ptr();
    curtextcolor = description[char_on as usize].tagtextcolor;
    curoutlinecolor = description[char_on as usize].tagoutlinecolor;
    if *curtext.offset(0 as libc::c_int as isize) as libc::c_int == '\0' as i32 {
        curpatch = description[char_on as usize].namepic;
    }
    if curtextcolor == 0 {
        curtextcolor = (*charskin).prefcolor;
    }
    if curoutlinecolor == 0 {
        col = skincolors[(*charskin).prefcolor as usize].invcolor;
        curoutlinecolor = col;
    }
    txsh = oxsh;
    ox = 8 as libc::c_int
        + (*description[char_on as usize].charpic).width as libc::c_int
            / 2 as libc::c_int;
    y = my + 144 as libc::c_int;
    x = ox - txsh;
    if !curpatch.is_null() {
        x -= (*curpatch).width as libc::c_int / 2 as libc::c_int;
    }
    if *curtext.offset(0 as libc::c_int as isize) as libc::c_int != '\0' as i32 {
        V_DrawNameTag(
            x,
            y,
            0x800000 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            R_GetTranslationColormap(
                TC_DEFAULT as libc::c_int,
                curtextcolor as skincolornum_t,
                1 as libc::c_int as uint8_t,
            ),
            R_GetTranslationColormap(
                TC_DEFAULT as libc::c_int,
                curoutlinecolor as skincolornum_t,
                1 as libc::c_int as uint8_t,
            ),
            curtext,
        );
    } else if !curpatch.is_null() {
        V_DrawStretchyFixedPatch(
            x * ((1 as libc::c_int) << 16 as libc::c_int),
            y << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0 as libc::c_int,
            curpatch,
            0 as *const uint8_t,
        );
    }
    if char_scroll != 0 {
        if prev != -(1 as libc::c_int) && char_scroll < 0 as libc::c_int {
            prevtext = (description[prev as usize].displayname).as_mut_ptr();
            prevtextcolor = description[prev as usize].tagtextcolor;
            prevoutlinecolor = description[prev as usize].tagoutlinecolor;
            if *prevtext.offset(0 as libc::c_int as isize) as libc::c_int == '\0' as i32
            {
                prevpatch = description[prev as usize].namepic;
            }
            charskin = &mut *skins
                .as_mut_ptr()
                .offset(
                    *((*description.as_mut_ptr().offset(prev as isize)).skinnum)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize) as isize,
                ) as *mut skin_t;
            if prevtextcolor == 0 {
                prevtextcolor = (*charskin).prefcolor;
            }
            if prevoutlinecolor == 0 {
                col = skincolors[(*charskin).prefcolor as usize].invcolor;
                prevoutlinecolor = col;
            }
            x = ox - txsh - w;
            if !prevpatch.is_null() {
                x -= (*prevpatch).width as libc::c_int / 2 as libc::c_int;
            }
            if *prevtext.offset(0 as libc::c_int as isize) as libc::c_int != '\0' as i32
            {
                V_DrawNameTag(
                    x,
                    y,
                    0x800000 as libc::c_int,
                    (1 as libc::c_int) << 16 as libc::c_int,
                    R_GetTranslationColormap(
                        TC_DEFAULT as libc::c_int,
                        prevtextcolor as skincolornum_t,
                        1 as libc::c_int as uint8_t,
                    ),
                    R_GetTranslationColormap(
                        TC_DEFAULT as libc::c_int,
                        prevoutlinecolor as skincolornum_t,
                        1 as libc::c_int as uint8_t,
                    ),
                    prevtext,
                );
            } else if !prevpatch.is_null() {
                V_DrawStretchyFixedPatch(
                    x * ((1 as libc::c_int) << 16 as libc::c_int),
                    y << 16 as libc::c_int,
                    (1 as libc::c_int) << 16 as libc::c_int,
                    (1 as libc::c_int) << 16 as libc::c_int,
                    0 as libc::c_int,
                    prevpatch,
                    0 as *const uint8_t,
                );
            }
        } else if next != -(1 as libc::c_int) && char_scroll > 0 as libc::c_int {
            nexttext = (description[next as usize].displayname).as_mut_ptr();
            nexttextcolor = description[next as usize].tagtextcolor;
            nextoutlinecolor = description[next as usize].tagoutlinecolor;
            if *nexttext.offset(0 as libc::c_int as isize) as libc::c_int == '\0' as i32
            {
                nextpatch = description[next as usize].namepic;
            }
            charskin = &mut *skins
                .as_mut_ptr()
                .offset(
                    *((*description.as_mut_ptr().offset(next as isize)).skinnum)
                        .as_mut_ptr()
                        .offset(0 as libc::c_int as isize) as isize,
                ) as *mut skin_t;
            if nexttextcolor == 0 {
                nexttextcolor = (*charskin).prefcolor;
            }
            if nextoutlinecolor == 0 {
                col = skincolors[(*charskin).prefcolor as usize].invcolor;
                nextoutlinecolor = col;
            }
            x = ox - txsh + w;
            if !nextpatch.is_null() {
                x -= (*nextpatch).width as libc::c_int / 2 as libc::c_int;
            }
            if *nexttext.offset(0 as libc::c_int as isize) as libc::c_int != '\0' as i32
            {
                V_DrawNameTag(
                    x,
                    y,
                    0x800000 as libc::c_int,
                    (1 as libc::c_int) << 16 as libc::c_int,
                    R_GetTranslationColormap(
                        TC_DEFAULT as libc::c_int,
                        nexttextcolor as skincolornum_t,
                        1 as libc::c_int as uint8_t,
                    ),
                    R_GetTranslationColormap(
                        TC_DEFAULT as libc::c_int,
                        nextoutlinecolor as skincolornum_t,
                        1 as libc::c_int as uint8_t,
                    ),
                    nexttext,
                );
            } else if !nextpatch.is_null() {
                V_DrawStretchyFixedPatch(
                    x * ((1 as libc::c_int) << 16 as libc::c_int),
                    y << 16 as libc::c_int,
                    (1 as libc::c_int) << 16 as libc::c_int,
                    (1 as libc::c_int) << 16 as libc::c_int,
                    0 as libc::c_int,
                    nextpatch,
                    0 as *const uint8_t,
                );
            }
        }
    }
    M_DrawMenuTitle();
}
unsafe extern "C" fn M_ChoosePlayer(mut choice: int32_t) {
    let mut ultmode: boolean = if currentMenu == &mut SP_MarathonDef as *mut menu_t {
        (cv_dummymarathon.value == 2 as libc::c_int) as libc::c_int
    } else {
        (ultimate_selectable != 0
            && SP_PlayerDef.prevMenu == &mut SP_LoadDef as *mut menu_t
            && saveSlotSelected == 0 as libc::c_int) as libc::c_int
    };
    let mut skinnum: uint8_t = 0;
    if choice == 255 as libc::c_int {
        botskin = 0 as libc::c_int as uint8_t;
        skinnum = botskin;
        botingame = false_0 as libc::c_int;
    } else {
        skinnum = description[choice as usize].skinnum[0 as libc::c_int as usize]
            as uint8_t;
        botingame = (description[choice as usize].skinnum[1 as libc::c_int as usize]
            as libc::c_int != -(1 as libc::c_int)) as libc::c_int;
        if botingame != 0 {
            botskin = (description[choice as usize].skinnum[1 as libc::c_int as usize]
                as libc::c_int + 1 as libc::c_int) as uint8_t;
            botcolor = skins[description[choice as usize]
                    .skinnum[1 as libc::c_int as usize] as usize]
                .prefcolor;
        } else {
            botcolor = 0 as libc::c_int as uint16_t;
            botskin = botcolor as uint8_t;
        }
    }
    M_ClearMenus(true_0 as libc::c_int);
    if marathonmode as u64 == 0
        && startmap as libc::c_int != spstage_start as libc::c_int
    {
        cursaveslot = 0 as libc::c_int;
    }
    gamecomplete = 0 as libc::c_int as uint8_t;
    G_DeferedInitNew(
        ultmode,
        G_BuildMapName(startmap as int32_t),
        skinnum as int32_t,
        false_0 as libc::c_int,
        fromlevelselect,
    );
    COM_BufAddTextEx(
        b"dummyconsvar 1\n\0" as *const u8 as *const libc::c_char,
        0 as com_flags_t,
    );
    if !(levelselect.rows).is_null() {
        Z_Free(levelselect.rows as *mut libc::c_void);
    }
    levelselect.rows = 0 as *mut levelselectrow_t;
    if !savegameinfo.is_null() {
        Z_Free(savegameinfo as *mut libc::c_void);
    }
    savegameinfo = 0 as *mut saveinfo_t;
}
static mut statsLocation: int32_t = 0;
static mut statsMax: int32_t = 0;
static mut statsMapList: [int16_t; 1036] = [0; 1036];
unsafe extern "C" fn M_Statistics(mut choice: int32_t) {
    let mut i: int16_t = 0;
    let mut j: int16_t = 0 as libc::c_int as int16_t;
    memset(
        statsMapList.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[int16_t; 1036]>() as libc::c_ulong,
    );
    i = 0 as libc::c_int as int16_t;
    while (i as libc::c_int) < 1035 as libc::c_int {
        if !((mapheaderinfo[i as usize]).is_null()
            || (*mapheaderinfo[i as usize]).lvlttl[0 as libc::c_int as usize]
                as libc::c_int == '\0' as i32)
        {
            if !((*mapheaderinfo[i as usize]).typeoflevel
                & TOL_SP as libc::c_int as uint32_t == 0
                || (*mapheaderinfo[i as usize]).menuflags as libc::c_int
                    & 2 as libc::c_int != 0)
            {
                if !((*clientGamedata).mapvisited[i as usize] as libc::c_int
                    & 63 as libc::c_int == 0)
                {
                    let fresh15 = j;
                    j = j + 1;
                    statsMapList[fresh15 as usize] = i;
                }
            }
        }
        i += 1;
        i;
    }
    statsMapList[j as usize] = -(1 as libc::c_int) as int16_t;
    statsMax = j as libc::c_int - 11 as libc::c_int + numextraemblems;
    statsLocation = 0 as libc::c_int;
    if statsMax < 0 as libc::c_int {
        statsMax = 0 as libc::c_int;
    }
    M_SetupNextMenu(&mut SP_LevelStatsDef);
}
unsafe extern "C" fn M_DrawStatsMaps(mut location: libc::c_int) {
    let mut current_block: u64;
    let mut data: *mut gamedata_t = clientGamedata;
    let mut y: int32_t = 80 as libc::c_int;
    let mut i: int32_t = -(1 as libc::c_int);
    let mut mnum: int16_t = 0;
    let mut exemblem: *mut extraemblem_t = 0 as *mut extraemblem_t;
    let mut dotopname: boolean = true_0 as libc::c_int;
    let mut dobottomarrow: boolean = (location < statsMax) as libc::c_int;
    if location != 0 {
        V_DrawString(
            10 as libc::c_int,
            y - skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1A\0" as *const u8 as *const libc::c_char,
        );
    }
    loop {
        i += 1;
        if !(statsMapList[i as usize] as libc::c_int != -(1 as libc::c_int)) {
            current_block = 7149356873433890176;
            break;
        }
        if location != 0 {
            location -= 1;
            location;
        } else {
            if dotopname != 0 {
                V_DrawString(
                    20 as libc::c_int,
                    y,
                    0x3000 as libc::c_int,
                    b"LEVEL NAME\0" as *const u8 as *const libc::c_char,
                );
                V_DrawString(
                    248 as libc::c_int,
                    y,
                    0x3000 as libc::c_int,
                    b"EMBLEMS\0" as *const u8 as *const libc::c_char,
                );
                y += 8 as libc::c_int;
                dotopname = false_0 as libc::c_int;
            }
            mnum = statsMapList[i as usize];
            M_DrawMapEmblems(
                mnum as libc::c_int + 1 as libc::c_int,
                292 as libc::c_int,
                y,
                false_0 as libc::c_int,
            );
            if (*mapheaderinfo[mnum as usize]).actnum as libc::c_int != 0 as libc::c_int
            {
                V_DrawString(
                    20 as libc::c_int,
                    y,
                    0x2000 as libc::c_int | 0x800000 as libc::c_int,
                    va(
                        b"%s %d\0" as *const u8 as *const libc::c_char,
                        ((*mapheaderinfo[mnum as usize]).lvlttl).as_mut_ptr(),
                        (*mapheaderinfo[mnum as usize]).actnum as libc::c_int,
                    ),
                );
            } else {
                V_DrawString(
                    20 as libc::c_int,
                    y,
                    0x2000 as libc::c_int | 0x800000 as libc::c_int,
                    ((*mapheaderinfo[mnum as usize]).lvlttl).as_mut_ptr(),
                );
            }
            y += 8 as libc::c_int;
            if y >= 200 as libc::c_int - 8 as libc::c_int {
                current_block = 17623562190876951919;
                break;
            }
        }
    }
    match current_block {
        7149356873433890176 => {
            if dotopname != 0 && location == 0 {
                V_DrawString(
                    20 as libc::c_int,
                    y,
                    0x3000 as libc::c_int,
                    b"LEVEL NAME\0" as *const u8 as *const libc::c_char,
                );
                V_DrawString(
                    248 as libc::c_int,
                    y,
                    0x3000 as libc::c_int,
                    b"EMBLEMS\0" as *const u8 as *const libc::c_char,
                );
                y += 8 as libc::c_int;
            } else if location != 0 {
                location -= 1;
                location;
            }
            i = -(2 as libc::c_int);
            while i < numextraemblems {
                if i == -(1 as libc::c_int) {
                    V_DrawString(
                        20 as libc::c_int,
                        y,
                        0x3000 as libc::c_int,
                        b"EXTRA EMBLEMS\0" as *const u8 as *const libc::c_char,
                    );
                    if location != 0 {
                        y += 8 as libc::c_int;
                        location += 1;
                        location;
                    }
                }
                if location != 0 {
                    location -= 1;
                    location;
                } else {
                    if i >= 0 as libc::c_int {
                        exemblem = &mut *extraemblems.as_mut_ptr().offset(i as isize)
                            as *mut extraemblem_t;
                        if (*data).extraCollected[i as usize] != 0 {
                            V_DrawStretchyFixedPatch(
                                (292 as libc::c_int) << 16 as libc::c_int,
                                y << 16 as libc::c_int,
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 2 as libc::c_int,
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 2 as libc::c_int,
                                0 as libc::c_int,
                                W_CachePatchName(
                                    M_GetExtraEmblemPatch(exemblem, false_0 as libc::c_int),
                                    PU_PATCH as libc::c_int,
                                ) as *mut patch_t,
                                R_GetTranslationColormap(
                                    TC_DEFAULT as libc::c_int,
                                    M_GetExtraEmblemColor(exemblem),
                                    1 as libc::c_int as uint8_t,
                                ),
                            );
                        } else {
                            V_DrawStretchyFixedPatch(
                                (292 as libc::c_int) << 16 as libc::c_int,
                                y << 16 as libc::c_int,
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 2 as libc::c_int,
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 2 as libc::c_int,
                                0 as libc::c_int,
                                W_CachePatchName(
                                    b"NEEDIT\0" as *const u8 as *const libc::c_char,
                                    PU_PATCH as libc::c_int,
                                ) as *mut patch_t,
                                0 as *const uint8_t,
                            );
                        }
                        V_DrawString(
                            20 as libc::c_int,
                            y,
                            0x2000 as libc::c_int | 0x800000 as libc::c_int,
                            if (*data).extraCollected[i as usize] == 0
                                && (*exemblem).showconditionset as libc::c_int != 0
                                && !((*exemblem).showconditionset as libc::c_int
                                    >= 128 as libc::c_int
                                    || (*data).achieved[(*exemblem).showconditionset as usize]
                                        != 0)
                            {
                                M_CreateSecretMenuOption(
                                    ((*exemblem).description).as_mut_ptr(),
                                )
                            } else {
                                ((*exemblem).description).as_mut_ptr()
                                    as *const libc::c_char
                            },
                        );
                    }
                    y += 8 as libc::c_int;
                    if y >= 200 as libc::c_int - 8 as libc::c_int {
                        break;
                    }
                }
                i += 1;
                i;
            }
        }
        _ => {}
    }
    if dobottomarrow != 0 {
        V_DrawString(
            10 as libc::c_int,
            y - 8 as libc::c_int + skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1B\0" as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn M_DrawLevelStats() {
    let mut data: *mut gamedata_t = clientGamedata;
    let mut beststr: [libc::c_char; 40] = [0; 40];
    let mut besttime: tic_t = 0 as libc::c_int as tic_t;
    let mut bestscore: uint32_t = 0 as libc::c_int as uint32_t;
    let mut bestrings: uint32_t = 0 as libc::c_int as uint32_t;
    let mut i: int32_t = 0;
    let mut mapsunfinished: int32_t = 0 as libc::c_int;
    let mut bestunfinished: [boolean; 3] = [
        false_0 as libc::c_int,
        false_0 as libc::c_int,
        false_0 as libc::c_int,
    ];
    M_DrawMenuTitle();
    V_DrawString(
        20 as libc::c_int,
        24 as libc::c_int,
        0x2000 as libc::c_int,
        b"Total Play Time:\0" as *const u8 as *const libc::c_char,
    );
    V_DrawCenteredString(
        320 as libc::c_int / 2 as libc::c_int,
        32 as libc::c_int,
        0 as libc::c_int,
        va(
            b"%i hours, %i minutes, %i seconds\0" as *const u8 as *const libc::c_char,
            G_TicsToHours((*data).totalplaytime),
            G_TicsToMinutes((*data).totalplaytime, false_0 as libc::c_int),
            G_TicsToSeconds((*data).totalplaytime),
        ),
    );
    i = 0 as libc::c_int;
    while i < 1035 as libc::c_int {
        let mut mapunfinished: boolean = false_0 as libc::c_int;
        if !((mapheaderinfo[i as usize]).is_null()
            || (*mapheaderinfo[i as usize]).menuflags as libc::c_int & 4 as libc::c_int
                == 0)
        {
            if ((*data).mainrecords[i as usize]).is_null() {
                mapsunfinished += 1;
                mapsunfinished;
                bestunfinished[2 as libc::c_int as usize] = true_0 as libc::c_int;
                bestunfinished[1 as libc::c_int
                    as usize] = bestunfinished[2 as libc::c_int as usize];
                bestunfinished[0 as libc::c_int
                    as usize] = bestunfinished[1 as libc::c_int as usize];
            } else {
                if (*(*data).mainrecords[i as usize]).score
                    > 0 as libc::c_int as uint32_t
                {
                    bestscore = bestscore
                        .wrapping_add((*(*data).mainrecords[i as usize]).score);
                } else {
                    bestunfinished[0 as libc::c_int as usize] = true_0 as libc::c_int;
                    mapunfinished = bestunfinished[0 as libc::c_int as usize];
                }
                if (*(*data).mainrecords[i as usize]).time > 0 as libc::c_int as tic_t {
                    besttime = besttime
                        .wrapping_add((*(*data).mainrecords[i as usize]).time);
                } else {
                    bestunfinished[1 as libc::c_int as usize] = true_0 as libc::c_int;
                    mapunfinished = bestunfinished[1 as libc::c_int as usize];
                }
                if (*(*data).mainrecords[i as usize]).rings as libc::c_int
                    > 0 as libc::c_int
                {
                    bestrings = bestrings
                        .wrapping_add(
                            (*(*data).mainrecords[i as usize]).rings as uint32_t,
                        );
                } else {
                    bestunfinished[2 as libc::c_int as usize] = true_0 as libc::c_int;
                    mapunfinished = bestunfinished[2 as libc::c_int as usize];
                }
                if mapunfinished != 0 {
                    mapsunfinished += 1;
                    mapsunfinished;
                }
            }
        }
        i += 1;
        i;
    }
    V_DrawString(
        20 as libc::c_int,
        48 as libc::c_int,
        0 as libc::c_int,
        b"Combined records:\0" as *const u8 as *const libc::c_char,
    );
    if mapsunfinished != 0 {
        V_DrawString(
            20 as libc::c_int,
            56 as libc::c_int,
            0x5000 as libc::c_int,
            va(b"(%d unfinished)\0" as *const u8 as *const libc::c_char, mapsunfinished),
        );
    } else {
        V_DrawString(
            20 as libc::c_int,
            56 as libc::c_int,
            0x3000 as libc::c_int,
            b"(complete)\0" as *const u8 as *const libc::c_char,
        );
    }
    V_DrawString(
        36 as libc::c_int,
        64 as libc::c_int,
        0 as libc::c_int,
        va(
            b"x %d/%d\0" as *const u8 as *const libc::c_char,
            M_CountEmblems(data),
            numemblems + numextraemblems,
        ),
    );
    V_DrawStretchyFixedPatch(
        (20 as libc::c_int) << 16 as libc::c_int,
        (64 as libc::c_int) << 16 as libc::c_int,
        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchName(
            b"EMBLICON\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t,
        0 as *const uint8_t,
    );
    sprintf(
        beststr.as_mut_ptr(),
        b"%u\0" as *const u8 as *const libc::c_char,
        bestscore,
    );
    V_DrawString(
        320 as libc::c_int / 2 as libc::c_int,
        48 as libc::c_int,
        0x2000 as libc::c_int,
        b"SCORE:\0" as *const u8 as *const libc::c_char,
    );
    V_DrawRightAlignedString(
        320 as libc::c_int - 16 as libc::c_int,
        48 as libc::c_int,
        if bestunfinished[0 as libc::c_int as usize] != 0 {
            0x5000 as libc::c_int
        } else {
            0 as libc::c_int
        },
        beststr.as_mut_ptr(),
    );
    sprintf(
        beststr.as_mut_ptr(),
        b"%i:%02i:%02i.%02i\0" as *const u8 as *const libc::c_char,
        G_TicsToHours(besttime),
        G_TicsToMinutes(besttime, false_0 as libc::c_int),
        G_TicsToSeconds(besttime),
        G_TicsToCentiseconds(besttime),
    );
    V_DrawString(
        320 as libc::c_int / 2 as libc::c_int,
        56 as libc::c_int,
        0x2000 as libc::c_int,
        b"TIME:\0" as *const u8 as *const libc::c_char,
    );
    V_DrawRightAlignedString(
        320 as libc::c_int - 16 as libc::c_int,
        56 as libc::c_int,
        if bestunfinished[1 as libc::c_int as usize] != 0 {
            0x5000 as libc::c_int
        } else {
            0 as libc::c_int
        },
        beststr.as_mut_ptr(),
    );
    sprintf(
        beststr.as_mut_ptr(),
        b"%u\0" as *const u8 as *const libc::c_char,
        bestrings,
    );
    V_DrawString(
        320 as libc::c_int / 2 as libc::c_int,
        64 as libc::c_int,
        0x2000 as libc::c_int,
        b"RINGS:\0" as *const u8 as *const libc::c_char,
    );
    V_DrawRightAlignedString(
        320 as libc::c_int - 16 as libc::c_int,
        64 as libc::c_int,
        if bestunfinished[2 as libc::c_int as usize] != 0 {
            0x5000 as libc::c_int
        } else {
            0 as libc::c_int
        },
        beststr.as_mut_ptr(),
    );
    M_DrawStatsMaps(statsLocation);
}
unsafe extern "C" fn M_HandleLevelStats(mut choice: int32_t) {
    let mut exitmenu: boolean = false_0 as libc::c_int;
    match choice {
        238 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            if statsLocation < statsMax {
                statsLocation += 1;
                statsLocation;
            }
        }
        230 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            if statsLocation != 0 {
                statsLocation -= 1;
                statsLocation;
            }
        }
        239 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            statsLocation
                += if statsLocation + 13 as libc::c_int >= statsMax {
                    statsMax - statsLocation
                } else {
                    13 as libc::c_int
                };
        }
        231 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            statsLocation
                -= if statsLocation < 13 as libc::c_int {
                    statsLocation
                } else {
                    13 as libc::c_int
                };
        }
        27 => {
            exitmenu = true_0 as libc::c_int;
        }
        _ => {}
    }
    if exitmenu != 0 {
        if !((*currentMenu).prevMenu).is_null() {
            M_SetupNextMenu((*currentMenu).prevMenu);
        } else {
            M_ClearMenus(true_0 as libc::c_int);
        }
    }
}
unsafe extern "C" fn M_DrawTimeAttackMenu() {
    let mut data: *mut gamedata_t = clientGamedata;
    let mut i: int32_t = 0;
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut empatx: int32_t = 0;
    let mut empaty: int32_t = 0;
    let mut cursory: int32_t = 0 as libc::c_int;
    let mut dispstatus: uint16_t = 0;
    let mut PictureOfUrFace: *mut patch_t = 0 as *mut patch_t;
    let mut empatch: *mut patch_t = 0 as *mut patch_t;
    M_SetMenuCurBackground(b"RECATKBG\0" as *const u8 as *const libc::c_char);
    curbgxspeed = 0 as libc::c_int;
    curbgyspeed = 18 as libc::c_int;
    M_ChangeMenuMusic(
        b"_recat\0" as *const u8 as *const libc::c_char,
        true_0 as libc::c_int,
    );
    if curbgcolor >= 0 as libc::c_int {
        V_DrawFill(
            0 as libc::c_int,
            0 as libc::c_int,
            320 as libc::c_int,
            200 as libc::c_int,
            curbgcolor,
        );
    } else if curbghide == 0 || titlemapinaction == 0 {
        F_SkyScroll(curbgname.as_mut_ptr());
        if strncmp(
            b"RECATKBG\0" as *const u8 as *const libc::c_char,
            curbgname.as_mut_ptr(),
            8 as libc::c_int as libc::c_ulong,
        ) == 0
        {
            M_DrawRecordAttackForeground();
        }
    }
    if curfadevalue != 0 {
        V_DrawFadeScreen(0xff00 as libc::c_int as uint16_t, curfadevalue as uint8_t);
    }
    M_DrawMenuTitle();
    x = (*currentMenu).x as int32_t;
    y = (*currentMenu).y as int32_t;
    i = 0 as libc::c_int;
    while i < (*currentMenu).numitems as libc::c_int {
        dispstatus = ((*((*currentMenu).menuitems).offset(i as isize)).status
            as libc::c_int & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int)
            as uint16_t;
        if !(dispstatus as libc::c_int != 32 as libc::c_int
            && dispstatus as libc::c_int != 48 as libc::c_int)
        {
            y = (*currentMenu).y as libc::c_int
                + (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                    as libc::c_int;
            if i == itemOn as libc::c_int {
                cursory = y;
            }
            V_DrawString(
                x,
                y,
                if dispstatus as libc::c_int == 48 as libc::c_int {
                    0x2000 as libc::c_int
                } else {
                    0 as libc::c_int
                },
                (*((*currentMenu).menuitems).offset(i as isize)).text,
            );
            if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
                & 15 as libc::c_int == 8 as libc::c_int
            {
                let mut cv: *mut consvar_t = (*((*currentMenu).menuitems)
                    .offset(i as isize))
                    .itemaction as *mut consvar_t;
                let mut soffset: int32_t = 0 as libc::c_int;
                if currentMenu != &mut SP_TimeAttackDef as *mut menu_t {
                    soffset = 80 as libc::c_int;
                }
                V_DrawString(
                    320 as libc::c_int - x - soffset
                        - V_StringWidth((*cv).string, 0 as libc::c_int),
                    y,
                    0x2000 as libc::c_int,
                    (*cv).string,
                );
                if i == itemOn as libc::c_int {
                    V_DrawCharacter(
                        320 as libc::c_int - x - soffset - 10 as libc::c_int
                            - V_StringWidth((*cv).string, 0 as libc::c_int)
                            - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                        y,
                        '\u{1c}' as i32 | 0x2000 as libc::c_int,
                        false_0 as libc::c_int,
                    );
                    V_DrawCharacter(
                        320 as libc::c_int - x - soffset + 2 as libc::c_int
                            + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                        y,
                        '\u{1d}' as i32 | 0x2000 as libc::c_int,
                        false_0 as libc::c_int,
                    );
                }
            }
        }
        i += 1;
        i;
    }
    V_DrawStretchyFixedPatch(
        ((*currentMenu).x as libc::c_int - 24 as libc::c_int)
            * ((1 as libc::c_int) << 16 as libc::c_int),
        cursory << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchName(
            b"M_CURSOR\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t,
        0 as *const uint8_t,
    );
    V_DrawString(
        (*currentMenu).x as int32_t,
        cursory,
        0x2000 as libc::c_int,
        (*((*currentMenu).menuitems).offset(itemOn as isize)).text,
    );
    if skins[(cv_chooseskin.value - 1 as libc::c_int) as usize]
        .sprites[SPR2_XTRA as libc::c_int as usize]
        .numframes > 1 as libc::c_int as size_t
    {
        let mut sprdef: *mut spritedef_t = &mut *((*skins
            .as_mut_ptr()
            .offset((cv_chooseskin.value - 1 as libc::c_int) as isize))
            .sprites)
            .as_mut_ptr()
            .offset(SPR2_XTRA as libc::c_int as isize) as *mut spritedef_t;
        let mut sprframe: *mut spriteframe_t = &mut *((*sprdef).spriteframes)
            .offset(1 as libc::c_int as isize) as *mut spriteframe_t;
        PictureOfUrFace = W_CachePatchNum(
            (*sprframe).lumppat[0 as libc::c_int as usize],
            PU_PATCH as libc::c_int,
        ) as *mut patch_t;
    } else {
        PictureOfUrFace = W_CachePatchName(
            b"MISSING\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t;
    }
    if (*PictureOfUrFace).width as libc::c_int >= 256 as libc::c_int {
        V_DrawStretchyFixedPatch(
            (224 as libc::c_int) << 16 as libc::c_int,
            (120 as libc::c_int) << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 4 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 4 as libc::c_int,
            0 as libc::c_int,
            PictureOfUrFace,
            0 as *const uint8_t,
        );
    } else {
        V_DrawStretchyFixedPatch(
            (224 as libc::c_int) << 16 as libc::c_int,
            (120 as libc::c_int) << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            PictureOfUrFace,
            0 as *const uint8_t,
        );
    }
    if cv_nextmap.value != 0 {
        let mut em: *mut emblem_t = 0 as *mut emblem_t;
        let mut yHeight: int32_t = 0;
        let mut PictureOfLevel: *mut patch_t = 0 as *mut patch_t;
        let mut lumpnum: lumpnum_t = 0;
        let mut beststr: [libc::c_char; 40] = [0; 40];
        let mut reqscore: [libc::c_char; 40] = [0; 40];
        let mut reqtime: [libc::c_char; 40] = [0; 40];
        let mut reqrings: [libc::c_char; 40] = [0; 40];
        strcpy(reqscore.as_mut_ptr(), b"\0\0" as *const u8 as *const libc::c_char);
        strcpy(reqtime.as_mut_ptr(), b"\0\0" as *const u8 as *const libc::c_char);
        strcpy(reqrings.as_mut_ptr(), b"\0\0" as *const u8 as *const libc::c_char);
        M_DrawLevelPlatterHeader(
            32 as libc::c_int - 16 as libc::c_int / 2 as libc::c_int,
            cv_nextmap.string,
            true_0 as libc::c_int,
            false_0 as libc::c_int,
        );
        lumpnum = W_CheckNumForName(
            va(
                b"%sP\0" as *const u8 as *const libc::c_char,
                G_BuildMapName(cv_nextmap.value),
            ),
        );
        if lumpnum != 4294967295 as libc::c_uint {
            PictureOfLevel = W_CachePatchName(
                va(
                    b"%sP\0" as *const u8 as *const libc::c_char,
                    G_BuildMapName(cv_nextmap.value),
                ),
                PU_PATCH as libc::c_int,
            ) as *mut patch_t;
        } else {
            PictureOfLevel = W_CachePatchName(
                b"BLANKLVL\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t;
        }
        y = 32 as libc::c_int + 16 as libc::c_int;
        V_DrawStretchyFixedPatch(
            (216 as libc::c_int) << 16 as libc::c_int,
            y << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            PictureOfLevel,
            0 as *const uint8_t,
        );
        if currentMenu == &mut SP_TimeAttackDef as *mut menu_t {
            if itemOn as libc::c_int == talevel as libc::c_int {
                y = y + 25 as libc::c_int - 4 as libc::c_int;
                V_DrawCharacter(
                    216 as libc::c_int - 10 as libc::c_int
                        - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                    y,
                    '\u{1c}' as i32 | 0x2000 as libc::c_int,
                    false_0 as libc::c_int,
                );
                V_DrawCharacter(
                    216 as libc::c_int + 80 as libc::c_int + 2 as libc::c_int
                        + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                    y,
                    '\u{1d}' as i32 | 0x2000 as libc::c_int,
                    false_0 as libc::c_int,
                );
            }
            V_DrawString(
                104 as libc::c_int - 72 as libc::c_int,
                180 as libc::c_int,
                0x50000 as libc::c_int,
                b"Press ESC to exit\0" as *const u8 as *const libc::c_char,
            );
        }
        em = M_GetLevelEmblems(cv_nextmap.value);
        while !em.is_null() {
            let mut current_block_73: u64;
            match (*em).type_0 as libc::c_int {
                3 => {
                    yHeight = 33 as libc::c_int;
                    sprintf(
                        reqscore.as_mut_ptr(),
                        b"(%u)\0" as *const u8 as *const libc::c_char,
                        (*em).var,
                    );
                    current_block_73 = 16203797167131938757;
                }
                4 => {
                    yHeight = 53 as libc::c_int;
                    sprintf(
                        reqtime.as_mut_ptr(),
                        b"(%i:%02i.%02i)\0" as *const u8 as *const libc::c_char,
                        G_TicsToMinutes((*em).var as tic_t, true_0 as libc::c_int),
                        G_TicsToSeconds((*em).var as tic_t),
                        G_TicsToCentiseconds((*em).var as tic_t),
                    );
                    current_block_73 = 16203797167131938757;
                }
                5 => {
                    yHeight = 73 as libc::c_int;
                    sprintf(
                        reqrings.as_mut_ptr(),
                        b"(%u)\0" as *const u8 as *const libc::c_char,
                        (*em).var,
                    );
                    current_block_73 = 16203797167131938757;
                }
                _ => {
                    current_block_73 = 13753205876949936598;
                }
            }
            match current_block_73 {
                16203797167131938757 => {
                    empatch = W_CachePatchName(
                        M_GetEmblemPatch(em, true_0 as libc::c_int),
                        PU_PATCH as libc::c_int,
                    ) as *mut patch_t;
                    empatx = (*empatch).leftoffset as libc::c_int / 2 as libc::c_int;
                    empaty = (*empatch).topoffset as libc::c_int / 2 as libc::c_int;
                    if (*data)
                        .collected[em.offset_from(emblemlocations.as_mut_ptr())
                        as libc::c_long as usize] != 0
                    {
                        V_DrawStretchyFixedPatch(
                            104 as libc::c_int + 76 as libc::c_int + empatx
                                << 16 as libc::c_int,
                            yHeight + 16 as libc::c_int / 2 as libc::c_int + empaty
                                << 16 as libc::c_int,
                            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                            0 as libc::c_int,
                            empatch,
                            R_GetTranslationColormap(
                                TC_DEFAULT as libc::c_int,
                                M_GetEmblemColor(em),
                                1 as libc::c_int as uint8_t,
                            ),
                        );
                    } else {
                        V_DrawStretchyFixedPatch(
                            (104 as libc::c_int + 76 as libc::c_int)
                                << 16 as libc::c_int,
                            (yHeight + 16 as libc::c_int / 2 as libc::c_int)
                                << 16 as libc::c_int,
                            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                            0 as libc::c_int,
                            W_CachePatchName(
                                b"NEEDITL\0" as *const u8 as *const libc::c_char,
                                PU_PATCH as libc::c_int,
                            ) as *mut patch_t,
                            0 as *const uint8_t,
                        );
                    }
                }
                _ => {}
            }
            em = M_GetLevelEmblems(-(1 as libc::c_int));
        }
        M_DrawMapEmblems(
            cv_nextmap.value,
            288 as libc::c_int,
            28 as libc::c_int,
            true_0 as libc::c_int,
        );
        if ((*data).mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
            .is_null()
            || (*(*data).mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
                .score == 0
        {
            sprintf(
                beststr.as_mut_ptr(),
                b"(none)\0" as *const u8 as *const libc::c_char,
            );
        } else {
            sprintf(
                beststr.as_mut_ptr(),
                b"%u\0" as *const u8 as *const libc::c_char,
                (*(*data).mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
                    .score,
            );
        }
        V_DrawString(
            104 as libc::c_int - 72 as libc::c_int,
            33 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x2000 as libc::c_int,
            b"SCORE:\0" as *const u8 as *const libc::c_char,
        );
        V_DrawRightAlignedString(
            104 as libc::c_int + 64 as libc::c_int,
            33 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x800000 as libc::c_int,
            beststr.as_mut_ptr(),
        );
        V_DrawRightAlignedString(
            104 as libc::c_int + 72 as libc::c_int,
            43 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x800000 as libc::c_int,
            reqscore.as_mut_ptr(),
        );
        if ((*data).mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
            .is_null()
            || (*(*data).mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
                .time == 0
        {
            sprintf(
                beststr.as_mut_ptr(),
                b"(none)\0" as *const u8 as *const libc::c_char,
            );
        } else {
            sprintf(
                beststr.as_mut_ptr(),
                b"%i:%02i.%02i\0" as *const u8 as *const libc::c_char,
                G_TicsToMinutes(
                    (*(*data)
                        .mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
                        .time,
                    true_0 as libc::c_int,
                ),
                G_TicsToSeconds(
                    (*(*data)
                        .mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
                        .time,
                ),
                G_TicsToCentiseconds(
                    (*(*data)
                        .mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
                        .time,
                ),
            );
        }
        V_DrawString(
            104 as libc::c_int - 72 as libc::c_int,
            53 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x2000 as libc::c_int,
            b"TIME:\0" as *const u8 as *const libc::c_char,
        );
        V_DrawRightAlignedString(
            104 as libc::c_int + 64 as libc::c_int,
            53 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x800000 as libc::c_int,
            beststr.as_mut_ptr(),
        );
        V_DrawRightAlignedString(
            104 as libc::c_int + 72 as libc::c_int,
            63 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x800000 as libc::c_int,
            reqtime.as_mut_ptr(),
        );
        if ((*data).mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
            .is_null()
            || (*(*data).mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
                .rings == 0
        {
            sprintf(
                beststr.as_mut_ptr(),
                b"(none)\0" as *const u8 as *const libc::c_char,
            );
        } else {
            sprintf(
                beststr.as_mut_ptr(),
                b"%hu\0" as *const u8 as *const libc::c_char,
                (*(*data).mainrecords[(cv_nextmap.value - 1 as libc::c_int) as usize])
                    .rings as libc::c_int,
            );
        }
        V_DrawString(
            104 as libc::c_int - 72 as libc::c_int,
            73 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x2000 as libc::c_int,
            b"RINGS:\0" as *const u8 as *const libc::c_char,
        );
        V_DrawRightAlignedString(
            104 as libc::c_int + 64 as libc::c_int,
            73 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x800000 as libc::c_int
                | (if (*data).mapvisited[(cv_nextmap.value - 1 as libc::c_int) as usize]
                    as libc::c_int & 32 as libc::c_int != 0
                {
                    0x2000 as libc::c_int
                } else {
                    0 as libc::c_int
                }),
            beststr.as_mut_ptr(),
        );
        V_DrawRightAlignedString(
            104 as libc::c_int + 72 as libc::c_int,
            83 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x800000 as libc::c_int,
            reqrings.as_mut_ptr(),
        );
    }
    if currentMenu != &mut SP_TimeAttackDef as *mut menu_t {
        let mut ncv: *mut consvar_t = 0 as *mut consvar_t;
        x = SP_TimeAttackDef.x as int32_t;
        y = SP_TimeAttackDef.y as int32_t;
        V_DrawString(
            x,
            y
                + SP_TimeAttackMenu[talevel as libc::c_int as usize].alphaKey
                    as libc::c_int,
            0x50000 as libc::c_int,
            SP_TimeAttackMenu[talevel as libc::c_int as usize].text,
        );
        ncv = SP_TimeAttackMenu[taplayer as libc::c_int as usize].itemaction
            as *mut consvar_t;
        V_DrawString(
            x,
            y
                + SP_TimeAttackMenu[taplayer as libc::c_int as usize].alphaKey
                    as libc::c_int,
            0x50000 as libc::c_int,
            SP_TimeAttackMenu[taplayer as libc::c_int as usize].text,
        );
        V_DrawString(
            320 as libc::c_int - x - V_StringWidth((*ncv).string, 0 as libc::c_int),
            y
                + SP_TimeAttackMenu[taplayer as libc::c_int as usize].alphaKey
                    as libc::c_int,
            0x2000 as libc::c_int | 0x50000 as libc::c_int,
            (*ncv).string,
        );
    }
}
unsafe extern "C" fn M_HandleTimeAttackLevelSelect(mut choice: int32_t) {
    match choice {
        238 => {
            M_NextOpt();
        }
        230 => {
            M_PrevOpt();
        }
        233 => {
            CV_AddValue(&mut cv_nextmap, -(1 as libc::c_int));
        }
        235 => {
            CV_AddValue(&mut cv_nextmap, 1 as libc::c_int);
        }
        13 => {
            if levellistmode as libc::c_uint
                == LLM_NIGHTSATTACK as libc::c_int as libc::c_uint
            {
                M_NightsAttackLevelSelect(0 as libc::c_int);
            } else {
                M_TimeAttackLevelSelect(0 as libc::c_int);
            }
        }
        27 => {
            noFurtherInput = true_0 as libc::c_int;
            M_GoBack(0 as libc::c_int);
            return;
        }
        _ => return,
    }
    S_StartSound(0 as *const libc::c_void, sfx_menu1);
}
unsafe extern "C" fn M_TimeAttackLevelSelect(mut choice: int32_t) {
    SP_TimeAttackLevelSelectDef.prevMenu = currentMenu;
    M_SetupNextMenu(&mut SP_TimeAttackLevelSelectDef);
}
unsafe extern "C" fn M_TimeAttack(mut choice: int32_t) {
    SP_TimeAttackDef.prevMenu = &mut MainDef;
    levellistmode = LLM_RECORDATTACK;
    if M_PrepareLevelPlatter(-(1 as libc::c_int), true_0 as libc::c_int) == 0 {
        M_StartMessage(
            b"No record-attackable levels found.\n\0" as *const u8
                as *const libc::c_char,
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    }
    M_PatchSkinNameTable();
    G_SetGamestate(GS_TIMEATTACK);
    titlemapinaction = TITLEMAP_OFF as libc::c_int as uint8_t;
    M_SetupNextMenu(&mut SP_TimeAttackDef);
    if M_CanShowLevelInList(cv_nextmap.value - 1 as libc::c_int, -(1 as libc::c_int))
        == 0
        && (*(levelselect.rows).offset(0 as libc::c_int as isize))
            .maplist[0 as libc::c_int as usize] != 0
    {
        CV_SetValue(
            &mut cv_nextmap,
            (*(levelselect.rows).offset(0 as libc::c_int as isize))
                .maplist[0 as libc::c_int as usize],
        );
    } else {
        Nextmap_OnChange();
    }
    itemOn = tastart as libc::c_int as int16_t;
}
unsafe extern "C" fn M_DrawNightsAttackMenu() {
    let mut data: *mut gamedata_t = clientGamedata;
    let mut i: int32_t = 0;
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut cursory: int32_t = 0 as libc::c_int;
    let mut dispstatus: uint16_t = 0;
    M_SetMenuCurBackground(b"NTSATKBG\0" as *const u8 as *const libc::c_char);
    M_ChangeMenuMusic(
        b"_nitat\0" as *const u8 as *const libc::c_char,
        true_0 as libc::c_int,
    );
    M_DrawNightsAttackBackground();
    if curfadevalue != 0 {
        V_DrawFadeScreen(0xff00 as libc::c_int as uint16_t, curfadevalue as uint8_t);
    }
    M_DrawMenuTitle();
    x = (*currentMenu).x as int32_t;
    y = (*currentMenu).y as int32_t;
    i = 0 as libc::c_int;
    while i < (*currentMenu).numitems as libc::c_int {
        dispstatus = ((*((*currentMenu).menuitems).offset(i as isize)).status
            as libc::c_int & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int)
            as uint16_t;
        if !(dispstatus as libc::c_int != 32 as libc::c_int
            && dispstatus as libc::c_int != 48 as libc::c_int)
        {
            y = (*currentMenu).y as libc::c_int
                + (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                    as libc::c_int;
            if i == itemOn as libc::c_int {
                cursory = y;
            }
            V_DrawString(
                x,
                y,
                if dispstatus as libc::c_int == 48 as libc::c_int {
                    0x2000 as libc::c_int
                } else {
                    0 as libc::c_int
                },
                (*((*currentMenu).menuitems).offset(i as isize)).text,
            );
            if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
                & 15 as libc::c_int == 8 as libc::c_int
            {
                let mut cv: *mut consvar_t = (*((*currentMenu).menuitems)
                    .offset(i as isize))
                    .itemaction as *mut consvar_t;
                let mut soffset: int32_t = 0 as libc::c_int;
                if currentMenu != &mut SP_NightsAttackDef as *mut menu_t {
                    soffset = 80 as libc::c_int;
                }
                V_DrawString(
                    320 as libc::c_int - x - soffset
                        - V_StringWidth((*cv).string, 0 as libc::c_int),
                    y,
                    0x2000 as libc::c_int,
                    (*cv).string,
                );
                if i == itemOn as libc::c_int {
                    V_DrawCharacter(
                        320 as libc::c_int - x - soffset - 10 as libc::c_int
                            - V_StringWidth((*cv).string, 0 as libc::c_int)
                            - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                        y,
                        '\u{1c}' as i32 | 0x2000 as libc::c_int,
                        false_0 as libc::c_int,
                    );
                    V_DrawCharacter(
                        320 as libc::c_int - x - soffset + 2 as libc::c_int
                            + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                        y,
                        '\u{1d}' as i32 | 0x2000 as libc::c_int,
                        false_0 as libc::c_int,
                    );
                }
            }
        }
        i += 1;
        i;
    }
    V_DrawStretchyFixedPatch(
        ((*currentMenu).x as libc::c_int - 24 as libc::c_int)
            * ((1 as libc::c_int) << 16 as libc::c_int),
        cursory << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchName(
            b"M_CURSOR\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t,
        0 as *const uint8_t,
    );
    V_DrawString(
        (*currentMenu).x as int32_t,
        cursory,
        0x2000 as libc::c_int,
        (*((*currentMenu).menuitems).offset(itemOn as isize)).text,
    );
    if cv_nextmap.value != 0 {
        let mut em: *mut emblem_t = 0 as *mut emblem_t;
        let mut yHeight: int32_t = 0;
        let mut xpos: int32_t = 0;
        let mut PictureOfLevel: *mut patch_t = 0 as *mut patch_t;
        let mut lumpnum: lumpnum_t = 0;
        let mut beststr: [libc::c_char; 40] = [0; 40];
        let mut bestgrade: uint8_t = G_GetBestNightsGrade(
            cv_nextmap.value as int16_t,
            cv_dummymares.value as uint8_t,
            data,
        );
        let mut bestscore: uint32_t = G_GetBestNightsScore(
            cv_nextmap.value as int16_t,
            cv_dummymares.value as uint8_t,
            data,
        );
        let mut besttime: tic_t = G_GetBestNightsTime(
            cv_nextmap.value as int16_t,
            cv_dummymares.value as uint8_t,
            data,
        );
        M_DrawLevelPlatterHeader(
            32 as libc::c_int - 16 as libc::c_int / 2 as libc::c_int,
            cv_nextmap.string,
            true_0 as libc::c_int,
            false_0 as libc::c_int,
        );
        lumpnum = W_CheckNumForName(
            va(
                b"%sP\0" as *const u8 as *const libc::c_char,
                G_BuildMapName(cv_nextmap.value),
            ),
        );
        if lumpnum != 4294967295 as libc::c_uint {
            PictureOfLevel = W_CachePatchName(
                va(
                    b"%sP\0" as *const u8 as *const libc::c_char,
                    G_BuildMapName(cv_nextmap.value),
                ),
                PU_PATCH as libc::c_int,
            ) as *mut patch_t;
        } else {
            PictureOfLevel = W_CachePatchName(
                b"BLANKLVL\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t;
        }
        y = 32 as libc::c_int + 16 as libc::c_int;
        V_DrawStretchyFixedPatch(
            (208 as libc::c_int) << 16 as libc::c_int,
            y << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            PictureOfLevel,
            0 as *const uint8_t,
        );
        if currentMenu == &mut SP_NightsAttackDef as *mut menu_t {
            if itemOn as libc::c_int == nalevel as libc::c_int {
                y = y + 25 as libc::c_int - 4 as libc::c_int;
                V_DrawCharacter(
                    208 as libc::c_int - 10 as libc::c_int
                        - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                    y,
                    '\u{1c}' as i32 | 0x2000 as libc::c_int,
                    false_0 as libc::c_int,
                );
                V_DrawCharacter(
                    208 as libc::c_int + 80 as libc::c_int + 2 as libc::c_int
                        + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                    y,
                    '\u{1d}' as i32 | 0x2000 as libc::c_int,
                    false_0 as libc::c_int,
                );
            }
            V_DrawString(
                104 as libc::c_int - 72 as libc::c_int,
                180 as libc::c_int,
                0x50000 as libc::c_int,
                b"Press ESC to exit\0" as *const u8 as *const libc::c_char,
            );
        }
        M_DrawNightsAttackSuperSonic();
        if P_HasGrades(cv_nextmap.value as int16_t, cv_dummymares.value as uint8_t) != 0
        {
            V_DrawString(
                104 as libc::c_int - 72 as libc::c_int,
                48 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
                0x2000 as libc::c_int,
                b"BEST GRADE:\0" as *const u8 as *const libc::c_char,
            );
            V_DrawStretchyFixedPatch(
                (104 as libc::c_int + 72 as libc::c_int
                    - (*ngradeletters[bestgrade as usize]).width as libc::c_int
                        / 2 as libc::c_int) << 16 as libc::c_int,
                (48 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int
                    + 8 as libc::c_int
                    - (*ngradeletters[bestgrade as usize]).height as libc::c_int
                        / 2 as libc::c_int) << 16 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0 as libc::c_int,
                ngradeletters[bestgrade as usize],
                0 as *const uint8_t,
            );
        }
        if bestscore == 0 {
            sprintf(
                beststr.as_mut_ptr(),
                b"(none)\0" as *const u8 as *const libc::c_char,
            );
        } else {
            sprintf(
                beststr.as_mut_ptr(),
                b"%u\0" as *const u8 as *const libc::c_char,
                bestscore,
            );
        }
        V_DrawString(
            104 as libc::c_int - 72 as libc::c_int,
            58 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x2000 as libc::c_int,
            b"BEST SCORE:\0" as *const u8 as *const libc::c_char,
        );
        V_DrawRightAlignedString(
            104 as libc::c_int + 72 as libc::c_int,
            58 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x800000 as libc::c_int,
            beststr.as_mut_ptr(),
        );
        if besttime == 4294967295 as libc::c_uint {
            sprintf(
                beststr.as_mut_ptr(),
                b"(none)\0" as *const u8 as *const libc::c_char,
            );
        } else {
            sprintf(
                beststr.as_mut_ptr(),
                b"%i:%02i.%02i\0" as *const u8 as *const libc::c_char,
                G_TicsToMinutes(besttime, true_0 as libc::c_int),
                G_TicsToSeconds(besttime),
                G_TicsToCentiseconds(besttime),
            );
        }
        V_DrawString(
            104 as libc::c_int - 72 as libc::c_int,
            68 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x2000 as libc::c_int,
            b"BEST TIME:\0" as *const u8 as *const libc::c_char,
        );
        V_DrawRightAlignedString(
            104 as libc::c_int + 72 as libc::c_int,
            68 as libc::c_int + 16 as libc::c_int / 2 as libc::c_int,
            0x800000 as libc::c_int,
            beststr.as_mut_ptr(),
        );
        if cv_dummymares.value == 0 as libc::c_int {
            em = M_GetLevelEmblems(cv_nextmap.value);
            while !em.is_null() {
                let mut current_block_64: u64;
                match (*em).type_0 as libc::c_int {
                    6 => {
                        xpos = 104 as libc::c_int + 38 as libc::c_int;
                        yHeight = 48 as libc::c_int;
                        current_block_64 = 10753070352654377903;
                    }
                    7 => {
                        xpos = 104 as libc::c_int + 76 as libc::c_int;
                        yHeight = 68 as libc::c_int;
                        current_block_64 = 10753070352654377903;
                    }
                    _ => {
                        current_block_64 = 17160881092763136131;
                    }
                }
                match current_block_64 {
                    10753070352654377903 => {
                        if (*data)
                            .collected[em.offset_from(emblemlocations.as_mut_ptr())
                            as libc::c_long as usize] != 0
                        {
                            V_DrawStretchyFixedPatch(
                                xpos << 16 as libc::c_int,
                                (yHeight + 16 as libc::c_int / 2 as libc::c_int)
                                    << 16 as libc::c_int,
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 2 as libc::c_int,
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 2 as libc::c_int,
                                0 as libc::c_int,
                                W_CachePatchName(
                                    M_GetEmblemPatch(em, false_0 as libc::c_int),
                                    PU_PATCH as libc::c_int,
                                ) as *mut patch_t,
                                R_GetTranslationColormap(
                                    TC_DEFAULT as libc::c_int,
                                    M_GetEmblemColor(em),
                                    1 as libc::c_int as uint8_t,
                                ),
                            );
                        } else {
                            V_DrawStretchyFixedPatch(
                                xpos << 16 as libc::c_int,
                                (yHeight + 16 as libc::c_int / 2 as libc::c_int)
                                    << 16 as libc::c_int,
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 2 as libc::c_int,
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 2 as libc::c_int,
                                0 as libc::c_int,
                                W_CachePatchName(
                                    b"NEEDIT\0" as *const u8 as *const libc::c_char,
                                    PU_PATCH as libc::c_int,
                                ) as *mut patch_t,
                                0 as *const uint8_t,
                            );
                        }
                    }
                    _ => {}
                }
                em = M_GetLevelEmblems(-(1 as libc::c_int));
            }
            M_DrawMapEmblems(
                cv_nextmap.value,
                288 as libc::c_int,
                28 as libc::c_int,
                true_0 as libc::c_int,
            );
        }
    }
    if currentMenu != &mut SP_NightsAttackDef as *mut menu_t {
        V_DrawString(
            SP_NightsAttackDef.x as int32_t,
            SP_NightsAttackDef.y as libc::c_int
                + SP_TimeAttackMenu[nalevel as libc::c_int as usize].alphaKey
                    as libc::c_int,
            0x50000 as libc::c_int,
            SP_NightsAttackMenu[nalevel as libc::c_int as usize].text,
        );
    }
}
unsafe extern "C" fn M_NightsAttackLevelSelect(mut choice: int32_t) {
    SP_NightsAttackLevelSelectDef.prevMenu = currentMenu;
    M_SetupNextMenu(&mut SP_NightsAttackLevelSelectDef);
}
unsafe extern "C" fn M_NightsAttack(mut choice: int32_t) {
    SP_NightsAttackDef.prevMenu = &mut MainDef;
    levellistmode = LLM_NIGHTSATTACK;
    if M_PrepareLevelPlatter(-(1 as libc::c_int), true_0 as libc::c_int) == 0 {
        M_StartMessage(
            b"No NiGHTS-attackable levels found.\n\0" as *const u8
                as *const libc::c_char,
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    }
    M_PatchSkinNameTable();
    ntssupersonic[0 as libc::c_int
        as usize] = W_CachePatchName(
        b"NTSSONC1\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    ntssupersonic[1 as libc::c_int
        as usize] = W_CachePatchName(
        b"NTSSONC2\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    G_SetGamestate(GS_TIMEATTACK);
    titlemapinaction = TITLEMAP_OFF as libc::c_int as uint8_t;
    M_SetupNextMenu(&mut SP_NightsAttackDef);
    if M_CanShowLevelInList(cv_nextmap.value - 1 as libc::c_int, -(1 as libc::c_int))
        == 0
        && (*(levelselect.rows).offset(0 as libc::c_int as isize))
            .maplist[0 as libc::c_int as usize] != 0
    {
        CV_SetValue(
            &mut cv_nextmap,
            (*(levelselect.rows).offset(0 as libc::c_int as isize))
                .maplist[0 as libc::c_int as usize],
        );
    } else {
        Nextmap_OnChange();
    }
    itemOn = nastart as libc::c_int as int16_t;
}
unsafe extern "C" fn M_ChooseNightsAttack(mut choice: int32_t) {
    let mut gpath: *mut libc::c_char = 0 as *mut libc::c_char;
    let glen: size_t = (strlen(b"replay\0" as *const u8 as *const libc::c_char))
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(strlen(timeattackfolder.as_mut_ptr()))
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(strlen(b"MAPXX\0" as *const u8 as *const libc::c_char))
        .wrapping_add(1 as libc::c_int as libc::c_ulong);
    let mut nameofdemo: [libc::c_char; 256] = [0; 256];
    emeralds = 0 as libc::c_int as uint16_t;
    memset(
        &mut luabanks as *mut [int32_t; 16] as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[int32_t; 16]>() as libc::c_ulong,
    );
    M_ClearMenus(true_0 as libc::c_int);
    modeattacking = 2 as libc::c_int as uint8_t;
    I_mkdir(
        va(b"%s/replay\0" as *const u8 as *const libc::c_char, srb2home.as_mut_ptr()),
        0o755 as libc::c_int,
    );
    I_mkdir(
        va(
            b"%s/replay/%s\0" as *const u8 as *const libc::c_char,
            srb2home.as_mut_ptr(),
            timeattackfolder.as_mut_ptr(),
        ),
        0o755 as libc::c_int,
    );
    gpath = malloc(glen) as *mut libc::c_char;
    if gpath.is_null() {
        I_Error(
            b"Out of memory for replay filepath\n\0" as *const u8 as *const libc::c_char,
        );
    }
    sprintf(
        gpath,
        b"replay/%s/%s\0" as *const u8 as *const libc::c_char,
        timeattackfolder.as_mut_ptr(),
        G_BuildMapName(cv_nextmap.value),
    );
    snprintf(
        nameofdemo.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%s-%s-last\0" as *const u8 as *const libc::c_char,
        gpath,
        (skins[(cv_chooseskin.value - 1 as libc::c_int) as usize].name).as_mut_ptr(),
    );
    if cv_autorecord.value == 0 {
        remove(
            va(
                b"%s/%s.lmp\0" as *const u8 as *const libc::c_char,
                srb2home.as_mut_ptr(),
                nameofdemo.as_mut_ptr(),
            ),
        );
    } else {
        G_RecordDemo(nameofdemo.as_mut_ptr());
    }
    G_DeferedInitNew(
        false_0 as libc::c_int,
        G_BuildMapName(cv_nextmap.value),
        (cv_chooseskin.value - 1 as libc::c_int) as uint8_t as int32_t,
        false_0 as libc::c_int,
        false_0 as libc::c_int,
    );
}
unsafe extern "C" fn M_ChooseTimeAttack(mut choice: int32_t) {
    let mut gpath: *mut libc::c_char = 0 as *mut libc::c_char;
    let glen: size_t = (strlen(b"replay\0" as *const u8 as *const libc::c_char))
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(strlen(timeattackfolder.as_mut_ptr()))
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(strlen(b"MAPXX\0" as *const u8 as *const libc::c_char))
        .wrapping_add(1 as libc::c_int as libc::c_ulong);
    let mut nameofdemo: [libc::c_char; 256] = [0; 256];
    emeralds = 0 as libc::c_int as uint16_t;
    memset(
        &mut luabanks as *mut [int32_t; 16] as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[int32_t; 16]>() as libc::c_ulong,
    );
    M_ClearMenus(true_0 as libc::c_int);
    modeattacking = 1 as libc::c_int as uint8_t;
    I_mkdir(
        va(b"%s/replay\0" as *const u8 as *const libc::c_char, srb2home.as_mut_ptr()),
        0o755 as libc::c_int,
    );
    I_mkdir(
        va(
            b"%s/replay/%s\0" as *const u8 as *const libc::c_char,
            srb2home.as_mut_ptr(),
            timeattackfolder.as_mut_ptr(),
        ),
        0o755 as libc::c_int,
    );
    gpath = malloc(glen) as *mut libc::c_char;
    if gpath.is_null() {
        I_Error(
            b"Out of memory for replay filepath\n\0" as *const u8 as *const libc::c_char,
        );
    }
    sprintf(
        gpath,
        b"replay/%s/%s\0" as *const u8 as *const libc::c_char,
        timeattackfolder.as_mut_ptr(),
        G_BuildMapName(cv_nextmap.value),
    );
    snprintf(
        nameofdemo.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%s-%s-last\0" as *const u8 as *const libc::c_char,
        gpath,
        (skins[(cv_chooseskin.value - 1 as libc::c_int) as usize].name).as_mut_ptr(),
    );
    if cv_autorecord.value == 0 {
        remove(
            va(
                b"%s/%s.lmp\0" as *const u8 as *const libc::c_char,
                srb2home.as_mut_ptr(),
                nameofdemo.as_mut_ptr(),
            ),
        );
    } else {
        G_RecordDemo(nameofdemo.as_mut_ptr());
    }
    G_DeferedInitNew(
        false_0 as libc::c_int,
        G_BuildMapName(cv_nextmap.value),
        (cv_chooseskin.value - 1 as libc::c_int) as uint8_t as int32_t,
        false_0 as libc::c_int,
        false_0 as libc::c_int,
    );
}
static mut ra_demoname: [libc::c_char; 1024] = [0; 1024];
unsafe extern "C" fn M_StartTimeAttackReplay(mut choice: int32_t) {
    if choice == 'y' as i32 || choice == 13 as libc::c_int {
        M_ClearMenus(true_0 as libc::c_int);
        modeattacking = 1 as libc::c_int as uint8_t;
        G_DoPlayDemo(ra_demoname.as_mut_ptr());
    }
}
unsafe extern "C" fn M_ReplayTimeAttack(mut choice: int32_t) {
    let mut which: *const libc::c_char = 0 as *const libc::c_char;
    let mut error: uint8_t = DFILE_ERROR_NONE as libc::c_int as uint8_t;
    if currentMenu == &mut SP_ReplayDef as *mut menu_t {
        match choice {
            1 => {
                which = b"time-best\0" as *const u8 as *const libc::c_char;
            }
            2 => {
                which = b"rings-best\0" as *const u8 as *const libc::c_char;
            }
            3 => {
                which = b"last\0" as *const u8 as *const libc::c_char;
            }
            4 => {
                snprintf(
                    ra_demoname.as_mut_ptr(),
                    1024 as libc::c_int as libc::c_ulong,
                    b"%s/replay/%s/%s-guest.lmp\0" as *const u8 as *const libc::c_char,
                    srb2home.as_mut_ptr(),
                    timeattackfolder.as_mut_ptr(),
                    G_BuildMapName(cv_nextmap.value),
                );
            }
            0 | _ => {
                which = b"score-best\0" as *const u8 as *const libc::c_char;
            }
        }
        if choice != 4 as libc::c_int {
            snprintf(
                ra_demoname.as_mut_ptr(),
                1024 as libc::c_int as libc::c_ulong,
                b"%s/replay/%s/%s-%s-%s.lmp\0" as *const u8 as *const libc::c_char,
                srb2home.as_mut_ptr(),
                timeattackfolder.as_mut_ptr(),
                G_BuildMapName(cv_nextmap.value),
                (skins[(cv_chooseskin.value - 1 as libc::c_int) as usize].name)
                    .as_mut_ptr(),
                which,
            );
        }
    } else if currentMenu == &mut SP_NightsReplayDef as *mut menu_t {
        match choice {
            1 => {
                which = b"time-best\0" as *const u8 as *const libc::c_char;
            }
            2 => {
                which = b"last\0" as *const u8 as *const libc::c_char;
            }
            3 => {
                snprintf(
                    ra_demoname.as_mut_ptr(),
                    1024 as libc::c_int as libc::c_ulong,
                    b"%s/replay/%s/%s-guest.lmp\0" as *const u8 as *const libc::c_char,
                    srb2home.as_mut_ptr(),
                    timeattackfolder.as_mut_ptr(),
                    G_BuildMapName(cv_nextmap.value),
                );
            }
            0 | _ => {
                which = b"score-best\0" as *const u8 as *const libc::c_char;
            }
        }
        if choice != 3 as libc::c_int {
            snprintf(
                ra_demoname.as_mut_ptr(),
                1024 as libc::c_int as libc::c_ulong,
                b"%s/replay/%s/%s-%s-%s.lmp\0" as *const u8 as *const libc::c_char,
                srb2home.as_mut_ptr(),
                timeattackfolder.as_mut_ptr(),
                G_BuildMapName(cv_nextmap.value),
                (skins[(cv_chooseskin.value - 1 as libc::c_int) as usize].name)
                    .as_mut_ptr(),
                which,
            );
            if FIL_FileExists(ra_demoname.as_mut_ptr()) == 0 {
                snprintf(
                    ra_demoname.as_mut_ptr(),
                    1024 as libc::c_int as libc::c_ulong,
                    b"%s/replay/%s/%s-%s.lmp\0" as *const u8 as *const libc::c_char,
                    srb2home.as_mut_ptr(),
                    timeattackfolder.as_mut_ptr(),
                    G_BuildMapName(cv_nextmap.value),
                    which,
                );
            }
        }
    }
    demofileoverride = DFILE_OVERRIDE_NONE;
    error = G_CheckDemoForError(ra_demoname.as_mut_ptr());
    if error != 0 {
        S_StartSound(0 as *const libc::c_void, sfx_skid);
        match error as libc::c_int {
            255 => {
                M_StartMessage(
                    b"An error occurred loading this replay.\n\n(Press a key)\n\0"
                        as *const u8 as *const libc::c_char,
                    0 as *mut libc::c_void,
                    MM_NOTHING,
                );
            }
            1 => {
                demofileoverride = DFILE_OVERRIDE_LOAD;
                M_StartMessage(
                    b"Add-ons for this replay\nhave not been loaded.\n\nAttempt to load files?\n\n(Press 'Y' to confirm)\n\0"
                        as *const u8 as *const libc::c_char,
                    ::core::mem::transmute::<
                        Option::<unsafe extern "C" fn(int32_t) -> ()>,
                        *mut libc::c_void,
                    >(
                        Some(
                            M_StartTimeAttackReplay
                                as unsafe extern "C" fn(int32_t) -> (),
                        ),
                    ),
                    MM_YESNO,
                );
            }
            2 => {
                M_StartMessage(
                    b"Add-ons for this replay\nwere loaded out of order.\n\n(Press a key)\n\0"
                        as *const u8 as *const libc::c_char,
                    0 as *mut libc::c_void,
                    MM_NOTHING,
                );
            }
            3 => {
                M_StartMessage(
                    b"Add-ons for this replay\nhave not been loaded,\nand some are in the wrong order.\n\n(Press a key)\n\0"
                        as *const u8 as *const libc::c_char,
                    0 as *mut libc::c_void,
                    MM_NOTHING,
                );
            }
            4 => {
                M_StartMessage(
                    b"Add-ons for this replay\ncould not be loaded.\n\n(Press a key)\n\0"
                        as *const u8 as *const libc::c_char,
                    0 as *mut libc::c_void,
                    MM_NOTHING,
                );
            }
            5 => {
                M_StartMessage(
                    b"You have more files loaded\nthan the replay does.\n\n(Press a key)\n\0"
                        as *const u8 as *const libc::c_char,
                    0 as *mut libc::c_void,
                    MM_NOTHING,
                );
            }
            _ => {}
        }
        return;
    }
    M_StartTimeAttackReplay(13 as libc::c_int);
}
unsafe extern "C" fn M_EraseGuest(mut choice: int32_t) {
    let mut rguest: *const libc::c_char = va(
        b"%s/replay/%s/%s-guest.lmp\0" as *const u8 as *const libc::c_char,
        srb2home.as_mut_ptr(),
        timeattackfolder.as_mut_ptr(),
        G_BuildMapName(cv_nextmap.value),
    );
    if choice == 'y' as i32 || choice == 13 as libc::c_int {
        if FIL_FileExists(rguest) != 0 {
            remove(rguest);
        }
    }
    M_SetupNextMenu((*(*currentMenu).prevMenu).prevMenu);
    Nextmap_OnChange();
    M_StartMessage(
        b"Guest replay data erased.\n\0" as *const u8 as *const libc::c_char,
        0 as *mut libc::c_void,
        MM_NOTHING,
    );
}
unsafe extern "C" fn M_OverwriteGuest(mut which: *const libc::c_char) {
    let mut rguest: *mut libc::c_char = Z_StrDup(
        va(
            b"%s/replay/%s/%s-guest.lmp\0" as *const u8 as *const libc::c_char,
            srb2home.as_mut_ptr(),
            timeattackfolder.as_mut_ptr(),
            G_BuildMapName(cv_nextmap.value),
        ),
    );
    let mut buf: *mut uint8_t = 0 as *mut uint8_t;
    let mut len_0: size_t = 0;
    len_0 = FIL_ReadFileTag(
        va(
            b"%s/replay/%s/%s-%s-%s.lmp\0" as *const u8 as *const libc::c_char,
            srb2home.as_mut_ptr(),
            timeattackfolder.as_mut_ptr(),
            G_BuildMapName(cv_nextmap.value),
            (skins[(cv_chooseskin.value - 1 as libc::c_int) as usize].name).as_mut_ptr(),
            which,
        ),
        &mut buf,
        PU_STATIC as libc::c_int,
    );
    if len_0 == 0 {
        return;
    }
    if FIL_FileExists(rguest) != 0 {
        M_StopMessage(0 as libc::c_int);
        remove(rguest);
    }
    FIL_WriteFile(rguest, buf as *const libc::c_void, len_0);
    Z_Free(rguest as *mut libc::c_void);
    if currentMenu == &mut SP_NightsGuestReplayDef as *mut menu_t {
        M_SetupNextMenu(&mut SP_NightsAttackDef);
    } else {
        M_SetupNextMenu(&mut SP_TimeAttackDef);
    }
    Nextmap_OnChange();
    M_StartMessage(
        b"Guest replay data saved.\n\0" as *const u8 as *const libc::c_char,
        0 as *mut libc::c_void,
        MM_NOTHING,
    );
}
unsafe extern "C" fn M_OverwriteGuest_Time(mut choice: int32_t) {
    M_OverwriteGuest(b"time-best\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn M_OverwriteGuest_Score(mut choice: int32_t) {
    M_OverwriteGuest(b"score-best\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn M_OverwriteGuest_Rings(mut choice: int32_t) {
    M_OverwriteGuest(b"rings-best\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn M_OverwriteGuest_Last(mut choice: int32_t) {
    M_OverwriteGuest(b"last\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn M_SetGuestReplay(mut choice: int32_t) {
    let mut which: Option::<unsafe extern "C" fn(int32_t) -> ()> = None;
    if currentMenu == &mut SP_NightsGuestReplayDef as *mut menu_t
        && choice >= 2 as libc::c_int
    {
        choice += 1;
        choice;
    }
    match choice {
        0 => {
            which = Some(M_OverwriteGuest_Score as unsafe extern "C" fn(int32_t) -> ());
        }
        1 => {
            which = Some(M_OverwriteGuest_Time as unsafe extern "C" fn(int32_t) -> ());
        }
        2 => {
            which = Some(M_OverwriteGuest_Rings as unsafe extern "C" fn(int32_t) -> ());
        }
        3 => {
            which = Some(M_OverwriteGuest_Last as unsafe extern "C" fn(int32_t) -> ());
        }
        4 | _ => {
            M_StartMessage(
                b"Are you sure you want to\ndelete the guest replay data?\n\n(Press 'Y' to confirm)\n\0"
                    as *const u8 as *const libc::c_char,
                ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(int32_t) -> ()>,
                    *mut libc::c_void,
                >(Some(M_EraseGuest as unsafe extern "C" fn(int32_t) -> ())),
                MM_YESNO,
            );
            return;
        }
    }
    if FIL_FileExists(
        va(
            b"%s/replay/%s/%s-guest.lmp\0" as *const u8 as *const libc::c_char,
            srb2home.as_mut_ptr(),
            timeattackfolder.as_mut_ptr(),
            G_BuildMapName(cv_nextmap.value),
        ),
    ) != 0
    {
        M_StartMessage(
            b"Are you sure you want to\noverwrite the guest replay data?\n\n(Press 'Y' to confirm)\n\0"
                as *const u8 as *const libc::c_char,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(int32_t) -> ()>,
                *mut libc::c_void,
            >(which),
            MM_YESNO,
        );
    } else {
        which.expect("non-null function pointer")(0 as libc::c_int);
    };
}
#[no_mangle]
pub unsafe extern "C" fn M_ModeAttackRetry(mut choice: int32_t) {
    G_CheckDemoStatus();
    if modeattacking as libc::c_int == 1 as libc::c_int {
        M_ChooseTimeAttack(0 as libc::c_int);
    } else if modeattacking as libc::c_int == 2 as libc::c_int {
        M_ChooseNightsAttack(0 as libc::c_int);
    }
}
unsafe extern "C" fn M_ModeAttackEndGame(mut choice: int32_t) {
    G_CheckDemoStatus();
    if gamestate as libc::c_uint == GS_LEVEL as libc::c_int as libc::c_uint
        || gamestate as libc::c_uint == GS_INTERMISSION as libc::c_int as libc::c_uint
    {
        Command_ExitGame_f();
    }
    M_StartControlPanel();
    match modeattacking as libc::c_int {
        2 => {
            currentMenu = &mut SP_NightsAttackDef;
            wipetypepost = menupres[MN_SP_NIGHTSATTACK as libc::c_int as usize]
                .enterwipe;
        }
        1 | _ => {
            currentMenu = &mut SP_TimeAttackDef;
            wipetypepost = menupres[MN_SP_TIMEATTACK as libc::c_int as usize].enterwipe;
        }
    }
    itemOn = (*currentMenu).lastOn;
    G_SetGamestate(GS_TIMEATTACK);
    modeattacking = 0 as libc::c_int as uint8_t;
    M_ChangeMenuMusic(
        b"_title\0" as *const u8 as *const libc::c_char,
        true_0 as libc::c_int,
    );
    Nextmap_OnChange();
}
unsafe extern "C" fn M_MarathonLiveEventBackup(mut choice: int32_t) {
    if choice == 'y' as i32 || choice == 13 as libc::c_int {
        marathonmode = MA_INIT;
        G_LoadGame(420 as libc::c_int as uint32_t, 0 as libc::c_int as int16_t);
        cursaveslot = 420 as libc::c_int;
        if marathonmode as libc::c_uint & MA_RUNNING as libc::c_int as libc::c_uint == 0
        {
            marathonmode = 0 as marathonmode_t;
        }
        return;
    }
    M_StopMessage(0 as libc::c_int);
    stopstopmessage = true_0 as libc::c_int;
    if choice == 0x80 as libc::c_int + 113 as libc::c_int {
        if FIL_FileExists(liveeventbackup.as_mut_ptr()) != 0 {
            remove(liveeventbackup.as_mut_ptr());
        }
        S_StartSound(
            0 as *const libc::c_void,
            (sfx_bewar1 as libc::c_int + M_RandomKey(4 as libc::c_int)) as sfxenum_t,
        );
        M_StartMessage(
            b"Live event backup erased.\n\0" as *const u8 as *const libc::c_char,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(int32_t) -> ()>,
                *mut libc::c_void,
            >(Some(M_Marathon as unsafe extern "C" fn(int32_t) -> ())),
            MM_NOTHING,
        );
        return;
    }
    M_Marathon(-(1 as libc::c_int));
}
unsafe extern "C" fn M_Marathon(mut choice: int32_t) {
    let mut skinset: uint8_t = 0;
    let mut mapnum: int32_t = 0 as libc::c_int;
    if choice != -(1 as libc::c_int) && FIL_FileExists(liveeventbackup.as_mut_ptr()) != 0
    {
        M_StartMessage(
            b"\x82Live event backup detected.\n\x80\t\t\tDo you want to resurrect the last run?\n\t\t\t(Fs in chat if we crashed on stream.)\n\t\t\t\n\t\t\tPress 'Y' or 'Enter' to resume,\n\t\t\t'Del' to delete, or any other\n\t\t\tkey to continue to Marathon Run.\0"
                as *const u8 as *const libc::c_char,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(int32_t) -> ()>,
                *mut libc::c_void,
            >(Some(M_MarathonLiveEventBackup as unsafe extern "C" fn(int32_t) -> ())),
            MM_YESNO,
        );
        return;
    }
    fromlevelselect = false_0 as libc::c_int;
    maplistoption = 0 as libc::c_int as uint8_t;
    startmap = spmarathon_start;
    CV_SetValue(&mut cv_newgametype, GT_COOP as libc::c_int);
    skinset = M_SetupChoosePlayerDirect(-(1 as libc::c_int));
    SP_MarathonMenu[marathonplayer as libc::c_int as usize]
        .status = (if skinset as libc::c_int == 32 as libc::c_int {
        4 as libc::c_int | 32 as libc::c_int
    } else {
        0 as libc::c_int
            | 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
    }) as uint16_t;
    while mapnum < 1035 as libc::c_int {
        if !(mapheaderinfo[mapnum as usize]).is_null() {
            if (*mapheaderinfo[mapnum as usize]).cutscenenum as libc::c_int != 0
                || (*mapheaderinfo[mapnum as usize]).precutscenenum as libc::c_int != 0
            {
                break;
            }
        }
        mapnum += 1;
        mapnum;
    }
    SP_MarathonMenu[marathoncutscenes as libc::c_int as usize]
        .status = (if mapnum < 1035 as libc::c_int {
        8 as libc::c_int | 32 as libc::c_int
    } else {
        0 as libc::c_int
            | 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
    }) as uint16_t;
    M_ChangeMenuMusic(
        b"spec8\0" as *const u8 as *const libc::c_char,
        true_0 as libc::c_int,
    );
    SP_MarathonDef.prevMenu = &mut MainDef;
    G_SetGamestate(GS_TIMEATTACK);
    titlemapinaction = TITLEMAP_OFF as libc::c_int as uint8_t;
    M_SetupNextMenu(&mut SP_MarathonDef);
    itemOn = marathonstart as libc::c_int as int16_t;
    recatkdrawtimer = (50 as libc::c_int - 8 as libc::c_int)
        * ((1 as libc::c_int) << 16 as libc::c_int);
    char_scroll = 0 as libc::c_int;
}
unsafe extern "C" fn M_HandleMarathonChoosePlayer(mut choice: int32_t) {
    let mut selectval: int32_t = 0;
    if keydown > 1 as libc::c_int as tic_t {
        return;
    }
    match choice {
        238 => {
            M_NextOpt();
        }
        230 => {
            M_PrevOpt();
        }
        233 => {
            selectval = description[char_on as usize].prev as int32_t;
            if selectval == char_on as libc::c_int {
                return;
            }
            char_on = selectval as int16_t;
        }
        235 => {
            selectval = description[char_on as usize].next as int32_t;
            if selectval == char_on as libc::c_int {
                return;
            }
            char_on = selectval as int16_t;
        }
        27 => {
            noFurtherInput = true_0 as libc::c_int;
            M_GoBack(0 as libc::c_int);
            return;
        }
        _ => return,
    }
    S_StartSound(0 as *const libc::c_void, sfx_menu1);
}
unsafe extern "C" fn M_StartMarathon(mut choice: int32_t) {
    marathontime = 0 as libc::c_int as tic_t;
    marathonmode = (MA_RUNNING as libc::c_int | MA_INIT as libc::c_int)
        as marathonmode_t;
    cursaveslot = if cv_dummymarathon.value == 1 as libc::c_int {
        420 as libc::c_int
    } else {
        0 as libc::c_int
    };
    if cv_dummycutscenes.value == 0 {
        marathonmode = ::core::mem::transmute::<
            libc::c_uint,
            marathonmode_t,
        >(marathonmode as libc::c_uint | MA_NOCUTSCENES as libc::c_int as libc::c_uint);
    }
    if cv_dummyloadless.value != 0 {
        marathonmode = ::core::mem::transmute::<
            libc::c_uint,
            marathonmode_t,
        >(marathonmode as libc::c_uint | MA_INGAME as libc::c_int as libc::c_uint);
    }
    M_ChoosePlayer(char_on as int32_t);
}
unsafe extern "C" fn M_DrawMarathon() {
    let mut i: int32_t = 0;
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut cursory: int32_t = 0 as libc::c_int;
    let mut cnt: int32_t = 0;
    let mut soffset: int32_t = 0 as libc::c_int;
    let mut w: int32_t = 0;
    let mut dispstatus: uint16_t = 0;
    let mut cv: *mut consvar_t = 0 as *mut consvar_t;
    let mut cvstring: *const libc::c_char = 0 as *const libc::c_char;
    let mut work: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fa: angle_t = 0;
    let mut dupz: int32_t = if vid.dupx < vid.dupy { vid.dupx } else { vid.dupy };
    let mut xspan: int32_t = vid.width / dupz;
    let mut yspan: int32_t = vid.height / dupz;
    let mut diffx: int32_t = (xspan - 320 as libc::c_int) / 2 as libc::c_int;
    let mut diffy: int32_t = (yspan - 200 as libc::c_int) / 2 as libc::c_int;
    let mut maxy: int32_t = 200 as libc::c_int + diffy;
    curbgxspeed = 0 as libc::c_int;
    curbgyspeed = 18 as libc::c_int;
    M_ChangeMenuMusic(
        b"spec8\0" as *const u8 as *const libc::c_char,
        true_0 as libc::c_int,
    );
    V_DrawFill(
        -diffx,
        -diffy,
        diffx + (320 as libc::c_int - 190 as libc::c_int) / 2 as libc::c_int,
        yspan,
        158 as libc::c_int,
    );
    V_DrawFill(
        (320 as libc::c_int - 190 as libc::c_int) / 2 as libc::c_int,
        -diffy,
        190 as libc::c_int,
        yspan,
        31 as libc::c_int,
    );
    V_DrawFill(
        (320 as libc::c_int + 190 as libc::c_int) / 2 as libc::c_int,
        -diffy,
        diffx + (320 as libc::c_int - 190 as libc::c_int) / 2 as libc::c_int,
        yspan,
        158 as libc::c_int,
    );
    if curfadevalue != 0 {
        V_DrawFadeScreen(0xff00 as libc::c_int as uint16_t, curfadevalue as uint8_t);
    }
    x = ((320 as libc::c_int - 82 as libc::c_int) / 2 as libc::c_int + 11 as libc::c_int)
        << 16 as libc::c_int;
    y = ((200 as libc::c_int - 82 as libc::c_int) / 2 as libc::c_int + 12 as libc::c_int
        - 10 as libc::c_int) << 16 as libc::c_int;
    cnt = 36 as libc::c_int * recatkdrawtimer / 35 as libc::c_int;
    fa = FixedAngle(cnt) >> 19 as libc::c_int
        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
    y
        -= 10 as libc::c_int
            * (*finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int);
    if renderisnewtic != 0 {
        recatkdrawtimer += (1 as libc::c_int) << 16 as libc::c_int;
    }
    cnt = (recatkdrawtimer >> 16 as libc::c_int) % 50 as libc::c_int;
    soffset = cnt;
    if useBlackRock == 0 {
        if cnt > 8 as libc::c_int {
            cnt = 8 as libc::c_int;
        }
        V_DrawStretchyFixedPatch(
            x + ((6 as libc::c_int) << 16 as libc::c_int),
            y,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            (cnt & !(1 as libc::c_int)) << 16 as libc::c_int - 1 as libc::c_int,
            W_CachePatchName(
                b"RECCLOCK\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
    } else if cnt > 8 as libc::c_int {
        cnt = 8 as libc::c_int;
        V_DrawStretchyFixedPatch(
            x,
            y,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0x50000 as libc::c_int,
            W_CachePatchName(
                b"ENDEGRK5\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
    } else {
        V_DrawStretchyFixedPatch(
            x,
            y,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            cnt << 16 as libc::c_int,
            W_CachePatchName(
                b"ROID0000\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
        V_DrawStretchyFixedPatch(
            x,
            y,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            0x50000 as libc::c_int,
            W_CachePatchName(
                b"ENDEGRK5\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
        V_DrawStretchyFixedPatch(
            x,
            y,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            cnt << 16 as libc::c_int,
            W_CachePatchName(
                b"ENDEGRK0\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t,
            0 as *const uint8_t,
        );
    }
    let mut col: uint8_t = 0;
    i = 0 as libc::c_int;
    w = (8 as libc::c_int - cnt + 1 as libc::c_int) / 3 as libc::c_int
        + 1 as libc::c_int;
    w *= w;
    cursory = 0 as libc::c_int;
    while i < cnt {
        i += 1;
        i;
        col = (158 as libc::c_int + (cnt - i) / 3 as libc::c_int) as uint8_t;
        if col as libc::c_int >= 160 as libc::c_int {
            col = 253 as libc::c_int as uint8_t;
        }
        V_DrawFill(
            (320 as libc::c_int - 190 as libc::c_int) / 2 as libc::c_int - cursory - w,
            -diffy,
            w,
            yspan,
            col as int32_t,
        );
        V_DrawFill(
            (320 as libc::c_int + 190 as libc::c_int) / 2 as libc::c_int + cursory,
            -diffy,
            w,
            yspan,
            col as int32_t,
        );
        cursory += w;
        w *= 2 as libc::c_int;
    }
    w = char_scroll
        + ((8 as libc::c_int - cnt) * (8 as libc::c_int - cnt)
            << 16 as libc::c_int - 5 as libc::c_int);
    if soffset == 50 as libc::c_int - 1 as libc::c_int && renderisnewtic != 0 {
        w += ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int;
    }
    let mut fg: *mut patch_t = W_CachePatchName(
        b"RECATKFG\0" as *const u8 as *const libc::c_char,
        PU_PATCH as libc::c_int,
    ) as *mut patch_t;
    let mut trans: int32_t = 0x60000 as libc::c_int
        + ((cnt & !(3 as libc::c_int)) << 16 as libc::c_int - 2 as libc::c_int);
    let mut height: int32_t = (*fg).height as libc::c_int / 2 as libc::c_int;
    let mut patchname: [libc::c_char; 7] = *::core::mem::transmute::<
        &[u8; 7],
        &mut [libc::c_char; 7],
    >(b"CEMGx0\0");
    dupz = w * 7 as libc::c_int / 6 as libc::c_int;
    dupz = (dupz >> 16 as libc::c_int) % height;
    y = height / 2 as libc::c_int;
    while y + dupz >= -diffy {
        y -= height;
    }
    while y - 2 as libc::c_int - dupz < maxy {
        V_DrawStretchyFixedPatch(
            (320 as libc::c_int - 190 as libc::c_int)
                << 16 as libc::c_int - 1 as libc::c_int,
            y - 2 as libc::c_int - dupz << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            trans,
            fg,
            0 as *const uint8_t,
        );
        V_DrawStretchyFixedPatch(
            (320 as libc::c_int + 190 as libc::c_int)
                << 16 as libc::c_int - 1 as libc::c_int,
            y + dupz << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            trans | 0x800000 as libc::c_int,
            fg,
            0 as *const uint8_t,
        );
        y += height;
    }
    trans = 0x40000 as libc::c_int
        + ((cnt & !(1 as libc::c_int)) << 16 as libc::c_int - 1 as libc::c_int);
    i = 0 as libc::c_int;
    while i < 7 as libc::c_int {
        fa = FixedAngle(w) >> 19 as libc::c_int
            & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
        x = ((320 as libc::c_int) << 16 as libc::c_int - 1 as libc::c_int)
            + 60 as libc::c_int
                * (finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int);
        y = ((200 as libc::c_int + 16 as libc::c_int - 20 as libc::c_int)
            << 16 as libc::c_int - 1 as libc::c_int)
            - 60 as libc::c_int
                * (*finecosine.offset(fa as isize)
                    >> 16 as libc::c_int - 16 as libc::c_int);
        w += ((360 as libc::c_int) << 16 as libc::c_int) / 7 as libc::c_int;
        patchname[4 as libc::c_int
            as usize] = ('A' as i32 + i as libc::c_char as libc::c_int) as libc::c_char;
        V_DrawStretchyFixedPatch(
            x,
            y,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            trans,
            W_CachePatchName(patchname.as_mut_ptr(), PU_PATCH as libc::c_int)
                as *mut patch_t,
            0 as *const uint8_t,
        );
        i += 1;
        i;
    }
    height = 18 as libc::c_int;
    dupz = (w >> 16 as libc::c_int) % height;
    y = dupz + height / 4 as libc::c_int;
    x = 105 as libc::c_int + dupz;
    while y >= -diffy {
        x -= height;
        y -= height;
    }
    while y - dupz < maxy && x < xspan / 2 as libc::c_int {
        V_DrawFill(
            320 as libc::c_int / 2 as libc::c_int - x - height,
            -diffy,
            height,
            diffy + y + height,
            153 as libc::c_int,
        );
        V_DrawFill(
            320 as libc::c_int / 2 as libc::c_int + x,
            maxy - y - height,
            height,
            height + y,
            153 as libc::c_int,
        );
        y += height;
        x += height;
    }
    if soffset == 0 {
        char_scroll += 360 as libc::c_int * renderdeltatics / 42 as libc::c_int;
        if char_scroll >= (360 as libc::c_int) << 16 as libc::c_int {
            char_scroll -= (360 as libc::c_int) << 16 as libc::c_int;
        }
        if recatkdrawtimer
            > ((10 as libc::c_int) << 16 as libc::c_int) * 35 as libc::c_int
        {
            recatkdrawtimer
                -= ((10 as libc::c_int) << 16 as libc::c_int) * 35 as libc::c_int;
        }
    }
    M_DrawMenuTitle();
    x = (*currentMenu).x as int32_t;
    y = (*currentMenu).y as int32_t;
    dispstatus = ((*((*currentMenu).menuitems)
        .offset(marathonplayer as libc::c_int as isize))
        .status as libc::c_int
        & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int) as uint16_t;
    if dispstatus as libc::c_int == 32 as libc::c_int
        || dispstatus as libc::c_int == 48 as libc::c_int
    {
        soffset = 68 as libc::c_int;
        if (*description[char_on as usize].charpic).width as libc::c_int
            >= 256 as libc::c_int
        {
            V_DrawStretchyFixedPatch(
                (224 as libc::c_int) << 16 as libc::c_int,
                (120 as libc::c_int) << 16 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 4 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 4 as libc::c_int,
                0 as libc::c_int,
                description[char_on as usize].charpic,
                0 as *const uint8_t,
            );
        } else {
            V_DrawStretchyFixedPatch(
                (224 as libc::c_int) << 16 as libc::c_int,
                (120 as libc::c_int) << 16 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                0 as libc::c_int,
                description[char_on as usize].charpic,
                0 as *const uint8_t,
            );
        }
    } else {
        soffset = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*currentMenu).numitems as libc::c_int {
        dispstatus = ((*((*currentMenu).menuitems).offset(i as isize)).status
            as libc::c_int & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int)
            as uint16_t;
        if !(dispstatus as libc::c_int != 32 as libc::c_int
            && dispstatus as libc::c_int != 48 as libc::c_int)
        {
            y = (*currentMenu).y as libc::c_int
                + (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                    as libc::c_int;
            if i == itemOn as libc::c_int {
                cursory = y;
            }
            V_DrawString(
                x,
                y,
                if dispstatus as libc::c_int == 48 as libc::c_int {
                    0x2000 as libc::c_int
                } else {
                    0 as libc::c_int
                },
                (*((*currentMenu).menuitems).offset(i as isize)).text,
            );
            cv = 0 as *mut consvar_t;
            cvstring = 0 as *const libc::c_char;
            work = 0 as *mut libc::c_char;
            if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
                & 15 as libc::c_int == 8 as libc::c_int
            {
                cv = (*((*currentMenu).menuitems).offset(i as isize)).itemaction
                    as *mut consvar_t;
                cvstring = (*cv).string;
            } else if i == marathonplayer as libc::c_int {
                if description[char_on as usize].displayname[0 as libc::c_int as usize]
                    != 0
                {
                    work = Z_StrDup(
                        (description[char_on as usize].displayname).as_mut_ptr(),
                    );
                    cnt = 0 as libc::c_int;
                    while *work.offset(cnt as isize) != 0 {
                        if *work.offset(cnt as isize) as libc::c_int == '\n' as i32 {
                            *work.offset(cnt as isize) = ' ' as i32 as libc::c_char;
                        }
                        cnt += 1;
                        cnt;
                    }
                    cvstring = work;
                } else {
                    cvstring = (description[char_on as usize].skinname).as_mut_ptr();
                }
            }
            if !cvstring.is_null() {
                let mut flags: int32_t = 0x2000 as libc::c_int;
                if cv == &mut cv_dummymarathon as *mut consvar_t
                    && (*cv).value == 2 as libc::c_int
                {
                    flags = 0x5000 as libc::c_int;
                }
                if cv == &mut cv_dummymarathon as *mut consvar_t
                    && (*cv).value == 1 as libc::c_int
                {
                    w = V_ThinStringWidth(cvstring, 0 as libc::c_int);
                    V_DrawThinString(
                        320 as libc::c_int - x - soffset - w,
                        y + 1 as libc::c_int,
                        flags,
                        cvstring,
                    );
                } else {
                    w = V_StringWidth(cvstring, 0 as libc::c_int);
                    V_DrawString(
                        320 as libc::c_int - x - soffset - w,
                        y,
                        flags,
                        cvstring,
                    );
                }
                if i == itemOn as libc::c_int {
                    V_DrawCharacter(
                        320 as libc::c_int - x - soffset - 10 as libc::c_int - w
                            - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                        y,
                        '\u{1c}' as i32 | 0x2000 as libc::c_int,
                        false_0 as libc::c_int,
                    );
                    V_DrawCharacter(
                        320 as libc::c_int - x - soffset + 2 as libc::c_int
                            + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                        y,
                        '\u{1d}' as i32 | 0x2000 as libc::c_int,
                        false_0 as libc::c_int,
                    );
                }
                if !work.is_null() {
                    Z_Free(work as *mut libc::c_void);
                }
            }
        }
        i += 1;
        i;
    }
    V_DrawStretchyFixedPatch(
        ((*currentMenu).x as libc::c_int - 24 as libc::c_int)
            * ((1 as libc::c_int) << 16 as libc::c_int),
        cursory << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchName(
            b"M_CURSOR\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t,
        0 as *const uint8_t,
    );
    V_DrawString(
        (*currentMenu).x as int32_t,
        cursory,
        0x2000 as libc::c_int,
        (*((*currentMenu).menuitems).offset(itemOn as isize)).text,
    );
    V_DrawString(
        104 as libc::c_int - 72 as libc::c_int,
        180 as libc::c_int,
        0x50000 as libc::c_int,
        b"Press ESC to exit\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn M_ExitGameResponse(mut ch: int32_t) {
    if ch != 'y' as i32 && ch != 13 as libc::c_int {
        return;
    }
    G_SetExitGameFlag();
    M_ClearMenus(true_0 as libc::c_int);
}
unsafe extern "C" fn M_EndGame(mut choice: int32_t) {
    if demoplayback != 0 || demorecording != 0 {
        return;
    }
    if Playing() == 0 {
        return;
    }
    M_StartMessage(
        b"Are you sure you want to end the game?\n\n(Press 'Y' to confirm)\n\0"
            as *const u8 as *const libc::c_char,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(int32_t) -> ()>,
            *mut libc::c_void,
        >(Some(M_ExitGameResponse as unsafe extern "C" fn(int32_t) -> ())),
        MM_YESNO,
    );
}
static mut localservercount: uint32_t = 0;
unsafe extern "C" fn M_HandleServerPage(mut choice: int32_t) {
    let mut exitmenu: boolean = false_0 as libc::c_int;
    match choice {
        238 => {
            M_NextOpt();
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
        }
        230 => {
            M_PrevOpt();
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
        }
        8 | 27 => {
            exitmenu = true_0 as libc::c_int;
        }
        13 | 235 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            if (serverlistpage.wrapping_add(1 as libc::c_int as uint32_t)
                * 11 as libc::c_int as uint32_t) < serverlistcount
            {
                serverlistpage = serverlistpage.wrapping_add(1);
                serverlistpage;
            }
        }
        233 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            if serverlistpage > 0 as libc::c_int as uint32_t {
                serverlistpage = serverlistpage.wrapping_sub(1);
                serverlistpage;
            }
        }
        _ => {}
    }
    if exitmenu != 0 {
        if !((*currentMenu).prevMenu).is_null() {
            M_SetupNextMenu((*currentMenu).prevMenu);
        } else {
            M_ClearMenus(true_0 as libc::c_int);
        }
    }
}
unsafe extern "C" fn M_Connect(mut choice: int32_t) {
    M_ClearMenus(false_0 as libc::c_int);
    COM_BufAddTextEx(
        va(
            b"connect node %d\n\0" as *const u8 as *const libc::c_char,
            serverlist[((choice - FIRSTSERVERLINE as libc::c_int) as uint32_t)
                    .wrapping_add(serverlistpage * 11 as libc::c_int as uint32_t)
                    as usize]
                .node as libc::c_int,
        ),
        0 as com_flags_t,
    );
}
unsafe extern "C" fn M_Refresh(mut choice: int32_t) {
    M_DrawTextBox(
        52 as libc::c_int,
        200 as libc::c_int / 2 as libc::c_int - 10 as libc::c_int,
        25 as libc::c_int,
        3 as libc::c_int,
    );
    V_DrawCenteredString(
        320 as libc::c_int / 2 as libc::c_int,
        200 as libc::c_int / 2 as libc::c_int,
        0 as libc::c_int,
        b"Searching for servers...\0" as *const u8 as *const libc::c_char,
    );
    V_DrawCenteredString(
        320 as libc::c_int / 2 as libc::c_int,
        200 as libc::c_int / 2 as libc::c_int + 12 as libc::c_int,
        0 as libc::c_int,
        b"Please wait.\0" as *const u8 as *const libc::c_char,
    );
    I_OsPolling();
    I_UpdateNoBlit();
    if rendermode as libc::c_uint == render_soft as libc::c_int as libc::c_uint {
        I_FinishUpdate();
    }
    CL_UpdateServerList(
        !((ms_RoomId as libc::c_int) < 0 as libc::c_int) as libc::c_int,
        ms_RoomId as int32_t,
    );
    serverlistpage = 0 as libc::c_int as uint32_t;
}
static mut menuRoomIndex: int32_t = 0 as libc::c_int;
unsafe extern "C" fn M_DrawRoomMenu() {
    static mut frame: fixed_t = -((12 as libc::c_int) << 16 as libc::c_int);
    let mut dot_frame: libc::c_int = 0;
    let mut text: [libc::c_char; 4] = [0; 4];
    let mut rmotd: *const libc::c_char = 0 as *const libc::c_char;
    let mut waiting_message: *const libc::c_char = 0 as *const libc::c_char;
    let mut dots: libc::c_int = 0;
    if m_waiting_mode as u64 != 0 {
        dot_frame = (frame >> 16 as libc::c_int) / 4 as libc::c_int;
        dots = dot_frame + 3 as libc::c_int;
        strcpy(text.as_mut_ptr(), b"   \0" as *const u8 as *const libc::c_char);
        if dots > 0 as libc::c_int {
            if dot_frame < 0 as libc::c_int {
                dot_frame = 0 as libc::c_int;
            }
            strncpy(
                &mut *text.as_mut_ptr().offset(dot_frame as isize),
                b"...\0" as *const u8 as *const libc::c_char,
                (if dots < 3 as libc::c_int - dot_frame {
                    dots
                } else {
                    3 as libc::c_int - dot_frame
                }) as libc::c_ulong,
            );
        }
        frame += renderdeltatics;
        while frame >= (12 as libc::c_int) << 16 as libc::c_int {
            frame -= (12 as libc::c_int) << 16 as libc::c_int;
        }
        let ref mut fresh16 = (*((*currentMenu).menuitems)
            .offset(0 as libc::c_int as isize))
            .text;
        *fresh16 = text.as_mut_ptr();
    }
    M_DrawGenericMenu();
    V_DrawString(
        (*currentMenu).x as libc::c_int - 16 as libc::c_int,
        (*currentMenu).y as int32_t,
        0x2000 as libc::c_int,
        b"Select a room\0" as *const u8 as *const libc::c_char,
    );
    if m_waiting_mode as libc::c_uint == M_NOT_WAITING as libc::c_int as libc::c_uint {
        M_DrawTextBox(
            144 as libc::c_int,
            24 as libc::c_int,
            20 as libc::c_int,
            20 as libc::c_int,
        );
        if itemOn as libc::c_int == 0 as libc::c_int {
            rmotd = b"Don't connect to the Master Server.\0" as *const u8
                as *const libc::c_char;
        } else {
            rmotd = (room_list[(itemOn as libc::c_int - 1 as libc::c_int) as usize].motd)
                .as_mut_ptr();
        }
        rmotd = V_WordWrap(
            0 as libc::c_int,
            20 as libc::c_int * 8 as libc::c_int,
            0 as libc::c_int,
            rmotd,
        );
        V_DrawString(
            144 as libc::c_int + 8 as libc::c_int,
            32 as libc::c_int,
            0x800000 as libc::c_int | 0x20000000 as libc::c_int,
            rmotd,
        );
    }
    if m_waiting_mode as u64 != 0 {
        M_DrawTextBox(
            52 as libc::c_int,
            200 as libc::c_int / 2 as libc::c_int - 10 as libc::c_int,
            25 as libc::c_int,
            3 as libc::c_int,
        );
        if m_waiting_mode as libc::c_uint
            == M_WAITING_VERSION as libc::c_int as libc::c_uint
        {
            waiting_message = b"Checking for updates...\0" as *const u8
                as *const libc::c_char;
        } else {
            waiting_message = b"Fetching room info...\0" as *const u8
                as *const libc::c_char;
        }
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            200 as libc::c_int / 2 as libc::c_int,
            0 as libc::c_int,
            waiting_message,
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            200 as libc::c_int / 2 as libc::c_int + 12 as libc::c_int,
            0 as libc::c_int,
            b"Please wait.\0" as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn M_DrawConnectMenu() {
    let mut i: uint16_t = 0;
    let mut gt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut numPages: int32_t = (serverlistcount
        .wrapping_add((11 as libc::c_int - 1 as libc::c_int) as uint32_t)
        / 11 as libc::c_int as uint32_t) as int32_t;
    i = FIRSTSERVERLINE as libc::c_int as uint16_t;
    while (i as uint32_t)
        < (if localservercount < 11 as libc::c_int as uint32_t {
            localservercount
        } else {
            11 as libc::c_int as uint32_t
        })
            .wrapping_add(FIRSTSERVERLINE as libc::c_int as uint32_t)
    {
        MP_ConnectMenu[i as usize]
            .status = (32 as libc::c_int | 1 as libc::c_int) as uint16_t;
        i = i.wrapping_add(1);
        i;
    }
    if numPages == 0 {
        numPages = 1 as libc::c_int;
    }
    if (ms_RoomId as libc::c_int) < 0 as libc::c_int {
        V_DrawRightAlignedString(
            320 as libc::c_int - (*currentMenu).x as libc::c_int,
            (*currentMenu).y as libc::c_int
                + MP_ConnectMenu[mp_connect_room as libc::c_int as usize].alphaKey
                    as libc::c_int,
            0x2000 as libc::c_int,
            if itemOn as libc::c_int == mp_connect_room as libc::c_int {
                b"<Select to change>\0" as *const u8 as *const libc::c_char
            } else {
                b"<Unlisted Mode>\0" as *const u8 as *const libc::c_char
            },
        );
    } else {
        V_DrawRightAlignedString(
            320 as libc::c_int - (*currentMenu).x as libc::c_int,
            (*currentMenu).y as libc::c_int
                + MP_ConnectMenu[mp_connect_room as libc::c_int as usize].alphaKey
                    as libc::c_int,
            0x2000 as libc::c_int,
            (room_list[menuRoomIndex as usize].name).as_mut_ptr(),
        );
    }
    V_DrawRightAlignedString(
        320 as libc::c_int - (*currentMenu).x as libc::c_int,
        (*currentMenu).y as libc::c_int
            + MP_ConnectMenu[mp_connect_page as libc::c_int as usize].alphaKey
                as libc::c_int,
        0x2000 as libc::c_int,
        va(
            b"%u of %d\0" as *const u8 as *const libc::c_char,
            serverlistpage.wrapping_add(1 as libc::c_int as uint32_t),
            numPages,
        ),
    );
    V_DrawFill(
        1 as libc::c_int,
        (*currentMenu).y as libc::c_int + 40 as libc::c_int,
        318 as libc::c_int,
        1 as libc::c_int,
        0 as libc::c_int,
    );
    if serverlistcount <= 0 as libc::c_int as uint32_t {
        V_DrawString(
            (*currentMenu).x as int32_t,
            (*currentMenu).y as libc::c_int + 44 as libc::c_int,
            0 as libc::c_int,
            b"No servers found\0" as *const u8 as *const libc::c_char,
        );
    } else {
        i = 0 as libc::c_int as uint16_t;
        while (i as uint32_t)
            < (if serverlistcount
                .wrapping_sub(serverlistpage * 11 as libc::c_int as uint32_t)
                < 11 as libc::c_int as uint32_t
            {
                serverlistcount
                    .wrapping_sub(serverlistpage * 11 as libc::c_int as uint32_t)
            } else {
                11 as libc::c_int as uint32_t
            })
        {
            let mut slindex: int32_t = (i as uint32_t)
                .wrapping_add(serverlistpage * 11 as libc::c_int as uint32_t) as int32_t;
            let mut globalflags: uint32_t = ((if serverlist[slindex as usize]
                .info
                .refusereason as libc::c_int != 0
            {
                0x50000 as libc::c_int
            } else {
                0 as libc::c_int
            })
                | (if itemOn as libc::c_int
                    == FIRSTSERVERLINE as libc::c_int + i as libc::c_int
                {
                    0x2000 as libc::c_int
                } else {
                    0 as libc::c_int
                }) | 0x800000 as libc::c_int) as uint32_t;
            V_DrawString(
                (*currentMenu).x as int32_t,
                (*currentMenu).y as libc::c_int + 44 as libc::c_int
                    + i as libc::c_int * 12 as libc::c_int,
                globalflags as int32_t,
                (serverlist[slindex as usize].info.servername).as_mut_ptr(),
            );
            if serverlist[slindex as usize].info.modifiedgame != 0 {
                V_DrawSmallString(
                    (*currentMenu).x as libc::c_int + 202 as libc::c_int,
                    (*currentMenu).y as libc::c_int + 44 as libc::c_int
                        + i as libc::c_int * 12 as libc::c_int + 8 as libc::c_int,
                    globalflags as int32_t,
                    b"\x85Mod\0" as *const u8 as *const libc::c_char,
                );
            }
            if serverlist[slindex as usize].info.cheatsenabled != 0 {
                V_DrawSmallString(
                    (*currentMenu).x as libc::c_int + 222 as libc::c_int,
                    (*currentMenu).y as libc::c_int + 44 as libc::c_int
                        + i as libc::c_int * 12 as libc::c_int + 8 as libc::c_int,
                    globalflags as int32_t,
                    b"\x83Cheats\0" as *const u8 as *const libc::c_char,
                );
            }
            V_DrawSmallString(
                (*currentMenu).x as int32_t,
                (*currentMenu).y as libc::c_int + 44 as libc::c_int
                    + i as libc::c_int * 12 as libc::c_int + 8 as libc::c_int,
                globalflags as int32_t,
                va(
                    b"Ping: %u\0" as *const u8 as *const libc::c_char,
                    serverlist[slindex as usize].info.time as int32_t as uint32_t,
                ),
            );
            gt = (serverlist[slindex as usize].info.gametypename).as_mut_ptr();
            V_DrawSmallString(
                (*currentMenu).x as libc::c_int + 46 as libc::c_int,
                (*currentMenu).y as libc::c_int + 44 as libc::c_int
                    + i as libc::c_int * 12 as libc::c_int + 8 as libc::c_int,
                globalflags as int32_t,
                va(
                    b"Players: %02d/%02d\0" as *const u8 as *const libc::c_char,
                    serverlist[slindex as usize].info.numberofplayer as libc::c_int,
                    serverlist[slindex as usize].info.maxplayer as libc::c_int,
                ),
            );
            if strlen(gt) > 11 as libc::c_int as libc::c_ulong {
                gt = va(b"Gametype: %.11s...\0" as *const u8 as *const libc::c_char, gt);
            } else {
                gt = va(b"Gametype: %s\0" as *const u8 as *const libc::c_char, gt);
            }
            V_DrawSmallString(
                (*currentMenu).x as libc::c_int + 112 as libc::c_int,
                (*currentMenu).y as libc::c_int + 44 as libc::c_int
                    + i as libc::c_int * 12 as libc::c_int + 8 as libc::c_int,
                globalflags as int32_t,
                gt,
            );
            MP_ConnectMenu[(i as libc::c_int + FIRSTSERVERLINE as libc::c_int) as usize]
                .status = (32 as libc::c_int | 0 as libc::c_int) as uint16_t;
            i = i.wrapping_add(1);
            i;
        }
    }
    localservercount = serverlistcount;
    M_DrawGenericMenu();
    if m_waiting_mode as u64 != 0 {
        M_DrawTextBox(
            52 as libc::c_int,
            200 as libc::c_int / 2 as libc::c_int - 10 as libc::c_int,
            25 as libc::c_int,
            3 as libc::c_int,
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            200 as libc::c_int / 2 as libc::c_int,
            0 as libc::c_int,
            b"Searching for servers...\0" as *const u8 as *const libc::c_char,
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            200 as libc::c_int / 2 as libc::c_int + 12 as libc::c_int,
            0 as libc::c_int,
            b"Please wait.\0" as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn M_CancelConnect() -> boolean {
    D_CloseConnection();
    return true_0 as libc::c_int;
}
unsafe extern "C" fn ServerListEntryComparator_time(
    mut entry1: *const libc::c_void,
    mut entry2: *const libc::c_void,
) -> libc::c_int {
    let mut sa: *const serverelem_t = entry1 as *const serverelem_t;
    let mut sb: *const serverelem_t = entry2 as *const serverelem_t;
    if (*sa).info.time != (*sb).info.time {
        return ((*sa).info.time).wrapping_sub((*sb).info.time) as libc::c_int;
    }
    return strcmp(((*sa).info.servername).as_ptr(), ((*sb).info.servername).as_ptr());
}
unsafe extern "C" fn ServerListEntryComparator_numberofplayer(
    mut entry1: *const libc::c_void,
    mut entry2: *const libc::c_void,
) -> libc::c_int {
    let mut sa: *const serverelem_t = entry1 as *const serverelem_t;
    let mut sb: *const serverelem_t = entry2 as *const serverelem_t;
    if (*sa).info.numberofplayer as libc::c_int
        != (*sb).info.numberofplayer as libc::c_int
    {
        return (*sa).info.numberofplayer as libc::c_int
            - (*sb).info.numberofplayer as libc::c_int;
    }
    return strcmp(((*sa).info.servername).as_ptr(), ((*sb).info.servername).as_ptr());
}
unsafe extern "C" fn ServerListEntryComparator_numberofplayer_reverse(
    mut entry1: *const libc::c_void,
    mut entry2: *const libc::c_void,
) -> libc::c_int {
    let mut sa: *const serverelem_t = entry1 as *const serverelem_t;
    let mut sb: *const serverelem_t = entry2 as *const serverelem_t;
    if (*sb).info.numberofplayer as libc::c_int
        != (*sa).info.numberofplayer as libc::c_int
    {
        return (*sb).info.numberofplayer as libc::c_int
            - (*sa).info.numberofplayer as libc::c_int;
    }
    return strcmp(((*sb).info.servername).as_ptr(), ((*sa).info.servername).as_ptr());
}
unsafe extern "C" fn ServerListEntryComparator_maxplayer_reverse(
    mut entry1: *const libc::c_void,
    mut entry2: *const libc::c_void,
) -> libc::c_int {
    let mut sa: *const serverelem_t = entry1 as *const serverelem_t;
    let mut sb: *const serverelem_t = entry2 as *const serverelem_t;
    if (*sb).info.maxplayer as libc::c_int != (*sa).info.maxplayer as libc::c_int {
        return (*sb).info.maxplayer as libc::c_int - (*sa).info.maxplayer as libc::c_int;
    }
    return strcmp(((*sb).info.servername).as_ptr(), ((*sa).info.servername).as_ptr());
}
unsafe extern "C" fn ServerListEntryComparator_gametypename(
    mut entry1: *const libc::c_void,
    mut entry2: *const libc::c_void,
) -> libc::c_int {
    let mut sa: *const serverelem_t = entry1 as *const serverelem_t;
    let mut sb: *const serverelem_t = entry2 as *const serverelem_t;
    let mut c: libc::c_int = 0;
    c = strcasecmp(
        ((*sa).info.gametypename).as_ptr(),
        ((*sb).info.gametypename).as_ptr(),
    );
    if c != 0 {
        return c;
    }
    return strcmp(((*sa).info.servername).as_ptr(), ((*sb).info.servername).as_ptr());
}
unsafe extern "C" fn ServerListEntryComparator_modified(
    mut entry1: *const libc::c_void,
    mut entry2: *const libc::c_void,
) -> libc::c_int {
    let mut sa: *const serverelem_t = entry1 as *const serverelem_t;
    let mut sb: *const serverelem_t = entry2 as *const serverelem_t;
    let mut modstate_a: libc::c_int = (if (*sa).info.cheatsenabled as libc::c_int != 0 {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    })
        | (if (*sa).info.modifiedgame as libc::c_int != 0 {
            2 as libc::c_int
        } else {
            0 as libc::c_int
        });
    let mut modstate_b: libc::c_int = (if (*sb).info.cheatsenabled as libc::c_int != 0 {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    })
        | (if (*sb).info.modifiedgame as libc::c_int != 0 {
            2 as libc::c_int
        } else {
            0 as libc::c_int
        });
    if modstate_a != modstate_b {
        return modstate_a - modstate_b;
    }
    return strcmp(((*sa).info.servername).as_ptr(), ((*sb).info.servername).as_ptr());
}
#[no_mangle]
pub unsafe extern "C" fn M_SortServerList() {
    match cv_serversort.value {
        0 => {
            qsort(
                serverlist.as_mut_ptr() as *mut libc::c_void,
                serverlistcount as size_t,
                ::core::mem::size_of::<serverelem_t>() as libc::c_ulong,
                Some(
                    ServerListEntryComparator_time
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                        ) -> libc::c_int,
                ),
            );
        }
        1 => {
            qsort(
                serverlist.as_mut_ptr() as *mut libc::c_void,
                serverlistcount as size_t,
                ::core::mem::size_of::<serverelem_t>() as libc::c_ulong,
                Some(
                    ServerListEntryComparator_modified
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                        ) -> libc::c_int,
                ),
            );
        }
        2 => {
            qsort(
                serverlist.as_mut_ptr() as *mut libc::c_void,
                serverlistcount as size_t,
                ::core::mem::size_of::<serverelem_t>() as libc::c_ulong,
                Some(
                    ServerListEntryComparator_numberofplayer_reverse
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                        ) -> libc::c_int,
                ),
            );
        }
        3 => {
            qsort(
                serverlist.as_mut_ptr() as *mut libc::c_void,
                serverlistcount as size_t,
                ::core::mem::size_of::<serverelem_t>() as libc::c_ulong,
                Some(
                    ServerListEntryComparator_numberofplayer
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                        ) -> libc::c_int,
                ),
            );
        }
        4 => {
            qsort(
                serverlist.as_mut_ptr() as *mut libc::c_void,
                serverlistcount as size_t,
                ::core::mem::size_of::<serverelem_t>() as libc::c_ulong,
                Some(
                    ServerListEntryComparator_maxplayer_reverse
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                        ) -> libc::c_int,
                ),
            );
        }
        5 => {
            qsort(
                serverlist.as_mut_ptr() as *mut libc::c_void,
                serverlistcount as size_t,
                ::core::mem::size_of::<serverelem_t>() as libc::c_ulong,
                Some(
                    ServerListEntryComparator_gametypename
                        as unsafe extern "C" fn(
                            *const libc::c_void,
                            *const libc::c_void,
                        ) -> libc::c_int,
                ),
            );
        }
        _ => {}
    };
}
unsafe extern "C" fn M_CheckMODVersion(mut id: libc::c_int) -> boolean {
    let mut updatestring: [libc::c_char; 500] = [0; 500];
    let mut updatecheck: *const libc::c_char = GetMODVersion(id);
    if !updatecheck.is_null() {
        sprintf(
            updatestring.as_mut_ptr(),
            b"A new update is available for SRB2.\nPlease visit SRB2.org to download it.\n\nYou are using version: %s\nThe newest version is: %s\n\nThis update is required for online\nplay using the Master Server.\nYou will not be able to connect to\nthe Master Server until you update to\nthe newest version of the game.\n\n(Press a key)\n\0"
                as *const u8 as *const libc::c_char,
            b"v2.2.13\0" as *const u8 as *const libc::c_char,
            updatecheck,
        );
        M_StartMessage(updatestring.as_mut_ptr(), 0 as *mut libc::c_void, MM_NOTHING);
        return false_0 as libc::c_int;
    } else {
        return true_0 as libc::c_int
    };
}
unsafe extern "C" fn M_ConnectMenu(mut choice: int32_t) {
    serverlistpage = 0 as libc::c_int as uint32_t;
    if (ms_RoomId as libc::c_int) < 0 as libc::c_int {
        M_RoomMenu(0 as libc::c_int);
        (*currentMenu).prevMenu = &mut MP_MainDef;
    } else {
        M_SetupNextMenu(&mut MP_ConnectDef);
    }
    itemOn = 0 as libc::c_int as int16_t;
    M_Refresh(0 as libc::c_int);
}
unsafe extern "C" fn M_ConnectMenuModChecks(mut choice: int32_t) {
    if modifiedgame != 0 {
        M_StartMessage(
            b"You have add-ons loaded.\nYou won't be able to join netgames!\n\nTo play online, restart the game\nand don't load any addons.\nSRB2 will automatically add\neverything you need when you join.\n\n(Press a key)\n\0"
                as *const u8 as *const libc::c_char,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(int32_t) -> ()>,
                *mut libc::c_void,
            >(Some(M_ConnectMenu as unsafe extern "C" fn(int32_t) -> ())),
            MM_EVENTHANDLER,
        );
        return;
    }
    M_ConnectMenu(-(1 as libc::c_int));
}
#[no_mangle]
pub static mut roomIds: [uint32_t; 16] = [0; 16];
unsafe extern "C" fn M_RoomMenu(mut choice: int32_t) {
    let mut i: int32_t = 0;
    M_DrawTextBox(
        52 as libc::c_int,
        200 as libc::c_int / 2 as libc::c_int - 10 as libc::c_int,
        25 as libc::c_int,
        3 as libc::c_int,
    );
    V_DrawCenteredString(
        320 as libc::c_int / 2 as libc::c_int,
        200 as libc::c_int / 2 as libc::c_int,
        0 as libc::c_int,
        b"Fetching room info...\0" as *const u8 as *const libc::c_char,
    );
    V_DrawCenteredString(
        320 as libc::c_int / 2 as libc::c_int,
        200 as libc::c_int / 2 as libc::c_int + 12 as libc::c_int,
        0 as libc::c_int,
        b"Please wait.\0" as *const u8 as *const libc::c_char,
    );
    I_OsPolling();
    I_UpdateNoBlit();
    if rendermode as libc::c_uint == render_soft as libc::c_int as libc::c_uint {
        I_FinishUpdate();
    }
    i = 1 as libc::c_int;
    while i < 16 as libc::c_int + 1 as libc::c_int {
        MP_RoomMenu[i as usize]
            .status = (1 as libc::c_int
            + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)) as uint16_t;
        i += 1;
        i;
    }
    memset(
        roomIds.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[uint32_t; 16]>() as libc::c_ulong,
    );
    MP_RoomDef.prevMenu = currentMenu;
    M_SetupNextMenu(&mut MP_RoomDef);
    if M_CheckMODVersion(0 as libc::c_int) != 0 {
        GetRoomsList(
            ((*currentMenu).prevMenu == &mut MP_ServerDef as *mut menu_t) as libc::c_int,
            0 as libc::c_int,
        );
    }
}
unsafe extern "C" fn M_ChooseRoom(mut choice: int32_t) {
    if choice == 0 as libc::c_int {
        ms_RoomId = -(1 as libc::c_int) as int16_t;
    } else {
        ms_RoomId = roomIds[(choice - 1 as libc::c_int) as usize] as int16_t;
        menuRoomIndex = choice - 1 as libc::c_int;
    }
    serverlistpage = 0 as libc::c_int as uint32_t;
    if (*currentMenu).prevMenu == &mut MP_MainDef as *mut menu_t {
        M_SetupNextMenu(&mut MP_ConnectDef);
    } else {
        M_SetupNextMenu((*currentMenu).prevMenu);
    }
    if currentMenu == &mut MP_ConnectDef as *mut menu_t {
        M_Refresh(0 as libc::c_int);
    }
}
unsafe extern "C" fn M_StartServer(mut choice: int32_t) {
    let mut StartSplitScreenGame: boolean = (currentMenu
        == &mut MP_SplitServerDef as *mut menu_t) as libc::c_int;
    if StartSplitScreenGame == 0 {
        netgame = true_0 as libc::c_int;
    }
    multiplayer = true_0 as libc::c_int;
    cv_debug = 0 as libc::c_int;
    if demoplayback != 0 {
        G_StopDemo();
    }
    if metalrecording != 0 {
        G_StopMetalDemo();
    }
    if StartSplitScreenGame == 0 {
        D_MapChange(
            cv_nextmap.value,
            cv_newgametype.value,
            false_0 as libc::c_int,
            1 as libc::c_int,
            1 as libc::c_int,
            false_0 as libc::c_int,
            false_0 as libc::c_int,
        );
        COM_BufAddTextEx(
            b"dummyconsvar 1\n\0" as *const u8 as *const libc::c_char,
            0 as com_flags_t,
        );
    } else {
        paused = false_0 as libc::c_int as uint8_t;
        SV_StartSinglePlayerServer();
        if splitscreen == 0 {
            splitscreen = true_0 as libc::c_int;
            SplitScreen_OnChange();
        }
        D_MapChange(
            cv_nextmap.value,
            cv_newgametype.value,
            false_0 as libc::c_int,
            1 as libc::c_int,
            1 as libc::c_int,
            false_0 as libc::c_int,
            false_0 as libc::c_int,
        );
    }
    M_ClearMenus(true_0 as libc::c_int);
}
unsafe extern "C" fn M_DrawServerMenu() {
    M_DrawGenericMenu();
    if currentMenu == &mut MP_ServerDef as *mut menu_t {
        M_DrawLevelPlatterHeader(
            (*currentMenu).y as libc::c_int - 16 as libc::c_int / 2 as libc::c_int,
            b"Server settings\0" as *const u8 as *const libc::c_char,
            true_0 as libc::c_int,
            false_0 as libc::c_int,
        );
        if (ms_RoomId as libc::c_int) < 0 as libc::c_int {
            V_DrawRightAlignedString(
                320 as libc::c_int - (*currentMenu).x as libc::c_int,
                (*currentMenu).y as libc::c_int
                    + MP_ServerMenu[mp_server_room as libc::c_int as usize].alphaKey
                        as libc::c_int,
                0x2000 as libc::c_int,
                if itemOn as libc::c_int == mp_server_room as libc::c_int {
                    b"<Select to change>\0" as *const u8 as *const libc::c_char
                } else {
                    b"<Unlisted Mode>\0" as *const u8 as *const libc::c_char
                },
            );
        } else {
            V_DrawRightAlignedString(
                320 as libc::c_int - (*currentMenu).x as libc::c_int,
                (*currentMenu).y as libc::c_int
                    + MP_ServerMenu[mp_server_room as libc::c_int as usize].alphaKey
                        as libc::c_int,
                0x2000 as libc::c_int,
                (room_list[menuRoomIndex as usize].name).as_mut_ptr(),
            );
        }
    }
    if cv_nextmap.value != 0 {
        let mut PictureOfLevel: *mut patch_t = 0 as *mut patch_t;
        let mut lumpnum: lumpnum_t = 0;
        let mut headerstr: [libc::c_char; 40] = [0; 40];
        sprintf(
            headerstr.as_mut_ptr(),
            b"%s - %s\0" as *const u8 as *const libc::c_char,
            cv_newgametype.string,
            cv_nextmap.string,
        );
        M_DrawLevelPlatterHeader(
            (*currentMenu).y as libc::c_int
                + MP_ServerMenu[mp_server_levelgt as libc::c_int as usize].alphaKey
                    as libc::c_int - 10 as libc::c_int
                - 16 as libc::c_int / 2 as libc::c_int,
            headerstr.as_mut_ptr() as *const libc::c_char,
            true_0 as libc::c_int,
            false_0 as libc::c_int,
        );
        lumpnum = W_CheckNumForName(
            va(
                b"%sP\0" as *const u8 as *const libc::c_char,
                G_BuildMapName(cv_nextmap.value),
            ),
        );
        if lumpnum != 4294967295 as libc::c_uint {
            PictureOfLevel = W_CachePatchName(
                va(
                    b"%sP\0" as *const u8 as *const libc::c_char,
                    G_BuildMapName(cv_nextmap.value),
                ),
                PU_PATCH as libc::c_int,
            ) as *mut patch_t;
        } else {
            PictureOfLevel = W_CachePatchName(
                b"BLANKLVL\0" as *const u8 as *const libc::c_char,
                PU_PATCH as libc::c_int,
            ) as *mut patch_t;
        }
        V_DrawStretchyFixedPatch(
            319 as libc::c_int
                - ((*currentMenu).x as libc::c_int
                    + (*PictureOfLevel).width as libc::c_int / 2 as libc::c_int)
                << 16 as libc::c_int,
            ((*currentMenu).y as libc::c_int
                + MP_ServerMenu[mp_server_levelgt as libc::c_int as usize].alphaKey
                    as libc::c_int) << 16 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
            0 as libc::c_int,
            PictureOfLevel,
            0 as *const uint8_t,
        );
    }
}
unsafe extern "C" fn M_MapChange(mut choice: int32_t) {
    MISC_ChangeLevelDef.prevMenu = currentMenu;
    levellistmode = LLM_CREATESERVER;
    if Playing() != 0
        && M_CanShowLevelOnPlatter(
            cv_nextmap.value - 1 as libc::c_int,
            cv_newgametype.value,
        ) == 0
        && M_CanShowLevelOnPlatter(
            gamemap as libc::c_int - 1 as libc::c_int,
            cv_newgametype.value,
        ) != 0
    {
        CV_SetValue(&mut cv_nextmap, gamemap as int32_t);
    }
    if M_PrepareLevelPlatter(
        cv_newgametype.value,
        (currentMenu == &mut MPauseDef as *mut menu_t) as libc::c_int,
    ) == 0
    {
        M_StartMessage(
            b"No selectable levels found.\n\0" as *const u8 as *const libc::c_char,
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    }
    M_SetupNextMenu(&mut MISC_ChangeLevelDef);
}
unsafe extern "C" fn M_StartSplitServerMenu(mut choice: int32_t) {
    levellistmode = LLM_CREATESERVER;
    Newgametype_OnChange();
    M_SetupNextMenu(&mut MP_SplitServerDef);
}
unsafe extern "C" fn M_ServerOptions(mut choice: int32_t) {
    if splitscreen != 0 && netgame == 0
        || currentMenu == &mut MP_SplitServerDef as *mut menu_t
    {
        OP_ServerOptionsMenu[1 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
        OP_ServerOptionsMenu[2 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
        OP_ServerOptionsMenu[3 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
        OP_ServerOptionsMenu[4 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
        OP_ServerOptionsMenu[36 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
        OP_ServerOptionsMenu[37 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
        OP_ServerOptionsMenu[38 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
    } else {
        OP_ServerOptionsMenu[1 as libc::c_int as usize]
            .status = (32 as libc::c_int | 8 as libc::c_int | 1024 as libc::c_int)
            as uint16_t;
        OP_ServerOptionsMenu[2 as libc::c_int as usize]
            .status = (32 as libc::c_int | 8 as libc::c_int) as uint16_t;
        OP_ServerOptionsMenu[3 as libc::c_int as usize]
            .status = (32 as libc::c_int | 8 as libc::c_int) as uint16_t;
        OP_ServerOptionsMenu[4 as libc::c_int as usize]
            .status = (32 as libc::c_int | 8 as libc::c_int) as uint16_t;
        OP_ServerOptionsMenu[36 as libc::c_int as usize]
            .status = (32 as libc::c_int | 8 as libc::c_int | 1024 as libc::c_int)
            as uint16_t;
        OP_ServerOptionsMenu[37 as libc::c_int as usize]
            .status = (32 as libc::c_int | 8 as libc::c_int) as uint16_t;
        OP_ServerOptionsMenu[38 as libc::c_int as usize]
            .status = (32 as libc::c_int | 8 as libc::c_int) as uint16_t;
    }
    if currentMenu == &mut OP_MainDef as *mut menu_t {
        OP_ServerOptionsDef
            .menuid = (MN_OP_MAIN as libc::c_int
            | (MN_OP_SERVER as libc::c_int) << 6 as libc::c_int) as uint32_t;
    } else {
        OP_ServerOptionsDef
            .menuid = (MN_MP_MAIN as libc::c_int
            | (MN_MP_SERVER_OPTIONS as libc::c_int) << 6 as libc::c_int) as uint32_t;
    }
    OP_ServerOptionsDef.prevMenu = currentMenu;
    M_SetupNextMenu(&mut OP_ServerOptionsDef);
}
unsafe extern "C" fn M_StartServerMenu(mut choice: int32_t) {
    ms_RoomId = -(1 as libc::c_int) as int16_t;
    levellistmode = LLM_CREATESERVER;
    Newgametype_OnChange();
    M_SetupNextMenu(&mut MP_ServerDef);
    itemOn = 1 as libc::c_int as int16_t;
}
static mut setupm_ip: [libc::c_char; 128] = [0; 128];
unsafe extern "C" fn M_DrawConnectIP() {
    let mut x: int32_t = (*currentMenu).x as int32_t;
    let mut y: int32_t = (*currentMenu).y as libc::c_int + 22 as libc::c_int;
    let boxwidth_0: int32_t = 320 as libc::c_int
        - 2 as libc::c_int * (x + 5 as libc::c_int);
    let maxstrwidth: int32_t = boxwidth_0 - 5 as libc::c_int;
    let mut drawnstr: *mut libc::c_char = malloc(
        ::core::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong,
    ) as *mut libc::c_char;
    let mut drawnstr_orig: *mut libc::c_char = drawnstr;
    let mut drawthin: boolean = 0;
    let mut shorten: boolean = false_0 as libc::c_int;
    V_DrawFill(
        x + 5 as libc::c_int,
        y + 4 as libc::c_int + 5 as libc::c_int,
        boxwidth_0,
        8 as libc::c_int + 6 as libc::c_int,
        159 as libc::c_int,
    );
    strcpy(drawnstr, setupm_ip.as_mut_ptr());
    drawthin = (V_StringWidth(drawnstr, 0x800000 as libc::c_int)
        + V_StringWidth(
            b"_\0" as *const u8 as *const libc::c_char,
            0x800000 as libc::c_int,
        ) > maxstrwidth) as libc::c_int;
    if drawthin != 0 {
        let mut dotswidth: int32_t = V_ThinStringWidth(
            b"... \0" as *const u8 as *const libc::c_char,
            0x800000 as libc::c_int,
        );
        while V_ThinStringWidth(drawnstr, 0x800000 as libc::c_int)
            + V_ThinStringWidth(
                b"_\0" as *const u8 as *const libc::c_char,
                0x800000 as libc::c_int,
            ) >= maxstrwidth
        {
            shorten = true_0 as libc::c_int;
            drawnstr = drawnstr.offset(1);
            drawnstr;
        }
        if shorten != 0 {
            let mut initiallen: int32_t = V_ThinStringWidth(
                drawnstr,
                0x800000 as libc::c_int,
            );
            let mut cutofflen: int32_t = 0 as libc::c_int;
            loop {
                cutofflen = initiallen
                    - V_ThinStringWidth(drawnstr, 0x800000 as libc::c_int);
                if !(cutofflen < dotswidth) {
                    break;
                }
                drawnstr = drawnstr.offset(1);
                drawnstr;
            }
            V_DrawThinString(
                x + 8 as libc::c_int,
                y + 13 as libc::c_int,
                0x800000 as libc::c_int | 0x6000 as libc::c_int,
                b"... \0" as *const u8 as *const libc::c_char,
            );
            x
                += V_ThinStringWidth(
                    b"... \0" as *const u8 as *const libc::c_char,
                    0x800000 as libc::c_int,
                );
        }
        V_DrawThinString(
            x + 8 as libc::c_int,
            y + 13 as libc::c_int,
            0x800000 as libc::c_int,
            drawnstr,
        );
    } else {
        V_DrawString(
            x + 8 as libc::c_int,
            y + 12 as libc::c_int,
            0x800000 as libc::c_int,
            drawnstr,
        );
    }
    if itemOn as libc::c_int == 2 as libc::c_int
        && (skullAnimCounter as libc::c_int) < 4 as libc::c_int
    {
        if drawthin != 0 {
            V_DrawCharacter(
                x + 8 as libc::c_int
                    + V_ThinStringWidth(drawnstr, 0x800000 as libc::c_int),
                y + 12 as libc::c_int,
                '_' as i32,
                false_0 as libc::c_int,
            );
        } else {
            V_DrawCharacter(
                x + 8 as libc::c_int + V_StringWidth(drawnstr, 0x800000 as libc::c_int),
                y + 12 as libc::c_int,
                '_' as i32,
                false_0 as libc::c_int,
            );
        }
    }
    free(drawnstr_orig as *mut libc::c_void);
}
unsafe extern "C" fn M_DrawMPMainMenu() {
    let mut x: int32_t = (*currentMenu).x as int32_t;
    let mut y: int32_t = (*currentMenu).y as int32_t;
    M_DrawGenericMenu();
    V_DrawRightAlignedString(
        320 as libc::c_int - x,
        y + 66 as libc::c_int,
        if itemOn as libc::c_int == 4 as libc::c_int {
            0x2000 as libc::c_int
        } else {
            0 as libc::c_int
        },
        va(b"(2-%d players)\0" as *const u8 as *const libc::c_char, 32 as libc::c_int),
    );
    V_DrawRightAlignedString(
        320 as libc::c_int - x,
        y + 76 as libc::c_int,
        if itemOn as libc::c_int == 5 as libc::c_int {
            0x2000 as libc::c_int
        } else {
            0 as libc::c_int
        },
        b"(2 players)\0" as *const u8 as *const libc::c_char,
    );
    V_DrawRightAlignedString(
        320 as libc::c_int - x,
        y + 116 as libc::c_int,
        if itemOn as libc::c_int == 8 as libc::c_int {
            0x2000 as libc::c_int
        } else {
            0 as libc::c_int
        },
        b"(splitscreen)\0" as *const u8 as *const libc::c_char,
    );
    M_DrawConnectIP();
}
unsafe extern "C" fn M_ConnectIP(mut choice: int32_t) {
    if *setupm_ip.as_mut_ptr() as libc::c_int == 0 as libc::c_int {
        M_StartMessage(
            b"You must specify an IP address.\n\0" as *const u8 as *const libc::c_char,
            0 as *mut libc::c_void,
            MM_NOTHING,
        );
        return;
    }
    M_ClearMenus(true_0 as libc::c_int);
    COM_BufAddTextEx(
        va(
            b"connect \"%s\"\n\0" as *const u8 as *const libc::c_char,
            setupm_ip.as_mut_ptr(),
        ),
        0 as com_flags_t,
    );
    M_DrawTextBox(
        56 as libc::c_int,
        200 as libc::c_int / 2 as libc::c_int - 12 as libc::c_int,
        24 as libc::c_int,
        2 as libc::c_int,
    );
    V_DrawCenteredString(
        320 as libc::c_int / 2 as libc::c_int,
        200 as libc::c_int / 2 as libc::c_int,
        0 as libc::c_int,
        b"Connecting to server...\0" as *const u8 as *const libc::c_char,
    );
    I_OsPolling();
    I_UpdateNoBlit();
    if rendermode as libc::c_uint == render_soft as libc::c_int as libc::c_uint {
        I_FinishUpdate();
    }
}
unsafe extern "C" fn M_HandleConnectIP(mut choice: int32_t) {
    let mut l: size_t = 0;
    let mut exitmenu: boolean = false_0 as libc::c_int;
    let mut current_block_48: u64;
    match choice {
        238 => {
            M_NextOpt();
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            current_block_48 = 13281731871476506071;
        }
        230 => {
            M_PrevOpt();
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            current_block_48 = 13281731871476506071;
        }
        13 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            M_ConnectIP(1 as libc::c_int);
            current_block_48 = 13281731871476506071;
        }
        27 => {
            exitmenu = true_0 as libc::c_int;
            current_block_48 = 13281731871476506071;
        }
        8 => {
            l = strlen(setupm_ip.as_mut_ptr());
            if l != 0 as libc::c_int as size_t {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                setupm_ip[l.wrapping_sub(1 as libc::c_int as size_t)
                    as usize] = 0 as libc::c_int as libc::c_char;
            }
            current_block_48 = 13281731871476506071;
        }
        241 => {
            if setupm_ip[0 as libc::c_int as usize] as libc::c_int != 0 && shiftdown == 0
            {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                setupm_ip[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
            }
            if shiftdown == 0 {
                current_block_48 = 13281731871476506071;
            } else {
                current_block_48 = 11837596278867164089;
            }
        }
        _ => {
            current_block_48 = 11837596278867164089;
        }
    }
    match current_block_48 {
        11837596278867164089 => {
            l = strlen(setupm_ip.as_mut_ptr());
            if ctrldown != 0 {
                match choice {
                    118 | 86 => {
                        let mut paste: *const libc::c_char = I_ClipboardPaste();
                        if !paste.is_null() {
                            strncat(
                                setupm_ip.as_mut_ptr(),
                                paste,
                                ((128 as libc::c_int - 1 as libc::c_int) as size_t)
                                    .wrapping_sub(l),
                            );
                            if strlen(paste) != 0 as libc::c_int as libc::c_ulong {
                                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                            }
                        }
                    }
                    240 | 99 | 67 => {
                        I_ClipboardCopy(setupm_ip.as_mut_ptr(), l);
                        S_StartSound(0 as *const libc::c_void, sfx_menu1);
                    }
                    120 | 88 => {
                        I_ClipboardCopy(setupm_ip.as_mut_ptr(), l);
                        S_StartSound(0 as *const libc::c_void, sfx_menu1);
                        setupm_ip[0 as libc::c_int
                            as usize] = 0 as libc::c_int as libc::c_char;
                    }
                    _ => {}
                }
            } else {
                if shiftdown != 0 {
                    match choice {
                        240 => {
                            let mut paste_0: *const libc::c_char = I_ClipboardPaste();
                            if !paste_0.is_null() {
                                strncat(
                                    setupm_ip.as_mut_ptr(),
                                    paste_0,
                                    ((128 as libc::c_int - 1 as libc::c_int) as size_t)
                                        .wrapping_sub(l),
                                );
                                if strlen(paste_0) != 0 as libc::c_int as libc::c_ulong {
                                    S_StartSound(0 as *const libc::c_void, sfx_menu1);
                                }
                            }
                        }
                        241 => {
                            I_ClipboardCopy(setupm_ip.as_mut_ptr(), l);
                            S_StartSound(0 as *const libc::c_void, sfx_menu1);
                            setupm_ip[0 as libc::c_int
                                as usize] = 0 as libc::c_int as libc::c_char;
                        }
                        _ => {}
                    }
                }
                if !(l >= (128 as libc::c_int - 1 as libc::c_int) as size_t) {
                    if choice >= '-' as i32 && choice <= ':' as i32
                        || (choice == '[' as i32 || choice == ']' as i32)
                        || choice >= 'A' as i32 && choice <= 'Z' as i32
                        || choice >= 'a' as i32 && choice <= 'z' as i32
                    {
                        S_StartSound(0 as *const libc::c_void, sfx_menu1);
                        setupm_ip[l as usize] = choice as libc::c_char;
                        setupm_ip[l.wrapping_add(1 as libc::c_int as size_t)
                            as usize] = 0 as libc::c_int as libc::c_char;
                    } else if choice >= 199 as libc::c_int
                        && choice <= 211 as libc::c_int && choice != 202 as libc::c_int
                        && choice != 206 as libc::c_int
                    {
                        let mut keypad_translation: [libc::c_char; 13] = [
                            '7' as i32 as libc::c_char,
                            '8' as i32 as libc::c_char,
                            '9' as i32 as libc::c_char,
                            '-' as i32 as libc::c_char,
                            '4' as i32 as libc::c_char,
                            '5' as i32 as libc::c_char,
                            '6' as i32 as libc::c_char,
                            '+' as i32 as libc::c_char,
                            '1' as i32 as libc::c_char,
                            '2' as i32 as libc::c_char,
                            '3' as i32 as libc::c_char,
                            '0' as i32 as libc::c_char,
                            '.' as i32 as libc::c_char,
                        ];
                        choice = keypad_translation[(choice - 199 as libc::c_int)
                            as usize] as int32_t;
                        S_StartSound(0 as *const libc::c_void, sfx_menu1);
                        setupm_ip[l as usize] = choice as libc::c_char;
                        setupm_ip[l.wrapping_add(1 as libc::c_int as size_t)
                            as usize] = 0 as libc::c_int as libc::c_char;
                    }
                }
            }
        }
        _ => {}
    }
    if exitmenu != 0 {
        (*currentMenu).lastOn = itemOn;
        if !((*currentMenu).prevMenu).is_null() {
            M_SetupNextMenu((*currentMenu).prevMenu);
        } else {
            M_ClearMenus(true_0 as libc::c_int);
        }
    }
}
static mut multi_tics: fixed_t = 0;
static mut multi_frame: uint8_t = 0;
static mut multi_spr2: uint8_t = 0;
static mut multi_paused: boolean = 0;
static mut multi_invcolor: boolean = 0;
static mut setupm_name: [libc::c_char; 22] = [0; 22];
static mut setupm_player: *mut player_t = 0 as *const player_t as *mut player_t;
static mut setupm_cvskin: *mut consvar_t = 0 as *const consvar_t as *mut consvar_t;
static mut setupm_cvcolor: *mut consvar_t = 0 as *const consvar_t as *mut consvar_t;
static mut setupm_cvname: *mut consvar_t = 0 as *const consvar_t as *mut consvar_t;
static mut setupm_cvdefaultskin: *mut consvar_t = 0 as *const consvar_t
    as *mut consvar_t;
static mut setupm_cvdefaultcolor: *mut consvar_t = 0 as *const consvar_t
    as *mut consvar_t;
static mut setupm_fakeskin: int32_t = 0;
static mut setupm_fakecolor: *mut menucolor_t = 0 as *const menucolor_t
    as *mut menucolor_t;
static mut colorgrid: boolean = 0;
unsafe extern "C" fn M_GetColorGridIndex(mut color: uint16_t) -> uint16_t {
    let mut look: *mut menucolor_t = 0 as *mut menucolor_t;
    let mut i: uint16_t = 0 as libc::c_int as uint16_t;
    if skincolors[color as usize].accessible == 0 {
        return 0 as libc::c_int as uint16_t;
    }
    look = menucolorhead;
    loop {
        while skincolors[(*look).color as usize].accessible == 0 {
            if look == menucolortail {
                return 0 as libc::c_int as uint16_t;
            }
            look = (*look).next;
        }
        if (*look).color as libc::c_int == color as libc::c_int {
            return i;
        }
        if look == menucolortail {
            return 0 as libc::c_int as uint16_t;
        }
        i = i.wrapping_add(1);
        i;
        look = (*look).next;
    };
}
unsafe extern "C" fn M_GridIndexToX(mut index: uint16_t) -> int32_t {
    return index as libc::c_int % 16 as libc::c_int;
}
unsafe extern "C" fn M_GridIndexToY(mut index: uint16_t) -> int32_t {
    return index as libc::c_int / 16 as libc::c_int;
}
unsafe extern "C" fn M_ColorGridLen() -> uint16_t {
    let mut look: *mut menucolor_t = 0 as *mut menucolor_t;
    let mut i: uint16_t = 0 as libc::c_int as uint16_t;
    look = menucolorhead;
    loop {
        loop {
            if look == menucolortail {
                return i;
            }
            look = (*look).next;
            if !(skincolors[(*look).color as usize].accessible == 0) {
                break;
            }
        }
        i = i.wrapping_add(1);
        i;
    };
}
unsafe extern "C" fn M_GridPosToGridIndex(mut x: int32_t, mut y: int32_t) -> uint16_t {
    let grid_len: uint16_t = M_ColorGridLen();
    let grid_height: uint16_t = ((grid_len as libc::c_int - 1 as libc::c_int)
        / 16 as libc::c_int + 1 as libc::c_int) as uint16_t;
    let last_row_len: uint16_t = (16 as libc::c_int
        - (grid_height as libc::c_int * 16 as libc::c_int - grid_len as libc::c_int))
        as uint16_t;
    let mut row_len: uint16_t = 16 as libc::c_int as uint16_t;
    let mut new_index: uint16_t = 0 as libc::c_int as uint16_t;
    while y < 0 as libc::c_int {
        y += grid_height as libc::c_int;
    }
    y = y % grid_height as libc::c_int;
    if y >= grid_height as libc::c_int - 1 as libc::c_int
        && last_row_len as libc::c_int > 0 as libc::c_int
    {
        row_len = last_row_len;
    }
    while x < 0 as libc::c_int {
        x += row_len as libc::c_int;
    }
    x = x % row_len as libc::c_int;
    new_index = (y * 16 as libc::c_int + x) as uint16_t;
    if new_index as libc::c_int >= grid_len as libc::c_int {
        new_index = (grid_len as libc::c_int - 1 as libc::c_int) as uint16_t;
    }
    return new_index;
}
unsafe extern "C" fn M_GridIndexToMenuColor(mut index: uint16_t) -> *mut menucolor_t {
    let mut look: *mut menucolor_t = menucolorhead;
    let mut i: uint16_t = 0 as libc::c_int as uint16_t;
    look = menucolorhead;
    loop {
        while skincolors[(*look).color as usize].accessible == 0 {
            if look == menucolortail {
                return menucolorhead;
            }
            look = (*look).next;
        }
        if i as libc::c_int == index as libc::c_int {
            return look;
        }
        if look == menucolortail {
            return menucolorhead;
        }
        i = i.wrapping_add(1);
        i;
        look = (*look).next;
    };
}
unsafe extern "C" fn M_DrawSetupMultiPlayerMenu() {
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut cursory: int32_t = 0 as libc::c_int;
    let mut flags: int32_t = 0 as libc::c_int;
    let mut sprdef: *mut spritedef_t = 0 as *mut spritedef_t;
    let mut sprframe: *mut spriteframe_t = 0 as *mut spriteframe_t;
    let mut patch: *mut patch_t = 0 as *mut patch_t;
    let mut colormap: *mut uint8_t = 0 as *mut uint8_t;
    x = MP_PlayerSetupDef.x as int32_t;
    y = MP_PlayerSetupDef.y as int32_t;
    M_DrawMenuTitle();
    M_DrawLevelPlatterHeader(
        y - (16 as libc::c_int - 12 as libc::c_int),
        b"Name\0" as *const u8 as *const libc::c_char,
        true_0 as libc::c_int,
        false_0 as libc::c_int,
    );
    if itemOn as libc::c_int == 0 as libc::c_int {
        cursory = y;
    }
    y += 11 as libc::c_int;
    V_DrawFill(x, y, 282 as libc::c_int, 14 as libc::c_int, 159 as libc::c_int);
    V_DrawString(
        x + 8 as libc::c_int,
        y + 3 as libc::c_int,
        0x800000 as libc::c_int,
        setupm_name.as_mut_ptr(),
    );
    if (skullAnimCounter as libc::c_int) < 4 as libc::c_int
        && itemOn as libc::c_int == 0 as libc::c_int
    {
        V_DrawCharacter(
            x + 8 as libc::c_int
                + V_StringWidth(setupm_name.as_mut_ptr(), 0x800000 as libc::c_int),
            y + 3 as libc::c_int,
            '_' as i32 | 0x80 as libc::c_int,
            false_0 as libc::c_int,
        );
    }
    y += 20 as libc::c_int;
    M_DrawLevelPlatterHeader(
        y - (16 as libc::c_int - 12 as libc::c_int),
        b"Character\0" as *const u8 as *const libc::c_char,
        true_0 as libc::c_int,
        false_0 as libc::c_int,
    );
    if itemOn as libc::c_int == 1 as libc::c_int {
        cursory = y;
    }
    V_DrawRightAlignedString(
        320 as libc::c_int - x,
        y,
        (if MP_PlayerSetupMenu[1 as libc::c_int as usize].status as libc::c_int
            & 15 as libc::c_int == 1 as libc::c_int
        {
            0x50000 as libc::c_int
        } else {
            0 as libc::c_int
        })
            | (if itemOn as libc::c_int == 1 as libc::c_int {
                0x2000 as libc::c_int
            } else {
                0 as libc::c_int
            }) | 0x800000 as libc::c_int,
        (skins[setupm_fakeskin as usize].realname).as_mut_ptr(),
    );
    if itemOn as libc::c_int == 1 as libc::c_int
        && MP_PlayerSetupMenu[1 as libc::c_int as usize].status as libc::c_int
            & 15 as libc::c_int != 1 as libc::c_int
    {
        V_DrawCharacter(
            320 as libc::c_int - x - 10 as libc::c_int
                - V_StringWidth(
                    (skins[setupm_fakeskin as usize].realname).as_mut_ptr(),
                    0x800000 as libc::c_int,
                ) - skullAnimCounter as libc::c_int / 5 as libc::c_int,
            y,
            '\u{1c}' as i32 | 0x2000 as libc::c_int,
            false_0 as libc::c_int,
        );
        V_DrawCharacter(
            320 as libc::c_int - x + 2 as libc::c_int
                + skullAnimCounter as libc::c_int / 5 as libc::c_int,
            y,
            '\u{1d}' as i32 | 0x2000 as libc::c_int,
            false_0 as libc::c_int,
        );
    }
    x = if colorgrid != 0 {
        92 as libc::c_int
    } else {
        320 as libc::c_int / 2 as libc::c_int
    };
    y += 11 as libc::c_int;
    multi_tics -= renderdeltatics;
    while multi_paused == 0 && multi_tics <= 0 as libc::c_int {
        multi_frame = multi_frame.wrapping_add(1);
        multi_frame;
        multi_tics += 4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
    }
    V_DrawFill(
        x - 74 as libc::c_int / 2 as libc::c_int,
        y,
        74 as libc::c_int,
        84 as libc::c_int,
        if multi_invcolor != 0 {
            skincolors[skincolors[(*setupm_fakecolor).color as usize].invcolor as usize]
                .ramp[skincolors[(*setupm_fakecolor).color as usize].invshade as usize]
                as libc::c_int
        } else {
            159 as libc::c_int
        },
    );
    sprdef = &mut *((*skins.as_mut_ptr().offset(setupm_fakeskin as isize)).sprites)
        .as_mut_ptr()
        .offset(multi_spr2 as isize) as *mut spritedef_t;
    if (*setupm_fakecolor).color == 0 || (*sprdef).numframes == 0 {
        sprdef = &mut *sprites.offset(SPR_UNKN as libc::c_int as isize)
            as *mut spritedef_t;
        if (*sprdef).numframes == 0 {
            return;
        }
        sprframe = &mut *((*sprdef).spriteframes).offset(0 as libc::c_int as isize)
            as *mut spriteframe_t;
        patch = W_CachePatchNum(
            (*sprframe).lumppat[0 as libc::c_int as usize],
            PU_PATCH as libc::c_int,
        ) as *mut patch_t;
        if (*sprframe).flip as libc::c_int & 1 as libc::c_int != 0 {
            flags |= 0x800000 as libc::c_int;
        }
        V_DrawStretchyFixedPatch(
            x * ((1 as libc::c_int) << 16 as libc::c_int),
            (y + 64 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            (1 as libc::c_int) << 16 as libc::c_int,
            flags,
            patch,
            0 as *const uint8_t,
        );
    } else {
        colormap = R_GetTranslationColormap(
            setupm_fakeskin,
            (*setupm_fakecolor).color as skincolornum_t,
            1 as libc::c_int as uint8_t,
        );
        if multi_frame as size_t >= (*sprdef).numframes {
            multi_frame = 0 as libc::c_int as uint8_t;
        }
        sprframe = &mut *((*sprdef).spriteframes).offset(multi_frame as isize)
            as *mut spriteframe_t;
        patch = W_CachePatchNum(
            (*sprframe).lumppat[0 as libc::c_int as usize],
            PU_PATCH as libc::c_int,
        ) as *mut patch_t;
        if (*sprframe).flip as libc::c_int & 1 as libc::c_int != 0 {
            flags |= 0x800000 as libc::c_int;
        }
        V_DrawStretchyFixedPatch(
            x << 16 as libc::c_int,
            (y + 64 as libc::c_int) << 16 as libc::c_int,
            FixedDiv(
                skins[setupm_fakeskin as usize].highresscale,
                skins[setupm_fakeskin as usize].shieldscale,
            ),
            FixedDiv(
                skins[setupm_fakeskin as usize].highresscale,
                skins[setupm_fakeskin as usize].shieldscale,
            ),
            flags,
            patch,
            colormap,
        );
    }
    if colorgrid != 0 {
        let mut pos: uint16_t = 0;
        let mut cx: int16_t = 96 as libc::c_int as int16_t;
        let mut cy: int16_t = 66 as libc::c_int as int16_t;
        let mut i: int16_t = 0;
        let mut j: int16_t = 0;
        let mut w: int32_t = 8 as libc::c_int;
        let mut stoprow: boolean = false_0 as libc::c_int;
        let mut mc: *mut menucolor_t = 0 as *mut menucolor_t;
        let grid_len: uint16_t = M_ColorGridLen();
        let grid_end_y: uint16_t = M_GridIndexToY(
            (grid_len as libc::c_int - 1 as libc::c_int) as uint16_t,
        ) as uint16_t;
        let mut grid_select: int32_t = M_GetColorGridIndex((*setupm_fakecolor).color)
            as int32_t;
        let mut grid_select_y: int32_t = M_GridIndexToY(grid_select as uint16_t);
        x = 132 as libc::c_int;
        y = 66 as libc::c_int;
        pos = M_GridPosToGridIndex(
            0 as libc::c_int,
            if 0 as libc::c_int
                > (if (grid_select_y - 3 as libc::c_int)
                    < grid_end_y as libc::c_int - 7 as libc::c_int
                {
                    grid_select_y - 3 as libc::c_int
                } else {
                    grid_end_y as libc::c_int - 7 as libc::c_int
                })
            {
                0 as libc::c_int
            } else if (grid_select_y - 3 as libc::c_int)
                < grid_end_y as libc::c_int - 7 as libc::c_int
            {
                grid_select_y - 3 as libc::c_int
            } else {
                grid_end_y as libc::c_int - 7 as libc::c_int
            },
        );
        mc = M_GridIndexToMenuColor(pos);
        V_DrawFill(
            x - 2 as libc::c_int,
            y - 2 as libc::c_int,
            132 as libc::c_int,
            132 as libc::c_int,
            159 as libc::c_int,
        );
        j = 0 as libc::c_int as int16_t;
        while (j as libc::c_int) < 8 as libc::c_int {
            i = 0 as libc::c_int as int16_t;
            while (i as libc::c_int) < 16 as libc::c_int {
                if skincolors[(*mc).color as usize].accessible != 0 {
                    M_DrawColorRamp(
                        x + i as libc::c_int * w,
                        y + j as libc::c_int * 16 as libc::c_int,
                        w,
                        1 as libc::c_int,
                        skincolors[(*mc).color as usize],
                    );
                    if mc == setupm_fakecolor {
                        cx = (x + i as libc::c_int * w) as int16_t;
                        cy = (y + j as libc::c_int * 16 as libc::c_int) as int16_t;
                    }
                }
                if stoprow != 0 {
                    break;
                }
                loop {
                    mc = (*mc).next;
                    if mc == menucolortail {
                        stoprow = true_0 as libc::c_int;
                    }
                    if !(skincolors[(*mc).color as usize].accessible == 0
                        && stoprow == 0)
                    {
                        break;
                    }
                }
                i += 1;
                i;
            }
            if stoprow != 0 {
                break;
            }
            j += 1;
            j;
        }
        if pos as libc::c_int > 0 as libc::c_int {
            V_DrawCharacter(
                264 as libc::c_int,
                y - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                '\u{1a}' as i32 | 0x2000 as libc::c_int,
                false_0 as libc::c_int,
            );
        }
        if stoprow == 0 {
            V_DrawCharacter(
                264 as libc::c_int,
                y + 120 as libc::c_int
                    + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                '\u{1b}' as i32 | 0x2000 as libc::c_int,
                false_0 as libc::c_int,
            );
        }
        V_DrawFill(
            cx as libc::c_int - 2 as libc::c_int,
            cy as libc::c_int - 2 as libc::c_int,
            12 as libc::c_int,
            20 as libc::c_int,
            0 as libc::c_int,
        );
        V_DrawFill(
            cx as libc::c_int - 1 as libc::c_int,
            cy as libc::c_int - 1 as libc::c_int,
            11 as libc::c_int,
            19 as libc::c_int,
            31 as libc::c_int,
        );
        V_DrawFill(
            cx as int32_t,
            cy as int32_t,
            9 as libc::c_int,
            17 as libc::c_int,
            0 as libc::c_int,
        );
        M_DrawColorRamp(
            cx as int32_t,
            cy as int32_t,
            w,
            1 as libc::c_int,
            skincolors[(*setupm_fakecolor).color as usize],
        );
        V_DrawFill(
            55 as libc::c_int,
            148 as libc::c_int,
            74 as libc::c_int,
            1 as libc::c_int,
            73 as libc::c_int,
        );
        V_DrawFill(
            55 as libc::c_int,
            149 as libc::c_int,
            74 as libc::c_int,
            1 as libc::c_int,
            26 as libc::c_int,
        );
        M_DrawColorRamp(
            55 as libc::c_int,
            150 as libc::c_int,
            74 as libc::c_int,
            1 as libc::c_int,
            skincolors[(*setupm_fakecolor).color as usize],
        );
        V_DrawRightAlignedString(
            x - 2 as libc::c_int,
            166 as libc::c_int,
            (if MP_PlayerSetupMenu[2 as libc::c_int as usize].status as libc::c_int
                & 15 as libc::c_int == 1 as libc::c_int
            {
                0x50000 as libc::c_int
            } else {
                0 as libc::c_int
            })
                | (if itemOn as libc::c_int == 2 as libc::c_int {
                    0x2000 as libc::c_int
                } else {
                    0 as libc::c_int
                }) | 0x800000 as libc::c_int,
            (skincolors[(*setupm_fakecolor).color as usize].name).as_mut_ptr(),
        );
        return;
    } else {
        let numcolors: int32_t = (282 as libc::c_int - 74 as libc::c_int)
            / (2 as libc::c_int * 8 as libc::c_int);
        let mut w_0: int32_t = 8 as libc::c_int;
        let mut mc_0: *mut menucolor_t = (*setupm_fakecolor).prev;
        let mut i_0: int16_t = 0;
        x = MP_PlayerSetupDef.x as int32_t;
        y += 75 as libc::c_int;
        M_DrawLevelPlatterHeader(
            y - (16 as libc::c_int - 12 as libc::c_int),
            b"Color...\0" as *const u8 as *const libc::c_char,
            true_0 as libc::c_int,
            false_0 as libc::c_int,
        );
        V_DrawRightAlignedString(
            320 as libc::c_int - x,
            y,
            (if MP_PlayerSetupMenu[2 as libc::c_int as usize].status as libc::c_int
                & 15 as libc::c_int == 1 as libc::c_int
            {
                0x50000 as libc::c_int
            } else {
                0 as libc::c_int
            })
                | (if itemOn as libc::c_int == 2 as libc::c_int {
                    0x2000 as libc::c_int
                } else {
                    0 as libc::c_int
                }) | 0x800000 as libc::c_int,
            (skincolors[(*setupm_fakecolor).color as usize].name).as_mut_ptr(),
        );
        if itemOn as libc::c_int == 2 as libc::c_int {
            cursory = y;
            if MP_PlayerSetupMenu[2 as libc::c_int as usize].status as libc::c_int
                & 15 as libc::c_int != 1 as libc::c_int
            {
                V_DrawCharacter(
                    320 as libc::c_int - x - 10 as libc::c_int
                        - V_StringWidth(
                            (skincolors[(*setupm_fakecolor).color as usize].name)
                                .as_mut_ptr(),
                            0x800000 as libc::c_int,
                        ) - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                    y,
                    '\u{1c}' as i32 | 0x2000 as libc::c_int,
                    false_0 as libc::c_int,
                );
                V_DrawCharacter(
                    320 as libc::c_int - x + 2 as libc::c_int
                        + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                    y,
                    '\u{1d}' as i32 | 0x2000 as libc::c_int,
                    false_0 as libc::c_int,
                );
            }
        }
        x += numcolors * w_0;
        y += 11 as libc::c_int;
        M_DrawColorRamp(
            x,
            y,
            74 as libc::c_int,
            1 as libc::c_int,
            skincolors[(*setupm_fakecolor).color as usize],
        );
        i_0 = 0 as libc::c_int as int16_t;
        while (i_0 as libc::c_int) < numcolors {
            x -= w_0;
            while skincolors[(*mc_0).color as usize].accessible == 0 {
                mc_0 = (*mc_0).prev;
            }
            M_DrawColorRamp(
                x,
                y,
                w_0,
                1 as libc::c_int,
                skincolors[(*mc_0).color as usize],
            );
            mc_0 = (*mc_0).prev;
            i_0 += 1;
            i_0;
        }
        mc_0 = (*setupm_fakecolor).next;
        x += numcolors * w_0 + 74 as libc::c_int;
        i_0 = 0 as libc::c_int as int16_t;
        while (i_0 as libc::c_int) < numcolors {
            while skincolors[(*mc_0).color as usize].accessible == 0 {
                mc_0 = (*mc_0).next;
            }
            M_DrawColorRamp(
                x,
                y,
                w_0,
                1 as libc::c_int,
                skincolors[(*mc_0).color as usize],
            );
            x += w_0;
            mc_0 = (*mc_0).next;
            i_0 += 1;
            i_0;
        }
    }
    x = MP_PlayerSetupDef.x as int32_t;
    y += 20 as libc::c_int;
    V_DrawString(
        x,
        y,
        (if R_SkinAvailable((*setupm_cvdefaultskin).string) != setupm_fakeskin
            || (*setupm_cvdefaultcolor).value != (*setupm_fakecolor).color as libc::c_int
        {
            0 as libc::c_int
        } else {
            0x50000 as libc::c_int
        })
            | (if itemOn as libc::c_int == 3 as libc::c_int {
                0x2000 as libc::c_int
            } else {
                0 as libc::c_int
            }),
        b"Save as default\0" as *const u8 as *const libc::c_char,
    );
    if itemOn as libc::c_int == 3 as libc::c_int {
        cursory = y;
    }
    V_DrawStretchyFixedPatch(
        (x - 17 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
        cursory << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchName(
            b"M_CURSOR\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t,
        0 as *const uint8_t,
    );
}
unsafe extern "C" fn M_DrawColorRamp(
    mut x: int32_t,
    mut y: int32_t,
    mut w: int32_t,
    mut h: int32_t,
    mut color: skincolor_t,
) {
    let mut i: uint8_t = 0;
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 16 as libc::c_int {
        V_DrawFill(x, y + i as libc::c_int * h, w, h, color.ramp[i as usize] as int32_t);
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn M_HandleSetupMultiPlayer(mut choice: int32_t) {
    let mut l: size_t = 0;
    let mut prev_setupm_fakeskin: int32_t = 0;
    let mut exitmenu: boolean = false_0 as libc::c_int;
    let mut current_block_85: u64;
    match choice {
        238 | 230 => {
            if itemOn as libc::c_int == 2 as libc::c_int && colorgrid != 0 {
                let mut index: uint16_t = M_GetColorGridIndex((*setupm_fakecolor).color);
                let mut x: int32_t = M_GridIndexToX(index);
                let mut y: int32_t = M_GridIndexToY(index);
                y
                    += if choice == 0x80 as libc::c_int + 102 as libc::c_int {
                        -(1 as libc::c_int)
                    } else {
                        1 as libc::c_int
                    };
                index = M_GridPosToGridIndex(x, y);
                setupm_fakecolor = M_GridIndexToMenuColor(index);
            } else if choice == 0x80 as libc::c_int + 102 as libc::c_int {
                M_PrevOpt();
            } else {
                M_NextOpt();
            }
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            current_block_85 = 10213293998891106930;
        }
        233 => {
            if itemOn as libc::c_int == 1 as libc::c_int {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                prev_setupm_fakeskin = setupm_fakeskin;
                loop {
                    setupm_fakeskin -= 1;
                    setupm_fakeskin;
                    if setupm_fakeskin < 0 as libc::c_int {
                        setupm_fakeskin = numskins - 1 as libc::c_int;
                    }
                    if !(prev_setupm_fakeskin != setupm_fakeskin
                        && R_SkinUsable(-(1 as libc::c_int), setupm_fakeskin) == 0)
                    {
                        break;
                    }
                }
                multi_spr2 = P_GetSkinSprite2(
                    &mut *skins.as_mut_ptr().offset(setupm_fakeskin as isize),
                    SPR2_WALK as libc::c_int as uint8_t,
                    0 as *mut player_t,
                );
            } else if itemOn as libc::c_int == 2 as libc::c_int {
                setupm_fakecolor = (*setupm_fakecolor).prev;
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
            }
            current_block_85 = 10213293998891106930;
        }
        13 => {
            if itemOn as libc::c_int == 3 as libc::c_int
                && (R_SkinAvailable((*setupm_cvdefaultskin).string) != setupm_fakeskin
                    || (*setupm_cvdefaultcolor).value
                        != (*setupm_fakecolor).color as libc::c_int)
            {
                S_StartSound(0 as *const libc::c_void, sfx_strpst);
                COM_BufAddTextEx(
                    va(
                        b"%s \"%s\"\n\0" as *const u8 as *const libc::c_char,
                        (*setupm_cvdefaultskin).name,
                        (skins[setupm_fakeskin as usize].name).as_mut_ptr(),
                    ),
                    0 as com_flags_t,
                );
                COM_BufAddTextEx(
                    va(
                        b"%s %d\n\0" as *const u8 as *const libc::c_char,
                        (*setupm_cvdefaultcolor).name,
                        (*setupm_fakecolor).color as libc::c_int,
                    ),
                    0 as com_flags_t,
                );
                current_block_85 = 10213293998891106930;
            } else if itemOn as libc::c_int == 2 as libc::c_int {
                if colorgrid == 0 {
                    S_StartSound(0 as *const libc::c_void, sfx_menu1);
                }
                colorgrid = (colorgrid == 0) as libc::c_int;
                current_block_85 = 10213293998891106930;
            } else {
                current_block_85 = 5934139102650740834;
            }
        }
        235 => {
            current_block_85 = 5934139102650740834;
        }
        231 | 239 => {
            let mut i: uint8_t = 0;
            if itemOn as libc::c_int == 2 as libc::c_int {
                if colorgrid != 0 {
                    let mut index_0: uint16_t = M_GetColorGridIndex(
                        (*setupm_fakecolor).color,
                    );
                    let mut x_0: int32_t = M_GridIndexToX(index_0);
                    let mut y_0: int32_t = M_GridIndexToY(index_0);
                    y_0
                        += if choice == 0x80 as libc::c_int + 102 as libc::c_int {
                            -(4 as libc::c_int)
                        } else {
                            4 as libc::c_int
                        };
                    index_0 = M_GridPosToGridIndex(x_0, y_0);
                    setupm_fakecolor = M_GridIndexToMenuColor(index_0);
                } else {
                    i = 0 as libc::c_int as uint8_t;
                    while (i as libc::c_int) < 13 as libc::c_int {
                        setupm_fakecolor = if choice
                            == 0x80 as libc::c_int + 103 as libc::c_int
                        {
                            (*setupm_fakecolor).prev
                        } else {
                            (*setupm_fakecolor).next
                        };
                        while skincolors[(*setupm_fakecolor).color as usize].accessible
                            == 0
                        {
                            setupm_fakecolor = if choice
                                == 0x80 as libc::c_int + 103 as libc::c_int
                            {
                                (*setupm_fakecolor).prev
                            } else {
                                (*setupm_fakecolor).next
                            };
                        }
                        i = i.wrapping_add(1);
                        i;
                    }
                }
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
            }
            current_block_85 = 10213293998891106930;
        }
        27 => {
            if itemOn as libc::c_int == 2 as libc::c_int && colorgrid != 0 {
                colorgrid = false_0 as libc::c_int;
            } else {
                exitmenu = true_0 as libc::c_int;
            }
            current_block_85 = 10213293998891106930;
        }
        8 => {
            if itemOn as libc::c_int == 0 as libc::c_int
                && {
                    l = strlen(setupm_name.as_mut_ptr());
                    l != 0 as libc::c_int as size_t
                }
            {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                setupm_name[l.wrapping_sub(1 as libc::c_int as size_t)
                    as usize] = 0 as libc::c_int as libc::c_char;
            } else if itemOn as libc::c_int == 2 as libc::c_int {
                let mut col: uint16_t = skins[setupm_fakeskin as usize].prefcolor;
                if (*setupm_fakecolor).color as libc::c_int != col as libc::c_int
                    && skincolors[col as usize].accessible != 0
                {
                    S_StartSound(0 as *const libc::c_void, sfx_menu1);
                    setupm_fakecolor = menucolorhead;
                    while !((*setupm_fakecolor).color as libc::c_int
                        == col as libc::c_int || setupm_fakecolor == menucolortail)
                    {
                        setupm_fakecolor = (*setupm_fakecolor).next;
                    }
                }
            }
            current_block_85 = 10213293998891106930;
        }
        241 => {
            if itemOn as libc::c_int == 0 as libc::c_int
                && {
                    l = strlen(setupm_name.as_mut_ptr());
                    l != 0 as libc::c_int as size_t
                }
            {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                setupm_name[0 as libc::c_int
                    as usize] = 0 as libc::c_int as libc::c_char;
            }
            current_block_85 = 10213293998891106930;
        }
        255 => {
            multi_paused = (multi_paused == 0) as libc::c_int;
            current_block_85 = 10213293998891106930;
        }
        240 => {
            multi_invcolor = (multi_invcolor == 0) as libc::c_int;
            current_block_85 = 10213293998891106930;
        }
        _ => {
            if itemOn as libc::c_int != 0 as libc::c_int || choice < 32 as libc::c_int
                || choice > 127 as libc::c_int
            {
                current_block_85 = 10213293998891106930;
            } else {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                l = strlen(setupm_name.as_mut_ptr());
                if l < 21 as libc::c_int as size_t {
                    setupm_name[l as usize] = choice as libc::c_char;
                    setupm_name[l.wrapping_add(1 as libc::c_int as size_t)
                        as usize] = 0 as libc::c_int as libc::c_char;
                }
                current_block_85 = 10213293998891106930;
            }
        }
    }
    match current_block_85 {
        5934139102650740834 => {
            if itemOn as libc::c_int == 1 as libc::c_int {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                prev_setupm_fakeskin = setupm_fakeskin;
                loop {
                    setupm_fakeskin += 1;
                    setupm_fakeskin;
                    if setupm_fakeskin > numskins - 1 as libc::c_int {
                        setupm_fakeskin = 0 as libc::c_int;
                    }
                    if !(prev_setupm_fakeskin != setupm_fakeskin
                        && R_SkinUsable(-(1 as libc::c_int), setupm_fakeskin) == 0)
                    {
                        break;
                    }
                }
                multi_spr2 = P_GetSkinSprite2(
                    &mut *skins.as_mut_ptr().offset(setupm_fakeskin as isize),
                    SPR2_WALK as libc::c_int as uint8_t,
                    0 as *mut player_t,
                );
            } else if itemOn as libc::c_int == 2 as libc::c_int {
                setupm_fakecolor = (*setupm_fakecolor).next;
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
            }
        }
        _ => {}
    }
    if itemOn as libc::c_int == 2 as libc::c_int
        && skincolors[(*setupm_fakecolor).color as usize].accessible == 0
    {
        if choice == 0x80 as libc::c_int + 105 as libc::c_int {
            while skincolors[(*setupm_fakecolor).color as usize].accessible == 0 {
                setupm_fakecolor = (*setupm_fakecolor).prev;
            }
        } else if choice == 0x80 as libc::c_int + 107 as libc::c_int
            || choice == 13 as libc::c_int
        {
            while skincolors[(*setupm_fakecolor).color as usize].accessible == 0 {
                setupm_fakecolor = (*setupm_fakecolor).next;
            }
        }
    }
    if exitmenu != 0 {
        if !((*currentMenu).prevMenu).is_null() {
            M_SetupNextMenu((*currentMenu).prevMenu);
        } else {
            M_ClearMenus(true_0 as libc::c_int);
        }
    }
}
unsafe extern "C" fn M_SetupMultiPlayer(mut choice: int32_t) {
    multi_frame = 0 as libc::c_int as uint8_t;
    multi_tics = 4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
    strcpy(setupm_name.as_mut_ptr(), cv_playername.string);
    setupm_player = &mut *players.as_mut_ptr().offset(consoleplayer as isize)
        as *mut player_t;
    setupm_cvskin = &mut cv_skin;
    setupm_cvcolor = &mut cv_playercolor;
    setupm_cvname = &mut cv_playername;
    setupm_cvdefaultskin = &mut cv_defaultskin;
    setupm_cvdefaultcolor = &mut cv_defaultplayercolor;
    setupm_fakeskin = R_SkinAvailable((*setupm_cvskin).string);
    if setupm_fakeskin == -(1 as libc::c_int) {
        setupm_fakeskin = 0 as libc::c_int;
    }
    setupm_fakecolor = menucolorhead;
    while !((*setupm_fakecolor).color as libc::c_int == (*setupm_cvcolor).value
        || setupm_fakecolor == menucolortail)
    {
        setupm_fakecolor = (*setupm_fakecolor).next;
    }
    if CanChangeSkin(consoleplayer) == 0 {
        MP_PlayerSetupMenu[1 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
    } else {
        MP_PlayerSetupMenu[1 as libc::c_int as usize]
            .status = (4 as libc::c_int | 32 as libc::c_int) as uint16_t;
    }
    if Playing() != 0 && G_GametypeHasTeams() != 0 {
        MP_PlayerSetupMenu[2 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
    } else {
        MP_PlayerSetupMenu[2 as libc::c_int as usize]
            .status = (4 as libc::c_int | 32 as libc::c_int) as uint16_t;
    }
    multi_spr2 = P_GetSkinSprite2(
        &mut *skins.as_mut_ptr().offset(setupm_fakeskin as isize),
        SPR2_WALK as libc::c_int as uint8_t,
        0 as *mut player_t,
    );
    MP_PlayerSetupDef.prevMenu = currentMenu;
    M_SetupNextMenu(&mut MP_PlayerSetupDef);
}
unsafe extern "C" fn M_SetupMultiPlayer2(mut choice: int32_t) {
    multi_frame = 0 as libc::c_int as uint8_t;
    multi_tics = 4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
    strcpy(setupm_name.as_mut_ptr(), cv_playername2.string);
    setupm_player = &mut *players.as_mut_ptr().offset(secondarydisplayplayer as isize)
        as *mut player_t;
    setupm_cvskin = &mut cv_skin2;
    setupm_cvcolor = &mut cv_playercolor2;
    setupm_cvname = &mut cv_playername2;
    setupm_cvdefaultskin = &mut cv_defaultskin2;
    setupm_cvdefaultcolor = &mut cv_defaultplayercolor2;
    setupm_fakeskin = R_SkinAvailable((*setupm_cvskin).string);
    if setupm_fakeskin == -(1 as libc::c_int) {
        setupm_fakeskin = 0 as libc::c_int;
    }
    setupm_fakecolor = menucolorhead;
    while !((*setupm_fakecolor).color as libc::c_int == (*setupm_cvcolor).value
        || setupm_fakecolor == menucolortail)
    {
        setupm_fakecolor = (*setupm_fakecolor).next;
    }
    if splitscreen != 0 && CanChangeSkin(secondarydisplayplayer) == 0 {
        MP_PlayerSetupMenu[1 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
    } else {
        MP_PlayerSetupMenu[1 as libc::c_int as usize]
            .status = (4 as libc::c_int | 32 as libc::c_int) as uint16_t;
    }
    if Playing() != 0 && G_GametypeHasTeams() != 0 {
        MP_PlayerSetupMenu[2 as libc::c_int as usize]
            .status = (1 as libc::c_int + (16 as libc::c_int + 128 as libc::c_int))
            as uint16_t;
    } else {
        MP_PlayerSetupMenu[2 as libc::c_int as usize]
            .status = (4 as libc::c_int | 32 as libc::c_int) as uint16_t;
    }
    multi_spr2 = P_GetSkinSprite2(
        &mut *skins.as_mut_ptr().offset(setupm_fakeskin as isize),
        SPR2_WALK as libc::c_int as uint8_t,
        0 as *mut player_t,
    );
    MP_PlayerSetupDef.prevMenu = currentMenu;
    M_SetupNextMenu(&mut MP_PlayerSetupDef);
}
unsafe extern "C" fn M_QuitMultiPlayerMenu() -> boolean {
    let mut l: size_t = 0;
    if strcmp(setupm_name.as_mut_ptr(), (*setupm_cvname).string) != 0 {
        l = (strlen(setupm_name.as_mut_ptr()))
            .wrapping_sub(1 as libc::c_int as libc::c_ulong);
        while l as libc::c_int >= 0 as libc::c_int
            && setupm_name[l as usize] as libc::c_int == ' ' as i32
        {
            setupm_name[l as usize] = 0 as libc::c_int as libc::c_char;
            l = l.wrapping_sub(1);
            l;
        }
        COM_BufAddTextEx(
            va(
                b"%s \"%s\"\n\0" as *const u8 as *const libc::c_char,
                (*setupm_cvname).name,
                setupm_name.as_mut_ptr(),
            ),
            0 as com_flags_t,
        );
    }
    COM_BufAddTextEx(
        va(
            b"%s \"%s\"\n\0" as *const u8 as *const libc::c_char,
            (*setupm_cvskin).name,
            (skins[setupm_fakeskin as usize].name).as_mut_ptr(),
        ),
        0 as com_flags_t,
    );
    if (*setupm_fakecolor).color as libc::c_int != (*setupm_cvcolor).value {
        COM_BufAddTextEx(
            va(
                b"%s %d\n\0" as *const u8 as *const libc::c_char,
                (*setupm_cvcolor).name,
                (*setupm_fakecolor).color as libc::c_int,
            ),
            0 as com_flags_t,
        );
    }
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn M_AddMenuColor(mut color: uint16_t) {
    let mut c: *mut menucolor_t = 0 as *mut menucolor_t;
    if color as libc::c_int >= numskincolors as libc::c_int {
        CONS_Printf(
            b"M_AddMenuColor: color %d does not exist.\0" as *const u8
                as *const libc::c_char,
            color as libc::c_int,
        );
        return;
    }
    c = malloc(::core::mem::size_of::<menucolor_t>() as libc::c_ulong)
        as *mut menucolor_t;
    (*c).color = color;
    if menucolorhead.is_null() {
        (*c).next = c;
        (*c).prev = c;
        menucolorhead = c;
        menucolortail = c;
    } else {
        (*c).next = menucolorhead;
        (*c).prev = menucolortail;
        (*menucolortail).next = c;
        (*menucolorhead).prev = c;
        menucolortail = c;
    };
}
#[no_mangle]
pub unsafe extern "C" fn M_MoveColorBefore(mut color: uint16_t, mut targ: uint16_t) {
    let mut look: *mut menucolor_t = 0 as *mut menucolor_t;
    let mut c: *mut menucolor_t = 0 as *mut menucolor_t;
    let mut t: *mut menucolor_t = 0 as *mut menucolor_t;
    if color as libc::c_int == targ as libc::c_int {
        return;
    }
    if color as libc::c_int >= numskincolors as libc::c_int {
        CONS_Printf(
            b"M_MoveColorBefore: color %d does not exist.\0" as *const u8
                as *const libc::c_char,
            color as libc::c_int,
        );
        return;
    }
    if targ as libc::c_int >= numskincolors as libc::c_int {
        CONS_Printf(
            b"M_MoveColorBefore: target color %d does not exist.\0" as *const u8
                as *const libc::c_char,
            targ as libc::c_int,
        );
        return;
    }
    look = menucolorhead;
    loop {
        if (*look).color as libc::c_int == color as libc::c_int {
            c = look;
        } else if (*look).color as libc::c_int == targ as libc::c_int {
            t = look;
        }
        if !c.is_null() && !t.is_null() {
            break;
        }
        if look == menucolortail {
            return;
        }
        look = (*look).next;
    }
    if c == (*t).prev {
        return;
    }
    if t == menucolorhead {
        menucolorhead = c;
    }
    if c == menucolortail {
        menucolortail = (*c).prev;
    }
    (*(*c).prev).next = (*c).next;
    (*(*c).next).prev = (*c).prev;
    (*c).prev = (*t).prev;
    (*c).next = t;
    (*(*t).prev).next = c;
    (*t).prev = c;
}
#[no_mangle]
pub unsafe extern "C" fn M_MoveColorAfter(mut color: uint16_t, mut targ: uint16_t) {
    let mut look: *mut menucolor_t = 0 as *mut menucolor_t;
    let mut c: *mut menucolor_t = 0 as *mut menucolor_t;
    let mut t: *mut menucolor_t = 0 as *mut menucolor_t;
    if color as libc::c_int == targ as libc::c_int {
        return;
    }
    if color as libc::c_int >= numskincolors as libc::c_int {
        CONS_Printf(
            b"M_MoveColorAfter: color %d does not exist.\n\0" as *const u8
                as *const libc::c_char,
            color as libc::c_int,
        );
        return;
    }
    if targ as libc::c_int >= numskincolors as libc::c_int {
        CONS_Printf(
            b"M_MoveColorAfter: target color %d does not exist.\n\0" as *const u8
                as *const libc::c_char,
            targ as libc::c_int,
        );
        return;
    }
    look = menucolorhead;
    loop {
        if (*look).color as libc::c_int == color as libc::c_int {
            c = look;
        } else if (*look).color as libc::c_int == targ as libc::c_int {
            t = look;
        }
        if !c.is_null() && !t.is_null() {
            break;
        }
        if look == menucolortail {
            return;
        }
        look = (*look).next;
    }
    if t == (*c).prev {
        return;
    }
    if t == menucolortail {
        menucolortail = c;
    } else if c == menucolortail {
        menucolortail = (*c).prev;
    }
    (*(*c).prev).next = (*c).next;
    (*(*c).next).prev = (*c).prev;
    (*c).next = (*t).next;
    (*c).prev = t;
    (*(*t).next).prev = c;
    (*t).next = c;
}
#[no_mangle]
pub unsafe extern "C" fn M_GetColorBefore(mut color: uint16_t) -> uint16_t {
    let mut look: *mut menucolor_t = 0 as *mut menucolor_t;
    if color as libc::c_int >= numskincolors as libc::c_int {
        CONS_Printf(
            b"M_GetColorBefore: color %d does not exist.\n\0" as *const u8
                as *const libc::c_char,
            color as libc::c_int,
        );
        return 0 as libc::c_int as uint16_t;
    }
    look = menucolorhead;
    loop {
        if (*look).color as libc::c_int == color as libc::c_int {
            return (*(*look).prev).color;
        }
        if look == menucolortail {
            return 0 as libc::c_int as uint16_t;
        }
        look = (*look).next;
    };
}
#[no_mangle]
pub unsafe extern "C" fn M_GetColorAfter(mut color: uint16_t) -> uint16_t {
    let mut look: *mut menucolor_t = 0 as *mut menucolor_t;
    if color as libc::c_int >= numskincolors as libc::c_int {
        CONS_Printf(
            b"M_GetColorAfter: color %d does not exist.\n\0" as *const u8
                as *const libc::c_char,
            color as libc::c_int,
        );
        return 0 as libc::c_int as uint16_t;
    }
    look = menucolorhead;
    loop {
        if (*look).color as libc::c_int == color as libc::c_int {
            return (*(*look).next).color;
        }
        if look == menucolortail {
            return 0 as libc::c_int as uint16_t;
        }
        look = (*look).next;
    };
}
#[no_mangle]
pub unsafe extern "C" fn M_GetColorIndex(mut color: uint16_t) -> uint16_t {
    let mut look: *mut menucolor_t = 0 as *mut menucolor_t;
    let mut i: uint16_t = 0 as libc::c_int as uint16_t;
    if color as libc::c_int >= numskincolors as libc::c_int {
        CONS_Printf(
            b"M_GetColorIndex: color %d does not exist.\n\0" as *const u8
                as *const libc::c_char,
            color as libc::c_int,
        );
        return 0 as libc::c_int as uint16_t;
    }
    look = menucolorhead;
    loop {
        if (*look).color as libc::c_int == color as libc::c_int {
            return i;
        }
        if look == menucolortail {
            return 0 as libc::c_int as uint16_t;
        }
        i = i.wrapping_add(1);
        i;
        look = (*look).next;
    };
}
#[no_mangle]
pub unsafe extern "C" fn M_GetColorFromIndex(mut index: uint16_t) -> *mut menucolor_t {
    let mut look: *mut menucolor_t = menucolorhead;
    let mut i: uint16_t = 0 as libc::c_int as uint16_t;
    if index as libc::c_int >= numskincolors as libc::c_int {
        CONS_Printf(
            b"M_GetColorIndex: index %d does not exist.\n\0" as *const u8
                as *const libc::c_char,
            index as libc::c_int,
        );
        return 0 as *mut menucolor_t;
    }
    i = 0 as libc::c_int as uint16_t;
    while i as libc::c_int <= index as libc::c_int {
        if look == menucolortail {
            return menucolorhead;
        }
        look = (*look).next;
        i = i.wrapping_add(1);
        i;
    }
    return look;
}
#[no_mangle]
pub unsafe extern "C" fn M_InitPlayerSetupColors() {
    let mut i: uint8_t = 0;
    numskincolors = SKINCOLOR_FIRSTFREESLOT as libc::c_int as uint16_t;
    menucolortail = 0 as *mut menucolor_t;
    menucolorhead = menucolortail;
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < numskincolors as libc::c_int {
        M_AddMenuColor(i as uint16_t);
        i = i.wrapping_add(1);
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn M_FreePlayerSetupColors() {
    let mut look: *mut menucolor_t = menucolorhead;
    let mut tmp: *mut menucolor_t = 0 as *mut menucolor_t;
    if menucolorhead.is_null() {
        return;
    }
    while true_0 as libc::c_int != 0 {
        if look != menucolortail {
            tmp = look;
            look = (*look).next;
            free(tmp as *mut libc::c_void);
        } else {
            free(look as *mut libc::c_void);
            return;
        }
    }
    menucolortail = 0 as *mut menucolor_t;
    menucolorhead = menucolortail;
}
static mut erasecontext: uint8_t = 0 as libc::c_int as uint8_t;
unsafe extern "C" fn M_EraseDataResponse(mut ch: int32_t) {
    if ch != 'y' as i32 && ch != 13 as libc::c_int {
        return;
    }
    if erasecontext as libc::c_int != 1 as libc::c_int {
        G_ClearRecords(clientGamedata);
    }
    if erasecontext as libc::c_int != 0 as libc::c_int {
        M_ClearSecrets(clientGamedata);
    }
    if erasecontext as libc::c_int == 2 as libc::c_int {
        (*clientGamedata).totalplaytime = 0 as libc::c_int as uint32_t;
        F_StartIntro();
    }
    S_StartSound(
        0 as *const libc::c_void,
        (sfx_bewar1 as libc::c_int + M_RandomKey(4 as libc::c_int)) as sfxenum_t,
    );
    M_ClearMenus(true_0 as libc::c_int);
}
unsafe extern "C" fn M_EraseData(mut choice: int32_t) {
    let mut eschoice: *const libc::c_char = 0 as *const libc::c_char;
    let mut esstr: *const libc::c_char = b"Are you sure you want to erase\n%s?\n\n(Press 'Y' to confirm)\n\0"
        as *const u8 as *const libc::c_char;
    erasecontext = choice as uint8_t;
    if choice == 0 as libc::c_int {
        eschoice = b"Record Attack data\0" as *const u8 as *const libc::c_char;
    } else if choice == 1 as libc::c_int {
        eschoice = b"Extras data\0" as *const u8 as *const libc::c_char;
    } else {
        eschoice = b"ALL game data\0" as *const u8 as *const libc::c_char;
    }
    M_StartMessage(
        va(esstr, eschoice),
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(int32_t) -> ()>,
            *mut libc::c_void,
        >(Some(M_EraseDataResponse as unsafe extern "C" fn(int32_t) -> ())),
        MM_YESNO,
    );
}
unsafe extern "C" fn M_ScreenshotOptions(mut choice: int32_t) {
    Screenshot_option_Onchange();
    Moviemode_mode_Onchange();
    M_SetupScreenshotMenu();
    M_SetupNextMenu(&mut OP_ScreenshotOptionsDef);
}
unsafe extern "C" fn M_SetupScreenshotMenu() {
    let mut item: *mut menuitem_t = &mut *OP_ScreenshotOptionsMenu
        .as_mut_ptr()
        .offset(op_screenshot_colorprofile as libc::c_int as isize) as *mut menuitem_t;
    (*item).status = (32 as libc::c_int | 8 as libc::c_int) as uint16_t;
}
unsafe extern "C" fn M_DrawJoystick() {
    let mut i: int32_t = 0;
    let mut compareval2: int32_t = 0;
    let mut compareval: int32_t = 0;
    M_DrawMenuTitle();
    i = 0 as libc::c_int;
    while i <= 4 as libc::c_int {
        M_DrawTextBox(
            OP_JoystickSetDef.x as libc::c_int - 8 as libc::c_int,
            OP_JoystickSetDef.y as libc::c_int + 16 as libc::c_int * i
                - 12 as libc::c_int,
            28 as libc::c_int,
            1 as libc::c_int,
        );
        compareval2 = cv_usejoystick2.value;
        compareval = cv_usejoystick.value;
        if setupcontrols_secondaryplayer != 0 && i == compareval2
            || setupcontrols_secondaryplayer == 0 && i == compareval
        {
            V_DrawString(
                OP_JoystickSetDef.x as int32_t,
                OP_JoystickSetDef.y as libc::c_int + 16 as libc::c_int * i
                    - 4 as libc::c_int,
                0x3000 as libc::c_int,
                (joystickInfo[i as usize]).as_mut_ptr(),
            );
        } else {
            V_DrawString(
                OP_JoystickSetDef.x as int32_t,
                OP_JoystickSetDef.y as libc::c_int + 16 as libc::c_int * i
                    - 4 as libc::c_int,
                0 as libc::c_int,
                (joystickInfo[i as usize]).as_mut_ptr(),
            );
        }
        if i == itemOn as libc::c_int {
            V_DrawStretchyFixedPatch(
                ((*currentMenu).x as libc::c_int - 24 as libc::c_int)
                    * ((1 as libc::c_int) << 16 as libc::c_int),
                (OP_JoystickSetDef.y as libc::c_int + 16 as libc::c_int * i
                    - 4 as libc::c_int) << 16 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                0 as libc::c_int,
                W_CachePatchName(
                    b"M_CURSOR\0" as *const u8 as *const libc::c_char,
                    PU_PATCH as libc::c_int,
                ) as *mut patch_t,
                0 as *const uint8_t,
            );
        }
        i += 1;
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn M_SetupJoystickMenu(mut choice: int32_t) {
    let mut i: int32_t = 0 as libc::c_int;
    let mut joyNA: *const libc::c_char = b"Unavailable\0" as *const u8
        as *const libc::c_char;
    let mut n: int32_t = I_NumJoys();
    strcpy(
        (joystickInfo[i as usize]).as_mut_ptr(),
        b"None\0" as *const u8 as *const libc::c_char,
    );
    i = 1 as libc::c_int;
    while i <= 4 as libc::c_int {
        if i <= n && !(I_GetJoyName(i)).is_null() {
            strncpy(
                (joystickInfo[i as usize]).as_mut_ptr(),
                I_GetJoyName(i),
                28 as libc::c_int as libc::c_ulong,
            );
        } else {
            strcpy((joystickInfo[i as usize]).as_mut_ptr(), joyNA);
        }
        i += 1;
        i;
    }
    M_SetupNextMenu(&mut OP_JoystickSetDef);
}
unsafe extern "C" fn M_Setup1PJoystickMenu(mut choice: int32_t) {
    setupcontrols_secondaryplayer = false_0 as libc::c_int;
    OP_JoystickSetDef.prevMenu = &mut OP_Joystick1Def;
    OP_JoystickSetDef.menuid
        &= !((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
            << 6 as libc::c_int) as uint32_t;
    OP_JoystickSetDef.menuid
        &= !((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
            << 6 as libc::c_int * 2 as libc::c_int) as uint32_t;
    OP_JoystickSetDef.menuid
        |= ((MN_OP_P1CONTROLS as libc::c_int) << 6 as libc::c_int) as uint32_t;
    OP_JoystickSetDef.menuid
        |= ((MN_OP_P1JOYSTICK as libc::c_int) << 6 as libc::c_int * 2 as libc::c_int)
            as uint32_t;
    M_SetupJoystickMenu(choice);
}
unsafe extern "C" fn M_Setup2PJoystickMenu(mut choice: int32_t) {
    setupcontrols_secondaryplayer = true_0 as libc::c_int;
    OP_JoystickSetDef.prevMenu = &mut OP_Joystick2Def;
    OP_JoystickSetDef.menuid
        &= !((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
            << 6 as libc::c_int) as uint32_t;
    OP_JoystickSetDef.menuid
        &= !((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
            << 6 as libc::c_int * 2 as libc::c_int) as uint32_t;
    OP_JoystickSetDef.menuid
        |= ((MN_OP_P2CONTROLS as libc::c_int) << 6 as libc::c_int) as uint32_t;
    OP_JoystickSetDef.menuid
        |= ((MN_OP_P2JOYSTICK as libc::c_int) << 6 as libc::c_int * 2 as libc::c_int)
            as uint32_t;
    M_SetupJoystickMenu(choice);
}
unsafe extern "C" fn M_AssignJoystick(mut choice: int32_t) {
    if setupcontrols_secondaryplayer != 0 {
        CV_SetValue(&mut cv_usejoystick2, choice);
    } else {
        CV_SetValue(&mut cv_usejoystick, choice);
    };
}
unsafe extern "C" fn M_Setup1PControlsMenu(mut choice: int32_t) {
    setupcontrols_secondaryplayer = false_0 as libc::c_int;
    setupcontrols = gamecontrol.as_mut_ptr();
    (*currentMenu).lastOn = itemOn;
    OP_ChangeControlsMenu[(18 as libc::c_int + 2 as libc::c_int) as usize]
        .status = (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int) as uint16_t;
    OP_ChangeControlsMenu[(18 as libc::c_int + 3 as libc::c_int) as usize]
        .status = (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int) as uint16_t;
    OP_ChangeControlsMenu[(18 as libc::c_int + 4 as libc::c_int) as usize]
        .status = (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int) as uint16_t;
    OP_ChangeControlsMenu[(18 as libc::c_int + 5 as libc::c_int) as usize]
        .status = (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int) as uint16_t;
    OP_ChangeControlsMenu[(18 as libc::c_int + 6 as libc::c_int) as usize]
        .status = (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int) as uint16_t;
    OP_ChangeControlsMenu[(18 as libc::c_int + 9 as libc::c_int) as usize]
        .status = (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int) as uint16_t;
    OP_ChangeControlsMenu[(28 as libc::c_int + 0 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsMenu[(28 as libc::c_int + 1 as libc::c_int) as usize]
        .status = 1 as libc::c_int as uint16_t;
    OP_ChangeControlsMenu[(28 as libc::c_int + 2 as libc::c_int) as usize]
        .status = (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int) as uint16_t;
    OP_ChangeControlsMenu[(28 as libc::c_int + 3 as libc::c_int) as usize]
        .status = (0 as libc::c_int | 32 as libc::c_int + 64 as libc::c_int) as uint16_t;
    OP_ChangeControlsDef.prevMenu = &mut OP_P1ControlsDef;
    OP_ChangeControlsDef.menuid
        &= !((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
            << 6 as libc::c_int) as uint32_t;
    OP_ChangeControlsDef.menuid
        |= ((MN_OP_P1CONTROLS as libc::c_int) << 6 as libc::c_int) as uint32_t;
    M_SetupNextMenu(&mut OP_ChangeControlsDef);
}
unsafe extern "C" fn M_Setup2PControlsMenu(mut choice: int32_t) {
    setupcontrols_secondaryplayer = true_0 as libc::c_int;
    setupcontrols = gamecontrolbis.as_mut_ptr();
    (*currentMenu).lastOn = itemOn;
    OP_ChangeControlsMenu[(18 as libc::c_int + 2 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsMenu[(18 as libc::c_int + 3 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsMenu[(18 as libc::c_int + 4 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsMenu[(18 as libc::c_int + 5 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsMenu[(18 as libc::c_int + 6 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsMenu[(18 as libc::c_int + 9 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsMenu[(28 as libc::c_int + 0 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsMenu[(28 as libc::c_int + 1 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsMenu[(28 as libc::c_int + 2 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsMenu[(28 as libc::c_int + 3 as libc::c_int) as usize]
        .status = (1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        as uint16_t;
    OP_ChangeControlsDef.prevMenu = &mut OP_P2ControlsDef;
    OP_ChangeControlsDef.menuid
        &= !((((1 as libc::c_int) << 6 as libc::c_int) - 1 as libc::c_int)
            << 6 as libc::c_int) as uint32_t;
    OP_ChangeControlsDef.menuid
        |= ((MN_OP_P2CONTROLS as libc::c_int) << 6 as libc::c_int) as uint32_t;
    M_SetupNextMenu(&mut OP_ChangeControlsDef);
}
unsafe extern "C" fn M_DrawControl() {
    let mut tmp: [libc::c_char; 50] = [0; 50];
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut i: int32_t = 0;
    let mut max: int32_t = 0;
    let mut cursory: int32_t = 0 as libc::c_int;
    let mut iter: int32_t = 0;
    let mut keys: [int32_t; 2] = [0; 2];
    x = (*currentMenu).x as int32_t;
    y = (*currentMenu).y as int32_t;
    iter = 18 as libc::c_int / 2 as libc::c_int;
    i = itemOn as int32_t;
    while (iter != 0
        || (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            == 1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        && i > 0 as libc::c_int
    {
        if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            != 1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int)
        {
            iter -= 1;
            iter;
        }
        i -= 1;
        i;
    }
    if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
        == 1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int)
    {
        i -= 1;
        i;
    }
    iter += 18 as libc::c_int / 2 as libc::c_int;
    max = itemOn as int32_t;
    while iter != 0 && max < (*currentMenu).numitems as libc::c_int {
        if (*((*currentMenu).menuitems).offset(max as isize)).status as libc::c_int
            != 1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int)
        {
            iter -= 1;
            iter;
        }
        max += 1;
        max;
    }
    if iter != 0 {
        iter += 18 as libc::c_int / 2 as libc::c_int;
        i = itemOn as int32_t;
        while (iter != 0
            || (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
                == 1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
            && i > 0 as libc::c_int
        {
            if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
                != 1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int)
            {
                iter -= 1;
                iter;
            }
            i -= 1;
            i;
        }
    }
    M_DrawMenuTitle();
    if tutorialmode != 0 && tutorialgcs != 0 {
        if gametic / 35 as libc::c_int as tic_t % 2 as libc::c_int as tic_t != 0 {
            V_DrawCenteredString(
                320 as libc::c_int / 2 as libc::c_int,
                30 as libc::c_int,
                0 as libc::c_int,
                b"\x82EXIT THE TUTORIAL TO CHANGE THE CONTROLS\0" as *const u8
                    as *const libc::c_char,
            );
        } else {
            V_DrawCenteredString(
                320 as libc::c_int / 2 as libc::c_int,
                30 as libc::c_int,
                0 as libc::c_int,
                b"EXIT THE TUTORIAL TO CHANGE THE CONTROLS\0" as *const u8
                    as *const libc::c_char,
            );
        }
    } else {
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            30 as libc::c_int,
            0 as libc::c_int,
            if setupcontrols_secondaryplayer != 0 {
                b"SET CONTROLS FOR SECONDARY PLAYER\0" as *const u8
                    as *const libc::c_char
            } else {
                b"PRESS ENTER TO CHANGE, BACKSPACE TO CLEAR\0" as *const u8
                    as *const libc::c_char
            },
        );
    }
    if i != 0 {
        V_DrawString(
            (*currentMenu).x as libc::c_int - 16 as libc::c_int,
            y - skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1A\0" as *const u8 as *const libc::c_char,
        );
    }
    if max != (*currentMenu).numitems as libc::c_int {
        V_DrawString(
            (*currentMenu).x as libc::c_int - 16 as libc::c_int,
            y + 8 as libc::c_int * (18 as libc::c_int - 1 as libc::c_int)
                + skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1B\0" as *const u8 as *const libc::c_char,
        );
    }
    while i < max {
        if !((*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            == 1 as libc::c_int + (32 as libc::c_int + 128 as libc::c_int))
        {
            if i == itemOn as libc::c_int {
                cursory = y;
            }
            if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
                == 32 as libc::c_int + 64 as libc::c_int + 0 as libc::c_int
            {
                V_DrawString(
                    x,
                    y,
                    if i == itemOn as libc::c_int {
                        0x2000 as libc::c_int
                    } else {
                        0 as libc::c_int
                    },
                    (*((*currentMenu).menuitems).offset(i as isize)).text,
                );
                keys[0 as libc::c_int
                    as usize] = (*setupcontrols
                    .offset(
                        (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                            as isize,
                    ))[0 as libc::c_int as usize];
                keys[1 as libc::c_int
                    as usize] = (*setupcontrols
                    .offset(
                        (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                            as isize,
                    ))[1 as libc::c_int as usize];
                tmp[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
                if keys[0 as libc::c_int as usize] == 0 as libc::c_int
                    && keys[1 as libc::c_int as usize] == 0 as libc::c_int
                {
                    strcpy(
                        tmp.as_mut_ptr(),
                        b"---\0" as *const u8 as *const libc::c_char,
                    );
                } else {
                    if keys[0 as libc::c_int as usize] != 0 as libc::c_int {
                        strcat(
                            tmp.as_mut_ptr(),
                            G_KeyNumToName(keys[0 as libc::c_int as usize]),
                        );
                    }
                    if keys[0 as libc::c_int as usize] != 0 as libc::c_int
                        && keys[1 as libc::c_int as usize] != 0 as libc::c_int
                    {
                        strcat(
                            tmp.as_mut_ptr(),
                            b" or \0" as *const u8 as *const libc::c_char,
                        );
                    }
                    if keys[1 as libc::c_int as usize] != 0 as libc::c_int {
                        strcat(
                            tmp.as_mut_ptr(),
                            G_KeyNumToName(keys[1 as libc::c_int as usize]),
                        );
                    }
                }
                V_DrawRightAlignedString(
                    320 as libc::c_int - (*currentMenu).x as libc::c_int,
                    y,
                    0x2000 as libc::c_int,
                    tmp.as_mut_ptr(),
                );
            } else if (*((*currentMenu).menuitems).offset(i as isize)).status
                as libc::c_int
                == 1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int)
                && i != max - 1 as libc::c_int
            {
                M_DrawLevelPlatterHeader(
                    y,
                    (*((*currentMenu).menuitems).offset(i as isize)).text,
                    true_0 as libc::c_int,
                    false_0 as libc::c_int,
                );
            }
            y += 8 as libc::c_int;
        }
        i += 1;
        i;
    }
    V_DrawStretchyFixedPatch(
        ((*currentMenu).x as libc::c_int - 20 as libc::c_int)
            * ((1 as libc::c_int) << 16 as libc::c_int),
        cursory << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchName(
            b"M_CURSOR\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t,
        0 as *const uint8_t,
    );
}
static mut controltochange: int32_t = 0;
static mut controltochangetext: [libc::c_char; 33] = [0; 33];
unsafe extern "C" fn M_ChangecontrolResponse(mut ev: *mut event_t) {
    let mut control: int32_t = 0;
    let mut found: int32_t = 0;
    let mut ch: int32_t = (*ev).key;
    if ch != 27 as libc::c_int && ch != 255 as libc::c_int {
        match (*ev).type_0 as libc::c_uint {
            3 | 5 | 4 | 6 => {
                ch = 0 as libc::c_int;
            }
            0 => {
                ch = (*ev).key;
            }
            _ => {}
        }
        control = controltochange;
        found = -(1 as libc::c_int);
        if (*setupcontrols.offset(control as isize))[0 as libc::c_int as usize] == ch {
            found = 0 as libc::c_int;
        } else if (*setupcontrols.offset(control as isize))[1 as libc::c_int as usize]
            == ch
        {
            found = 1 as libc::c_int;
        }
        if found >= 0 as libc::c_int {
            if ch >= KEY_MOUSE1 as libc::c_int
                && ch <= KEY_MOUSE1 as libc::c_int + 8 as libc::c_int
            {
                (*setupcontrols
                    .offset(
                        control as isize,
                    ))[found
                    as usize] = ch - KEY_MOUSE1 as libc::c_int
                    + KEY_DBLMOUSE1 as libc::c_int;
            } else if ch >= KEY_JOY1 as libc::c_int
                && ch <= KEY_JOY1 as libc::c_int + 32 as libc::c_int
            {
                (*setupcontrols
                    .offset(
                        control as isize,
                    ))[found
                    as usize] = ch - KEY_JOY1 as libc::c_int
                    + KEY_DBLJOY1 as libc::c_int;
            } else if ch >= KEY_2MOUSE1 as libc::c_int
                && ch <= KEY_2MOUSE1 as libc::c_int + 8 as libc::c_int
            {
                (*setupcontrols
                    .offset(
                        control as isize,
                    ))[found
                    as usize] = ch - KEY_2MOUSE1 as libc::c_int
                    + KEY_DBL2MOUSE1 as libc::c_int;
            } else if ch >= KEY_2JOY1 as libc::c_int
                && ch <= KEY_2JOY1 as libc::c_int + 32 as libc::c_int
            {
                (*setupcontrols
                    .offset(
                        control as isize,
                    ))[found
                    as usize] = ch - KEY_2JOY1 as libc::c_int
                    + KEY_DBL2JOY1 as libc::c_int;
            }
        } else {
            found = 0 as libc::c_int;
            if (*setupcontrols.offset(control as isize))[0 as libc::c_int as usize]
                == 0 as libc::c_int
            {
                found += 1;
                found;
            }
            if (*setupcontrols.offset(control as isize))[1 as libc::c_int as usize]
                == 0 as libc::c_int
            {
                found += 1;
                found;
            }
            if found == 2 as libc::c_int {
                found = 0 as libc::c_int;
                (*setupcontrols
                    .offset(
                        control as isize,
                    ))[1 as libc::c_int as usize] = 0 as libc::c_int;
            }
            G_CheckDoubleUsage(ch, true_0 as libc::c_int);
            (*setupcontrols.offset(control as isize))[found as usize] = ch;
        }
        S_StartSound(0 as *const libc::c_void, sfx_strpst);
    } else if ch == 255 as libc::c_int {
        static mut tmp: [libc::c_char; 158] = [0; 158];
        let mut prev: *mut menu_t = (*currentMenu).prevMenu;
        if controltochange == GC_PAUSE as libc::c_int {
            sprintf(
                tmp.as_mut_ptr(),
                b"The \x82Pause Key \x80is enabled, but \nit cannot be used to retry runs \nduring Record Attack. \n\nHit another key for\n%s\nESC for Cancel\0"
                    as *const u8 as *const libc::c_char,
                controltochangetext.as_mut_ptr(),
            );
        } else {
            sprintf(
                tmp.as_mut_ptr(),
                b"The \x82Pause Key \x80is enabled, but \nit is not configurable. \n\nHit another key for\n%s\nESC for Cancel\0"
                    as *const u8 as *const libc::c_char,
                controltochangetext.as_mut_ptr(),
            );
        }
        M_StartMessage(
            tmp.as_mut_ptr(),
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut event_t) -> ()>,
                *mut libc::c_void,
            >(Some(M_ChangecontrolResponse as unsafe extern "C" fn(*mut event_t) -> ())),
            MM_EVENTHANDLER,
        );
        (*currentMenu).prevMenu = prev;
        S_StartSound(0 as *const libc::c_void, sfx_s3k42);
        return;
    } else {
        S_StartSound(0 as *const libc::c_void, sfx_skid);
    }
    M_StopMessage(0 as libc::c_int);
}
unsafe extern "C" fn M_ChangeControl(mut choice: int32_t) {
    static mut tmp: [libc::c_char; 68] = [0; 68];
    if tutorialmode != 0 && tutorialgcs != 0 {
        return;
    }
    controltochange = (*((*currentMenu).menuitems).offset(choice as isize)).alphaKey
        as int32_t;
    sprintf(
        tmp.as_mut_ptr(),
        b"Hit the new key for\n%s\nESC for Cancel\0" as *const u8 as *const libc::c_char,
        (*((*currentMenu).menuitems).offset(choice as isize)).text,
    );
    strlcpy(
        controltochangetext.as_mut_ptr(),
        (*((*currentMenu).menuitems).offset(choice as isize)).text,
        33 as libc::c_int as libc::c_ulong,
    );
    M_StartMessage(
        tmp.as_mut_ptr(),
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut event_t) -> ()>,
            *mut libc::c_void,
        >(Some(M_ChangecontrolResponse as unsafe extern "C" fn(*mut event_t) -> ())),
        MM_EVENTHANDLER,
    );
}
unsafe extern "C" fn M_Setup1PPlaystyleMenu(mut choice: int32_t) {
    playstyle_activeplayer = 0 as libc::c_int as uint8_t;
    OP_PlaystyleDef.prevMenu = &mut OP_P1ControlsDef;
    M_SetupNextMenu(&mut OP_PlaystyleDef);
}
unsafe extern "C" fn M_Setup2PPlaystyleMenu(mut choice: int32_t) {
    playstyle_activeplayer = 1 as libc::c_int as uint8_t;
    OP_PlaystyleDef.prevMenu = &mut OP_P2ControlsDef;
    M_SetupNextMenu(&mut OP_PlaystyleDef);
}
unsafe extern "C" fn M_DrawPlaystyleMenu() {
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < 4 as libc::c_int as size_t {
        if i != 3 as libc::c_int as size_t {
            V_DrawCenteredString(
                (i.wrapping_add(1 as libc::c_int as size_t)
                    * 320 as libc::c_int as size_t / 4 as libc::c_int as size_t)
                    as int32_t,
                20 as libc::c_int,
                if i == playstyle_currentchoice as size_t {
                    0x2000 as libc::c_int
                } else {
                    0 as libc::c_int
                },
                PlaystyleNames[i as usize],
            );
        }
        if i == playstyle_currentchoice as size_t {
            V_DrawFill(
                20 as libc::c_int,
                40 as libc::c_int,
                280 as libc::c_int,
                150 as libc::c_int,
                159 as libc::c_int,
            );
            V_DrawStretchyFixedPatch(
                ((i.wrapping_add(1 as libc::c_int as size_t)
                    * 320 as libc::c_int as size_t / 4 as libc::c_int as size_t)
                    .wrapping_sub(8 as libc::c_int as size_t)
                    * ((1 as libc::c_int) << 16 as libc::c_int) as size_t) as fixed_t,
                (10 as libc::c_int) << 16 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                0 as libc::c_int,
                W_CachePatchName(
                    b"M_CURSOR\0" as *const u8 as *const libc::c_char,
                    PU_CACHE as libc::c_int,
                ) as *mut patch_t,
                0 as *const uint8_t,
            );
            V_DrawString(
                30 as libc::c_int,
                50 as libc::c_int,
                0x800000 as libc::c_int,
                PlaystyleDesc[i as usize],
            );
        }
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn M_HandlePlaystyleMenu(mut choice: int32_t) {
    match choice {
        27 | 8 => {
            M_SetupNextMenu((*currentMenu).prevMenu);
        }
        13 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            CV_SetValue(
                if playstyle_activeplayer as libc::c_int != 0 {
                    &mut *cv_directionchar.as_mut_ptr().offset(1 as libc::c_int as isize)
                } else {
                    &mut *cv_directionchar.as_mut_ptr().offset(0 as libc::c_int as isize)
                },
                if playstyle_currentchoice as libc::c_int != 0 {
                    1 as libc::c_int
                } else {
                    0 as libc::c_int
                },
            );
            CV_SetValue(
                if playstyle_activeplayer as libc::c_int != 0 {
                    &mut *cv_useranalog.as_mut_ptr().offset(1 as libc::c_int as isize)
                } else {
                    &mut *cv_useranalog.as_mut_ptr().offset(0 as libc::c_int as isize)
                },
                playstyle_currentchoice as libc::c_int / 2 as libc::c_int,
            );
            if playstyle_activeplayer != 0 {
                CV_UpdateCam2Dist();
            } else {
                CV_UpdateCamDist();
            }
            M_SetupNextMenu((*currentMenu).prevMenu);
        }
        233 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            playstyle_currentchoice = ((playstyle_currentchoice as libc::c_int
                + 2 as libc::c_int) % 3 as libc::c_int) as uint8_t;
        }
        235 => {
            S_StartSound(0 as *const libc::c_void, sfx_menu1);
            playstyle_currentchoice = ((playstyle_currentchoice as libc::c_int
                + 1 as libc::c_int) % 3 as libc::c_int) as uint8_t;
        }
        _ => {}
    };
}
unsafe extern "C" fn M_DrawCameraOptionsMenu() {
    M_DrawGenericScrollMenu();
    if gamestate as libc::c_uint == GS_LEVEL as libc::c_int as libc::c_uint
        && (paused as libc::c_int != 0 || P_AutoPause() != 0)
    {
        if currentMenu == &mut OP_Camera2OptionsDef as *mut menu_t && splitscreen != 0
            && camera2.chase != 0
        {
            P_MoveChaseCamera(
                &mut *players.as_mut_ptr().offset(secondarydisplayplayer as isize),
                &mut camera2,
                false_0 as libc::c_int,
            );
        }
        if currentMenu == &mut OP_CameraOptionsDef as *mut menu_t && camera.chase != 0 {
            P_MoveChaseCamera(
                &mut *players.as_mut_ptr().offset(displayplayer as isize),
                &mut camera,
                false_0 as libc::c_int,
            );
        }
    }
}
static mut modedescs: [modedesc_t; 36] = [modedesc_t {
    modenum: 0,
    desc: 0 as *const libc::c_char,
    goodratio: 0,
}; 36];
unsafe extern "C" fn M_VideoModeMenu(mut choice: int32_t) {
    let mut i: int32_t = 0;
    let mut j: int32_t = 0;
    let mut vdup: int32_t = 0;
    let mut nummodes: int32_t = 0;
    let mut width: int32_t = 0;
    let mut height: int32_t = 0;
    let mut desc: *const libc::c_char = 0 as *const libc::c_char;
    memset(
        modedescs.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[modedesc_t; 36]>() as libc::c_ulong,
    );
    VID_PrepareModeList();
    vidm_nummodes = 0 as libc::c_int;
    vidm_selected = 0 as libc::c_int;
    nummodes = VID_NumModes();
    i = 0 as libc::c_int;
    while i < nummodes && vidm_nummodes < 12 as libc::c_int * 3 as libc::c_int {
        desc = VID_GetModeName(i);
        if !desc.is_null() {
            vdup = 0 as libc::c_int;
            j = 0 as libc::c_int;
            while j < vidm_nummodes {
                if strcmp(modedescs[j as usize].desc, desc) == 0 {
                    if modedescs[j as usize].modenum != 0 {
                        modedescs[j as usize].modenum = i;
                        vdup = 1 as libc::c_int;
                        if i == vid.modenum {
                            vidm_selected = j;
                        }
                    } else {
                        vdup = 1 as libc::c_int;
                    }
                    break;
                } else {
                    j += 1;
                    j;
                }
            }
            if vdup == 0 {
                modedescs[vidm_nummodes as usize].modenum = i;
                modedescs[vidm_nummodes as usize].desc = desc;
                if i == vid.modenum {
                    vidm_selected = vidm_nummodes;
                }
                sscanf(
                    desc,
                    b"%u%*c%u\0" as *const u8 as *const libc::c_char,
                    &mut width as *mut int32_t,
                    &mut height as *mut int32_t,
                );
                if SCR_IsAspectCorrect(width, height) != 0 {
                    modedescs[vidm_nummodes as usize]
                        .goodratio = 1 as libc::c_int as uint8_t;
                }
                vidm_nummodes += 1;
                vidm_nummodes;
            }
        }
        i += 1;
        i;
    }
    vidm_column_size = (vidm_nummodes + 2 as libc::c_int) / 3 as libc::c_int;
    M_SetupNextMenu(&mut OP_VideoModeDef);
}
unsafe extern "C" fn M_DrawMainVideoMenu() {
    M_DrawGenericScrollMenu();
    if (itemOn as libc::c_int) < 8 as libc::c_int {
        let mut y: int32_t = (*currentMenu).y as libc::c_int
            + (*((*currentMenu).menuitems).offset(1 as libc::c_int as isize)).alphaKey
                as libc::c_int * 2 as libc::c_int;
        if itemOn as libc::c_int == 7 as libc::c_int {
            y -= 10 as libc::c_int;
        }
        V_DrawRightAlignedString(
            320 as libc::c_int - (*currentMenu).x as libc::c_int,
            y,
            if SCR_IsAspectCorrect(vid.width, vid.height) != 0 {
                0x3000 as libc::c_int
            } else {
                0x2000 as libc::c_int
            },
            va(b"%dx%d\0" as *const u8 as *const libc::c_char, vid.width, vid.height),
        );
    }
}
unsafe extern "C" fn M_DrawVideoMode() {
    let mut i: int32_t = 0;
    let mut j: int32_t = 0;
    let mut row: int32_t = 0;
    let mut col: int32_t = 0;
    M_DrawMenuTitle();
    V_DrawCenteredString(
        320 as libc::c_int / 2 as libc::c_int,
        OP_VideoModeDef.y as int32_t,
        0x2000 as libc::c_int,
        b"Choose mode, reselect to change default\0" as *const u8 as *const libc::c_char,
    );
    V_DrawCenteredString(
        320 as libc::c_int / 2 as libc::c_int,
        OP_VideoModeDef.y as libc::c_int + 8 as libc::c_int,
        0x2000 as libc::c_int,
        b"Press F11 to toggle fullscreen\0" as *const u8 as *const libc::c_char,
    );
    row = 41 as libc::c_int;
    col = OP_VideoModeDef.y as libc::c_int + 24 as libc::c_int;
    i = 0 as libc::c_int;
    while i < vidm_nummodes {
        if i == vidm_selected {
            V_DrawString(row, col, 0x2000 as libc::c_int, modedescs[i as usize].desc);
        } else {
            V_DrawString(
                row,
                col,
                if modedescs[i as usize].goodratio as libc::c_int != 0 {
                    0x3000 as libc::c_int
                } else {
                    0 as libc::c_int
                },
                modedescs[i as usize].desc,
            );
        }
        col += 8 as libc::c_int;
        if i % vidm_column_size == vidm_column_size - 1 as libc::c_int {
            row += 7 as libc::c_int * 13 as libc::c_int;
            col = OP_VideoModeDef.y as libc::c_int + 24 as libc::c_int;
        }
        i += 1;
        i;
    }
    if vidm_testingmode > 0 as libc::c_int {
        let mut testtime: int32_t = vidm_testingmode / 35 as libc::c_int
            + 1 as libc::c_int;
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 116 as libc::c_int,
            0 as libc::c_int,
            va(
                b"Previewing mode %c%dx%d\0" as *const u8 as *const libc::c_char,
                if SCR_IsAspectCorrect(vid.width, vid.height) != 0 {
                    0x83 as libc::c_int
                } else {
                    0x80 as libc::c_int
                },
                vid.width,
                vid.height,
            ),
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 138 as libc::c_int,
            0 as libc::c_int,
            b"Press ENTER again to keep this mode\0" as *const u8 as *const libc::c_char,
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 150 as libc::c_int,
            0 as libc::c_int,
            va(
                b"Wait %d second%s\0" as *const u8 as *const libc::c_char,
                testtime,
                if testtime > 1 as libc::c_int {
                    b"s\0" as *const u8 as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            ),
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 158 as libc::c_int,
            0 as libc::c_int,
            b"or press ESC to return\0" as *const u8 as *const libc::c_char,
        );
    } else {
        V_DrawFill(
            60 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 98 as libc::c_int,
            200 as libc::c_int,
            12 as libc::c_int,
            159 as libc::c_int,
        );
        V_DrawFill(
            60 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 114 as libc::c_int,
            200 as libc::c_int,
            20 as libc::c_int,
            159 as libc::c_int,
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 100 as libc::c_int,
            0 as libc::c_int,
            va(
                b"Current mode is %c%dx%d\0" as *const u8 as *const libc::c_char,
                if SCR_IsAspectCorrect(vid.width, vid.height) != 0 {
                    0x83 as libc::c_int
                } else {
                    0x80 as libc::c_int
                },
                vid.width,
                vid.height,
            ),
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 116 as libc::c_int,
            if cv_fullscreen.value != 0 {
                0 as libc::c_int
            } else {
                0x50000 as libc::c_int
            },
            va(
                b"Default mode is %c%dx%d\0" as *const u8 as *const libc::c_char,
                if SCR_IsAspectCorrect(cv_scr_width.value, cv_scr_height.value) != 0 {
                    0x83 as libc::c_int
                } else if VID_GetModeForSize(cv_scr_width.value, cv_scr_height.value)
                    + 1 as libc::c_int == 0
                {
                    0x85 as libc::c_int
                } else {
                    0x80 as libc::c_int
                },
                cv_scr_width.value,
                cv_scr_height.value,
            ),
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 124 as libc::c_int,
            if cv_fullscreen.value != 0 {
                0x50000 as libc::c_int
            } else {
                0 as libc::c_int
            },
            va(
                b"Windowed mode is %c%dx%d\0" as *const u8 as *const libc::c_char,
                if SCR_IsAspectCorrect(cv_scr_width_w.value, cv_scr_height_w.value) != 0
                {
                    0x83 as libc::c_int
                } else if VID_GetModeForSize(cv_scr_width_w.value, cv_scr_height_w.value)
                    + 1 as libc::c_int == 0
                {
                    0x85 as libc::c_int
                } else {
                    0x80 as libc::c_int
                },
                cv_scr_width_w.value,
                cv_scr_height_w.value,
            ),
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 138 as libc::c_int,
            0x3000 as libc::c_int,
            b"Green modes are recommended.\0" as *const u8 as *const libc::c_char,
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 146 as libc::c_int,
            0x2000 as libc::c_int,
            b"Other modes may have visual errors.\0" as *const u8 as *const libc::c_char,
        );
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            OP_VideoModeDef.y as libc::c_int + 158 as libc::c_int,
            0x2000 as libc::c_int,
            b"Larger modes may have performance issues.\0" as *const u8
                as *const libc::c_char,
        );
    }
    i = 41 as libc::c_int - 10 as libc::c_int
        + vidm_selected / vidm_column_size * 7 as libc::c_int * 13 as libc::c_int;
    j = OP_VideoModeDef.y as libc::c_int + 24 as libc::c_int
        + vidm_selected % vidm_column_size * 8 as libc::c_int;
    V_DrawStretchyFixedPatch(
        (i - 8 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
        j << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchName(
            b"M_CURSOR\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t,
        0 as *const uint8_t,
    );
}
unsafe extern "C" fn M_DrawColorMenu() {
    let mut x: int32_t = 0;
    let mut y: int32_t = 0;
    let mut i: int32_t = 0;
    let mut max: int32_t = 0;
    let mut tempcentery: int32_t = 0;
    let mut cursory: int32_t = 0 as libc::c_int;
    x = (*currentMenu).x as int32_t;
    y = (*currentMenu).y as int32_t;
    V_DrawFill(
        19 as libc::c_int,
        y - 4 as libc::c_int,
        47 as libc::c_int,
        1 as libc::c_int,
        35 as libc::c_int,
    );
    V_DrawFill(
        19 as libc::c_int + 47 as libc::c_int,
        y - 4 as libc::c_int,
        47 as libc::c_int,
        1 as libc::c_int,
        73 as libc::c_int,
    );
    V_DrawFill(
        19 as libc::c_int + 2 as libc::c_int * 47 as libc::c_int,
        y - 4 as libc::c_int,
        47 as libc::c_int,
        1 as libc::c_int,
        112 as libc::c_int,
    );
    V_DrawFill(
        19 as libc::c_int + 3 as libc::c_int * 47 as libc::c_int,
        y - 4 as libc::c_int,
        47 as libc::c_int,
        1 as libc::c_int,
        255 as libc::c_int,
    );
    V_DrawFill(
        19 as libc::c_int + 4 as libc::c_int * 47 as libc::c_int,
        y - 4 as libc::c_int,
        47 as libc::c_int,
        1 as libc::c_int,
        152 as libc::c_int,
    );
    V_DrawFill(
        19 as libc::c_int + 5 as libc::c_int * 47 as libc::c_int,
        y - 4 as libc::c_int,
        46 as libc::c_int,
        1 as libc::c_int,
        181 as libc::c_int,
    );
    V_DrawFill(
        300 as libc::c_int,
        y - 4 as libc::c_int,
        1 as libc::c_int,
        1 as libc::c_int,
        26 as libc::c_int,
    );
    V_DrawFill(
        19 as libc::c_int,
        y - 3 as libc::c_int,
        282 as libc::c_int,
        1 as libc::c_int,
        26 as libc::c_int,
    );
    if (*((*currentMenu).menuitems).offset(itemOn as isize)).alphaKey as libc::c_int
        * 2 as libc::c_int
        - (*((*currentMenu).menuitems).offset(0 as libc::c_int as isize)).alphaKey
            as libc::c_int * 2 as libc::c_int <= 72 as libc::c_int
    {
        tempcentery = (*currentMenu).y as libc::c_int
            - (*((*currentMenu).menuitems).offset(0 as libc::c_int as isize)).alphaKey
                as libc::c_int * 2 as libc::c_int;
    } else if (*((*currentMenu).menuitems)
        .offset(((*currentMenu).numitems as libc::c_int - 1 as libc::c_int) as isize))
        .alphaKey as libc::c_int * 2 as libc::c_int
        - (*((*currentMenu).menuitems).offset(itemOn as isize)).alphaKey as libc::c_int
            * 2 as libc::c_int <= 72 as libc::c_int
    {
        tempcentery = (*currentMenu).y as libc::c_int
            - (*((*currentMenu).menuitems)
                .offset(
                    ((*currentMenu).numitems as libc::c_int - 1 as libc::c_int) as isize,
                ))
                .alphaKey as libc::c_int * 2 as libc::c_int
            + 2 as libc::c_int * 72 as libc::c_int;
    } else {
        tempcentery = (*currentMenu).y as libc::c_int
            - (*((*currentMenu).menuitems).offset(itemOn as isize)).alphaKey
                as libc::c_int * 2 as libc::c_int + 72 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*currentMenu).numitems as libc::c_int {
        if (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            != 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
            && (*((*currentMenu).menuitems).offset(i as isize)).alphaKey as libc::c_int
                * 2 as libc::c_int + tempcentery >= (*currentMenu).y as libc::c_int
        {
            break;
        }
        i += 1;
        i;
    }
    max = (*currentMenu).numitems as int32_t;
    while max > 0 as libc::c_int {
        if (*((*currentMenu).menuitems).offset(max as isize)).status as libc::c_int
            != 1 as libc::c_int
                + (16 as libc::c_int + 32 as libc::c_int + 64 as libc::c_int)
            && (*((*currentMenu).menuitems).offset((max - 1 as libc::c_int) as isize))
                .alphaKey as libc::c_int * 2 as libc::c_int + tempcentery
                <= (*currentMenu).y as libc::c_int + 2 as libc::c_int * 72 as libc::c_int
        {
            break;
        }
        max -= 1;
        max;
    }
    if i != 0 {
        V_DrawString(
            (*currentMenu).x as libc::c_int - 20 as libc::c_int,
            (*currentMenu).y as libc::c_int
                - skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1A\0" as *const u8 as *const libc::c_char,
        );
    }
    if max != (*currentMenu).numitems as libc::c_int {
        V_DrawString(
            (*currentMenu).x as libc::c_int - 20 as libc::c_int,
            (*currentMenu).y as libc::c_int + 2 as libc::c_int * 72 as libc::c_int
                + skullAnimCounter as libc::c_int / 5 as libc::c_int,
            0x2000 as libc::c_int,
            b"\x1B\0" as *const u8 as *const libc::c_char,
        );
    }
    M_DrawMenuTitle();
    while i < max {
        y = (*((*currentMenu).menuitems).offset(i as isize)).alphaKey as libc::c_int
            * 2 as libc::c_int + tempcentery;
        if i == itemOn as libc::c_int {
            cursory = y;
        }
        match (*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int
        {
            32 | 48 => {
                if i != itemOn as libc::c_int
                    && (*((*currentMenu).menuitems).offset(i as isize)).status
                        as libc::c_int
                        & 48 as libc::c_int + 64 as libc::c_int + 128 as libc::c_int
                        == 32 as libc::c_int
                {
                    V_DrawString(
                        x,
                        y,
                        0 as libc::c_int,
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    );
                } else {
                    V_DrawString(
                        x,
                        y,
                        0x2000 as libc::c_int,
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    );
                }
                match (*((*currentMenu).menuitems).offset(i as isize)).status
                    as libc::c_int & 15 as libc::c_int
                {
                    8 => {
                        let mut cv: *mut consvar_t = (*((*currentMenu).menuitems)
                            .offset(i as isize))
                            .itemaction as *mut consvar_t;
                        let mut current_block_40: u64;
                        match (*((*currentMenu).menuitems).offset(i as isize)).status
                            as libc::c_int
                            & 512 as libc::c_int + 1024 as libc::c_int
                                + 2048 as libc::c_int
                        {
                            512 => {
                                M_DrawSlider(
                                    x,
                                    y,
                                    cv,
                                    (i == itemOn as libc::c_int) as libc::c_int,
                                );
                                current_block_40 = 17148350807101900901;
                            }
                            1536 => {
                                current_block_40 = 17148350807101900901;
                            }
                            2560 => {
                                current_block_40 = 1622411330066726685;
                            }
                            1024 => {
                                if y + 12 as libc::c_int
                                    > (*currentMenu).y as libc::c_int
                                        + 2 as libc::c_int * 72 as libc::c_int
                                {
                                    current_block_40 = 1622411330066726685;
                                } else {
                                    M_DrawTextBox(
                                        x,
                                        y + 4 as libc::c_int,
                                        32 as libc::c_int,
                                        1 as libc::c_int,
                                    );
                                    V_DrawString(
                                        x + 8 as libc::c_int,
                                        y + 12 as libc::c_int,
                                        0x800000 as libc::c_int,
                                        (*cv).string,
                                    );
                                    if (skullAnimCounter as libc::c_int) < 4 as libc::c_int
                                        && i == itemOn as libc::c_int
                                    {
                                        V_DrawCharacter(
                                            x + 8 as libc::c_int
                                                + V_StringWidth((*cv).string, 0 as libc::c_int),
                                            y + 12 as libc::c_int,
                                            '_' as i32 | 0x80 as libc::c_int,
                                            false_0 as libc::c_int,
                                        );
                                    }
                                    y += 16 as libc::c_int;
                                    current_block_40 = 1622411330066726685;
                                }
                            }
                            _ => {
                                V_DrawRightAlignedString(
                                    320 as libc::c_int - x,
                                    y,
                                    if (*cv).flags & CV_CHEAT as libc::c_int != 0
                                        && CV_IsSetToDefault(cv) == 0
                                    {
                                        0x5000 as libc::c_int
                                    } else {
                                        0x2000 as libc::c_int
                                    },
                                    (*cv).string,
                                );
                                if i == itemOn as libc::c_int {
                                    V_DrawCharacter(
                                        320 as libc::c_int - x - 10 as libc::c_int
                                            - V_StringWidth((*cv).string, 0 as libc::c_int)
                                            - skullAnimCounter as libc::c_int / 5 as libc::c_int,
                                        y,
                                        '\u{1c}' as i32 | 0x2000 as libc::c_int,
                                        false_0 as libc::c_int,
                                    );
                                    V_DrawCharacter(
                                        320 as libc::c_int - x + 2 as libc::c_int
                                            + skullAnimCounter as libc::c_int / 5 as libc::c_int,
                                        y,
                                        '\u{1d}' as i32 | 0x2000 as libc::c_int,
                                        false_0 as libc::c_int,
                                    );
                                }
                                current_block_40 = 1622411330066726685;
                            }
                        }
                        match current_block_40 {
                            17148350807101900901 => {}
                            _ => {}
                        }
                    }
                    _ => {}
                }
            }
            144 => {
                V_DrawString(
                    x,
                    y,
                    0x50000 as libc::c_int,
                    (*((*currentMenu).menuitems).offset(i as isize)).text,
                );
            }
            192 => {
                V_DrawString(
                    x,
                    y,
                    0x50000 as libc::c_int | 0x800 as libc::c_int,
                    M_CreateSecretMenuOption(
                        (*((*currentMenu).menuitems).offset(i as isize)).text,
                    ),
                );
            }
            176 => {
                V_DrawFill(
                    19 as libc::c_int,
                    y,
                    281 as libc::c_int,
                    9 as libc::c_int,
                    (*((*currentMenu).menuitems).offset((i + 1 as libc::c_int) as isize))
                        .alphaKey as int32_t,
                );
                V_DrawFill(
                    300 as libc::c_int,
                    y,
                    1 as libc::c_int,
                    9 as libc::c_int,
                    26 as libc::c_int,
                );
                M_DrawLevelPlatterHeader(
                    y - (16 as libc::c_int - 12 as libc::c_int),
                    (*((*currentMenu).menuitems).offset(i as isize)).text,
                    false_0 as libc::c_int,
                    false_0 as libc::c_int,
                );
            }
            16 | 64 | 128 | 96 | 80 | 112 | 160 | 0 | _ => {}
        }
        i += 1;
        i;
    }
    V_DrawStretchyFixedPatch(
        ((*currentMenu).x as libc::c_int - 24 as libc::c_int)
            * ((1 as libc::c_int) << 16 as libc::c_int),
        cursory << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        (1 as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        W_CachePatchName(
            b"M_CURSOR\0" as *const u8 as *const libc::c_char,
            PU_PATCH as libc::c_int,
        ) as *mut patch_t,
        0 as *const uint8_t,
    );
}
unsafe extern "C" fn M_HandleVideoMode(mut ch: int32_t) {
    if vidm_testingmode > 0 as libc::c_int {
        match ch {
            27 => {
                setmodeneeded = vidm_previousmode + 1 as libc::c_int;
                vidm_testingmode = 0 as libc::c_int;
            }
            13 => {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                vidm_testingmode = 0 as libc::c_int;
            }
            _ => {}
        }
    } else {
        match ch {
            238 => {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                vidm_selected += 1;
                if vidm_selected >= vidm_nummodes {
                    vidm_selected = 0 as libc::c_int;
                }
            }
            230 => {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                vidm_selected -= 1;
                if vidm_selected < 0 as libc::c_int {
                    vidm_selected = vidm_nummodes - 1 as libc::c_int;
                }
            }
            233 => {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                vidm_selected -= vidm_column_size;
                if vidm_selected < 0 as libc::c_int {
                    vidm_selected = vidm_column_size * 3 as libc::c_int + vidm_selected;
                }
                if vidm_selected >= vidm_nummodes {
                    vidm_selected = vidm_nummodes - 1 as libc::c_int;
                }
            }
            235 => {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                vidm_selected += vidm_column_size;
                if vidm_selected >= vidm_column_size * 3 as libc::c_int {
                    vidm_selected %= vidm_column_size;
                }
                if vidm_selected >= vidm_nummodes {
                    vidm_selected = vidm_nummodes - 1 as libc::c_int;
                }
            }
            13 => {
                if vid.modenum == modedescs[vidm_selected as usize].modenum {
                    S_StartSound(0 as *const libc::c_void, sfx_strpst);
                    SCR_SetDefaultMode();
                } else {
                    S_StartSound(0 as *const libc::c_void, sfx_menu1);
                    vidm_testingmode = 15 as libc::c_int * 35 as libc::c_int;
                    vidm_previousmode = vid.modenum;
                    if setmodeneeded == 0 {
                        setmodeneeded = modedescs[vidm_selected as usize].modenum
                            + 1 as libc::c_int;
                    }
                }
            }
            27 => {
                if !((*currentMenu).prevMenu).is_null() {
                    M_SetupNextMenu((*currentMenu).prevMenu);
                } else {
                    M_ClearMenus(true_0 as libc::c_int);
                }
            }
            8 => {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                CV_Set(&mut cv_scr_width, cv_scr_width.defaultvalue);
                CV_Set(&mut cv_scr_height, cv_scr_height.defaultvalue);
                CV_Set(&mut cv_scr_width_w, cv_scr_width_w.defaultvalue);
                CV_Set(&mut cv_scr_height_w, cv_scr_height_w.defaultvalue);
                if cv_fullscreen.value != 0 {
                    setmodeneeded = VID_GetModeForSize(
                        cv_scr_width.value,
                        cv_scr_height.value,
                    ) + 1 as libc::c_int;
                } else {
                    setmodeneeded = VID_GetModeForSize(
                        cv_scr_width_w.value,
                        cv_scr_height_w.value,
                    ) + 1 as libc::c_int;
                }
            }
            196 => {
                CV_AddValue(&mut cv_renderer, 1 as libc::c_int);
            }
            215 => {
                S_StartSound(0 as *const libc::c_void, sfx_menu1);
                CV_SetValue(
                    &mut cv_fullscreen,
                    (cv_fullscreen.value == 0) as libc::c_int,
                );
            }
            _ => {}
        }
    };
}
unsafe extern "C" fn M_DrawScreenshotMenu() {
    M_DrawGenericScrollMenu();
}
unsafe extern "C" fn M_DrawMonitorToggles() {
    let mut i: int32_t = 0;
    let mut y: int32_t = 0;
    let mut sum: int32_t = 0 as libc::c_int;
    let mut cv: *mut consvar_t = 0 as *mut consvar_t;
    let mut cheating: boolean = false_0 as libc::c_int;
    M_DrawGenericMenu();
    i = 0 as libc::c_int;
    while i < (*currentMenu).numitems as libc::c_int {
        if !((*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            & 8 as libc::c_int == 0
            || {
                cv = (*((*currentMenu).menuitems).offset(i as isize)).itemaction
                    as *mut consvar_t;
                cv.is_null()
            })
        {
            sum += (*cv).value;
            if CV_IsSetToDefault(cv) == 0 {
                cheating = true_0 as libc::c_int;
            }
        }
        i += 1;
        i;
    }
    i = 0 as libc::c_int;
    while i < (*currentMenu).numitems as libc::c_int {
        if !((*((*currentMenu).menuitems).offset(i as isize)).status as libc::c_int
            & 8 as libc::c_int == 0
            || {
                cv = (*((*currentMenu).menuitems).offset(i as isize)).itemaction
                    as *mut consvar_t;
                cv.is_null()
            })
        {
            y = (*currentMenu).y as libc::c_int
                + (*((*currentMenu).menuitems).offset(i as isize)).alphaKey
                    as libc::c_int;
            M_DrawSlider(
                (*currentMenu).x as libc::c_int + 20 as libc::c_int,
                y,
                cv,
                (i == itemOn as libc::c_int) as libc::c_int,
            );
            if (*cv).value == 0 {
                V_DrawRightAlignedString(
                    312 as libc::c_int,
                    y,
                    0x800 as libc::c_int
                        | (if i == itemOn as libc::c_int {
                            0x2000 as libc::c_int
                        } else {
                            0 as libc::c_int
                        }),
                    b"None\0" as *const u8 as *const libc::c_char,
                );
            } else {
                V_DrawRightAlignedString(
                    312 as libc::c_int,
                    y,
                    0x800 as libc::c_int
                        | (if i == itemOn as libc::c_int {
                            0x2000 as libc::c_int
                        } else {
                            0 as libc::c_int
                        }),
                    va(
                        b"%3d%%\0" as *const u8 as *const libc::c_char,
                        (*cv).value * 100 as libc::c_int / sum,
                    ),
                );
            }
        }
        i += 1;
        i;
    }
    if cheating != 0 {
        V_DrawCenteredString(
            320 as libc::c_int / 2 as libc::c_int,
            (*currentMenu).y as int32_t,
            0x5000 as libc::c_int,
            b"* MODIFIED, CHEATS ENABLED *\0" as *const u8 as *const libc::c_char,
        );
    }
}
static mut quitsounds: [int32_t; 15] = [
    sfx_itemup as libc::c_int,
    sfx_jump as libc::c_int,
    sfx_skid as libc::c_int,
    sfx_spring as libc::c_int,
    sfx_pop as libc::c_int,
    sfx_spdpad as libc::c_int,
    sfx_wdjump as libc::c_int,
    sfx_mswarp as libc::c_int,
    sfx_splash as libc::c_int,
    sfx_floush as libc::c_int,
    sfx_gloop as libc::c_int,
    sfx_s3k66 as libc::c_int,
    sfx_s3k6a as libc::c_int,
    sfx_s3k73 as libc::c_int,
    sfx_chchng as libc::c_int,
];
#[no_mangle]
pub unsafe extern "C" fn M_QuitResponse(mut ch: int32_t) {
    let mut ptime: tic_t = 0;
    let mut mrand: int32_t = 0;
    if ch != 'y' as i32 && ch != 13 as libc::c_int {
        return;
    }
    LUA_HookBool(true_0 as libc::c_int, hook_GameQuit as libc::c_int);
    if !(netgame != 0 || cv_debug != 0) {
        S_ResetCaptions();
        marathonmode = 0 as marathonmode_t;
        mrand = M_RandomKey(
            (::core::mem::size_of::<[int32_t; 15]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<int32_t>() as libc::c_ulong)
                as int32_t,
        );
        if quitsounds[mrand as usize] != 0 {
            S_StartSound(
                0 as *const libc::c_void,
                quitsounds[mrand as usize] as sfxenum_t,
            );
        }
        ptime = (I_GetTime())
            .wrapping_add(
                (35 as libc::c_int * 1 as libc::c_int * 2 as libc::c_int) as tic_t,
            );
        while ptime > I_GetTime() {
            V_DrawStretchyFixedPatch(
                0 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (0 as libc::c_int) << 16 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                0 as libc::c_int,
                W_CachePatchName(
                    b"GAMEQUIT\0" as *const u8 as *const libc::c_char,
                    PU_PATCH as libc::c_int,
                ) as *mut patch_t,
                0 as *const uint8_t,
            );
            I_FinishUpdate();
            I_Sleep(cv_sleep.value as uint32_t);
            I_UpdateTime(cv_timescale.value);
        }
    }
    I_Quit();
}
unsafe extern "C" fn M_QuitSRB2(mut choice: int32_t) {
    M_StartMessage(
        quitmsg[M_RandomKey(NUM_QUITMESSAGES as libc::c_int) as usize],
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(int32_t) -> ()>,
            *mut libc::c_void,
        >(Some(M_QuitResponse as unsafe extern "C" fn(int32_t) -> ())),
        MM_YESNO,
    );
}
unsafe extern "C" fn run_static_initializers() {
    OP_CameraOptionsMenu = [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"General Toggles\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Third-person Camera\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_chasecam as *mut consvar_t as *mut libc::c_void,
                alphaKey: 6 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Flip Camera with Gravity\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_flipcam as *mut consvar_t as *mut libc::c_void,
                alphaKey: 11 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Orbital Looking\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam_orbit as *mut consvar_t as *mut libc::c_void,
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Downhill Slope Adjustment\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam_adjust as *mut consvar_t as *mut libc::c_void,
                alphaKey: 21 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Positioning\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4096 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Distance\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *(*cv_cam_savedist
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 36 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4096 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Height\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *(*cv_cam_saveheight
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 41 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Spacial Speed\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam_speed as *mut consvar_t as *mut libc::c_void,
                alphaKey: 46 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Rotation Speed\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam_turnmultiplier as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 51 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Display Options\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Crosshair\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_crosshair as *mut consvar_t as *mut libc::c_void,
                alphaKey: 66 as libc::c_int as uint16_t,
            };
            init
        },
    ];
    OP_Camera2OptionsMenu = [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"General Toggles\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Third-person Camera\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_chasecam2 as *mut consvar_t as *mut libc::c_void,
                alphaKey: 6 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Flip Camera with Gravity\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_flipcam2 as *mut consvar_t as *mut libc::c_void,
                alphaKey: 11 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Orbital Looking\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam2_orbit as *mut consvar_t as *mut libc::c_void,
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Downhill Slope Adjustment\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam2_adjust as *mut consvar_t as *mut libc::c_void,
                alphaKey: 21 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Positioning\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4096 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Distance\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *(*cv_cam_savedist
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 36 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4096 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Height\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *(*cv_cam_saveheight
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 41 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Spacial Speed\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam2_speed as *mut consvar_t as *mut libc::c_void,
                alphaKey: 46 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Rotation Speed\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam2_turnmultiplier as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 51 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Display Options\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Crosshair\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_crosshair2 as *mut consvar_t as *mut libc::c_void,
                alphaKey: 66 as libc::c_int as uint16_t,
            };
            init
        },
    ];
    OP_CameraExtendedOptionsMenu = [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"General Toggles\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Third-person Camera\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_chasecam as *mut consvar_t as *mut libc::c_void,
                alphaKey: 6 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Flip Camera with Gravity\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_flipcam as *mut consvar_t as *mut libc::c_void,
                alphaKey: 11 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Orbital Looking\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam_orbit as *mut consvar_t as *mut libc::c_void,
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Downhill Slope Adjustment\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam_adjust as *mut consvar_t as *mut libc::c_void,
                alphaKey: 21 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Positioning\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4096 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Distance\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *(*cv_cam_savedist
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 36 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4096 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Height\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *(*cv_cam_saveheight
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 41 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Spacial Speed\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam_speed as *mut consvar_t as *mut libc::c_void,
                alphaKey: 46 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Rotation Speed\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam_turnmultiplier as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 51 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Automatic Camera Options\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Shift to player angle\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_shiftfacing
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 66 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Turn to player angle\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_turnfacing
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 71 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Turn to ability\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_turnfacingability
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 76 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Turn to spindash\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_turnfacingspindash
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 81 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Turn to input\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_turnfacinginput
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 86 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Locked Camera Options\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 95 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Lock button behavior\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_centertoggle
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 101 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Sideways movement\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_lockedinput
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 106 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Targeting assist\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_lockonboss
                    .as_mut_ptr()
                    .offset(0 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 111 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Display Options\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 120 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Crosshair\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_crosshair as *mut consvar_t as *mut libc::c_void,
                alphaKey: 126 as libc::c_int as uint16_t,
            };
            init
        },
    ];
    OP_Camera2ExtendedOptionsMenu = [
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"General Toggles\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 0 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Third-person Camera\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_chasecam2 as *mut consvar_t as *mut libc::c_void,
                alphaKey: 6 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Flip Camera with Gravity\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_flipcam2 as *mut consvar_t as *mut libc::c_void,
                alphaKey: 11 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Orbital Looking\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam2_orbit as *mut consvar_t as *mut libc::c_void,
                alphaKey: 16 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Downhill Slope Adjustment\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam2_adjust as *mut consvar_t as *mut libc::c_void,
                alphaKey: 21 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Positioning\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 30 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4096 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Distance\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *(*cv_cam_savedist
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 36 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4096 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Height\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *(*cv_cam_saveheight
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize))
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 41 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Camera Spacial Speed\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam2_speed as *mut consvar_t as *mut libc::c_void,
                alphaKey: 46 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 4608 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Rotation Speed\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_cam2_turnmultiplier as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 51 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Automatic Camera Options\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 60 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Shift to player angle\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_shiftfacing
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 66 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Turn to player angle\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_turnfacing
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 71 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Turn to ability\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_turnfacingability
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 76 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Turn to spindash\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_turnfacingspindash
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 81 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int | 512 as libc::c_int)
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Turn to input\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_turnfacinginput
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 86 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Locked Camera Options\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 95 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Lock button behavior\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_centertoggle
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 101 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Sideways movement\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_lockedinput
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 106 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Targeting assist\0" as *const u8 as *const libc::c_char,
                itemaction: &mut *cv_cam_lockonboss
                    .as_mut_ptr()
                    .offset(1 as libc::c_int as isize) as *mut consvar_t
                    as *mut libc::c_void,
                alphaKey: 111 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (1 as libc::c_int + (48 as libc::c_int + 128 as libc::c_int))
                    as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Display Options\0" as *const u8 as *const libc::c_char,
                itemaction: 0 as *mut libc::c_void,
                alphaKey: 120 as libc::c_int as uint16_t,
            };
            init
        },
        {
            let mut init = menuitem_s {
                status: (32 as libc::c_int | 8 as libc::c_int) as uint16_t,
                patch: 0 as *const libc::c_char,
                text: b"Crosshair\0" as *const u8 as *const libc::c_char,
                itemaction: &mut cv_crosshair2 as *mut consvar_t as *mut libc::c_void,
                alphaKey: 126 as libc::c_int as uint16_t,
            };
            init
        },
    ];
    MainDef = {
        let mut init = menu_s {
            menuid: MN_MAIN as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 6]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: 0 as *mut menu_s,
            menuitems: MainMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawCenteredMenu as unsafe extern "C" fn() -> ()),
            x: (320 as libc::c_int / 2 as libc::c_int) as int16_t,
            y: 72 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MISC_AddonsDef = {
        let mut init = menu_s {
            menuid: MN_AD_MAIN as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 1]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: MISC_AddonsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawAddons as unsafe extern "C" fn() -> ()),
            x: 50 as libc::c_int as int16_t,
            y: 28 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MAPauseDef = {
        let mut init = menu_s {
            menuid: MN_SPECIAL as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 4]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: 0 as *mut menu_s,
            menuitems: MAPauseMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawPauseMenu as unsafe extern "C" fn() -> ()),
            x: 40 as libc::c_int as int16_t,
            y: 72 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SPauseDef = {
        let mut init = menu_s {
            menuid: MN_SPECIAL as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 8]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: 0 as *mut menu_s,
            menuitems: SPauseMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawPauseMenu as unsafe extern "C" fn() -> ()),
            x: 40 as libc::c_int as int16_t,
            y: 72 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MPauseDef = {
        let mut init = menu_s {
            menuid: MN_SPECIAL as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 14]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: 0 as *mut menu_s,
            menuitems: MPauseMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawPauseMenu as unsafe extern "C" fn() -> ()),
            x: 40 as libc::c_int as int16_t,
            y: 72 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MISC_ScrambleTeamDef = {
        let mut init = menu_s {
            menuid: MN_SPECIAL as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 2]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MPauseDef,
            menuitems: MISC_ScrambleTeamMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 27 as libc::c_int as int16_t,
            y: 40 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MISC_ChangeTeamDef = {
        let mut init = menu_s {
            menuid: MN_SPECIAL as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 2]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MPauseDef,
            menuitems: MISC_ChangeTeamMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 27 as libc::c_int as int16_t,
            y: 40 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MISC_ChangeLevelDef = {
        let mut init = menu_s {
            menuid: MN_SPECIAL as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 1]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: MISC_ChangeLevelMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawLevelPlatterMenu as unsafe extern "C" fn() -> ()),
            x: 0 as libc::c_int as int16_t,
            y: 0 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MISC_HelpDef = {
        let mut init = menu_s {
            menuid: MN_SPECIAL as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 5]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: 0 as *mut menu_s,
            menuitems: MISC_HelpMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawImageDef as unsafe extern "C" fn() -> ()),
            x: 0 as libc::c_int as int16_t,
            y: 0 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SR_PandoraDef = {
        let mut init = menu_s {
            menuid: (MN_SR_MAIN as libc::c_int
                | (MN_SR_PANDORA as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_PANDRA\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 10]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut SPauseDef,
            menuitems: SR_PandorasBox.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 60 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: Some(M_ExitPandorasBox as unsafe extern "C" fn() -> boolean),
        };
        init
    };
    SR_MainDef = {
        let mut init = menu_s {
            menuid: MN_SR_MAIN as libc::c_int as uint32_t,
            menutitlepic: b"M_SECRET\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 81]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: SR_MainMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 60 as libc::c_int as int16_t,
            y: 40 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SR_LevelSelectDef = {
        let mut init = menu_s {
            menuid: (MN_SR_MAIN as libc::c_int
                | (MN_SR_LEVELSELECT as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 1]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: SR_LevelSelectMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawLevelPlatterMenu as unsafe extern "C" fn() -> ()),
            x: 0 as libc::c_int as int16_t,
            y: 0 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SR_SoundTestDef = {
        let mut init = menu_s {
            menuid: (MN_SR_MAIN as libc::c_int
                | (MN_SR_SOUNDTEST as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 1]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut SR_MainDef,
            menuitems: SR_SoundTestMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawSoundTest as unsafe extern "C" fn() -> ()),
            x: 60 as libc::c_int as int16_t,
            y: 150 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SR_EmblemHintDef = {
        let mut init = menu_s {
            menuid: (MN_SR_MAIN as libc::c_int
                | (MN_SR_EMBLEMHINT as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 3]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut SPauseDef,
            menuitems: SR_EmblemHintMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawEmblemHints as unsafe extern "C" fn() -> ()),
            x: 60 as libc::c_int as int16_t,
            y: 150 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_MainDef = {
        let mut init = menu_s {
            menuid: MN_SP_MAIN as libc::c_int as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 6]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: SP_MainMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawCenteredMenu as unsafe extern "C" fn() -> ()),
            x: (320 as libc::c_int / 2 as libc::c_int) as int16_t,
            y: 72 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_LevelSelectDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_LOAD as libc::c_int
                    | (MN_SP_PLAYER as libc::c_int
                        | (MN_SP_LEVELSELECT as libc::c_int) << 6 as libc::c_int)
                        << 6 as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 1]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: SP_LevelSelectMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawLevelPlatterMenu as unsafe extern "C" fn() -> ()),
            x: 0 as libc::c_int as int16_t,
            y: 0 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_PauseLevelSelectDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_LOAD as libc::c_int
                    | (MN_SP_PLAYER as libc::c_int
                        | (MN_SP_LEVELSELECT as libc::c_int) << 6 as libc::c_int)
                        << 6 as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: 0 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 1]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: SP_LevelSelectMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawLevelPlatterMenu as unsafe extern "C" fn() -> ()),
            x: 0 as libc::c_int as int16_t,
            y: 0 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_TimeAttackLevelSelectDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_TIMEATTACK as libc::c_int
                    | (MN_SP_TIMEATTACK_LEVELSELECT as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_ATTACK\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 1]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: SP_TimeAttackLevelSelectMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawLevelPlatterMenu as unsafe extern "C" fn() -> ()),
            x: 0 as libc::c_int as int16_t,
            y: 0 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_TimeAttackDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_TIMEATTACK as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_ATTACK\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 6]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: SP_TimeAttackMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawTimeAttackMenu as unsafe extern "C" fn() -> ()),
            x: 32 as libc::c_int as int16_t,
            y: 40 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_ReplayDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_TIMEATTACK as libc::c_int
                    | (MN_SP_REPLAY as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_ATTACK\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 6]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut SP_TimeAttackDef,
            menuitems: SP_ReplayMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawTimeAttackMenu as unsafe extern "C" fn() -> ()),
            x: 32 as libc::c_int as int16_t,
            y: 120 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_GuestReplayDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_TIMEATTACK as libc::c_int
                    | (MN_SP_GUESTREPLAY as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_ATTACK\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 6]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut SP_TimeAttackDef,
            menuitems: SP_GuestReplayMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawTimeAttackMenu as unsafe extern "C" fn() -> ()),
            x: 32 as libc::c_int as int16_t,
            y: 120 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_GhostDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_TIMEATTACK as libc::c_int
                    | (MN_SP_GHOST as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_ATTACK\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 6]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut SP_TimeAttackDef,
            menuitems: SP_GhostMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawTimeAttackMenu as unsafe extern "C" fn() -> ()),
            x: 32 as libc::c_int as int16_t,
            y: 120 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_NightsAttackLevelSelectDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_NIGHTSATTACK as libc::c_int
                    | (MN_SP_NIGHTS_LEVELSELECT as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_NIGHTS\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 1]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: SP_NightsAttackLevelSelectMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawLevelPlatterMenu as unsafe extern "C" fn() -> ()),
            x: 0 as libc::c_int as int16_t,
            y: 0 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_NightsAttackDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_NIGHTSATTACK as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_NIGHTS\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 7]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: SP_NightsAttackMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawNightsAttackMenu as unsafe extern "C" fn() -> ()),
            x: 32 as libc::c_int as int16_t,
            y: 40 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_NightsReplayDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_NIGHTSATTACK as libc::c_int
                    | (MN_SP_NIGHTS_REPLAY as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_NIGHTS\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 5]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut SP_NightsAttackDef,
            menuitems: SP_NightsReplayMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawNightsAttackMenu as unsafe extern "C" fn() -> ()),
            x: 32 as libc::c_int as int16_t,
            y: 120 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_NightsGuestReplayDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_NIGHTSATTACK as libc::c_int
                    | (MN_SP_NIGHTS_GUESTREPLAY as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_NIGHTS\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 5]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut SP_NightsAttackDef,
            menuitems: SP_NightsGuestReplayMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawNightsAttackMenu as unsafe extern "C" fn() -> ()),
            x: 32 as libc::c_int as int16_t,
            y: 120 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_NightsGhostDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_NIGHTSATTACK as libc::c_int
                    | (MN_SP_NIGHTS_GHOST as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_NIGHTS\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 5]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut SP_NightsAttackDef,
            menuitems: SP_NightsGhostMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawNightsAttackMenu as unsafe extern "C" fn() -> ()),
            x: 32 as libc::c_int as int16_t,
            y: 120 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_MarathonDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_MARATHON as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_RATHON\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 5]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: SP_MarathonMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawMarathon as unsafe extern "C" fn() -> ()),
            x: 32 as libc::c_int as int16_t,
            y: 40 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    SP_PlayerDef = {
        let mut init = menu_s {
            menuid: (MN_SP_MAIN as libc::c_int
                | (MN_SP_LOAD as libc::c_int
                    | (MN_SP_PLAYER as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_PICKP\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 1]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut SP_MainDef,
            menuitems: SP_PlayerMenu.as_mut_ptr(),
            drawroutine: Some(
                M_DrawSetupChoosePlayerMenu as unsafe extern "C" fn() -> (),
            ),
            x: 24 as libc::c_int as int16_t,
            y: 32 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MP_SplitServerDef = {
        let mut init = menu_s {
            menuid: (MN_MP_MAIN as libc::c_int
                | (MN_MP_SPLITSCREEN as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_MULTI\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 3]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MP_MainDef,
            menuitems: MP_SplitServerMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawServerMenu as unsafe extern "C" fn() -> ()),
            x: 27 as libc::c_int as int16_t,
            y: (30 as libc::c_int - 50 as libc::c_int) as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MP_MainDef = {
        let mut init = menu_s {
            menuid: MN_MP_MAIN as libc::c_int as uint32_t,
            menutitlepic: b"M_MULTI\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 9]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: MP_MainMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawMPMainMenu as unsafe extern "C" fn() -> ()),
            x: 27 as libc::c_int as int16_t,
            y: 40 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: Some(M_CancelConnect as unsafe extern "C" fn() -> boolean),
        };
        init
    };
    MP_ServerDef = {
        let mut init = menu_s {
            menuid: (MN_MP_MAIN as libc::c_int
                | (MN_MP_SERVER as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_MULTI\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 7]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MP_MainDef,
            menuitems: MP_ServerMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawServerMenu as unsafe extern "C" fn() -> ()),
            x: 27 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MP_ConnectDef = {
        let mut init = menu_s {
            menuid: (MN_MP_MAIN as libc::c_int
                | (MN_MP_CONNECT as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_MULTI\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 15]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MP_MainDef,
            menuitems: MP_ConnectMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawConnectMenu as unsafe extern "C" fn() -> ()),
            x: 27 as libc::c_int as int16_t,
            y: 24 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: Some(M_CancelConnect as unsafe extern "C" fn() -> boolean),
        };
        init
    };
    MP_RoomDef = {
        let mut init = menu_s {
            menuid: (MN_MP_MAIN as libc::c_int
                | (MN_MP_ROOM as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_MULTI\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 18]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MP_ConnectDef,
            menuitems: MP_RoomMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawRoomMenu as unsafe extern "C" fn() -> ()),
            x: 27 as libc::c_int as int16_t,
            y: 32 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    MP_PlayerSetupDef = {
        let mut init = menu_s {
            menuid: (MN_MP_MAIN as libc::c_int
                | (MN_MP_SPLITSCREEN as libc::c_int
                    | (MN_MP_PLAYERSETUP as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_SPLAYR\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 4]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: MP_PlayerSetupMenu.as_mut_ptr(),
            drawroutine: Some(
                M_DrawSetupMultiPlayerMenu as unsafe extern "C" fn() -> (),
            ),
            x: 19 as libc::c_int as int16_t,
            y: 22 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: Some(M_QuitMultiPlayerMenu as unsafe extern "C" fn() -> boolean),
        };
        init
    };
    OP_MainDef = {
        let mut init = menu_s {
            menuid: MN_OP_MAIN as libc::c_int as uint32_t,
            menutitlepic: b"M_OPTTTL\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 7]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut MainDef,
            menuitems: OP_MainMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 50 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_ChangeControlsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (0 as libc::c_int
                    | (MN_OP_CHANGECONTROLS as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_CONTRO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 51]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_MainDef,
            menuitems: OP_ChangeControlsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawControl as unsafe extern "C" fn() -> ()),
            x: 24 as libc::c_int as int16_t,
            y: 40 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_P1ControlsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_P1CONTROLS as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_CONTRO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 6]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_MainDef,
            menuitems: OP_P1ControlsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawControlsDefMenu as unsafe extern "C" fn() -> ()),
            x: 50 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_P2ControlsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_P2CONTROLS as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_CONTRO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 6]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_MainDef,
            menuitems: OP_P2ControlsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawControlsDefMenu as unsafe extern "C" fn() -> ()),
            x: 50 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_MouseOptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_P1CONTROLS as libc::c_int
                    | (MN_OP_P1MOUSE as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_CONTRO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 7]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_P1ControlsDef,
            menuitems: OP_MouseOptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 35 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_Mouse2OptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_P2CONTROLS as libc::c_int
                    | (MN_OP_P2MOUSE as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_CONTRO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 8]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_P2ControlsDef,
            menuitems: OP_Mouse2OptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 35 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_Joystick1Def = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_P1CONTROLS as libc::c_int
                    | (MN_OP_P1JOYSTICK as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_CONTRO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 13]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_P1ControlsDef,
            menuitems: OP_Joystick1Menu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 50 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_Joystick2Def = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_P2CONTROLS as libc::c_int
                    | (MN_OP_P2JOYSTICK as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_CONTRO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 13]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_P2ControlsDef,
            menuitems: OP_Joystick2Menu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 50 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_JoystickSetDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (0 as libc::c_int
                    | (0 as libc::c_int
                        | (MN_OP_JOYSTICKSET as libc::c_int) << 6 as libc::c_int)
                        << 6 as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_CONTRO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 5]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_Joystick1Def,
            menuitems: OP_JoystickSetMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawJoystick as unsafe extern "C" fn() -> ()),
            x: 60 as libc::c_int as int16_t,
            y: 40 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_CameraOptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_P1CONTROLS as libc::c_int
                    | (MN_OP_P1CAMERA as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_CONTRO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 12]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_P1ControlsDef,
            menuitems: OP_CameraOptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawCameraOptionsMenu as unsafe extern "C" fn() -> ()),
            x: 35 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_Camera2OptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_P2CONTROLS as libc::c_int
                    | (MN_OP_P2CAMERA as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_CONTRO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 12]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_P2ControlsDef,
            menuitems: OP_Camera2OptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawCameraOptionsMenu as unsafe extern "C" fn() -> ()),
            x: 35 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_VideoOptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_VIDEO as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_VIDEO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 35]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_MainDef,
            menuitems: OP_VideoOptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawMainVideoMenu as unsafe extern "C" fn() -> ()),
            x: 30 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_ColorOptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_VIDEO as libc::c_int
                    | (MN_OP_COLOR as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_VIDEO\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 31]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_VideoOptionsDef,
            menuitems: OP_ColorOptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawColorMenu as unsafe extern "C" fn() -> ()),
            x: 30 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_SoundOptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_SOUND as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_SOUND\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 13]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_MainDef,
            menuitems: OP_SoundOptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericScrollMenu as unsafe extern "C" fn() -> ()),
            x: 30 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_SoundAdvancedDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_SOUND as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_SOUND\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 6]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_SoundOptionsDef,
            menuitems: OP_SoundAdvancedMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 30 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_ServerOptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_SERVER as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_SERVER\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 40]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_MainDef,
            menuitems: OP_ServerOptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericScrollMenu as unsafe extern "C" fn() -> ()),
            x: 30 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_MonitorToggleDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_SOUND as libc::c_int
                    | (MN_OP_MONITORTOGGLE as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_SERVER\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 13]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_ServerOptionsDef,
            menuitems: OP_MonitorToggleMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawMonitorToggles as unsafe extern "C" fn() -> ()),
            x: 30 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_DataOptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_DATA as libc::c_int) << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_DATA\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 3]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_MainDef,
            menuitems: OP_DataOptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 60 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_ScreenshotOptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_DATA as libc::c_int
                    | (MN_OP_SCREENSHOTS as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_SCREEN\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 21]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_DataOptionsDef,
            menuitems: OP_ScreenshotOptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawScreenshotMenu as unsafe extern "C" fn() -> ()),
            x: 30 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_AddonsOptionsDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_DATA as libc::c_int
                    | (MN_OP_ADDONS as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_ADDONS\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 8]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_DataOptionsDef,
            menuitems: OP_AddonsOptionsMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 30 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
    OP_EraseDataDef = {
        let mut init = menu_s {
            menuid: (MN_OP_MAIN as libc::c_int
                | (MN_OP_DATA as libc::c_int
                    | (MN_OP_ERASEDATA as libc::c_int) << 6 as libc::c_int)
                    << 6 as libc::c_int) as uint32_t,
            menutitlepic: b"M_DATA\0" as *const u8 as *const libc::c_char,
            numitems: (::core::mem::size_of::<[menuitem_t; 3]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<menuitem_t>() as libc::c_ulong)
                as int16_t,
            prevMenu: &mut OP_DataOptionsDef,
            menuitems: OP_EraseDataMenu.as_mut_ptr(),
            drawroutine: Some(M_DrawGenericMenu as unsafe extern "C" fn() -> ()),
            x: 60 as libc::c_int as int16_t,
            y: 30 as libc::c_int as int16_t,
            lastOn: 0 as libc::c_int as int16_t,
            quitroutine: None,
        };
        init
    };
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
