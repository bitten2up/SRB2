use ::libc;
use ::c2rust_bitfields;
extern "C" {
    fn abs(_: libc::c_int) -> libc::c_int;
    fn FixedHypot(x: fixed_t, y: fixed_t) -> fixed_t;
    fn FV4_Load(
        vec: *mut vector4_t,
        x: fixed_t,
        y: fixed_t,
        z: fixed_t,
        a: fixed_t,
    ) -> *mut vector4_t;
    fn FV4_Copy(a_o: *mut vector4_t, a_i: *const vector4_t) -> *mut vector4_t;
    fn FM_MultMatrixVec4(
        matrix: *const matrix_t,
        vec: *const vector4_t,
        out: *mut vector4_t,
    ) -> *const vector4_t;
    fn get_number(word: *const libc::c_char) -> fixed_t;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strtok(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    static mut numskincolors: uint16_t;
    static mut titlemapinaction: uint8_t;
    static mut ultimatemode: uint8_t;
    fn CONS_Printf(fmt: *const libc::c_char, _: ...);
    fn CONS_Alert(level: alerttype_t, fmt: *const libc::c_char, _: ...);
    fn CONS_Debug(debugflags: int32_t, fmt: *const libc::c_char, _: ...);
    static mut M_Memcpy: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_void,
            size_t,
        ) -> *mut libc::c_void,
    >;
    fn sizeu1(num: size_t) -> *mut libc::c_char;
    static mut finesine: [fixed_t; 10240];
    static mut finecosine: *mut fixed_t;
    fn AngleFixed(af: angle_t) -> fixed_t;
    fn FixedAngle(fa: fixed_t) -> angle_t;
    fn FM_RotateX(dest: *mut matrix_t, rad: angle_t) -> *mut matrix_t;
    fn FM_RotateZ(dest: *mut matrix_t, rad: angle_t) -> *mut matrix_t;
    fn A_FaceTarget();
    fn A_BossDeath();
    fn A_AttractChase();
    fn A_CapeChase();
    fn A_BossScream();
    fn A_LobShot();
    fn A_Boss1Laser();
    fn A_Boss2Chase();
    fn A_Boss2Pogo();
    fn A_Boss7Chase();
    fn A_BossJetFume();
    fn A_HomingChase();
    fn A_DoNPCPain();
    static mut states: [state_t; 6735];
    static mut astate: *mut state_t;
    static mut mobjinfo: [mobjinfo_t; 1163];
    static mut disableSpeedAdjust: boolean;
    static mut flashingtics: uint16_t;
    static mut maptol: uint32_t;
    fn G_GhostAddScale(scale: fixed_t);
    static mut secondarydisplayplayer: int32_t;
    static mut players: [player_t; 32];
    static mut displayplayer: int32_t;
    fn G_GhostAddFlip();
    static mut gravity: fixed_t;
    static mut CheckForReverseGravity: boolean;
    static mut playeringame: [boolean; 32];
    static mut nummaprings: int32_t;
    static mut skincolor_blueteam: uint16_t;
    static mut skincolor_redteam: uint16_t;
    static mut skincolor_redring: uint16_t;
    static mut netgame: boolean;
    static mut CheckForBustableBlocks: boolean;
    static mut blueflag: *mut mobj_t;
    static mut consoleplayer: int32_t;
    static mut splitscreen: boolean;
    static mut redflag: *mut mobj_t;
    static mut underwatertics: uint16_t;
    static mut CheckForMarioBlocks: boolean;
    static mut CheckForFloatBob: boolean;
    static mut gamemap: int16_t;
    static mut cv_exitmove: consvar_t;
    static mut bossdisabled: uint16_t;
    static mut sstimer: int32_t;
    static mut gametyperules: uint32_t;
    static mut multiplayer: boolean;
    fn SendNetXCmd(id: netxcmd_t, param: *const libc::c_void, nparam: size_t);
    static mut cv_coopstarposts: consvar_t;
    static mut metalrecording: boolean;
    static mut bflagpoint: *mut mapthing_t;
    static mut rflagpoint: *mut mapthing_t;
    static mut numstarposts: int32_t;
    static mut tokenbits: int32_t;
    fn P_AddWaypoint(sequence: uint8_t, id: uint8_t, waypoint: *mut mobj_t);
    static mut emblemlocations: [emblem_t; 512];
    fn M_GetEmblemColor(em: *mut emblem_t) -> skincolornum_t;
    fn M_GetLevelEmblems(mapnum: int32_t) -> *mut emblem_t;
    static mut modeattacking: uint8_t;
    static mut cv_matchboxes: consvar_t;
    static mut cv_competitionboxes: consvar_t;
    static mut cv_specialrings: consvar_t;
    static mut tokenlist: uint32_t;
    static mut runemeraldmanager: boolean;
    static mut cv_powerstones: consvar_t;
    static mut emeralds: uint16_t;
    static mut objectplacing: boolean;
    static mut playerstarts: [*mut mapthing_t; 32];
    static mut bluectfstarts: [*mut mapthing_t; 32];
    static mut redctfstarts: [*mut mapthing_t; 32];
    fn Tag_FindLineSpecial(special: int16_t, tag: mtag_t) -> int32_t;
    static mut curWeather: int32_t;
    static mut dedicated: boolean;
    static mut emeraldspawndelay: uint16_t;
    static mut globalweather: uint8_t;
    static mut sound_disabled: boolean;
    static mut postimgtype: postimg_t;
    static mut postimgtype2: postimg_t;
    static mut skincolor_bluering: uint16_t;
    fn Tag_Iterate_Things(tag: mtag_t, p: size_t) -> int32_t;
    fn Tag_Iterate_Sectors(tag: mtag_t, p: size_t) -> int32_t;
    fn Tag_FGet(list: *const taglist_t) -> mtag_t;
    static mut CV_OnOff: [CV_PossibleValue_t; 0];
    fn G_RingSlingerGametype() -> boolean;
    fn G_PlayerReborn(player: int32_t, betweenmaps: boolean);
    fn G_GametypeHasSpectators() -> boolean;
    fn G_CoopGametype() -> boolean;
    fn G_GametypeHasTeams() -> boolean;
    fn G_IsSpecialStage(mapnum: int32_t) -> boolean;
    fn G_PlatformGametype() -> boolean;
    static mut localaiming2: int32_t;
    static mut localaiming: int32_t;
    fn ST_Start();
    static mut linkColor: [[skincolornum_t; 12]; 3];
    fn P_MobjInsidePolyobj(po: *mut polyobj_t, mo: *mut mobj_t) -> boolean;
    fn HU_Start();
    static mut skyboxviewpnts: [*mut mobj_t; 16];
    static mut skyboxcenterpnts: [*mut mobj_t; 16];
    fn P_GetSectorGravityFactor(sec: *mut sector_t) -> fixed_t;
    fn P_MobjTouchingSectorSpecialFlag(
        mo: *mut mobj_t,
        flag: sectorspecialflags_t,
    ) -> *mut sector_t;
    fn P_CheckMobjTrigger(mobj: *mut mobj_t, pushable: boolean);
    fn P_LinedefExecute(tag: int16_t, actor: *mut mobj_t, caller: *mut sector_t);
    fn P_SpawnLightningFlash(sector: *mut sector_t);
    fn EV_DoCeiling(tag: mtag_t, line: *mut line_t, type_0: ceiling_e) -> int32_t;
    static mut leveltime: tic_t;
    fn P_AddThinker(n: thinklistnum_t, thinker: *mut thinker_t);
    fn P_RemoveThinker(thinker: *mut thinker_t);
    fn P_SetTarget2(mo: *mut *mut mobj_t, target: *mut mobj_t) -> *mut mobj_t;
    fn P_UnsetPrecipThingPosition(thing: *mut precipmobj_t);
    fn P_SetPrecipitationThingPosition(thing: *mut precipmobj_t);
    fn P_AproxDistance(dx: fixed_t, dy: fixed_t) -> fixed_t;
    fn P_RemoveThinkerDelayed(thinker: *mut thinker_t);
    fn P_PlayerFullbright(player: *mut player_t) -> boolean;
    fn P_IsObjectOnGround(mo: *mut mobj_t) -> boolean;
    fn P_DoPityCheck(player: *mut player_t);
    fn P_SetPlayerAngle(player: *mut player_t, angle: angle_t);
    fn P_ResetCamera(player: *mut player_t, thiscam: *mut camera_t);
    fn P_GiveFinishFlags(player: *mut player_t);
    fn P_AddPlayerScore(player: *mut player_t, amount: uint32_t);
    static mut thlist: [thinker_t; 0];
    static mut camera2: camera_t;
    static mut camera: camera_t;
    fn P_PlayerCanDamage(player: *mut player_t, thing: *mut mobj_t) -> boolean;
    fn EV_StartCrumble(
        sector: *mut sector_t,
        rover: *mut ffloor_t,
        floating: boolean,
        player: *mut player_t,
        origalpha: fixed_t,
        crumblereturn: boolean,
    ) -> int32_t;
    fn P_BoxOnLineSide(tmbox: *mut fixed_t, ld: *mut line_t) -> int32_t;
    fn P_SpawnGhostMobj(mobj: *mut mobj_t) -> *mut mobj_t;
    fn P_IsObjectInGoop(mo: *mut mobj_t) -> boolean;
    fn P_PlayerInPain(player: *mut player_t) -> boolean;
    fn P_ReturnThrustY(mo: *mut mobj_t, angle: angle_t, move_0: fixed_t) -> fixed_t;
    fn EV_CrumbleChain(sec: *mut sector_t, rover: *mut ffloor_t);
    fn EV_BounceSector(sector: *mut sector_t, momz: fixed_t, sourceline: *mut line_t);
    fn P_BlockThingsIterator(
        x: int32_t,
        y: int32_t,
        func: Option::<unsafe extern "C" fn(*mut mobj_t) -> boolean>,
    ) -> boolean;
    fn P_InstaThrust(mo: *mut mobj_t, angle: angle_t, move_0: fixed_t);
    fn P_PlayerHitFloor(player: *mut player_t, dorollstuff: boolean) -> boolean;
    fn P_SetObjectMomZ(mo: *mut mobj_t, value: fixed_t, relative: boolean);
    fn EV_MarioBlock(rover: *mut ffloor_t, sector: *mut sector_t, puncher: *mut mobj_t);
    static mut cv_cam_height: consvar_t;
    static mut cv_cam2_height: consvar_t;
    fn P_TryCameraMove(x: fixed_t, y: fixed_t, thiscam: *mut camera_t) -> boolean;
    fn P_SlideCameraMove(thiscam: *mut camera_t);
    fn P_SceneryTryMove(thing: *mut mobj_t, x: fixed_t, y: fixed_t) -> boolean;
    fn P_ReturnThrustX(mo: *mut mobj_t, angle: angle_t, move_0: fixed_t) -> fixed_t;
    static mut var2: int32_t;
    static mut tmfloorz: fixed_t;
    static mut tmceilingz: fixed_t;
    static mut tmfloorrover: *mut ffloor_t;
    static mut tmceilingrover: *mut ffloor_t;
    fn P_LookForPlayers(
        actor: *mut mobj_t,
        allaround: boolean,
        tracer: boolean,
        dist: fixed_t,
    ) -> boolean;
    static mut var1: int32_t;
    static mut tmhitthing: *mut mobj_t;
    fn P_GetLives(player: *mut player_t) -> boolean;
    fn P_InternalFlickySpawn(
        actor: *mut mobj_t,
        flickytype: mobjtype_t,
        momz: fixed_t,
        lookforplayers: boolean,
        moveforward: int8_t,
    ) -> *mut mobj_t;
    static mut tmfloorthing: *mut mobj_t;
    fn P_BounceMove(mo: *mut mobj_t);
    fn P_SlideMove(mo: *mut mobj_t);
    static mut ceilingline: *mut line_t;
    fn P_SetUnderlayPosition(thing: *mut mobj_t);
    static mut tmceilingslope: *mut pslope_t;
    static mut tmfloorslope: *mut pslope_t;
    fn P_MoveOrigin(thing: *mut mobj_t, x: fixed_t, y: fixed_t, z: fixed_t) -> boolean;
    static mut bmaporgx: fixed_t;
    fn P_RadiusAttack(
        spot: *mut mobj_t,
        source: *mut mobj_t,
        damagedist: fixed_t,
        damagetype: uint8_t,
        sightcheck: boolean,
    );
    fn P_SetThingPosition(thing: *mut mobj_t);
    static mut bmaporgy: fixed_t;
    static mut bmapheight: int32_t;
    static mut bmapwidth: int32_t;
    fn P_CheckSight(t1: *mut mobj_t, t2: *mut mobj_t) -> boolean;
    static mut sector_list: *mut msecnode_t;
    fn P_UnsetThingPosition(thing: *mut mobj_t);
    fn P_DelPrecipSeclist(node: *mut mprecipsecnode_t);
    static mut precipsector_list: *mut mprecipsecnode_t;
    fn P_CheckPosition(thing: *mut mobj_t, x: fixed_t, y: fixed_t) -> boolean;
    fn P_DelSeclist(node: *mut msecnode_t);
    fn P_DamageMobj(
        target: *mut mobj_t,
        inflictor: *mut mobj_t,
        source: *mut mobj_t,
        damage: int32_t,
        damagetype: uint8_t,
    ) -> boolean;
    static mut blockingline: *mut line_t;
    fn P_CheckCameraPosition(x: fixed_t, y: fixed_t, thiscam: *mut camera_t) -> boolean;
    fn P_TryMove(
        thing: *mut mobj_t,
        x: fixed_t,
        y: fixed_t,
        allowdropoff: boolean,
    ) -> boolean;
    fn P_CheckSector(sector: *mut sector_t, crunch: boolean) -> boolean;
    fn P_SetOrigin(thing: *mut mobj_t, x: fixed_t, y: fixed_t, z: fixed_t) -> boolean;
    fn P_CeilingzAtPos(x: fixed_t, y: fixed_t, z: fixed_t, height: fixed_t) -> fixed_t;
    fn P_FloorzAtPos(x: fixed_t, y: fixed_t, z: fixed_t, height: fixed_t) -> fixed_t;
    fn P_KillMobj(
        target: *mut mobj_t,
        inflictor: *mut mobj_t,
        source: *mut mobj_t,
        damagetype: uint8_t,
    );
    fn P_CanPickupEmblem(player: *mut player_t, emblemID: int32_t) -> boolean;
    fn P_EmblemWasCollected(emblemID: int32_t) -> boolean;
    fn P_Thrust(mo: *mut mobj_t, angle: angle_t, move_0: fixed_t);
    static mut deathmatchstarts: [*mut mapthing_t; 64];
    static mut numdmstarts: int32_t;
    static mut numredctfstarts: int32_t;
    static mut numbluectfstarts: int32_t;
    static mut levelloading: boolean;
    static mut mapthings: *mut mapthing_t;
    static mut numsectors: size_t;
    fn R_RemoveMobjInterpolator(mobj: *mut mobj_t);
    fn R_AddMobjInterpolator(mobj: *mut mobj_t);
    static mut sectors: *mut sector_t;
    static mut subsectors: *mut subsector_t;
    static mut numsubsectors: size_t;
    static mut lines: *mut line_t;
    static mut udmf: boolean;
    fn R_ResetPrecipitationMobjInterpolationState(mobj: *mut precipmobj_t);
    fn R_PointToAngle2(
        px2: fixed_t,
        py2: fixed_t,
        px1: fixed_t,
        py1: fixed_t,
    ) -> angle_t;
    fn R_PointToDist2(px2: fixed_t, py2: fixed_t, px1: fixed_t, py1: fixed_t) -> fixed_t;
    fn R_PointInSubsector(x: fixed_t, y: fixed_t) -> *mut subsector_t;
    fn R_PointInSubsectorOrNull(x: fixed_t, y: fixed_t) -> *mut subsector_t;
    static mut cv_drawdist_precip: consvar_t;
    fn P_GetSkinSprite2(
        skin: *mut skin_t,
        spr2: uint8_t,
        player: *mut player_t,
    ) -> uint8_t;
    static mut skins: [skin_t; 32];
    static mut skyflatnum: int32_t;
    fn S_StartSound(origin: *const libc::c_void, sound_id: sfxenum_t);
    fn S_StartSoundAtVolume(
        origin: *const libc::c_void,
        sound_id: sfxenum_t,
        volume: int32_t,
    );
    fn S_StopSound(origin: *mut libc::c_void);
    fn S_CalculateSoundDistance(
        px1: fixed_t,
        py1: fixed_t,
        pz1: fixed_t,
        px2: fixed_t,
        py2: fixed_t,
        pz2: fixed_t,
    ) -> fixed_t;
    fn Z_Free(ptr: *mut libc::c_void);
    fn Z_MallocAlign(
        size: size_t,
        tag: int32_t,
        user: *mut libc::c_void,
        alignbits: int32_t,
    ) -> *mut libc::c_void;
    fn Z_CallocAlign(
        size: size_t,
        tag: int32_t,
        user: *mut libc::c_void,
        alignbits: int32_t,
    ) -> *mut libc::c_void;
    fn M_RandomByte() -> uint8_t;
    fn M_RandomKey(a: int32_t) -> int32_t;
    fn M_RandomRange(a: int32_t, b: int32_t) -> int32_t;
    fn P_RandomFixed() -> fixed_t;
    fn P_RandomByte() -> uint8_t;
    fn P_RandomKey(a: int32_t) -> int32_t;
    fn P_RandomRange(a: int32_t, b: int32_t) -> int32_t;
    fn LUA_HookMobj(_: *mut mobj_t, hook: libc::c_int) -> libc::c_int;
    fn LUA_HookMobjMoveBlocked(
        _: *mut mobj_t,
        _: *mut mobj_t,
        _: *mut line_t,
    ) -> libc::c_int;
    fn LUA_HookMapThingSpawn(_: *mut mobj_t, _: *mut mapthing_t) -> libc::c_int;
    fn B_MoveBlocked(player: *mut player_t);
    fn P_GetSlopeZAt(slope: *const pslope_t, x: fixed_t, y: fixed_t) -> fixed_t;
    fn P_GetSectorFloorZAt(sector: *const sector_t, x: fixed_t, y: fixed_t) -> fixed_t;
    fn P_GetSectorCeilingZAt(sector: *const sector_t, x: fixed_t, y: fixed_t) -> fixed_t;
    fn P_GetFFloorTopZAt(ffloor: *const ffloor_t, x: fixed_t, y: fixed_t) -> fixed_t;
    fn P_GetFFloorBottomZAt(ffloor: *const ffloor_t, x: fixed_t, y: fixed_t) -> fixed_t;
    fn P_QuantizeMomentumToSlope(momentum: *mut vector3_t, slope: *mut pslope_t);
    fn P_ReverseQuantizeMomentumToSlope(momentum: *mut vector3_t, slope: *mut pslope_t);
    fn P_SlopeLaunch(mo: *mut mobj_t);
    fn P_GetWallTransferMomZ(mo: *mut mobj_t, slope: *mut pslope_t) -> fixed_t;
    fn P_HandleSlopeLanding(thing: *mut mobj_t, slope: *mut pslope_t);
    fn P_ButteredSlope(mo: *mut mobj_t);
}
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type int8_t = __int8_t;
pub type int16_t = __int16_t;
pub type int32_t = __int32_t;
pub type int64_t = __int64_t;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type size_t = libc::c_ulong;
pub type boolean = int32_t;
pub type C2RustUnnamed = libc::c_uint;
pub const true_0: C2RustUnnamed = 1;
pub const false_0: C2RustUnnamed = 0;
pub type postimg_t = libc::c_uint;
pub const postimg_heat: postimg_t = 4;
pub const postimg_flip: postimg_t = 3;
pub const postimg_motion: postimg_t = 2;
pub const postimg_water: postimg_t = 1;
pub const postimg_none: postimg_t = 0;
pub type lumpnum_t = uint32_t;
pub type tic_t = uint32_t;
pub type fixed_t = int32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vector2_t {
    pub x: fixed_t,
    pub y: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vector3_t {
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vector4_t {
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub a: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct matrix_t {
    pub m: [fixed_t; 16],
}
pub type skincolornum_t = libc::c_uint;
pub const NUMSUPERCOLORS: skincolornum_t = 9;
pub const MAXSKINCOLORS: skincolornum_t = 1182;
pub const SKINCOLOR_LASTFREESLOT: skincolornum_t = 1181;
pub const SKINCOLOR_FIRSTFREESLOT: skincolornum_t = 158;
pub const SKINCOLOR_SUPERTAN5: skincolornum_t = 157;
pub const SKINCOLOR_SUPERTAN4: skincolornum_t = 156;
pub const SKINCOLOR_SUPERTAN3: skincolornum_t = 155;
pub const SKINCOLOR_SUPERTAN2: skincolornum_t = 154;
pub const SKINCOLOR_SUPERTAN1: skincolornum_t = 153;
pub const SKINCOLOR_SUPERRUST5: skincolornum_t = 152;
pub const SKINCOLOR_SUPERRUST4: skincolornum_t = 151;
pub const SKINCOLOR_SUPERRUST3: skincolornum_t = 150;
pub const SKINCOLOR_SUPERRUST2: skincolornum_t = 149;
pub const SKINCOLOR_SUPERRUST1: skincolornum_t = 148;
pub const SKINCOLOR_SUPERPURPLE5: skincolornum_t = 147;
pub const SKINCOLOR_SUPERPURPLE4: skincolornum_t = 146;
pub const SKINCOLOR_SUPERPURPLE3: skincolornum_t = 145;
pub const SKINCOLOR_SUPERPURPLE2: skincolornum_t = 144;
pub const SKINCOLOR_SUPERPURPLE1: skincolornum_t = 143;
pub const SKINCOLOR_SUPERSKY5: skincolornum_t = 142;
pub const SKINCOLOR_SUPERSKY4: skincolornum_t = 141;
pub const SKINCOLOR_SUPERSKY3: skincolornum_t = 140;
pub const SKINCOLOR_SUPERSKY2: skincolornum_t = 139;
pub const SKINCOLOR_SUPERSKY1: skincolornum_t = 138;
pub const SKINCOLOR_SUPERPERIDOT5: skincolornum_t = 137;
pub const SKINCOLOR_SUPERPERIDOT4: skincolornum_t = 136;
pub const SKINCOLOR_SUPERPERIDOT3: skincolornum_t = 135;
pub const SKINCOLOR_SUPERPERIDOT2: skincolornum_t = 134;
pub const SKINCOLOR_SUPERPERIDOT1: skincolornum_t = 133;
pub const SKINCOLOR_SUPERGOLD5: skincolornum_t = 132;
pub const SKINCOLOR_SUPERGOLD4: skincolornum_t = 131;
pub const SKINCOLOR_SUPERGOLD3: skincolornum_t = 130;
pub const SKINCOLOR_SUPERGOLD2: skincolornum_t = 129;
pub const SKINCOLOR_SUPERGOLD1: skincolornum_t = 128;
pub const SKINCOLOR_SUPERORANGE5: skincolornum_t = 127;
pub const SKINCOLOR_SUPERORANGE4: skincolornum_t = 126;
pub const SKINCOLOR_SUPERORANGE3: skincolornum_t = 125;
pub const SKINCOLOR_SUPERORANGE2: skincolornum_t = 124;
pub const SKINCOLOR_SUPERORANGE1: skincolornum_t = 123;
pub const SKINCOLOR_SUPERRED5: skincolornum_t = 122;
pub const SKINCOLOR_SUPERRED4: skincolornum_t = 121;
pub const SKINCOLOR_SUPERRED3: skincolornum_t = 120;
pub const SKINCOLOR_SUPERRED2: skincolornum_t = 119;
pub const SKINCOLOR_SUPERRED1: skincolornum_t = 118;
pub const SKINCOLOR_SUPERSILVER5: skincolornum_t = 117;
pub const SKINCOLOR_SUPERSILVER4: skincolornum_t = 116;
pub const SKINCOLOR_SUPERSILVER3: skincolornum_t = 115;
pub const SKINCOLOR_SUPERSILVER2: skincolornum_t = 114;
pub const SKINCOLOR_SUPERSILVER1: skincolornum_t = 113;
pub const FIRSTSUPERCOLOR: skincolornum_t = 113;
pub const SKINCOLOR_VOLCANIC: skincolornum_t = 112;
pub const SKINCOLOR_SANGRIA: skincolornum_t = 111;
pub const SKINCOLOR_FANCY: skincolornum_t = 110;
pub const SKINCOLOR_ROSY: skincolornum_t = 109;
pub const SKINCOLOR_TAFFY: skincolornum_t = 108;
pub const SKINCOLOR_RASPBERRY: skincolornum_t = 107;
pub const SKINCOLOR_PLUM: skincolornum_t = 106;
pub const SKINCOLOR_EVENTIDE: skincolornum_t = 105;
pub const SKINCOLOR_MAUVE: skincolornum_t = 104;
pub const SKINCOLOR_LILAC: skincolornum_t = 103;
pub const SKINCOLOR_ROYAL: skincolornum_t = 102;
pub const SKINCOLOR_VIOLET: skincolornum_t = 101;
pub const SKINCOLOR_NEON: skincolornum_t = 100;
pub const SKINCOLOR_MAGENTA: skincolornum_t = 99;
pub const SKINCOLOR_SIBERITE: skincolornum_t = 98;
pub const SKINCOLOR_BUBBLEGUM: skincolornum_t = 97;
pub const SKINCOLOR_FUCHSIA: skincolornum_t = 96;
pub const SKINCOLOR_NOBLE: skincolornum_t = 95;
pub const SKINCOLOR_PURPLE: skincolornum_t = 94;
pub const SKINCOLOR_PASTEL: skincolornum_t = 93;
pub const SKINCOLOR_MAJESTY: skincolornum_t = 92;
pub const SKINCOLOR_DUSK: skincolornum_t = 91;
pub const SKINCOLOR_VAPOR: skincolornum_t = 90;
pub const SKINCOLOR_GALAXY: skincolornum_t = 89;
pub const SKINCOLOR_MIDNIGHT: skincolornum_t = 88;
pub const SKINCOLOR_COBALT: skincolornum_t = 87;
pub const SKINCOLOR_BLUE: skincolornum_t = 86;
pub const SKINCOLOR_CORNFLOWER: skincolornum_t = 85;
pub const SKINCOLOR_ARCTIC: skincolornum_t = 84;
pub const SKINCOLOR_SAPPHIRE: skincolornum_t = 83;
pub const SKINCOLOR_DAYBREAK: skincolornum_t = 82;
pub const SKINCOLOR_ICY: skincolornum_t = 81;
pub const SKINCOLOR_DREAM: skincolornum_t = 80;
pub const SKINCOLOR_CERULEAN: skincolornum_t = 79;
pub const SKINCOLOR_MARINE: skincolornum_t = 78;
pub const SKINCOLOR_SKY: skincolornum_t = 77;
pub const SKINCOLOR_AQUAMARINE: skincolornum_t = 76;
pub const SKINCOLOR_TURQUOISE: skincolornum_t = 75;
pub const SKINCOLOR_CYAN: skincolornum_t = 74;
pub const SKINCOLOR_WAVE: skincolornum_t = 73;
pub const SKINCOLOR_OCEAN: skincolornum_t = 72;
pub const SKINCOLOR_TEAL: skincolornum_t = 71;
pub const SKINCOLOR_AQUA: skincolornum_t = 70;
pub const SKINCOLOR_BOTTLE: skincolornum_t = 69;
pub const SKINCOLOR_ISLAND: skincolornum_t = 68;
pub const SKINCOLOR_SEAFOAM: skincolornum_t = 67;
pub const SKINCOLOR_EMERALD: skincolornum_t = 66;
pub const SKINCOLOR_MASTER: skincolornum_t = 65;
pub const SKINCOLOR_MINT: skincolornum_t = 64;
pub const SKINCOLOR_JADE: skincolornum_t = 63;
pub const SKINCOLOR_SHAMROCK: skincolornum_t = 62;
pub const SKINCOLOR_FOREST: skincolornum_t = 61;
pub const SKINCOLOR_GREEN: skincolornum_t = 60;
pub const SKINCOLOR_CHARTREUSE: skincolornum_t = 59;
pub const SKINCOLOR_HEADLIGHT: skincolornum_t = 58;
pub const SKINCOLOR_APPLE: skincolornum_t = 57;
pub const SKINCOLOR_PERIDOT: skincolornum_t = 56;
pub const SKINCOLOR_LIME: skincolornum_t = 55;
pub const SKINCOLOR_LEMON: skincolornum_t = 54;
pub const SKINCOLOR_PEAR: skincolornum_t = 53;
pub const SKINCOLOR_OLIVE: skincolornum_t = 52;
pub const SKINCOLOR_YELLOW: skincolornum_t = 51;
pub const SKINCOLOR_GOLDENROD: skincolornum_t = 50;
pub const SKINCOLOR_SANDY: skincolornum_t = 49;
pub const SKINCOLOR_GOLD: skincolornum_t = 48;
pub const SKINCOLOR_TOPAZ: skincolornum_t = 47;
pub const SKINCOLOR_TANGERINE: skincolornum_t = 46;
pub const SKINCOLOR_RUST: skincolornum_t = 45;
pub const SKINCOLOR_ORANGE: skincolornum_t = 44;
pub const SKINCOLOR_APRICOT: skincolornum_t = 43;
pub const SKINCOLOR_COPPER: skincolornum_t = 42;
pub const SKINCOLOR_SUNSET: skincolornum_t = 41;
pub const SKINCOLOR_FOUNDATION: skincolornum_t = 40;
pub const SKINCOLOR_QUAIL: skincolornum_t = 39;
pub const SKINCOLOR_PEACHY: skincolornum_t = 38;
pub const SKINCOLOR_KETCHUP: skincolornum_t = 37;
pub const SKINCOLOR_GARNET: skincolornum_t = 36;
pub const SKINCOLOR_FLAME: skincolornum_t = 35;
pub const SKINCOLOR_CRIMSON: skincolornum_t = 34;
pub const SKINCOLOR_RED: skincolornum_t = 33;
pub const SKINCOLOR_PEPPER: skincolornum_t = 32;
pub const SKINCOLOR_SALMON: skincolornum_t = 31;
pub const SKINCOLOR_CHERRY: skincolornum_t = 30;
pub const SKINCOLOR_RUBY: skincolornum_t = 29;
pub const SKINCOLOR_LAVENDER: skincolornum_t = 28;
pub const SKINCOLOR_EGGPLANT: skincolornum_t = 27;
pub const SKINCOLOR_AZURE: skincolornum_t = 26;
pub const SKINCOLOR_MOSS: skincolornum_t = 25;
pub const SKINCOLOR_ROSEBUSH: skincolornum_t = 24;
pub const SKINCOLOR_BEIGE: skincolornum_t = 23;
pub const SKINCOLOR_TAN: skincolornum_t = 22;
pub const SKINCOLOR_ECRU: skincolornum_t = 21;
pub const SKINCOLOR_SEPIA: skincolornum_t = 20;
pub const SKINCOLOR_BRONZE: skincolornum_t = 19;
pub const SKINCOLOR_BOULDER: skincolornum_t = 18;
pub const SKINCOLOR_BROWN: skincolornum_t = 17;
pub const SKINCOLOR_LATTE: skincolornum_t = 16;
pub const SKINCOLOR_YOGURT: skincolornum_t = 15;
pub const SKINCOLOR_ROSEWOOD: skincolornum_t = 14;
pub const SKINCOLOR_PINK: skincolornum_t = 13;
pub const SKINCOLOR_BLUEBELL: skincolornum_t = 12;
pub const SKINCOLOR_MOONSTONE: skincolornum_t = 11;
pub const SKINCOLOR_SLATE: skincolornum_t = 10;
pub const SKINCOLOR_AETHER: skincolornum_t = 9;
pub const SKINCOLOR_BLACK: skincolornum_t = 8;
pub const SKINCOLOR_JET: skincolornum_t = 7;
pub const SKINCOLOR_CARBON: skincolornum_t = 6;
pub const SKINCOLOR_SILVER: skincolornum_t = 5;
pub const SKINCOLOR_GREY: skincolornum_t = 4;
pub const SKINCOLOR_CLOUDY: skincolornum_t = 3;
pub const SKINCOLOR_BONE: skincolornum_t = 2;
pub const SKINCOLOR_WHITE: skincolornum_t = 1;
pub const SKINCOLOR_NONE: skincolornum_t = 0;
pub type alerttype_t = libc::c_uint;
pub const CONS_ERROR: alerttype_t = 2;
pub const CONS_WARNING: alerttype_t = 1;
pub const CONS_NOTICE: alerttype_t = 0;
pub type mtag_t = int16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct taglist_t {
    pub tags: *mut mtag_t,
    pub count: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mapthing_t {
    pub x: int16_t,
    pub y: int16_t,
    pub angle: int16_t,
    pub pitch: int16_t,
    pub roll: int16_t,
    pub type_0: uint16_t,
    pub options: uint16_t,
    pub z: int16_t,
    pub extrainfo: uint8_t,
    pub tags: taglist_t,
    pub scale: fixed_t,
    pub spritexscale: fixed_t,
    pub spriteyscale: fixed_t,
    pub args: [int32_t; 10],
    pub stringargs: [*mut libc::c_char; 2],
    pub mobj: *mut mobj_s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mobj_s {
    pub thinker: thinker_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub old_x: fixed_t,
    pub old_y: fixed_t,
    pub old_z: fixed_t,
    pub old_x2: fixed_t,
    pub old_y2: fixed_t,
    pub old_z2: fixed_t,
    pub snext: *mut mobj_s,
    pub sprev: *mut *mut mobj_s,
    pub angle: angle_t,
    pub pitch: angle_t,
    pub roll: angle_t,
    pub old_angle: angle_t,
    pub old_pitch: angle_t,
    pub old_roll: angle_t,
    pub old_angle2: angle_t,
    pub old_pitch2: angle_t,
    pub old_roll2: angle_t,
    pub spriteroll: angle_t,
    pub old_spriteroll: angle_t,
    pub old_spriteroll2: angle_t,
    pub sprite: spritenum_t,
    pub frame: uint32_t,
    pub sprite2: uint8_t,
    pub anim_duration: uint16_t,
    pub renderflags: uint32_t,
    pub blendmode: int32_t,
    pub spritexscale: fixed_t,
    pub spriteyscale: fixed_t,
    pub spritexoffset: fixed_t,
    pub spriteyoffset: fixed_t,
    pub old_spritexscale: fixed_t,
    pub old_spriteyscale: fixed_t,
    pub old_spritexoffset: fixed_t,
    pub old_spriteyoffset: fixed_t,
    pub floorspriteslope: *mut pslope_s,
    pub touching_sectorlist: *mut msecnode_s,
    pub subsector: *mut subsector_s,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
    pub floorrover: *mut ffloor_s,
    pub ceilingrover: *mut ffloor_s,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub momx: fixed_t,
    pub momy: fixed_t,
    pub momz: fixed_t,
    pub pmomz: fixed_t,
    pub tics: int32_t,
    pub state: *mut state_t,
    pub flags: uint32_t,
    pub flags2: uint32_t,
    pub eflags: uint16_t,
    pub skin: *mut libc::c_void,
    pub color: uint16_t,
    pub drawonlyforplayer: *mut player_s,
    pub dontdrawforviewmobj: *mut mobj_s,
    pub bnext: *mut mobj_s,
    pub bprev: *mut *mut mobj_s,
    pub hnext: *mut mobj_s,
    pub hprev: *mut mobj_s,
    pub type_0: mobjtype_t,
    pub info: *const mobjinfo_t,
    pub health: int32_t,
    pub movedir: angle_t,
    pub movecount: int32_t,
    pub target: *mut mobj_s,
    pub reactiontime: int32_t,
    pub threshold: int32_t,
    pub player: *mut player_s,
    pub lastlook: int32_t,
    pub spawnpoint: *mut mapthing_t,
    pub tracer: *mut mobj_s,
    pub friction: fixed_t,
    pub movefactor: fixed_t,
    pub fuse: int32_t,
    pub watertop: fixed_t,
    pub waterbottom: fixed_t,
    pub mobjnum: uint32_t,
    pub scale: fixed_t,
    pub old_scale: fixed_t,
    pub old_scale2: fixed_t,
    pub destscale: fixed_t,
    pub scalespeed: fixed_t,
    pub extravalue1: int32_t,
    pub extravalue2: int32_t,
    pub cusval: int32_t,
    pub cvmem: int32_t,
    pub standingslope: *mut pslope_s,
    pub resetinterp: boolean,
    pub colorized: boolean,
    pub mirrored: boolean,
    pub shadowscale: fixed_t,
    pub dispoffset: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct pslope_s {
    pub id: uint16_t,
    pub next: *mut pslope_s,
    pub o: vector3_t,
    pub normal: vector3_t,
    pub d: vector2_t,
    pub zdelta: fixed_t,
    pub zangle: angle_t,
    pub xydirection: angle_t,
    pub flags: uint8_t,
}
pub type angle_t = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct player_s {
    pub mo: *mut mobj_t,
    pub cmd: ticcmd_t,
    pub playerstate: playerstate_t,
    pub camerascale: fixed_t,
    pub shieldscale: fixed_t,
    pub viewz: fixed_t,
    pub viewheight: fixed_t,
    pub deltaviewheight: fixed_t,
    pub bob: fixed_t,
    pub viewrollangle: angle_t,
    pub angleturn: int16_t,
    pub oldrelangleturn: int16_t,
    pub aiming: angle_t,
    pub drawangle: angle_t,
    pub old_drawangle: angle_t,
    pub old_drawangle2: angle_t,
    pub rings: int16_t,
    pub spheres: int16_t,
    pub pity: int8_t,
    pub currentweapon: int32_t,
    pub ringweapons: int32_t,
    pub ammoremoval: uint16_t,
    pub ammoremovaltimer: tic_t,
    pub ammoremovalweapon: int32_t,
    pub powers: [uint16_t; 30],
    pub pflags: pflags_t,
    pub panim: panim_t,
    pub stronganim: uint8_t,
    pub flashcount: uint16_t,
    pub flashpal: uint16_t,
    pub skincolor: uint16_t,
    pub skin: int32_t,
    pub availabilities: uint32_t,
    pub score: uint32_t,
    pub recordscore: uint32_t,
    pub dashspeed: fixed_t,
    pub normalspeed: fixed_t,
    pub runspeed: fixed_t,
    pub thrustfactor: uint8_t,
    pub accelstart: uint8_t,
    pub acceleration: uint8_t,
    pub charability: uint8_t,
    pub charability2: uint8_t,
    pub charflags: uint32_t,
    pub thokitem: mobjtype_t,
    pub spinitem: mobjtype_t,
    pub revitem: mobjtype_t,
    pub followitem: mobjtype_t,
    pub followmobj: *mut mobj_t,
    pub actionspd: fixed_t,
    pub mindash: fixed_t,
    pub maxdash: fixed_t,
    pub jumpfactor: fixed_t,
    pub height: fixed_t,
    pub spinheight: fixed_t,
    pub lives: int8_t,
    pub continues: int8_t,
    pub xtralife: int8_t,
    pub gotcontinue: uint8_t,
    pub speed: fixed_t,
    pub secondjump: uint8_t,
    pub fly1: uint8_t,
    pub scoreadd: uint8_t,
    pub glidetime: tic_t,
    pub climbing: uint8_t,
    pub deadtimer: int32_t,
    pub exiting: tic_t,
    pub homing: uint8_t,
    pub dashmode: tic_t,
    pub skidtime: tic_t,
    pub cmomx: fixed_t,
    pub cmomy: fixed_t,
    pub rmomx: fixed_t,
    pub rmomy: fixed_t,
    pub numboxes: int16_t,
    pub totalring: int16_t,
    pub realtime: tic_t,
    pub laps: uint8_t,
    pub ctfteam: int32_t,
    pub gotflag: uint16_t,
    pub weapondelay: int32_t,
    pub tossdelay: int32_t,
    pub starpostx: int16_t,
    pub starposty: int16_t,
    pub starpostz: int16_t,
    pub starpostnum: int32_t,
    pub starposttime: tic_t,
    pub starpostangle: angle_t,
    pub starpostscale: fixed_t,
    pub angle_pos: angle_t,
    pub old_angle_pos: angle_t,
    pub axis1: *mut mobj_t,
    pub axis2: *mut mobj_t,
    pub bumpertime: tic_t,
    pub flyangle: int32_t,
    pub drilltimer: tic_t,
    pub linkcount: int32_t,
    pub linktimer: tic_t,
    pub anotherflyangle: int32_t,
    pub nightstime: tic_t,
    pub drillmeter: int32_t,
    pub drilldelay: uint8_t,
    pub bonustime: boolean,
    pub capsule: *mut mobj_t,
    pub drone: *mut mobj_t,
    pub oldscale: fixed_t,
    pub mare: uint8_t,
    pub marelap: uint8_t,
    pub marebonuslap: uint8_t,
    pub marebegunat: tic_t,
    pub startedtime: tic_t,
    pub finishedtime: tic_t,
    pub lapbegunat: tic_t,
    pub lapstartedtime: tic_t,
    pub finishedspheres: int16_t,
    pub finishedrings: int16_t,
    pub marescore: uint32_t,
    pub lastmarescore: uint32_t,
    pub totalmarescore: uint32_t,
    pub lastmare: uint8_t,
    pub lastmarelap: uint8_t,
    pub lastmarebonuslap: uint8_t,
    pub totalmarelap: uint8_t,
    pub totalmarebonuslap: uint8_t,
    pub maxlink: int32_t,
    pub texttimer: uint8_t,
    pub textvar: uint8_t,
    pub lastsidehit: int16_t,
    pub lastlinehit: int16_t,
    pub losstime: tic_t,
    pub timeshit: uint8_t,
    pub onconveyor: int32_t,
    pub awayviewmobj: *mut mobj_t,
    pub awayviewtics: int32_t,
    pub awayviewaiming: angle_t,
    pub spectator: boolean,
    pub outofcoop: boolean,
    pub removing: boolean,
    pub bot: uint8_t,
    pub botleader: *mut player_s,
    pub lastbuttons: uint16_t,
    pub botmem: botmem_t,
    pub blocked: boolean,
    pub jointime: tic_t,
    pub quittime: tic_t,
}
pub type botmem_t = botmem_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct botmem_s {
    pub lastForward: boolean,
    pub lastBlocked: boolean,
    pub blocked: boolean,
    pub catchup_tics: uint8_t,
    pub thinkstate: uint8_t,
}
pub type mobj_t = mobj_s;
pub type mobjtype_t = mobj_type;
pub type mobj_type = libc::c_uint;
pub const NUMMOBJTYPES: mobj_type = 1163;
pub const MT_LASTFREESLOT: mobj_type = 1162;
pub const MT_FIRSTFREESLOT: mobj_type = 651;
pub const MT_RAY: mobj_type = 650;
pub const MT_NAMECHECK: mobj_type = 649;
pub const MT_YELLOWBRICKDEBRIS: mobj_type = 648;
pub const MT_BLUEBRICKDEBRIS: mobj_type = 647;
pub const MT_REDBRICKDEBRIS: mobj_type = 646;
pub const MT_WOODDEBRIS: mobj_type = 645;
pub const MT_BRICKDEBRIS: mobj_type = 644;
pub const MT_GFZDEBRIS: mobj_type = 643;
pub const MT_ROCKCRUMBLE16: mobj_type = 642;
pub const MT_ROCKCRUMBLE15: mobj_type = 641;
pub const MT_ROCKCRUMBLE14: mobj_type = 640;
pub const MT_ROCKCRUMBLE13: mobj_type = 639;
pub const MT_ROCKCRUMBLE12: mobj_type = 638;
pub const MT_ROCKCRUMBLE11: mobj_type = 637;
pub const MT_ROCKCRUMBLE10: mobj_type = 636;
pub const MT_ROCKCRUMBLE9: mobj_type = 635;
pub const MT_ROCKCRUMBLE8: mobj_type = 634;
pub const MT_ROCKCRUMBLE7: mobj_type = 633;
pub const MT_ROCKCRUMBLE6: mobj_type = 632;
pub const MT_ROCKCRUMBLE5: mobj_type = 631;
pub const MT_ROCKCRUMBLE4: mobj_type = 630;
pub const MT_ROCKCRUMBLE3: mobj_type = 629;
pub const MT_ROCKCRUMBLE2: mobj_type = 628;
pub const MT_ROCKCRUMBLE1: mobj_type = 627;
pub const MT_FALLINGROCK: mobj_type = 626;
pub const MT_ROCKSPAWNER: mobj_type = 625;
pub const MT_DUST: mobj_type = 624;
pub const MT_UWEXPLODE: mobj_type = 623;
pub const MT_EXPLODE: mobj_type = 622;
pub const MT_SPARK: mobj_type = 621;
pub const MT_SKYBOX: mobj_type = 620;
pub const MT_POLYSPAWN: mobj_type = 619;
pub const MT_POLYANCHOR: mobj_type = 618;
pub const MT_ANGLEMAN: mobj_type = 617;
pub const MT_OVERLAY: mobj_type = 616;
pub const MT_GHOST: mobj_type = 615;
pub const MT_PUSH: mobj_type = 614;
pub const MT_TUBEWAYPOINT: mobj_type = 613;
pub const MT_CRUMBLEOBJ: mobj_type = 612;
pub const MT_ALTVIEWMAN: mobj_type = 611;
pub const MT_TELEPORTMAN: mobj_type = 610;
pub const MT_HANGSTER: mobj_type = 609;
pub const MT_SPINBOBERT_FIRE2: mobj_type = 608;
pub const MT_SPINBOBERT_FIRE1: mobj_type = 607;
pub const MT_SPINBOBERT: mobj_type = 606;
pub const MT_CACOFIRE: mobj_type = 605;
pub const MT_CACOSHARD: mobj_type = 604;
pub const MT_CACOLANTERN: mobj_type = 603;
pub const MT_SMASHINGSPIKEBALL: mobj_type = 602;
pub const MT_BUGGLE: mobj_type = 601;
pub const MT_BUMBLEBORE: mobj_type = 600;
pub const MT_HIVEELEMENTAL: mobj_type = 599;
pub const MT_POPSHOT_TRAIL: mobj_type = 598;
pub const MT_POPSHOT: mobj_type = 597;
pub const MT_POPHAT: mobj_type = 596;
pub const MT_PENGUINATOR: mobj_type = 595;
pub const MT_SHLEEP: mobj_type = 594;
pub const MT_PIAN: mobj_type = 593;
pub const MT_NIGHTOPIANHELPER: mobj_type = 592;
pub const MT_IDEYAANCHOR: mobj_type = 591;
pub const MT_EGGCAPSULE: mobj_type = 590;
pub const MT_NIGHTSLINKFREEZE: mobj_type = 589;
pub const MT_NIGHTSEXTRATIME: mobj_type = 588;
pub const MT_NIGHTSHELPER: mobj_type = 587;
pub const MT_NIGHTSDRILLREFILL: mobj_type = 586;
pub const MT_NIGHTSSUPERLOOP: mobj_type = 585;
pub const MT_FLINGNIGHTSSTAR: mobj_type = 584;
pub const MT_NIGHTSSTAR: mobj_type = 583;
pub const MT_FLINGNIGHTSCHIP: mobj_type = 582;
pub const MT_NIGHTSCHIP: mobj_type = 581;
pub const MT_NIGHTSCORE: mobj_type = 580;
pub const MT_HOOPCENTER: mobj_type = 579;
pub const MT_HOOPCOLLIDE: mobj_type = 578;
pub const MT_HOOP: mobj_type = 577;
pub const MT_NIGHTSBUMPER: mobj_type = 576;
pub const MT_NIGHTSLOOPHELPER: mobj_type = 575;
pub const MT_NIGHTSPARKLE: mobj_type = 574;
pub const MT_NIGHTSDRONE_GOAL: mobj_type = 573;
pub const MT_NIGHTSDRONE_SPARKLING: mobj_type = 572;
pub const MT_NIGHTSDRONE_MAN: mobj_type = 571;
pub const MT_NIGHTSDRONE: mobj_type = 570;
pub const MT_AXISTRANSFERLINE: mobj_type = 569;
pub const MT_AXISTRANSFER: mobj_type = 568;
pub const MT_AXIS: mobj_type = 567;
pub const MT_TOAD: mobj_type = 566;
pub const MT_MARIOBUSH2: mobj_type = 565;
pub const MT_MARIOBUSH1: mobj_type = 564;
pub const MT_AXE: mobj_type = 563;
pub const MT_KOOPAFLAME: mobj_type = 562;
pub const MT_KOOPA: mobj_type = 561;
pub const MT_HAMMER: mobj_type = 560;
pub const MT_PUMATRAIL: mobj_type = 559;
pub const MT_PUMA: mobj_type = 558;
pub const MT_SHELL: mobj_type = 557;
pub const MT_FIREBALLTRAIL: mobj_type = 556;
pub const MT_FIREBALL: mobj_type = 555;
pub const MT_FIREFLOWER: mobj_type = 554;
pub const MT_BLUEGOOMBA: mobj_type = 553;
pub const MT_GOOMBA: mobj_type = 552;
pub const MT_FLINGCOIN: mobj_type = 551;
pub const MT_COIN: mobj_type = 550;
pub const MT_THROWNGRENADE: mobj_type = 549;
pub const MT_THROWNEXPLOSION: mobj_type = 548;
pub const MT_THROWNSCATTER: mobj_type = 547;
pub const MT_THROWNAUTOMATIC: mobj_type = 546;
pub const MT_THROWNINFINITY: mobj_type = 545;
pub const MT_THROWNBOUNCE: mobj_type = 544;
pub const MT_GRENADEPICKUP: mobj_type = 543;
pub const MT_SCATTERPICKUP: mobj_type = 542;
pub const MT_EXPLODEPICKUP: mobj_type = 541;
pub const MT_AUTOPICKUP: mobj_type = 540;
pub const MT_RAILPICKUP: mobj_type = 539;
pub const MT_BOUNCEPICKUP: mobj_type = 538;
pub const MT_GRENADERING: mobj_type = 537;
pub const MT_SCATTERRING: mobj_type = 536;
pub const MT_EXPLOSIONRING: mobj_type = 535;
pub const MT_AUTOMATICRING: mobj_type = 534;
pub const MT_INFINITYRING: mobj_type = 533;
pub const MT_RAILRING: mobj_type = 532;
pub const MT_BOUNCERING: mobj_type = 531;
pub const MT_REDRING: mobj_type = 530;
pub const MT_LHRT: mobj_type = 529;
pub const MT_CORK: mobj_type = 528;
pub const MT_AMBIENT: mobj_type = 527;
pub const MT_FINISHFLAG: mobj_type = 526;
pub const MT_GOTFLAG: mobj_type = 525;
pub const MT_TAG: mobj_type = 524;
pub const MT_LOCKONINF: mobj_type = 523;
pub const MT_LOCKON: mobj_type = 522;
pub const MT_GOTEMERALD: mobj_type = 521;
pub const MT_DROWNNUMBERS: mobj_type = 520;
pub const MT_SCORE: mobj_type = 519;
pub const MT_PARTICLEGEN: mobj_type = 518;
pub const MT_PARTICLE: mobj_type = 517;
pub const MT_TFOG: mobj_type = 516;
pub const MT_SPINDUST: mobj_type = 515;
pub const MT_WATERZAP: mobj_type = 514;
pub const MT_EXTRALARGEBUBBLE: mobj_type = 513;
pub const MT_MEDIUMBUBBLE: mobj_type = 512;
pub const MT_SMALLBUBBLE: mobj_type = 511;
pub const MT_SMOKE: mobj_type = 510;
pub const MT_LAVASPLISH: mobj_type = 509;
pub const MT_SPLISH: mobj_type = 508;
pub const MT_SNOWFLAKE: mobj_type = 507;
pub const MT_RAIN: mobj_type = 506;
pub const MT_SEED: mobj_type = 505;
pub const MT_SECRETFLICKY_02_CENTER: mobj_type = 504;
pub const MT_SECRETFLICKY_02: mobj_type = 503;
pub const MT_SECRETFLICKY_01_CENTER: mobj_type = 502;
pub const MT_SECRETFLICKY_01: mobj_type = 501;
pub const MT_FLICKY_16_CENTER: mobj_type = 500;
pub const MT_FLICKY_16: mobj_type = 499;
pub const MT_FLICKY_15_CENTER: mobj_type = 498;
pub const MT_FLICKY_15: mobj_type = 497;
pub const MT_FLICKY_14_CENTER: mobj_type = 496;
pub const MT_FLICKY_14: mobj_type = 495;
pub const MT_FLICKY_13_CENTER: mobj_type = 494;
pub const MT_FLICKY_13: mobj_type = 493;
pub const MT_FLICKY_12_CENTER: mobj_type = 492;
pub const MT_FLICKY_12: mobj_type = 491;
pub const MT_FLICKY_11_CENTER: mobj_type = 490;
pub const MT_FLICKY_11: mobj_type = 489;
pub const MT_FLICKY_10_CENTER: mobj_type = 488;
pub const MT_FLICKY_10: mobj_type = 487;
pub const MT_FLICKY_09_CENTER: mobj_type = 486;
pub const MT_FLICKY_09: mobj_type = 485;
pub const MT_FLICKY_08_CENTER: mobj_type = 484;
pub const MT_FLICKY_08: mobj_type = 483;
pub const MT_FLICKY_07_CENTER: mobj_type = 482;
pub const MT_FLICKY_07: mobj_type = 481;
pub const MT_FLICKY_06_CENTER: mobj_type = 480;
pub const MT_FLICKY_06: mobj_type = 479;
pub const MT_FLICKY_05_CENTER: mobj_type = 478;
pub const MT_FLICKY_05: mobj_type = 477;
pub const MT_FLICKY_04_CENTER: mobj_type = 476;
pub const MT_FLICKY_04: mobj_type = 475;
pub const MT_FLICKY_03_CENTER: mobj_type = 474;
pub const MT_FLICKY_03: mobj_type = 473;
pub const MT_FLICKY_02_CENTER: mobj_type = 472;
pub const MT_FLICKY_02: mobj_type = 471;
pub const MT_FLICKY_01_CENTER: mobj_type = 470;
pub const MT_FLICKY_01: mobj_type = 469;
pub const MT_SUPERSPARK: mobj_type = 468;
pub const MT_IVSP: mobj_type = 467;
pub const MT_THUNDERCOIN_SPARK: mobj_type = 466;
pub const MT_THUNDERCOIN_ORB: mobj_type = 465;
pub const MT_BUBBLEWRAP_ORB: mobj_type = 464;
pub const MT_FLAMEAURA_ORB: mobj_type = 463;
pub const MT_PITY_ORB: mobj_type = 462;
pub const MT_WHIRLWIND_ORB: mobj_type = 461;
pub const MT_ARMAGEDDON_ORB: mobj_type = 460;
pub const MT_FORCE_ORB: mobj_type = 459;
pub const MT_ATTRACT_ORB: mobj_type = 458;
pub const MT_ELEMENTAL_ORB: mobj_type = 457;
pub const MT_EGGSTATUE2: mobj_type = 456;
pub const MT_DBALL: mobj_type = 455;
pub const MT_PALMTREE_TOP: mobj_type = 454;
pub const MT_PALMTREE_TRUNK: mobj_type = 453;
pub const MT_BIG_PALMTREE_TOP: mobj_type = 452;
pub const MT_BIG_PALMTREE_TRUNK: mobj_type = 451;
pub const MT_BSZCLOVER: mobj_type = 450;
pub const MT_BSZSHRUB: mobj_type = 449;
pub const MT_BSZVINE_ORANGE: mobj_type = 448;
pub const MT_BSZVINE_YELLOW: mobj_type = 447;
pub const MT_BSZVINE_CYAN: mobj_type = 446;
pub const MT_BSZVINE_BLUE: mobj_type = 445;
pub const MT_BSZVINE_PURPLE: mobj_type = 444;
pub const MT_BSZVINE_RED: mobj_type = 443;
pub const MT_BSZBUSH_ORANGE: mobj_type = 442;
pub const MT_BSZBUSH_YELLOW: mobj_type = 441;
pub const MT_BSZBUSH_CYAN: mobj_type = 440;
pub const MT_BSZBUSH_BLUE: mobj_type = 439;
pub const MT_BSZBUSH_PURPLE: mobj_type = 438;
pub const MT_BSZBUSH_RED: mobj_type = 437;
pub const MT_BSZCLUSTER_ORANGE: mobj_type = 436;
pub const MT_BSZCLUSTER_YELLOW: mobj_type = 435;
pub const MT_BSZCLUSTER_CYAN: mobj_type = 434;
pub const MT_BSZCLUSTER_BLUE: mobj_type = 433;
pub const MT_BSZCLUSTER_PURPLE: mobj_type = 432;
pub const MT_BSZCLUSTER_RED: mobj_type = 431;
pub const MT_BSZTULIP_ORANGE: mobj_type = 430;
pub const MT_BSZTULIP_YELLOW: mobj_type = 429;
pub const MT_BSZTULIP_CYAN: mobj_type = 428;
pub const MT_BSZTULIP_BLUE: mobj_type = 427;
pub const MT_BSZTULIP_PURPLE: mobj_type = 426;
pub const MT_BSZTULIP_RED: mobj_type = 425;
pub const MT_BSZSHORTFLOWER_ORANGE: mobj_type = 424;
pub const MT_BSZSHORTFLOWER_YELLOW: mobj_type = 423;
pub const MT_BSZSHORTFLOWER_CYAN: mobj_type = 422;
pub const MT_BSZSHORTFLOWER_BLUE: mobj_type = 421;
pub const MT_BSZSHORTFLOWER_PURPLE: mobj_type = 420;
pub const MT_BSZSHORTFLOWER_RED: mobj_type = 419;
pub const MT_BSZFLOWER_ORANGE: mobj_type = 418;
pub const MT_BSZFLOWER_YELLOW: mobj_type = 417;
pub const MT_BSZFLOWER_CYAN: mobj_type = 416;
pub const MT_BSZFLOWER_BLUE: mobj_type = 415;
pub const MT_BSZFLOWER_PURPLE: mobj_type = 414;
pub const MT_BSZFLOWER_RED: mobj_type = 413;
pub const MT_BSZTALLFLOWER_ORANGE: mobj_type = 412;
pub const MT_BSZTALLFLOWER_YELLOW: mobj_type = 411;
pub const MT_BSZTALLFLOWER_CYAN: mobj_type = 410;
pub const MT_BSZTALLFLOWER_BLUE: mobj_type = 409;
pub const MT_BSZTALLFLOWER_PURPLE: mobj_type = 408;
pub const MT_BSZTALLFLOWER_RED: mobj_type = 407;
pub const MT_HHZSTALAGMITE_SHORT: mobj_type = 406;
pub const MT_HHZSTALAGMITE_TALL: mobj_type = 405;
pub const MT_HHZTENTACLE2: mobj_type = 404;
pub const MT_HHZTENTACLE1: mobj_type = 403;
pub const MT_HHZGRASS: mobj_type = 402;
pub const MT_HHZSHROOM: mobj_type = 401;
pub const MT_HHZTREE_PART: mobj_type = 400;
pub const MT_HHZTREE_TOP: mobj_type = 399;
pub const MT_JACKO3: mobj_type = 398;
pub const MT_JACKO2: mobj_type = 397;
pub const MT_JACKO1: mobj_type = 396;
pub const MT_CDLHRT: mobj_type = 395;
pub const MT_ROSY: mobj_type = 394;
pub const MT_FHZICE2: mobj_type = 393;
pub const MT_FHZICE1: mobj_type = 392;
pub const MT_XMASBUSH: mobj_type = 391;
pub const MT_XMASBERRYBUSH: mobj_type = 390;
pub const MT_XMASBLUEBERRYBUSH: mobj_type = 389;
pub const MT_MISTLETOE: mobj_type = 388;
pub const MT_HANGSTAR: mobj_type = 387;
pub const MT_LAMPPOST2: mobj_type = 386;
pub const MT_LAMPPOST1: mobj_type = 385;
pub const MT_SNOWMANHAT: mobj_type = 384;
pub const MT_SNOWMAN: mobj_type = 383;
pub const MT_CANDYCANE: mobj_type = 382;
pub const MT_XMASPOLE: mobj_type = 381;
pub const MT_STALAGMITE9: mobj_type = 380;
pub const MT_STALAGMITE8: mobj_type = 379;
pub const MT_STALAGMITE7: mobj_type = 378;
pub const MT_STALAGMITE6: mobj_type = 377;
pub const MT_STALAGMITE5: mobj_type = 376;
pub const MT_STALAGMITE4: mobj_type = 375;
pub const MT_STALAGMITE3: mobj_type = 374;
pub const MT_STALAGMITE2: mobj_type = 373;
pub const MT_STALAGMITE1: mobj_type = 372;
pub const MT_STALAGMITE0: mobj_type = 371;
pub const MT_BLUEGARGOYLE: mobj_type = 370;
pub const MT_GREENFLAME: mobj_type = 369;
pub const MT_TARGET: mobj_type = 368;
pub const MT_GLAREGOYLELONG: mobj_type = 367;
pub const MT_GLAREGOYLEDOWN: mobj_type = 366;
pub const MT_GLAREGOYLEUP: mobj_type = 365;
pub const MT_GLAREGOYLE: mobj_type = 364;
pub const MT_WALLVINE_SHORT: mobj_type = 363;
pub const MT_WALLVINE_LONG: mobj_type = 362;
pub const MT_TORCHFLOWER: mobj_type = 361;
pub const MT_JUNGLEPALM: mobj_type = 360;
pub const MT_BIGFERN: mobj_type = 359;
pub const MT_BIGFERNLEAF: mobj_type = 358;
pub const MT_ROLLOUTROCK: mobj_type = 357;
pub const MT_ROLLOUTSPAWN: mobj_type = 356;
pub const MT_LAVAFALLROCK: mobj_type = 355;
pub const MT_LAVAFALL_LAVA: mobj_type = 354;
pub const MT_LAVAFALL: mobj_type = 353;
pub const MT_FLAMEJETFLAMEB: mobj_type = 352;
pub const MT_FJSPINAXISB: mobj_type = 351;
pub const MT_FJSPINAXISA: mobj_type = 350;
pub const MT_FLAMEJETFLAME: mobj_type = 349;
pub const MT_VERTICALFLAMEJET: mobj_type = 348;
pub const MT_FLAMEJET: mobj_type = 347;
pub const MT_MINECARTSWITCHPOINT: mobj_type = 346;
pub const MT_TRAINSTEAMSPAWNER: mobj_type = 345;
pub const MT_TRAINDUSTSPAWNER: mobj_type = 344;
pub const MT_TRAINSEG: mobj_type = 343;
pub const MT_TRAINCAMEOSPAWNER: mobj_type = 342;
pub const MT_SALOONDOORCENTER: mobj_type = 341;
pub const MT_SALOONDOOR: mobj_type = 340;
pub const MT_MINECARTSPARK: mobj_type = 339;
pub const MT_MINECARTSIDEMARK: mobj_type = 338;
pub const MT_MINECARTENDSOLID: mobj_type = 337;
pub const MT_MINECARTEND: mobj_type = 336;
pub const MT_MINECARTSPAWNER: mobj_type = 335;
pub const MT_MINECARTSEG: mobj_type = 334;
pub const MT_MINECART: mobj_type = 333;
pub const MT_ARIDDUST: mobj_type = 332;
pub const MT_DUSTLAYER: mobj_type = 331;
pub const MT_DUSTDEVIL: mobj_type = 330;
pub const MT_PROXIMITYTNT: mobj_type = 329;
pub const MT_TNTBARREL: mobj_type = 328;
pub const MT_OILLAMP: mobj_type = 327;
pub const MT_ARIDSIGN_SHARPTURN: mobj_type = 326;
pub const MT_ARIDSIGN_CACTI: mobj_type = 325;
pub const MT_ARIDSIGN_CAUTION: mobj_type = 324;
pub const MT_CACTISMALLSEG: mobj_type = 323;
pub const MT_CACTITINYSEG: mobj_type = 322;
pub const MT_CACTI11: mobj_type = 321;
pub const MT_CACTI10: mobj_type = 320;
pub const MT_CACTI9: mobj_type = 319;
pub const MT_CACTI8: mobj_type = 318;
pub const MT_CACTI7: mobj_type = 317;
pub const MT_CACTI6: mobj_type = 316;
pub const MT_CACTI5: mobj_type = 315;
pub const MT_CACTI4: mobj_type = 314;
pub const MT_CACTI3: mobj_type = 313;
pub const MT_CACTI2: mobj_type = 312;
pub const MT_CACTI1: mobj_type = 311;
pub const MT_LITTLETUMBLEWEED: mobj_type = 310;
pub const MT_BIGTUMBLEWEED: mobj_type = 309;
pub const MT_BRAMBLES: mobj_type = 308;
pub const MT_SUSPICIOUSFACESTABBERSTATUE: mobj_type = 307;
pub const MT_FACESTABBERSTATUE: mobj_type = 306;
pub const MT_CRAWLASTATUE: mobj_type = 305;
pub const MT_WAVINGFLAGSEG2: mobj_type = 304;
pub const MT_WAVINGFLAGSEG1: mobj_type = 303;
pub const MT_WAVINGFLAG2: mobj_type = 302;
pub const MT_WAVINGFLAG1: mobj_type = 301;
pub const MT_FIRETORCH: mobj_type = 300;
pub const MT_FLAMEHOLDER: mobj_type = 299;
pub const MT_CANDLEPRICKET: mobj_type = 298;
pub const MT_CANDLE: mobj_type = 297;
pub const MT_CEZBUSH2: mobj_type = 296;
pub const MT_CEZBUSH1: mobj_type = 295;
pub const MT_PINETREE: mobj_type = 294;
pub const MT_CEZBANNER2: mobj_type = 293;
pub const MT_CEZBANNER1: mobj_type = 292;
pub const MT_CEZPOLE2: mobj_type = 291;
pub const MT_CEZPOLE1: mobj_type = 290;
pub const MT_CEZFLOWER: mobj_type = 289;
pub const MT_BIGFIREBAR: mobj_type = 288;
pub const MT_SMALLFIREBAR: mobj_type = 287;
pub const MT_REDSPRINGBALL: mobj_type = 286;
pub const MT_YELLOWSPRINGBALL: mobj_type = 285;
pub const MT_BIGGRABCHAIN: mobj_type = 284;
pub const MT_SMALLGRABCHAIN: mobj_type = 283;
pub const MT_BIGMACE: mobj_type = 282;
pub const MT_SMALLMACE: mobj_type = 281;
pub const MT_BIGMACECHAIN: mobj_type = 280;
pub const MT_SMALLMACECHAIN: mobj_type = 279;
pub const MT_CUSTOMMACEPOINT: mobj_type = 278;
pub const MT_FIREBARPOINT: mobj_type = 277;
pub const MT_HIDDEN_SLING: mobj_type = 276;
pub const MT_CHAINPOINT: mobj_type = 275;
pub const MT_SPRINGBALLPOINT: mobj_type = 274;
pub const MT_CHAINMACEPOINT: mobj_type = 273;
pub const MT_MACEPOINT: mobj_type = 272;
pub const MT_EGGSTATUE: mobj_type = 271;
pub const MT_FLAMEPARTICLE: mobj_type = 270;
pub const MT_FLAME: mobj_type = 269;
pub const MT_CHAIN: mobj_type = 268;
pub const MT_LIGHTBEAM: mobj_type = 267;
pub const MT_DSZ2STALAGMITE: mobj_type = 266;
pub const MT_DSZSTALAGMITE: mobj_type = 265;
pub const MT_ANIMALGAESEG: mobj_type = 264;
pub const MT_ANIMALGAETOP: mobj_type = 263;
pub const MT_KELP: mobj_type = 262;
pub const MT_BLUECRYSTAL: mobj_type = 261;
pub const MT_CORAL5: mobj_type = 260;
pub const MT_CORAL4: mobj_type = 259;
pub const MT_CORAL3: mobj_type = 258;
pub const MT_CORAL2: mobj_type = 257;
pub const MT_CORAL1: mobj_type = 256;
pub const MT_WATERDROP: mobj_type = 255;
pub const MT_WATERDRIP: mobj_type = 254;
pub const MT_SEAWEED: mobj_type = 253;
pub const MT_BIGGARGOYLE: mobj_type = 252;
pub const MT_GARGOYLE: mobj_type = 251;
pub const MT_ALARM: mobj_type = 250;
pub const MT_THZTREEBRANCH: mobj_type = 249;
pub const MT_THZTREE: mobj_type = 248;
pub const MT_THZFLOWER3: mobj_type = 247;
pub const MT_THZFLOWER2: mobj_type = 246;
pub const MT_THZFLOWER1: mobj_type = 245;
pub const MT_SPRINGTREE: mobj_type = 244;
pub const MT_BUSHREDTREE: mobj_type = 243;
pub const MT_BUSHTREE: mobj_type = 242;
pub const MT_POLYGONTREE: mobj_type = 241;
pub const MT_FHZPINKTREE: mobj_type = 240;
pub const MT_FHZTREE: mobj_type = 239;
pub const MT_CHECKERSUNSETTREE: mobj_type = 238;
pub const MT_CHECKERTREE: mobj_type = 237;
pub const MT_GFZCHERRYTREE: mobj_type = 236;
pub const MT_GFZBERRYTREE: mobj_type = 235;
pub const MT_GFZTREE: mobj_type = 234;
pub const MT_BUSH: mobj_type = 233;
pub const MT_BERRYBUSH: mobj_type = 232;
pub const MT_BLUEBERRYBUSH: mobj_type = 231;
pub const MT_GFZFLOWER3: mobj_type = 230;
pub const MT_GFZFLOWER2: mobj_type = 229;
pub const MT_GFZFLOWER1: mobj_type = 228;
pub const MT_TUTORIALFLOWERF: mobj_type = 227;
pub const MT_TUTORIALFLOWER: mobj_type = 226;
pub const MT_TUTORIALLEAF: mobj_type = 225;
pub const MT_TUTORIALPLANT: mobj_type = 224;
pub const MT_LETTER: mobj_type = 223;
pub const MT_DEMONFIRE: mobj_type = 222;
pub const MT_ARROW: mobj_type = 221;
pub const MT_CANNONBALLDECOR: mobj_type = 220;
pub const MT_CANNONBALL: mobj_type = 219;
pub const MT_TURRETLASER: mobj_type = 218;
pub const MT_JETTBULLET: mobj_type = 217;
pub const MT_MINE: mobj_type = 216;
pub const MT_ENERGYBALL: mobj_type = 215;
pub const MT_TORPEDO2: mobj_type = 214;
pub const MT_TORPEDO: mobj_type = 213;
pub const MT_LASER: mobj_type = 212;
pub const MT_ROCKET: mobj_type = 211;
pub const MT_THUNDERCOIN_ICON: mobj_type = 210;
pub const MT_BUBBLEWRAP_ICON: mobj_type = 209;
pub const MT_FLAMEAURA_ICON: mobj_type = 208;
pub const MT_SCORE10K_ICON: mobj_type = 207;
pub const MT_SCORE1K_ICON: mobj_type = 206;
pub const MT_RECYCLER_ICON: mobj_type = 205;
pub const MT_GRAVITY_ICON: mobj_type = 204;
pub const MT_MIXUP_ICON: mobj_type = 203;
pub const MT_EGGMAN_ICON: mobj_type = 202;
pub const MT_1UP_ICON: mobj_type = 201;
pub const MT_INVULN_ICON: mobj_type = 200;
pub const MT_SNEAKERS_ICON: mobj_type = 199;
pub const MT_ELEMENTAL_ICON: mobj_type = 198;
pub const MT_WHIRLWIND_ICON: mobj_type = 197;
pub const MT_ARMAGEDDON_ICON: mobj_type = 196;
pub const MT_FORCE_ICON: mobj_type = 195;
pub const MT_ATTRACT_ICON: mobj_type = 194;
pub const MT_PITY_ICON: mobj_type = 193;
pub const MT_RING_ICON: mobj_type = 192;
pub const MT_RING_BLUEBOX: mobj_type = 191;
pub const MT_RING_REDBOX: mobj_type = 190;
pub const MT_THUNDERCOIN_GOLDBOX: mobj_type = 189;
pub const MT_BUBBLEWRAP_GOLDBOX: mobj_type = 188;
pub const MT_FLAMEAURA_GOLDBOX: mobj_type = 187;
pub const MT_GRAVITY_GOLDBOX: mobj_type = 186;
pub const MT_EGGMAN_GOLDBOX: mobj_type = 185;
pub const MT_INVULN_GOLDBOX: mobj_type = 184;
pub const MT_SNEAKERS_GOLDBOX: mobj_type = 183;
pub const MT_ELEMENTAL_GOLDBOX: mobj_type = 182;
pub const MT_WHIRLWIND_GOLDBOX: mobj_type = 181;
pub const MT_ARMAGEDDON_GOLDBOX: mobj_type = 180;
pub const MT_FORCE_GOLDBOX: mobj_type = 179;
pub const MT_ATTRACT_GOLDBOX: mobj_type = 178;
pub const MT_PITY_GOLDBOX: mobj_type = 177;
pub const MT_THUNDERCOIN_BOX: mobj_type = 176;
pub const MT_BUBBLEWRAP_BOX: mobj_type = 175;
pub const MT_FLAMEAURA_BOX: mobj_type = 174;
pub const MT_SCORE10K_BOX: mobj_type = 173;
pub const MT_SCORE1K_BOX: mobj_type = 172;
pub const MT_RECYCLER_BOX: mobj_type = 171;
pub const MT_GRAVITY_BOX: mobj_type = 170;
pub const MT_MYSTERY_BOX: mobj_type = 169;
pub const MT_MIXUP_BOX: mobj_type = 168;
pub const MT_EGGMAN_BOX: mobj_type = 167;
pub const MT_1UP_BOX: mobj_type = 166;
pub const MT_INVULN_BOX: mobj_type = 165;
pub const MT_SNEAKERS_BOX: mobj_type = 164;
pub const MT_ELEMENTAL_BOX: mobj_type = 163;
pub const MT_WHIRLWIND_BOX: mobj_type = 162;
pub const MT_ARMAGEDDON_BOX: mobj_type = 161;
pub const MT_FORCE_BOX: mobj_type = 160;
pub const MT_ATTRACT_BOX: mobj_type = 159;
pub const MT_PITY_BOX: mobj_type = 158;
pub const MT_RING_BOX: mobj_type = 157;
pub const MT_BOXSPARKLE: mobj_type = 156;
pub const MT_CANNONLAUNCHER: mobj_type = 155;
pub const MT_BLASTEXECUTOR: mobj_type = 154;
pub const MT_BIGMINE: mobj_type = 153;
pub const MT_STARPOST: mobj_type = 152;
pub const MT_WALLSPIKEBASE: mobj_type = 151;
pub const MT_WALLSPIKE: mobj_type = 150;
pub const MT_SPIKE: mobj_type = 149;
pub const MT_SPINFIRE: mobj_type = 148;
pub const MT_SPIKEBALL: mobj_type = 147;
pub const MT_SIGN: mobj_type = 146;
pub const MT_BUBBLES: mobj_type = 145;
pub const MT_REDBOOSTER: mobj_type = 144;
pub const MT_YELLOWBOOSTER: mobj_type = 143;
pub const MT_BOOSTERROLLER: mobj_type = 142;
pub const MT_BOOSTERSEG: mobj_type = 141;
pub const MT_BLUEHORIZ: mobj_type = 140;
pub const MT_REDHORIZ: mobj_type = 139;
pub const MT_YELLOWHORIZ: mobj_type = 138;
pub const MT_BLUEDIAG: mobj_type = 137;
pub const MT_REDDIAG: mobj_type = 136;
pub const MT_YELLOWDIAG: mobj_type = 135;
pub const MT_BLUESPRING: mobj_type = 134;
pub const MT_REDSPRING: mobj_type = 133;
pub const MT_YELLOWSPRING: mobj_type = 132;
pub const MT_BALLOON: mobj_type = 131;
pub const MT_BUMPER: mobj_type = 130;
pub const MT_STEAM: mobj_type = 129;
pub const MT_FAN: mobj_type = 128;
pub const MT_FLINGEMERALD: mobj_type = 127;
pub const MT_EMERALDSPAWN: mobj_type = 126;
pub const MT_EMERHUNT: mobj_type = 125;
pub const MT_EMERALD7: mobj_type = 124;
pub const MT_EMERALD6: mobj_type = 123;
pub const MT_EMERALD5: mobj_type = 122;
pub const MT_EMERALD4: mobj_type = 121;
pub const MT_EMERALD3: mobj_type = 120;
pub const MT_EMERALD2: mobj_type = 119;
pub const MT_EMERALD1: mobj_type = 118;
pub const MT_EMBLEM: mobj_type = 117;
pub const MT_BLUEFLAG: mobj_type = 116;
pub const MT_REDFLAG: mobj_type = 115;
pub const MT_TOKEN: mobj_type = 114;
pub const MT_BLUETEAMRING: mobj_type = 113;
pub const MT_REDTEAMRING: mobj_type = 112;
pub const MT_BOMBSPHERE: mobj_type = 111;
pub const MT_FLINGBLUESPHERE: mobj_type = 110;
pub const MT_BLUESPHERE: mobj_type = 109;
pub const MT_FLINGRING: mobj_type = 108;
pub const MT_RING: mobj_type = 107;
pub const MT_MSGATHER: mobj_type = 106;
pub const MT_MSSHIELD_FRONT: mobj_type = 105;
pub const MT_METALSONIC_BATTLE: mobj_type = 104;
pub const MT_METALSONIC_RACE: mobj_type = 103;
pub const MT_CYBRAKDEMON_VILE_EXPLOSION: mobj_type = 102;
pub const MT_CYBRAKDEMON_NAPALM_FLAMES: mobj_type = 101;
pub const MT_CYBRAKDEMON_NAPALM_BOMB_SMALL: mobj_type = 100;
pub const MT_CYBRAKDEMON_NAPALM_BOMB_LARGE: mobj_type = 99;
pub const MT_CYBRAKDEMON_TARGET_DOT: mobj_type = 98;
pub const MT_CYBRAKDEMON_TARGET_RETICULE: mobj_type = 97;
pub const MT_CYBRAKDEMON_FLAMEREST: mobj_type = 96;
pub const MT_CYBRAKDEMON_FLAMESHOT: mobj_type = 95;
pub const MT_CYBRAKDEMON_MISSILE: mobj_type = 94;
pub const MT_CYBRAKDEMON_ELECTRIC_BARRIER: mobj_type = 93;
pub const MT_CYBRAKDEMON: mobj_type = 92;
pub const MT_BLACKEGGMAN_MISSILE: mobj_type = 91;
pub const MT_BLACKEGGMAN_GOOPFIRE: mobj_type = 90;
pub const MT_BLACKEGGMAN_HELPER: mobj_type = 89;
pub const MT_BLACKEGGMAN: mobj_type = 88;
pub const MT_FANGWAYPOINT: mobj_type = 87;
pub const MT_FSGNB: mobj_type = 86;
pub const MT_FSGNA: mobj_type = 85;
pub const MT_TNTDUST: mobj_type = 84;
pub const MT_FBOMB: mobj_type = 83;
pub const MT_PROJECTORLIGHT: mobj_type = 82;
pub const MT_VWREB: mobj_type = 81;
pub const MT_VWREF: mobj_type = 80;
pub const MT_BROKENROBOT: mobj_type = 79;
pub const MT_FANG: mobj_type = 78;
pub const MT_EGGROBO1JET: mobj_type = 77;
pub const MT_EGGROBO1: mobj_type = 76;
pub const MT_JETFLAME: mobj_type = 75;
pub const MT_EGGMOBILE4_MACE: mobj_type = 74;
pub const MT_EGGMOBILE4: mobj_type = 73;
pub const MT_SHOCKWAVE: mobj_type = 72;
pub const MT_FAKEMOBILE: mobj_type = 71;
pub const MT_EGGMOBILE3: mobj_type = 70;
pub const MT_GOOPTRAIL: mobj_type = 69;
pub const MT_GOOP: mobj_type = 68;
pub const MT_EGGMOBILE2_POGO: mobj_type = 67;
pub const MT_EGGMOBILE2: mobj_type = 66;
pub const MT_EGGMOBILE_FIRE: mobj_type = 65;
pub const MT_EGGMOBILE_TARGET: mobj_type = 64;
pub const MT_EGGMOBILE_BALL: mobj_type = 63;
pub const MT_JETFUME1: mobj_type = 62;
pub const MT_EGGMOBILE: mobj_type = 61;
pub const MT_BOSSJUNK: mobj_type = 60;
pub const MT_BOSS9GATHERPOINT: mobj_type = 59;
pub const MT_BOSS3WAYPOINT: mobj_type = 58;
pub const MT_EGGTRAP: mobj_type = 57;
pub const MT_BOSSFLYPOINT: mobj_type = 56;
pub const MT_SONIC3KBOSSEXPLODE: mobj_type = 55;
pub const MT_BOSSEXPLODE: mobj_type = 54;
pub const MT_DRAGONMINE: mobj_type = 53;
pub const MT_DRAGONTAIL: mobj_type = 52;
pub const MT_DRAGONWING: mobj_type = 51;
pub const MT_DRAGONBOMBER: mobj_type = 50;
pub const MT_PTERABYTE: mobj_type = 49;
pub const MT_PTERABYTEWAYPOINT: mobj_type = 48;
pub const MT_PTERABYTESPAWNER: mobj_type = 47;
pub const MT_PYREFLY_FIRE: mobj_type = 46;
pub const MT_PYREFLY: mobj_type = 45;
pub const MT_CANARIVORE_GAS: mobj_type = 44;
pub const MT_CANARIVORE: mobj_type = 43;
pub const MT_UNIBALL: mobj_type = 42;
pub const MT_UNIDUS: mobj_type = 41;
pub const MT_YELLOWSHELL: mobj_type = 40;
pub const MT_SPRINGSHELL: mobj_type = 39;
pub const MT_MINUSDIRT: mobj_type = 38;
pub const MT_MINUS: mobj_type = 37;
pub const MT_SNAPPER_HEAD: mobj_type = 36;
pub const MT_SNAPPER_LEG: mobj_type = 35;
pub const MT_GSNAPPER: mobj_type = 34;
pub const MT_EGGSHIELD: mobj_type = 33;
pub const MT_EGGGUARD: mobj_type = 32;
pub const MT_FACESTABBERSPEAR: mobj_type = 31;
pub const MT_FACESTABBER: mobj_type = 30;
pub const MT_ROBOHOOD: mobj_type = 29;
pub const MT_POINTYBALL: mobj_type = 28;
pub const MT_POINTY: mobj_type = 27;
pub const MT_VULTURE: mobj_type = 26;
pub const MT_SNAILER: mobj_type = 25;
pub const MT_JETJAW: mobj_type = 24;
pub const MT_BANPSPRING: mobj_type = 23;
pub const MT_BANPYURA: mobj_type = 22;
pub const MT_CRUSHCHAIN: mobj_type = 21;
pub const MT_CRUSHCLAW: mobj_type = 20;
pub const MT_CRUSHSTACEAN: mobj_type = 19;
pub const MT_SPINCUSHION: mobj_type = 18;
pub const MT_POPUPTURRET: mobj_type = 17;
pub const MT_TURRET: mobj_type = 16;
pub const MT_SKIM: mobj_type = 15;
pub const MT_DETON: mobj_type = 14;
pub const MT_CRAWLACOMMANDER: mobj_type = 13;
pub const MT_JETTGUNNER: mobj_type = 12;
pub const MT_JETTBOMBER: mobj_type = 11;
pub const MT_REDBUZZ: mobj_type = 10;
pub const MT_GOLDBUZZ: mobj_type = 9;
pub const MT_GFZFISH: mobj_type = 8;
pub const MT_REDCRAWLA: mobj_type = 7;
pub const MT_BLUECRAWLA: mobj_type = 6;
pub const MT_METALJETFUME: mobj_type = 5;
pub const MT_TAILSOVERLAY: mobj_type = 4;
pub const MT_PLAYER: mobj_type = 3;
pub const MT_THOK: mobj_type = 2;
pub const MT_UNKNOWN: mobj_type = 1;
pub const MT_NULL: mobj_type = 0;
pub type panim_t = libc::c_uint;
pub const PA_RIDE: panim_t = 13;
pub const PA_ABILITY2: panim_t = 12;
pub const PA_ABILITY: panim_t = 11;
pub const PA_FALL: panim_t = 10;
pub const PA_SPRING: panim_t = 9;
pub const PA_JUMP: panim_t = 8;
pub const PA_ROLL: panim_t = 7;
pub const PA_PAIN: panim_t = 6;
pub const PA_DASH: panim_t = 5;
pub const PA_RUN: panim_t = 4;
pub const PA_WALK: panim_t = 3;
pub const PA_EDGE: panim_t = 2;
pub const PA_IDLE: panim_t = 1;
pub const PA_ETC: panim_t = 0;
pub type pflags_t = libc::c_uint;
pub const PF_FINISHED: pflags_t = 1073741824;
pub const PF_CANCARRY: pflags_t = 536870912;
pub const PF_FORCESTRAFE: pflags_t = 268435456;
pub const PF_TAGIT: pflags_t = 134217728;
pub const PF_GAMETYPEOVER: pflags_t = 67108864;
pub const PF_DRILLING: pflags_t = 33554432;
pub const PF_TRANSFERTOCLOSEST: pflags_t = 16777216;
pub const PF_SLIDING: pflags_t = 8388608;
pub const PF_BOUNCING: pflags_t = 4194304;
pub const PF_GLIDING: pflags_t = 2097152;
pub const PF_SHIELDABILITY: pflags_t = 1048576;
pub const PF_THOKKED: pflags_t = 524288;
pub const PF_STARTDASH: pflags_t = 262144;
pub const PF_SPINNING: pflags_t = 131072;
pub const PF_NOJUMPDAMAGE: pflags_t = 65536;
pub const PF_JUMPED: pflags_t = 32768;
pub const PF_STARTJUMP: pflags_t = 16384;
pub const PF_APPLYAUTOBRAKE: pflags_t = 8192;
pub const PF_FULLSTASIS: pflags_t = 6144;
pub const PF_JUMPSTASIS: pflags_t = 4096;
pub const PF_STASIS: pflags_t = 2048;
pub const PF_WPNDOWN: pflags_t = 1024;
pub const PF_JUMPDOWN: pflags_t = 512;
pub const PF_SPINDOWN: pflags_t = 256;
pub const PF_ATTACKDOWN: pflags_t = 128;
pub const PF_INVIS: pflags_t = 64;
pub const PF_NOCLIP: pflags_t = 32;
pub const PF_GODMODE: pflags_t = 16;
pub const PF_AUTOBRAKE: pflags_t = 8;
pub const PF_DIRECTIONCHAR: pflags_t = 4;
pub const PF_ANALOGMODE: pflags_t = 2;
pub const PF_FLIPCAM: pflags_t = 1;
pub type playerstate_t = libc::c_uint;
pub const PST_REBORN: playerstate_t = 2;
pub const PST_DEAD: playerstate_t = 1;
pub const PST_LIVE: playerstate_t = 0;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct ticcmd_t {
    pub forwardmove: int8_t,
    pub sidemove: int8_t,
    pub angleturn: int16_t,
    pub aiming: int16_t,
    pub buttons: uint16_t,
    pub latency: uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mobjinfo_t {
    pub doomednum: int32_t,
    pub spawnstate: statenum_t,
    pub spawnhealth: int32_t,
    pub seestate: statenum_t,
    pub seesound: sfxenum_t,
    pub reactiontime: int32_t,
    pub attacksound: sfxenum_t,
    pub painstate: statenum_t,
    pub painchance: int32_t,
    pub painsound: sfxenum_t,
    pub meleestate: statenum_t,
    pub missilestate: statenum_t,
    pub deathstate: statenum_t,
    pub xdeathstate: statenum_t,
    pub deathsound: sfxenum_t,
    pub speed: fixed_t,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub dispoffset: int32_t,
    pub mass: int32_t,
    pub damage: int32_t,
    pub activesound: sfxenum_t,
    pub flags: uint32_t,
    pub raisestate: statenum_t,
}
pub type statenum_t = state;
pub type state = libc::c_uint;
pub const NUMSTATES: state = 6735;
pub const S_LASTFREESLOT: state = 6734;
pub const S_FIRSTFREESLOT: state = 2639;
pub const S_NAMECHECK: state = 2638;
pub const S_YELLOWBRICKDEBRIS: state = 2637;
pub const S_BLUEBRICKDEBRIS: state = 2636;
pub const S_REDBRICKDEBRIS: state = 2635;
pub const S_WOODDEBRIS: state = 2634;
pub const S_BRICKDEBRIS: state = 2633;
pub const S_GFZDEBRIS: state = 2632;
pub const S_ROCKCRUMBLEP: state = 2631;
pub const S_ROCKCRUMBLEO: state = 2630;
pub const S_ROCKCRUMBLEN: state = 2629;
pub const S_ROCKCRUMBLEM: state = 2628;
pub const S_ROCKCRUMBLEL: state = 2627;
pub const S_ROCKCRUMBLEK: state = 2626;
pub const S_ROCKCRUMBLEJ: state = 2625;
pub const S_ROCKCRUMBLEI: state = 2624;
pub const S_ROCKCRUMBLEH: state = 2623;
pub const S_ROCKCRUMBLEG: state = 2622;
pub const S_ROCKCRUMBLEF: state = 2621;
pub const S_ROCKCRUMBLEE: state = 2620;
pub const S_ROCKCRUMBLED: state = 2619;
pub const S_ROCKCRUMBLEC: state = 2618;
pub const S_ROCKCRUMBLEB: state = 2617;
pub const S_ROCKCRUMBLEA: state = 2616;
pub const S_ROCKSPAWN: state = 2615;
pub const S_DUST4: state = 2614;
pub const S_DUST3: state = 2613;
pub const S_DUST2: state = 2612;
pub const S_DUST1: state = 2611;
pub const S_WPLD6: state = 2610;
pub const S_WPLD5: state = 2609;
pub const S_WPLD4: state = 2608;
pub const S_WPLD3: state = 2607;
pub const S_WPLD2: state = 2606;
pub const S_WPLD1: state = 2605;
pub const S_XPLD_EGGTRAP: state = 2604;
pub const S_XPLD6: state = 2603;
pub const S_XPLD5: state = 2602;
pub const S_XPLD4: state = 2601;
pub const S_XPLD3: state = 2600;
pub const S_XPLD2: state = 2599;
pub const S_XPLD1: state = 2598;
pub const S_XPLD_FLICKY: state = 2597;
pub const S_SPRK3: state = 2596;
pub const S_SPRK2: state = 2595;
pub const S_SPRK1: state = 2594;
pub const S_CRUMBLE2: state = 2593;
pub const S_CRUMBLE1: state = 2592;
pub const S_HANGSTER_RETURN3: state = 2591;
pub const S_HANGSTER_RETURN2: state = 2590;
pub const S_HANGSTER_RETURN1: state = 2589;
pub const S_HANGSTER_ARCUP3: state = 2588;
pub const S_HANGSTER_ARCUP2: state = 2587;
pub const S_HANGSTER_ARCUP1: state = 2586;
pub const S_HANGSTER_FLYREPEAT: state = 2585;
pub const S_HANGSTER_FLY4: state = 2584;
pub const S_HANGSTER_FLY3: state = 2583;
pub const S_HANGSTER_FLY2: state = 2582;
pub const S_HANGSTER_FLY1: state = 2581;
pub const S_HANGSTER_ARC3: state = 2580;
pub const S_HANGSTER_ARC2: state = 2579;
pub const S_HANGSTER_ARC1: state = 2578;
pub const S_HANGSTER_SWOOP2: state = 2577;
pub const S_HANGSTER_SWOOP1: state = 2576;
pub const S_HANGSTER_LOOK: state = 2575;
pub const S_SPINBOBERT_FIRE_TRAIL3: state = 2574;
pub const S_SPINBOBERT_FIRE_TRAIL2: state = 2573;
pub const S_SPINBOBERT_FIRE_TRAIL1: state = 2572;
pub const S_SPINBOBERT_FIRE_GHOST: state = 2571;
pub const S_SPINBOBERT_FIRE_MOVE: state = 2570;
pub const S_SPINBOBERT_MOVE_DOWN: state = 2569;
pub const S_SPINBOBERT_MOVE_FLIPDOWN: state = 2568;
pub const S_SPINBOBERT_MOVE_UP: state = 2567;
pub const S_SPINBOBERT_MOVE_FLIPUP: state = 2566;
pub const S_CACOFIRE_EXPLODE4: state = 2565;
pub const S_CACOFIRE_EXPLODE3: state = 2564;
pub const S_CACOFIRE_EXPLODE2: state = 2563;
pub const S_CACOFIRE_EXPLODE1: state = 2562;
pub const S_CACOFIRE3: state = 2561;
pub const S_CACOFIRE2: state = 2560;
pub const S_CACOFIRE1: state = 2559;
pub const S_CACOSHARD2_2: state = 2558;
pub const S_CACOSHARD2_1: state = 2557;
pub const S_CACOSHARD1_2: state = 2556;
pub const S_CACOSHARD1_1: state = 2555;
pub const S_CACOSHARD_RANDOMIZE: state = 2554;
pub const S_CACO_DIE_FALL: state = 2553;
pub const S_CACO_DIE_SHATTER: state = 2552;
pub const S_CACO_DIE_SCREAM: state = 2551;
pub const S_CACO_DIE_GIB2: state = 2550;
pub const S_CACO_DIE_GIB1: state = 2549;
pub const S_CACO_DIE_FLAGS: state = 2548;
pub const S_CACO_CLOSE: state = 2547;
pub const S_CACO_SHOOT2: state = 2546;
pub const S_CACO_SHOOT1: state = 2545;
pub const S_CACO_SHOOT_SOUND: state = 2544;
pub const S_CACO_PREPARE3: state = 2543;
pub const S_CACO_PREPARE2: state = 2542;
pub const S_CACO_PREPARE1: state = 2541;
pub const S_CACO_PREPARE_SOUND: state = 2540;
pub const S_CACO_RANDOM: state = 2539;
pub const S_CACO_CHASE_REPEAT: state = 2538;
pub const S_CACO_CHASE: state = 2537;
pub const S_CACO_ROAR: state = 2536;
pub const S_CACO_WAKE4: state = 2535;
pub const S_CACO_WAKE3: state = 2534;
pub const S_CACO_WAKE2: state = 2533;
pub const S_CACO_WAKE1: state = 2532;
pub const S_CACO_LOOK: state = 2531;
pub const S_SMASHSPIKE_RISE2: state = 2530;
pub const S_SMASHSPIKE_RISE1: state = 2529;
pub const S_SMASHSPIKE_STOMP2: state = 2528;
pub const S_SMASHSPIKE_STOMP1: state = 2527;
pub const S_SMASHSPIKE_FALL: state = 2526;
pub const S_SMASHSPIKE_EASE2: state = 2525;
pub const S_SMASHSPIKE_EASE1: state = 2524;
pub const S_SMASHSPIKE_FLOAT: state = 2523;
pub const S_BUGGLEFLY: state = 2522;
pub const S_BUGGLEIDLE: state = 2521;
pub const S_BUMBLEBORE_DIE: state = 2520;
pub const S_BUMBLEBORE_STUCK2: state = 2519;
pub const S_BUMBLEBORE_STUCK1: state = 2518;
pub const S_BUMBLEBORE_FALL2: state = 2517;
pub const S_BUMBLEBORE_FALL1: state = 2516;
pub const S_BUMBLEBORE_RAISE: state = 2515;
pub const S_BUMBLEBORE_FLY2: state = 2514;
pub const S_BUMBLEBORE_FLY1: state = 2513;
pub const S_BUMBLEBORE_LOOK2: state = 2512;
pub const S_BUMBLEBORE_LOOK1: state = 2511;
pub const S_BUMBLEBORE_SPAWN: state = 2510;
pub const S_HIVEELEMENTAL_DIE3: state = 2509;
pub const S_HIVEELEMENTAL_DIE2: state = 2508;
pub const S_HIVEELEMENTAL_DIE1: state = 2507;
pub const S_HIVEELEMENTAL_PAIN: state = 2506;
pub const S_HIVEELEMENTAL_DORMANT: state = 2505;
pub const S_HIVEELEMENTAL_SHOOT2: state = 2504;
pub const S_HIVEELEMENTAL_SHOOT1: state = 2503;
pub const S_HIVEELEMENTAL_PREPARE2: state = 2502;
pub const S_HIVEELEMENTAL_PREPARE1: state = 2501;
pub const S_HIVEELEMENTAL_LOOK: state = 2500;
pub const S_POPSHOT_TRAIL: state = 2499;
pub const S_POPSHOT: state = 2498;
pub const S_POPHAT_SHOOT4: state = 2497;
pub const S_POPHAT_SHOOT3: state = 2496;
pub const S_POPHAT_SHOOT2: state = 2495;
pub const S_POPHAT_SHOOT1: state = 2494;
pub const S_POPHAT_LOOK: state = 2493;
pub const S_PENGUINATOR_SLIDE5: state = 2492;
pub const S_PENGUINATOR_SLIDE4: state = 2491;
pub const S_PENGUINATOR_SLIDE3: state = 2490;
pub const S_PENGUINATOR_SLIDE2: state = 2489;
pub const S_PENGUINATOR_SLIDE1: state = 2488;
pub const S_PENGUINATOR_WADDLE4: state = 2487;
pub const S_PENGUINATOR_WADDLE3: state = 2486;
pub const S_PENGUINATOR_WADDLE2: state = 2485;
pub const S_PENGUINATOR_WADDLE1: state = 2484;
pub const S_PENGUINATOR_LOOK: state = 2483;
pub const S_SHLEEPBOUNCE3: state = 2482;
pub const S_SHLEEPBOUNCE2: state = 2481;
pub const S_SHLEEPBOUNCE1: state = 2480;
pub const S_SHLEEP4: state = 2479;
pub const S_SHLEEP3: state = 2478;
pub const S_SHLEEP2: state = 2477;
pub const S_SHLEEP1: state = 2476;
pub const S_PIAN_SING: state = 2475;
pub const S_PIAN_FLY3: state = 2474;
pub const S_PIAN_FLY2: state = 2473;
pub const S_PIAN_FLY1: state = 2472;
pub const S_PIAN_LOOK3: state = 2471;
pub const S_PIAN_LOOK2: state = 2470;
pub const S_PIAN_LOOK1: state = 2469;
pub const S_NIGHTOPIANHELPER9: state = 2468;
pub const S_NIGHTOPIANHELPER8: state = 2467;
pub const S_NIGHTOPIANHELPER7: state = 2466;
pub const S_NIGHTOPIANHELPER6: state = 2465;
pub const S_NIGHTOPIANHELPER5: state = 2464;
pub const S_NIGHTOPIANHELPER4: state = 2463;
pub const S_NIGHTOPIANHELPER3: state = 2462;
pub const S_NIGHTOPIANHELPER2: state = 2461;
pub const S_NIGHTOPIANHELPER1: state = 2460;
pub const S_ORBIDYA5: state = 2459;
pub const S_ORBIDYA4: state = 2458;
pub const S_ORBIDYA3: state = 2457;
pub const S_ORBIDYA2: state = 2456;
pub const S_ORBIDYA1: state = 2455;
pub const S_ORBITEM8: state = 2454;
pub const S_ORBITEM7: state = 2453;
pub const S_ORBITEM6: state = 2452;
pub const S_ORBITEM5: state = 2451;
pub const S_ORBITEM4: state = 2450;
pub const S_ORBITEM3: state = 2449;
pub const S_ORBITEM2: state = 2448;
pub const S_ORBITEM1: state = 2447;
pub const S_EGGCAPSULE: state = 2446;
pub const S_NIGHTSLINKFREEZE: state = 2445;
pub const S_NIGHTSEXTRATIME: state = 2444;
pub const S_NIGHTSHELPER: state = 2443;
pub const S_NIGHTSDRILLREFILL: state = 2442;
pub const S_NIGHTSSUPERLOOP: state = 2441;
pub const S_NIGHTSCORE100_2: state = 2440;
pub const S_NIGHTSCORE90_2: state = 2439;
pub const S_NIGHTSCORE80_2: state = 2438;
pub const S_NIGHTSCORE70_2: state = 2437;
pub const S_NIGHTSCORE60_2: state = 2436;
pub const S_NIGHTSCORE50_2: state = 2435;
pub const S_NIGHTSCORE40_2: state = 2434;
pub const S_NIGHTSCORE30_2: state = 2433;
pub const S_NIGHTSCORE20_2: state = 2432;
pub const S_NIGHTSCORE10_2: state = 2431;
pub const S_NIGHTSCORE100: state = 2430;
pub const S_NIGHTSCORE90: state = 2429;
pub const S_NIGHTSCORE80: state = 2428;
pub const S_NIGHTSCORE70: state = 2427;
pub const S_NIGHTSCORE60: state = 2426;
pub const S_NIGHTSCORE50: state = 2425;
pub const S_NIGHTSCORE40: state = 2424;
pub const S_NIGHTSCORE30: state = 2423;
pub const S_NIGHTSCORE20: state = 2422;
pub const S_NIGHTSCORE10: state = 2421;
pub const S_HOOP_XMASB: state = 2420;
pub const S_HOOP_XMASA: state = 2419;
pub const S_HOOP: state = 2418;
pub const S_NIGHTSBUMPER12: state = 2417;
pub const S_NIGHTSBUMPER11: state = 2416;
pub const S_NIGHTSBUMPER10: state = 2415;
pub const S_NIGHTSBUMPER9: state = 2414;
pub const S_NIGHTSBUMPER8: state = 2413;
pub const S_NIGHTSBUMPER7: state = 2412;
pub const S_NIGHTSBUMPER6: state = 2411;
pub const S_NIGHTSBUMPER5: state = 2410;
pub const S_NIGHTSBUMPER4: state = 2409;
pub const S_NIGHTSBUMPER3: state = 2408;
pub const S_NIGHTSBUMPER2: state = 2407;
pub const S_NIGHTSBUMPER1: state = 2406;
pub const S_NIGHTSLOOPHELPER: state = 2405;
pub const S_NIGHTSPARKLESUPER4: state = 2404;
pub const S_NIGHTSPARKLESUPER3: state = 2403;
pub const S_NIGHTSPARKLESUPER2: state = 2402;
pub const S_NIGHTSPARKLESUPER1: state = 2401;
pub const S_NIGHTSPARKLE4: state = 2400;
pub const S_NIGHTSPARKLE3: state = 2399;
pub const S_NIGHTSPARKLE2: state = 2398;
pub const S_NIGHTSPARKLE1: state = 2397;
pub const S_NIGHTSDRONE_GOAL4: state = 2396;
pub const S_NIGHTSDRONE_GOAL3: state = 2395;
pub const S_NIGHTSDRONE_GOAL2: state = 2394;
pub const S_NIGHTSDRONE_GOAL1: state = 2393;
pub const S_NIGHTSDRONE_SPARKLING16: state = 2392;
pub const S_NIGHTSDRONE_SPARKLING15: state = 2391;
pub const S_NIGHTSDRONE_SPARKLING14: state = 2390;
pub const S_NIGHTSDRONE_SPARKLING13: state = 2389;
pub const S_NIGHTSDRONE_SPARKLING12: state = 2388;
pub const S_NIGHTSDRONE_SPARKLING11: state = 2387;
pub const S_NIGHTSDRONE_SPARKLING10: state = 2386;
pub const S_NIGHTSDRONE_SPARKLING9: state = 2385;
pub const S_NIGHTSDRONE_SPARKLING8: state = 2384;
pub const S_NIGHTSDRONE_SPARKLING7: state = 2383;
pub const S_NIGHTSDRONE_SPARKLING6: state = 2382;
pub const S_NIGHTSDRONE_SPARKLING5: state = 2381;
pub const S_NIGHTSDRONE_SPARKLING4: state = 2380;
pub const S_NIGHTSDRONE_SPARKLING3: state = 2379;
pub const S_NIGHTSDRONE_SPARKLING2: state = 2378;
pub const S_NIGHTSDRONE_SPARKLING1: state = 2377;
pub const S_NIGHTSDRONE_MAN2: state = 2376;
pub const S_NIGHTSDRONE_MAN1: state = 2375;
pub const S_TOAD: state = 2374;
pub const S_MARIOBUSH2: state = 2373;
pub const S_MARIOBUSH1: state = 2372;
pub const S_AXE3: state = 2371;
pub const S_AXE2: state = 2370;
pub const S_AXE1: state = 2369;
pub const S_KOOPAFLAME3: state = 2368;
pub const S_KOOPAFLAME2: state = 2367;
pub const S_KOOPAFLAME1: state = 2366;
pub const S_KOOPA2: state = 2365;
pub const S_KOOPA1: state = 2364;
pub const S_HAMMER: state = 2363;
pub const S_PUMATRAIL4: state = 2362;
pub const S_PUMATRAIL3: state = 2361;
pub const S_PUMATRAIL2: state = 2360;
pub const S_PUMATRAIL1: state = 2359;
pub const S_PUMA_DOWN3: state = 2358;
pub const S_PUMA_DOWN2: state = 2357;
pub const S_PUMA_DOWN1: state = 2356;
pub const S_PUMA_UP3: state = 2355;
pub const S_PUMA_UP2: state = 2354;
pub const S_PUMA_UP1: state = 2353;
pub const S_PUMA_START2: state = 2352;
pub const S_PUMA_START1: state = 2351;
pub const S_SHELL: state = 2350;
pub const S_FIREBALLTRAIL2: state = 2349;
pub const S_FIREBALLTRAIL1: state = 2348;
pub const S_FIREBALL: state = 2347;
pub const S_FIREFLOWER4: state = 2346;
pub const S_FIREFLOWER3: state = 2345;
pub const S_FIREFLOWER2: state = 2344;
pub const S_FIREFLOWER1: state = 2343;
pub const S_BLUEGOOMBA_DEAD: state = 2342;
pub const S_BLUEGOOMBA9: state = 2341;
pub const S_BLUEGOOMBA8: state = 2340;
pub const S_BLUEGOOMBA7: state = 2339;
pub const S_BLUEGOOMBA6: state = 2338;
pub const S_BLUEGOOMBA5: state = 2337;
pub const S_BLUEGOOMBA4: state = 2336;
pub const S_BLUEGOOMBA3: state = 2335;
pub const S_BLUEGOOMBA2: state = 2334;
pub const S_BLUEGOOMBA1B: state = 2333;
pub const S_BLUEGOOMBA1: state = 2332;
pub const S_GOOMBA_DEAD: state = 2331;
pub const S_GOOMBA9: state = 2330;
pub const S_GOOMBA8: state = 2329;
pub const S_GOOMBA7: state = 2328;
pub const S_GOOMBA6: state = 2327;
pub const S_GOOMBA5: state = 2326;
pub const S_GOOMBA4: state = 2325;
pub const S_GOOMBA3: state = 2324;
pub const S_GOOMBA2: state = 2323;
pub const S_GOOMBA1B: state = 2322;
pub const S_GOOMBA1: state = 2321;
pub const S_COINSPARKLE4: state = 2320;
pub const S_COINSPARKLE3: state = 2319;
pub const S_COINSPARKLE2: state = 2318;
pub const S_COINSPARKLE1: state = 2317;
pub const S_COIN3: state = 2316;
pub const S_COIN2: state = 2315;
pub const S_COIN1: state = 2314;
pub const S_RINGEXPLODE: state = 2313;
pub const S_THROWNSCATTER: state = 2312;
pub const S_THROWNGRENADE18: state = 2311;
pub const S_THROWNGRENADE17: state = 2310;
pub const S_THROWNGRENADE16: state = 2309;
pub const S_THROWNGRENADE15: state = 2308;
pub const S_THROWNGRENADE14: state = 2307;
pub const S_THROWNGRENADE13: state = 2306;
pub const S_THROWNGRENADE12: state = 2305;
pub const S_THROWNGRENADE11: state = 2304;
pub const S_THROWNGRENADE10: state = 2303;
pub const S_THROWNGRENADE9: state = 2302;
pub const S_THROWNGRENADE8: state = 2301;
pub const S_THROWNGRENADE7: state = 2300;
pub const S_THROWNGRENADE6: state = 2299;
pub const S_THROWNGRENADE5: state = 2298;
pub const S_THROWNGRENADE4: state = 2297;
pub const S_THROWNGRENADE3: state = 2296;
pub const S_THROWNGRENADE2: state = 2295;
pub const S_THROWNGRENADE1: state = 2294;
pub const S_THROWNEXPLOSION7: state = 2293;
pub const S_THROWNEXPLOSION6: state = 2292;
pub const S_THROWNEXPLOSION5: state = 2291;
pub const S_THROWNEXPLOSION4: state = 2290;
pub const S_THROWNEXPLOSION3: state = 2289;
pub const S_THROWNEXPLOSION2: state = 2288;
pub const S_THROWNEXPLOSION1: state = 2287;
pub const S_THROWNAUTOMATIC7: state = 2286;
pub const S_THROWNAUTOMATIC6: state = 2285;
pub const S_THROWNAUTOMATIC5: state = 2284;
pub const S_THROWNAUTOMATIC4: state = 2283;
pub const S_THROWNAUTOMATIC3: state = 2282;
pub const S_THROWNAUTOMATIC2: state = 2281;
pub const S_THROWNAUTOMATIC1: state = 2280;
pub const S_THROWNINFINITY7: state = 2279;
pub const S_THROWNINFINITY6: state = 2278;
pub const S_THROWNINFINITY5: state = 2277;
pub const S_THROWNINFINITY4: state = 2276;
pub const S_THROWNINFINITY3: state = 2275;
pub const S_THROWNINFINITY2: state = 2274;
pub const S_THROWNINFINITY1: state = 2273;
pub const S_THROWNBOUNCE7: state = 2272;
pub const S_THROWNBOUNCE6: state = 2271;
pub const S_THROWNBOUNCE5: state = 2270;
pub const S_THROWNBOUNCE4: state = 2269;
pub const S_THROWNBOUNCE3: state = 2268;
pub const S_THROWNBOUNCE2: state = 2267;
pub const S_THROWNBOUNCE1: state = 2266;
pub const S_GRENADEPICKUPFADE8: state = 2265;
pub const S_GRENADEPICKUPFADE7: state = 2264;
pub const S_GRENADEPICKUPFADE6: state = 2263;
pub const S_GRENADEPICKUPFADE5: state = 2262;
pub const S_GRENADEPICKUPFADE4: state = 2261;
pub const S_GRENADEPICKUPFADE3: state = 2260;
pub const S_GRENADEPICKUPFADE2: state = 2259;
pub const S_GRENADEPICKUPFADE1: state = 2258;
pub const S_GRENADEPICKUP: state = 2257;
pub const S_SCATTERPICKUPFADE8: state = 2256;
pub const S_SCATTERPICKUPFADE7: state = 2255;
pub const S_SCATTERPICKUPFADE6: state = 2254;
pub const S_SCATTERPICKUPFADE5: state = 2253;
pub const S_SCATTERPICKUPFADE4: state = 2252;
pub const S_SCATTERPICKUPFADE3: state = 2251;
pub const S_SCATTERPICKUPFADE2: state = 2250;
pub const S_SCATTERPICKUPFADE1: state = 2249;
pub const S_SCATTERPICKUP: state = 2248;
pub const S_EXPLODEPICKUPFADE8: state = 2247;
pub const S_EXPLODEPICKUPFADE7: state = 2246;
pub const S_EXPLODEPICKUPFADE6: state = 2245;
pub const S_EXPLODEPICKUPFADE5: state = 2244;
pub const S_EXPLODEPICKUPFADE4: state = 2243;
pub const S_EXPLODEPICKUPFADE3: state = 2242;
pub const S_EXPLODEPICKUPFADE2: state = 2241;
pub const S_EXPLODEPICKUPFADE1: state = 2240;
pub const S_EXPLODEPICKUP: state = 2239;
pub const S_AUTOPICKUPFADE8: state = 2238;
pub const S_AUTOPICKUPFADE7: state = 2237;
pub const S_AUTOPICKUPFADE6: state = 2236;
pub const S_AUTOPICKUPFADE5: state = 2235;
pub const S_AUTOPICKUPFADE4: state = 2234;
pub const S_AUTOPICKUPFADE3: state = 2233;
pub const S_AUTOPICKUPFADE2: state = 2232;
pub const S_AUTOPICKUPFADE1: state = 2231;
pub const S_AUTOPICKUP: state = 2230;
pub const S_RAILPICKUPFADE8: state = 2229;
pub const S_RAILPICKUPFADE7: state = 2228;
pub const S_RAILPICKUPFADE6: state = 2227;
pub const S_RAILPICKUPFADE5: state = 2226;
pub const S_RAILPICKUPFADE4: state = 2225;
pub const S_RAILPICKUPFADE3: state = 2224;
pub const S_RAILPICKUPFADE2: state = 2223;
pub const S_RAILPICKUPFADE1: state = 2222;
pub const S_RAILPICKUP: state = 2221;
pub const S_BOUNCEPICKUPFADE8: state = 2220;
pub const S_BOUNCEPICKUPFADE7: state = 2219;
pub const S_BOUNCEPICKUPFADE6: state = 2218;
pub const S_BOUNCEPICKUPFADE5: state = 2217;
pub const S_BOUNCEPICKUPFADE4: state = 2216;
pub const S_BOUNCEPICKUPFADE3: state = 2215;
pub const S_BOUNCEPICKUPFADE2: state = 2214;
pub const S_BOUNCEPICKUPFADE1: state = 2213;
pub const S_BOUNCEPICKUP: state = 2212;
pub const S_GRENADERINGAMMO: state = 2211;
pub const S_SCATTERRINGAMMO: state = 2210;
pub const S_EXPLOSIONRINGAMMO: state = 2209;
pub const S_AUTOMATICRINGAMMO: state = 2208;
pub const S_INFINITYRINGAMMO: state = 2207;
pub const S_RAILRINGAMMO: state = 2206;
pub const S_BOUNCERINGAMMO: state = 2205;
pub const S_RRNG7: state = 2204;
pub const S_RRNG6: state = 2203;
pub const S_RRNG5: state = 2202;
pub const S_RRNG4: state = 2201;
pub const S_RRNG3: state = 2200;
pub const S_RRNG2: state = 2199;
pub const S_RRNG1: state = 2198;
pub const S_LHRT: state = 2197;
pub const S_CORK: state = 2196;
pub const S_FINISHFLAG: state = 2195;
pub const S_GOTFLAG: state = 2194;
pub const S_TTAG: state = 2193;
pub const S_LOCKONINF4: state = 2192;
pub const S_LOCKONINF3: state = 2191;
pub const S_LOCKONINF2: state = 2190;
pub const S_LOCKONINF1: state = 2189;
pub const S_LOCKON4: state = 2188;
pub const S_LOCKON3: state = 2187;
pub const S_LOCKON2: state = 2186;
pub const S_LOCKON1: state = 2185;
pub const S_FLIGHTINDICATOR: state = 2184;
pub const S_FIVE2: state = 2183;
pub const S_FOUR2: state = 2182;
pub const S_THREE2: state = 2181;
pub const S_TWO2: state = 2180;
pub const S_ONE2: state = 2179;
pub const S_ZERO2: state = 2178;
pub const S_FIVE1: state = 2177;
pub const S_FOUR1: state = 2176;
pub const S_THREE1: state = 2175;
pub const S_TWO1: state = 2174;
pub const S_ONE1: state = 2173;
pub const S_ZERO1: state = 2172;
pub const S_SCRL: state = 2171;
pub const S_SCRK: state = 2170;
pub const S_SCRJ: state = 2169;
pub const S_SCRI: state = 2168;
pub const S_SCRH: state = 2167;
pub const S_SCRG: state = 2166;
pub const S_SCRF: state = 2165;
pub const S_SCRE: state = 2164;
pub const S_SCRD: state = 2163;
pub const S_SCRC: state = 2162;
pub const S_SCRB: state = 2161;
pub const S_SCRA: state = 2160;
pub const S_PARTICLE: state = 2159;
pub const S_SEED: state = 2158;
pub const S_FOG14: state = 2157;
pub const S_FOG13: state = 2156;
pub const S_FOG12: state = 2155;
pub const S_FOG11: state = 2154;
pub const S_FOG10: state = 2153;
pub const S_FOG9: state = 2152;
pub const S_FOG8: state = 2151;
pub const S_FOG7: state = 2150;
pub const S_FOG6: state = 2149;
pub const S_FOG5: state = 2148;
pub const S_FOG4: state = 2147;
pub const S_FOG3: state = 2146;
pub const S_FOG2: state = 2145;
pub const S_FOG1: state = 2144;
pub const S_SPINDUST_FIRE4: state = 2143;
pub const S_SPINDUST_FIRE3: state = 2142;
pub const S_SPINDUST_FIRE2: state = 2141;
pub const S_SPINDUST_FIRE1: state = 2140;
pub const S_SPINDUST_BUBBLE4: state = 2139;
pub const S_SPINDUST_BUBBLE3: state = 2138;
pub const S_SPINDUST_BUBBLE2: state = 2137;
pub const S_SPINDUST_BUBBLE1: state = 2136;
pub const S_SPINDUST4: state = 2135;
pub const S_SPINDUST3: state = 2134;
pub const S_SPINDUST2: state = 2133;
pub const S_SPINDUST1: state = 2132;
pub const S_WATERZAP: state = 2131;
pub const S_POP1: state = 2130;
pub const S_EXTRALARGEBUBBLE: state = 2129;
pub const S_LARGEBUBBLE2: state = 2128;
pub const S_LARGEBUBBLE1: state = 2127;
pub const S_MEDIUMBUBBLE: state = 2126;
pub const S_SMALLBUBBLE: state = 2125;
pub const S_SMOKE5: state = 2124;
pub const S_SMOKE4: state = 2123;
pub const S_SMOKE3: state = 2122;
pub const S_SMOKE2: state = 2121;
pub const S_SMOKE1: state = 2120;
pub const S_SPLASH3: state = 2119;
pub const S_SPLASH2: state = 2118;
pub const S_SPLASH1: state = 2117;
pub const S_LAVASPLISH: state = 2116;
pub const S_SPLISH9: state = 2115;
pub const S_SPLISH8: state = 2114;
pub const S_SPLISH7: state = 2113;
pub const S_SPLISH6: state = 2112;
pub const S_SPLISH5: state = 2111;
pub const S_SPLISH4: state = 2110;
pub const S_SPLISH3: state = 2109;
pub const S_SPLISH2: state = 2108;
pub const S_SPLISH1: state = 2107;
pub const S_SNOW3: state = 2106;
pub const S_SNOW2: state = 2105;
pub const S_SNOW1: state = 2104;
pub const S_RAINRETURN: state = 2103;
pub const S_RAIN1: state = 2102;
pub const S_REDBOOSTERSEG_FACE: state = 2101;
pub const S_REDBOOSTERSEG_RIGHT: state = 2100;
pub const S_REDBOOSTERSEG_LEFT: state = 2099;
pub const S_REDBOOSTERROLLER: state = 2098;
pub const S_YELLOWBOOSTERSEG_FACE: state = 2097;
pub const S_YELLOWBOOSTERSEG_RIGHT: state = 2096;
pub const S_YELLOWBOOSTERSEG_LEFT: state = 2095;
pub const S_YELLOWBOOSTERROLLER: state = 2094;
pub const S_BOOSTERSOUND: state = 2093;
pub const S_BHORIZ8: state = 2092;
pub const S_BHORIZ7: state = 2091;
pub const S_BHORIZ6: state = 2090;
pub const S_BHORIZ5: state = 2089;
pub const S_BHORIZ4: state = 2088;
pub const S_BHORIZ3: state = 2087;
pub const S_BHORIZ2: state = 2086;
pub const S_BHORIZ1: state = 2085;
pub const S_RHORIZ8: state = 2084;
pub const S_RHORIZ7: state = 2083;
pub const S_RHORIZ6: state = 2082;
pub const S_RHORIZ5: state = 2081;
pub const S_RHORIZ4: state = 2080;
pub const S_RHORIZ3: state = 2079;
pub const S_RHORIZ2: state = 2078;
pub const S_RHORIZ1: state = 2077;
pub const S_YHORIZ8: state = 2076;
pub const S_YHORIZ7: state = 2075;
pub const S_YHORIZ6: state = 2074;
pub const S_YHORIZ5: state = 2073;
pub const S_YHORIZ4: state = 2072;
pub const S_YHORIZ3: state = 2071;
pub const S_YHORIZ2: state = 2070;
pub const S_YHORIZ1: state = 2069;
pub const S_BDIAG8: state = 2068;
pub const S_BDIAG7: state = 2067;
pub const S_BDIAG6: state = 2066;
pub const S_BDIAG5: state = 2065;
pub const S_BDIAG4: state = 2064;
pub const S_BDIAG3: state = 2063;
pub const S_BDIAG2: state = 2062;
pub const S_BDIAG1: state = 2061;
pub const S_RDIAG8: state = 2060;
pub const S_RDIAG7: state = 2059;
pub const S_RDIAG6: state = 2058;
pub const S_RDIAG5: state = 2057;
pub const S_RDIAG4: state = 2056;
pub const S_RDIAG3: state = 2055;
pub const S_RDIAG2: state = 2054;
pub const S_RDIAG1: state = 2053;
pub const S_YDIAG8: state = 2052;
pub const S_YDIAG7: state = 2051;
pub const S_YDIAG6: state = 2050;
pub const S_YDIAG5: state = 2049;
pub const S_YDIAG4: state = 2048;
pub const S_YDIAG3: state = 2047;
pub const S_YDIAG2: state = 2046;
pub const S_YDIAG1: state = 2045;
pub const S_BLUESPRING5: state = 2044;
pub const S_BLUESPRING4: state = 2043;
pub const S_BLUESPRING3: state = 2042;
pub const S_BLUESPRING2: state = 2041;
pub const S_BLUESPRING: state = 2040;
pub const S_REDSPRING5: state = 2039;
pub const S_REDSPRING4: state = 2038;
pub const S_REDSPRING3: state = 2037;
pub const S_REDSPRING2: state = 2036;
pub const S_REDSPRING: state = 2035;
pub const S_YELLOWSPRING5: state = 2034;
pub const S_YELLOWSPRING4: state = 2033;
pub const S_YELLOWSPRING3: state = 2032;
pub const S_YELLOWSPRING2: state = 2031;
pub const S_YELLOWSPRING: state = 2030;
pub const S_BALLOONPOP6: state = 2029;
pub const S_BALLOONPOP5: state = 2028;
pub const S_BALLOONPOP4: state = 2027;
pub const S_BALLOONPOP3: state = 2026;
pub const S_BALLOONPOP2: state = 2025;
pub const S_BALLOONPOP1: state = 2024;
pub const S_BALLOON: state = 2023;
pub const S_BUMPERHIT: state = 2022;
pub const S_BUMPER: state = 2021;
pub const S_STEAM8: state = 2020;
pub const S_STEAM7: state = 2019;
pub const S_STEAM6: state = 2018;
pub const S_STEAM5: state = 2017;
pub const S_STEAM4: state = 2016;
pub const S_STEAM3: state = 2015;
pub const S_STEAM2: state = 2014;
pub const S_STEAM1: state = 2013;
pub const S_FAN5: state = 2012;
pub const S_FAN4: state = 2011;
pub const S_FAN3: state = 2010;
pub const S_FAN2: state = 2009;
pub const S_FAN: state = 2008;
pub const S_SECRETFLICKY_02_CENTER: state = 2007;
pub const S_SECRETFLICKY_02_STAND: state = 2006;
pub const S_SECRETFLICKY_02_FLAP3: state = 2005;
pub const S_SECRETFLICKY_02_FLAP2: state = 2004;
pub const S_SECRETFLICKY_02_FLAP1: state = 2003;
pub const S_SECRETFLICKY_02_OUT: state = 2002;
pub const S_SECRETFLICKY_01_CENTER: state = 2001;
pub const S_SECRETFLICKY_01_STAND: state = 2000;
pub const S_SECRETFLICKY_01_DOWN: state = 1999;
pub const S_SECRETFLICKY_01_UP: state = 1998;
pub const S_SECRETFLICKY_01_HOP: state = 1997;
pub const S_SECRETFLICKY_01_AIM: state = 1996;
pub const S_SECRETFLICKY_01_OUT: state = 1995;
pub const S_FLICKY_16_CENTER: state = 1994;
pub const S_FLICKY_16_STAND: state = 1993;
pub const S_FLICKY_16_FLAP3: state = 1992;
pub const S_FLICKY_16_FLAP2: state = 1991;
pub const S_FLICKY_16_FLAP1: state = 1990;
pub const S_FLICKY_16_OUT: state = 1989;
pub const S_FLICKY_15_CENTER: state = 1988;
pub const S_FLICKY_15_STAND: state = 1987;
pub const S_FLICKY_15_DOWN: state = 1986;
pub const S_FLICKY_15_UP: state = 1985;
pub const S_FLICKY_15_HOP: state = 1984;
pub const S_FLICKY_15_AIM: state = 1983;
pub const S_FLICKY_15_OUT: state = 1982;
pub const S_FLICKY_14_CENTER: state = 1981;
pub const S_FLICKY_14_STAND: state = 1980;
pub const S_FLICKY_14_FLAP3: state = 1979;
pub const S_FLICKY_14_FLAP2: state = 1978;
pub const S_FLICKY_14_FLAP1: state = 1977;
pub const S_FLICKY_14_OUT: state = 1976;
pub const S_FLICKY_13_CENTER: state = 1975;
pub const S_FLICKY_13_STAND: state = 1974;
pub const S_FLICKY_13_DOWN: state = 1973;
pub const S_FLICKY_13_UP: state = 1972;
pub const S_FLICKY_13_HOP: state = 1971;
pub const S_FLICKY_13_AIM: state = 1970;
pub const S_FLICKY_13_OUT: state = 1969;
pub const S_FLICKY_12_CENTER: state = 1968;
pub const S_FLICKY_12_STAND: state = 1967;
pub const S_FLICKY_12_RUN3: state = 1966;
pub const S_FLICKY_12_RUN2: state = 1965;
pub const S_FLICKY_12_RUN1: state = 1964;
pub const S_FLICKY_12_AIM: state = 1963;
pub const S_FLICKY_12_OUT: state = 1962;
pub const S_FLICKY_11_CENTER: state = 1961;
pub const S_FLICKY_11_STAND: state = 1960;
pub const S_FLICKY_11_RUN3: state = 1959;
pub const S_FLICKY_11_RUN2: state = 1958;
pub const S_FLICKY_11_RUN1: state = 1957;
pub const S_FLICKY_11_AIM: state = 1956;
pub const S_FLICKY_11_OUT: state = 1955;
pub const S_FLICKY_10_CENTER: state = 1954;
pub const S_FLICKY_10_STAND: state = 1953;
pub const S_FLICKY_10_FLAP2: state = 1952;
pub const S_FLICKY_10_FLAP1: state = 1951;
pub const S_FLICKY_10_OUT: state = 1950;
pub const S_FLICKY_09_CENTER: state = 1949;
pub const S_FLICKY_09_STAND: state = 1948;
pub const S_FLICKY_09_DOWN: state = 1947;
pub const S_FLICKY_09_UP: state = 1946;
pub const S_FLICKY_09_HOP: state = 1945;
pub const S_FLICKY_09_AIM: state = 1944;
pub const S_FLICKY_09_OUT: state = 1943;
pub const S_FLICKY_08_CENTER: state = 1942;
pub const S_FLICKY_08_STAND: state = 1941;
pub const S_FLICKY_08_SWIM4: state = 1940;
pub const S_FLICKY_08_SWIM3: state = 1939;
pub const S_FLICKY_08_SWIM2: state = 1938;
pub const S_FLICKY_08_SWIM1: state = 1937;
pub const S_FLICKY_08_FLAP4: state = 1936;
pub const S_FLICKY_08_FLAP3: state = 1935;
pub const S_FLICKY_08_FLAP2: state = 1934;
pub const S_FLICKY_08_FLAP1: state = 1933;
pub const S_FLICKY_08_HOP: state = 1932;
pub const S_FLICKY_08_AIM: state = 1931;
pub const S_FLICKY_08_OUT: state = 1930;
pub const S_FLICKY_07_CENTER: state = 1929;
pub const S_FLICKY_07_STAND: state = 1928;
pub const S_FLICKY_07_SWIM3: state = 1927;
pub const S_FLICKY_07_SWIM2: state = 1926;
pub const S_FLICKY_07_SWIM1: state = 1925;
pub const S_FLICKY_07_DOWNR: state = 1924;
pub const S_FLICKY_07_UPR: state = 1923;
pub const S_FLICKY_07_HOPR: state = 1922;
pub const S_FLICKY_07_AIMR: state = 1921;
pub const S_FLICKY_07_DOWNL: state = 1920;
pub const S_FLICKY_07_UPL: state = 1919;
pub const S_FLICKY_07_HOPL: state = 1918;
pub const S_FLICKY_07_AIML: state = 1917;
pub const S_FLICKY_07_OUT: state = 1916;
pub const S_FLICKY_06_CENTER: state = 1915;
pub const S_FLICKY_06_STAND: state = 1914;
pub const S_FLICKY_06_DOWN: state = 1913;
pub const S_FLICKY_06_UP: state = 1912;
pub const S_FLICKY_06_HOP: state = 1911;
pub const S_FLICKY_06_AIM: state = 1910;
pub const S_FLICKY_06_OUT: state = 1909;
pub const S_FLICKY_05_CENTER: state = 1908;
pub const S_FLICKY_05_STAND: state = 1907;
pub const S_FLICKY_05_DOWN: state = 1906;
pub const S_FLICKY_05_UP: state = 1905;
pub const S_FLICKY_05_HOP: state = 1904;
pub const S_FLICKY_05_AIM: state = 1903;
pub const S_FLICKY_05_OUT: state = 1902;
pub const S_FLICKY_04_CENTER: state = 1901;
pub const S_FLICKY_04_STAND: state = 1900;
pub const S_FLICKY_04_SWIM4: state = 1899;
pub const S_FLICKY_04_SWIM3: state = 1898;
pub const S_FLICKY_04_SWIM2: state = 1897;
pub const S_FLICKY_04_SWIM1: state = 1896;
pub const S_FLICKY_04_DOWN: state = 1895;
pub const S_FLICKY_04_UP: state = 1894;
pub const S_FLICKY_04_HOP: state = 1893;
pub const S_FLICKY_04_AIM: state = 1892;
pub const S_FLICKY_04_OUT: state = 1891;
pub const S_FLICKY_03_CENTER: state = 1890;
pub const S_FLICKY_03_STAND: state = 1889;
pub const S_FLICKY_03_FLAP2: state = 1888;
pub const S_FLICKY_03_FLAP1: state = 1887;
pub const S_FLICKY_03_UP: state = 1886;
pub const S_FLICKY_03_HOP: state = 1885;
pub const S_FLICKY_03_AIM: state = 1884;
pub const S_FLICKY_03_OUT: state = 1883;
pub const S_FLICKY_02_CENTER: state = 1882;
pub const S_FLICKY_02_STAND: state = 1881;
pub const S_FLICKY_02_DOWN: state = 1880;
pub const S_FLICKY_02_UP: state = 1879;
pub const S_FLICKY_02_HOP: state = 1878;
pub const S_FLICKY_02_AIM: state = 1877;
pub const S_FLICKY_02_OUT: state = 1876;
pub const S_FLICKY_01_CENTER: state = 1875;
pub const S_FLICKY_01_STAND: state = 1874;
pub const S_FLICKY_01_FLAP3: state = 1873;
pub const S_FLICKY_01_FLAP2: state = 1872;
pub const S_FLICKY_01_FLAP1: state = 1871;
pub const S_FLICKY_01_OUT: state = 1870;
pub const S_FLICKY_BUBBLE: state = 1869;
pub const S_SSPK5: state = 1868;
pub const S_SSPK4: state = 1867;
pub const S_SSPK3: state = 1866;
pub const S_SSPK2: state = 1865;
pub const S_SSPK1: state = 1864;
pub const S_IVSP: state = 1863;
pub const S_THUNDERCOIN_SPARK: state = 1862;
pub const S_ZAPSB11: state = 1861;
pub const S_ZAPSB10: state = 1860;
pub const S_ZAPSB9: state = 1859;
pub const S_ZAPSB8: state = 1858;
pub const S_ZAPSB7: state = 1857;
pub const S_ZAPSB6: state = 1856;
pub const S_ZAPSB5: state = 1855;
pub const S_ZAPSB4: state = 1854;
pub const S_ZAPSB3: state = 1853;
pub const S_ZAPSB2: state = 1852;
pub const S_ZAPSB1: state = 1851;
pub const S_ZAPS16: state = 1850;
pub const S_ZAPS15: state = 1849;
pub const S_ZAPS14: state = 1848;
pub const S_ZAPS13: state = 1847;
pub const S_ZAPS12: state = 1846;
pub const S_ZAPS11: state = 1845;
pub const S_ZAPS10: state = 1844;
pub const S_ZAPS9: state = 1843;
pub const S_ZAPS8: state = 1842;
pub const S_ZAPS7: state = 1841;
pub const S_ZAPS6: state = 1840;
pub const S_ZAPS5: state = 1839;
pub const S_ZAPS4: state = 1838;
pub const S_ZAPS3: state = 1837;
pub const S_ZAPS2: state = 1836;
pub const S_ZAPS1: state = 1835;
pub const S_BUBSB6: state = 1834;
pub const S_BUBSB5: state = 1833;
pub const S_BUBSB4: state = 1832;
pub const S_BUBSB3: state = 1831;
pub const S_BUBSB2: state = 1830;
pub const S_BUBSB1: state = 1829;
pub const S_BUBS11: state = 1828;
pub const S_BUBS10: state = 1827;
pub const S_BUBS9: state = 1826;
pub const S_BUBS8: state = 1825;
pub const S_BUBS7: state = 1824;
pub const S_BUBS6: state = 1823;
pub const S_BUBS5: state = 1822;
pub const S_BUBS4: state = 1821;
pub const S_BUBS3: state = 1820;
pub const S_BUBS2: state = 1819;
pub const S_BUBS1: state = 1818;
pub const S_FIRSB10: state = 1817;
pub const S_FIRSB9: state = 1816;
pub const S_FIRSB8: state = 1815;
pub const S_FIRSB7: state = 1814;
pub const S_FIRSB6: state = 1813;
pub const S_FIRSB5: state = 1812;
pub const S_FIRSB4: state = 1811;
pub const S_FIRSB3: state = 1810;
pub const S_FIRSB2: state = 1809;
pub const S_FIRSB1: state = 1808;
pub const S_FIRS11: state = 1807;
pub const S_FIRS10: state = 1806;
pub const S_FIRS9: state = 1805;
pub const S_FIRS8: state = 1804;
pub const S_FIRS7: state = 1803;
pub const S_FIRS6: state = 1802;
pub const S_FIRS5: state = 1801;
pub const S_FIRS4: state = 1800;
pub const S_FIRS3: state = 1799;
pub const S_FIRS2: state = 1798;
pub const S_FIRS1: state = 1797;
pub const S_PITY12: state = 1796;
pub const S_PITY11: state = 1795;
pub const S_PITY10: state = 1794;
pub const S_PITY9: state = 1793;
pub const S_PITY8: state = 1792;
pub const S_PITY7: state = 1791;
pub const S_PITY6: state = 1790;
pub const S_PITY5: state = 1789;
pub const S_PITY4: state = 1788;
pub const S_PITY3: state = 1787;
pub const S_PITY2: state = 1786;
pub const S_PITY1: state = 1785;
pub const S_ELEMF10: state = 1784;
pub const S_ELEMF9: state = 1783;
pub const S_ELEMF8: state = 1782;
pub const S_ELEMF7: state = 1781;
pub const S_ELEMF6: state = 1780;
pub const S_ELEMF5: state = 1779;
pub const S_ELEMF4: state = 1778;
pub const S_ELEMF3: state = 1777;
pub const S_ELEMF2: state = 1776;
pub const S_ELEMF1: state = 1775;
pub const S_ELEM14: state = 1774;
pub const S_ELEM13: state = 1773;
pub const S_ELEM12: state = 1772;
pub const S_ELEM11: state = 1771;
pub const S_ELEM10: state = 1770;
pub const S_ELEM9: state = 1769;
pub const S_ELEM8: state = 1768;
pub const S_ELEM7: state = 1767;
pub const S_ELEM6: state = 1766;
pub const S_ELEM5: state = 1765;
pub const S_ELEM4: state = 1764;
pub const S_ELEM3: state = 1763;
pub const S_ELEM2: state = 1762;
pub const S_ELEM1: state = 1761;
pub const S_FORC21: state = 1760;
pub const S_FORC20: state = 1759;
pub const S_FORC19: state = 1758;
pub const S_FORC18: state = 1757;
pub const S_FORC17: state = 1756;
pub const S_FORC16: state = 1755;
pub const S_FORC15: state = 1754;
pub const S_FORC14: state = 1753;
pub const S_FORC13: state = 1752;
pub const S_FORC12: state = 1751;
pub const S_FORC11: state = 1750;
pub const S_FORC10: state = 1749;
pub const S_FORC9: state = 1748;
pub const S_FORC8: state = 1747;
pub const S_FORC7: state = 1746;
pub const S_FORC6: state = 1745;
pub const S_FORC5: state = 1744;
pub const S_FORC4: state = 1743;
pub const S_FORC3: state = 1742;
pub const S_FORC2: state = 1741;
pub const S_FORC1: state = 1740;
pub const S_MAGN13: state = 1739;
pub const S_MAGN12: state = 1738;
pub const S_MAGN11: state = 1737;
pub const S_MAGN10: state = 1736;
pub const S_MAGN9: state = 1735;
pub const S_MAGN8: state = 1734;
pub const S_MAGN7: state = 1733;
pub const S_MAGN6: state = 1732;
pub const S_MAGN5: state = 1731;
pub const S_MAGN4: state = 1730;
pub const S_MAGN3: state = 1729;
pub const S_MAGN2: state = 1728;
pub const S_MAGN1: state = 1727;
pub const S_WIND8: state = 1726;
pub const S_WIND7: state = 1725;
pub const S_WIND6: state = 1724;
pub const S_WIND5: state = 1723;
pub const S_WIND4: state = 1722;
pub const S_WIND3: state = 1721;
pub const S_WIND2: state = 1720;
pub const S_WIND1: state = 1719;
pub const S_ARMB32: state = 1718;
pub const S_ARMB31: state = 1717;
pub const S_ARMB30: state = 1716;
pub const S_ARMB29: state = 1715;
pub const S_ARMB28: state = 1714;
pub const S_ARMB27: state = 1713;
pub const S_ARMB26: state = 1712;
pub const S_ARMB25: state = 1711;
pub const S_ARMB24: state = 1710;
pub const S_ARMB23: state = 1709;
pub const S_ARMB22: state = 1708;
pub const S_ARMB21: state = 1707;
pub const S_ARMB20: state = 1706;
pub const S_ARMB19: state = 1705;
pub const S_ARMB18: state = 1704;
pub const S_ARMB17: state = 1703;
pub const S_ARMB16: state = 1702;
pub const S_ARMB15: state = 1701;
pub const S_ARMB14: state = 1700;
pub const S_ARMB13: state = 1699;
pub const S_ARMB12: state = 1698;
pub const S_ARMB11: state = 1697;
pub const S_ARMB10: state = 1696;
pub const S_ARMB9: state = 1695;
pub const S_ARMB8: state = 1694;
pub const S_ARMB7: state = 1693;
pub const S_ARMB6: state = 1692;
pub const S_ARMB5: state = 1691;
pub const S_ARMB4: state = 1690;
pub const S_ARMB3: state = 1689;
pub const S_ARMB2: state = 1688;
pub const S_ARMB1: state = 1687;
pub const S_ARMF32: state = 1686;
pub const S_ARMF31: state = 1685;
pub const S_ARMF30: state = 1684;
pub const S_ARMF29: state = 1683;
pub const S_ARMF28: state = 1682;
pub const S_ARMF27: state = 1681;
pub const S_ARMF26: state = 1680;
pub const S_ARMF25: state = 1679;
pub const S_ARMF24: state = 1678;
pub const S_ARMF23: state = 1677;
pub const S_ARMF22: state = 1676;
pub const S_ARMF21: state = 1675;
pub const S_ARMF20: state = 1674;
pub const S_ARMF19: state = 1673;
pub const S_ARMF18: state = 1672;
pub const S_ARMF17: state = 1671;
pub const S_ARMF16: state = 1670;
pub const S_ARMF15: state = 1669;
pub const S_ARMF14: state = 1668;
pub const S_ARMF13: state = 1667;
pub const S_ARMF12: state = 1666;
pub const S_ARMF11: state = 1665;
pub const S_ARMF10: state = 1664;
pub const S_ARMF9: state = 1663;
pub const S_ARMF8: state = 1662;
pub const S_ARMF7: state = 1661;
pub const S_ARMF6: state = 1660;
pub const S_ARMF5: state = 1659;
pub const S_ARMF4: state = 1658;
pub const S_ARMF3: state = 1657;
pub const S_ARMF2: state = 1656;
pub const S_ARMF1: state = 1655;
pub const S_ARMA16: state = 1654;
pub const S_ARMA15: state = 1653;
pub const S_ARMA14: state = 1652;
pub const S_ARMA13: state = 1651;
pub const S_ARMA12: state = 1650;
pub const S_ARMA11: state = 1649;
pub const S_ARMA10: state = 1648;
pub const S_ARMA9: state = 1647;
pub const S_ARMA8: state = 1646;
pub const S_ARMA7: state = 1645;
pub const S_ARMA6: state = 1644;
pub const S_ARMA5: state = 1643;
pub const S_ARMA4: state = 1642;
pub const S_ARMA3: state = 1641;
pub const S_ARMA2: state = 1640;
pub const S_ARMA1: state = 1639;
pub const S_EGGSTATUE2: state = 1638;
pub const S_DBALL6: state = 1637;
pub const S_DBALL5: state = 1636;
pub const S_DBALL4: state = 1635;
pub const S_DBALL3: state = 1634;
pub const S_DBALL2: state = 1633;
pub const S_DBALL1: state = 1632;
pub const S_PALMTREE_TOP: state = 1631;
pub const S_PALMTREE_TRUNK: state = 1630;
pub const S_BIG_PALMTREE_TOP: state = 1629;
pub const S_BIG_PALMTREE_TRUNK: state = 1628;
pub const S_BSZCLOVER: state = 1627;
pub const S_BSZSHRUB: state = 1626;
pub const S_BSZVINE_ORANGE: state = 1625;
pub const S_BSZVINE_YELLOW: state = 1624;
pub const S_BSZVINE_CYAN: state = 1623;
pub const S_BSZVINE_BLUE: state = 1622;
pub const S_BSZVINE_PURPLE: state = 1621;
pub const S_BSZVINE_RED: state = 1620;
pub const S_BSZBUSH_ORANGE: state = 1619;
pub const S_BSZBUSH_YELLOW: state = 1618;
pub const S_BSZBUSH_CYAN: state = 1617;
pub const S_BSZBUSH_BLUE: state = 1616;
pub const S_BSZBUSH_PURPLE: state = 1615;
pub const S_BSZBUSH_RED: state = 1614;
pub const S_BSZCLUSTER_ORANGE: state = 1613;
pub const S_BSZCLUSTER_YELLOW: state = 1612;
pub const S_BSZCLUSTER_CYAN: state = 1611;
pub const S_BSZCLUSTER_BLUE: state = 1610;
pub const S_BSZCLUSTER_PURPLE: state = 1609;
pub const S_BSZCLUSTER_RED: state = 1608;
pub const S_BSZTULIP_ORANGE: state = 1607;
pub const S_BSZTULIP_YELLOW: state = 1606;
pub const S_BSZTULIP_CYAN: state = 1605;
pub const S_BSZTULIP_BLUE: state = 1604;
pub const S_BSZTULIP_PURPLE: state = 1603;
pub const S_BSZTULIP_RED: state = 1602;
pub const S_BSZSHORTFLOWER_ORANGE: state = 1601;
pub const S_BSZSHORTFLOWER_YELLOW: state = 1600;
pub const S_BSZSHORTFLOWER_CYAN: state = 1599;
pub const S_BSZSHORTFLOWER_BLUE: state = 1598;
pub const S_BSZSHORTFLOWER_PURPLE: state = 1597;
pub const S_BSZSHORTFLOWER_RED: state = 1596;
pub const S_BSZFLOWER_ORANGE: state = 1595;
pub const S_BSZFLOWER_YELLOW: state = 1594;
pub const S_BSZFLOWER_CYAN: state = 1593;
pub const S_BSZFLOWER_BLUE: state = 1592;
pub const S_BSZFLOWER_PURPLE: state = 1591;
pub const S_BSZFLOWER_RED: state = 1590;
pub const S_BSZTALLFLOWER_ORANGE: state = 1589;
pub const S_BSZTALLFLOWER_YELLOW: state = 1588;
pub const S_BSZTALLFLOWER_CYAN: state = 1587;
pub const S_BSZTALLFLOWER_BLUE: state = 1586;
pub const S_BSZTALLFLOWER_PURPLE: state = 1585;
pub const S_BSZTALLFLOWER_RED: state = 1584;
pub const S_HHZSTALAGMITE_SHORT: state = 1583;
pub const S_HHZSTALAGMITE_TALL: state = 1582;
pub const S_HHZTENT2: state = 1581;
pub const S_HHZTENT1: state = 1580;
pub const S_HHZGRASS: state = 1579;
pub const S_HHZSHROOM_16: state = 1578;
pub const S_HHZSHROOM_15: state = 1577;
pub const S_HHZSHROOM_14: state = 1576;
pub const S_HHZSHROOM_13: state = 1575;
pub const S_HHZSHROOM_12: state = 1574;
pub const S_HHZSHROOM_11: state = 1573;
pub const S_HHZSHROOM_10: state = 1572;
pub const S_HHZSHROOM_9: state = 1571;
pub const S_HHZSHROOM_8: state = 1570;
pub const S_HHZSHROOM_7: state = 1569;
pub const S_HHZSHROOM_6: state = 1568;
pub const S_HHZSHROOM_5: state = 1567;
pub const S_HHZSHROOM_4: state = 1566;
pub const S_HHZSHROOM_3: state = 1565;
pub const S_HHZSHROOM_2: state = 1564;
pub const S_HHZSHROOM_1: state = 1563;
pub const S_HHZTREE_LEAF: state = 1562;
pub const S_HHZTREE_TRUNK: state = 1561;
pub const S_HHZTREE_TOP: state = 1560;
pub const S_JACKO3OVERLAY_4: state = 1559;
pub const S_JACKO3OVERLAY_3: state = 1558;
pub const S_JACKO3OVERLAY_2: state = 1557;
pub const S_JACKO3OVERLAY_1: state = 1556;
pub const S_JACKO3: state = 1555;
pub const S_JACKO2OVERLAY_4: state = 1554;
pub const S_JACKO2OVERLAY_3: state = 1553;
pub const S_JACKO2OVERLAY_2: state = 1552;
pub const S_JACKO2OVERLAY_1: state = 1551;
pub const S_JACKO2: state = 1550;
pub const S_JACKO1OVERLAY_4: state = 1549;
pub const S_JACKO1OVERLAY_3: state = 1548;
pub const S_JACKO1OVERLAY_2: state = 1547;
pub const S_JACKO1OVERLAY_1: state = 1546;
pub const S_JACKO1: state = 1545;
pub const S_ROSY_UNHAPPY: state = 1544;
pub const S_ROSY_STND: state = 1543;
pub const S_ROSY_PAIN: state = 1542;
pub const S_ROSY_HUG: state = 1541;
pub const S_ROSY_WALK: state = 1540;
pub const S_ROSY_JUMP: state = 1539;
pub const S_ROSY_IDLE4: state = 1538;
pub const S_ROSY_IDLE3: state = 1537;
pub const S_ROSY_IDLE2: state = 1536;
pub const S_ROSY_IDLE1: state = 1535;
pub const S_FHZICE2: state = 1534;
pub const S_FHZICE1: state = 1533;
pub const S_XMASBUSH: state = 1532;
pub const S_XMASBERRYBUSH: state = 1531;
pub const S_XMASBLUEBERRYBUSH: state = 1530;
pub const S_MISTLETOE: state = 1529;
pub const S_HANGSTAR: state = 1528;
pub const S_LAMPPOST2: state = 1527;
pub const S_LAMPPOST1: state = 1526;
pub const S_SNOWMANHAT: state = 1525;
pub const S_SNOWMAN: state = 1524;
pub const S_CANDYCANE: state = 1523;
pub const S_XMASPOLE: state = 1522;
pub const S_STG9: state = 1521;
pub const S_STG8: state = 1520;
pub const S_STG7: state = 1519;
pub const S_STG6: state = 1518;
pub const S_STG5: state = 1517;
pub const S_STG4: state = 1516;
pub const S_STG3: state = 1515;
pub const S_STG2: state = 1514;
pub const S_STG1: state = 1513;
pub const S_STG0: state = 1512;
pub const S_BLUEGARGOYLE: state = 1511;
pub const S_GREENFLAME: state = 1510;
pub const S_TARGET_ALLDONE: state = 1509;
pub const S_TARGET_RESPAWN: state = 1508;
pub const S_TARGET_HIT2: state = 1507;
pub const S_TARGET_HIT1: state = 1506;
pub const S_TARGET_IDLE: state = 1505;
pub const S_GLAREGOYLELONG_COOLDOWN: state = 1504;
pub const S_GLAREGOYLELONG_LOOP: state = 1503;
pub const S_GLAREGOYLELONG_FIRE: state = 1502;
pub const S_GLAREGOYLELONG_HOLD: state = 1501;
pub const S_GLAREGOYLELONG_BLINK: state = 1500;
pub const S_GLAREGOYLELONG_CHARGE: state = 1499;
pub const S_GLAREGOYLELONG: state = 1498;
pub const S_GLAREGOYLEDOWN_COOLDOWN: state = 1497;
pub const S_GLAREGOYLEDOWN_LOOP: state = 1496;
pub const S_GLAREGOYLEDOWN_FIRE: state = 1495;
pub const S_GLAREGOYLEDOWN_HOLD: state = 1494;
pub const S_GLAREGOYLEDOWN_BLINK: state = 1493;
pub const S_GLAREGOYLEDOWN_CHARGE: state = 1492;
pub const S_GLAREGOYLEDOWN: state = 1491;
pub const S_GLAREGOYLEUP_COOLDOWN: state = 1490;
pub const S_GLAREGOYLEUP_LOOP: state = 1489;
pub const S_GLAREGOYLEUP_FIRE: state = 1488;
pub const S_GLAREGOYLEUP_HOLD: state = 1487;
pub const S_GLAREGOYLEUP_BLINK: state = 1486;
pub const S_GLAREGOYLEUP_CHARGE: state = 1485;
pub const S_GLAREGOYLEUP: state = 1484;
pub const S_GLAREGOYLE_COOLDOWN: state = 1483;
pub const S_GLAREGOYLE_LOOP: state = 1482;
pub const S_GLAREGOYLE_FIRE: state = 1481;
pub const S_GLAREGOYLE_HOLD: state = 1480;
pub const S_GLAREGOYLE_BLINK: state = 1479;
pub const S_GLAREGOYLE_CHARGE: state = 1478;
pub const S_GLAREGOYLE: state = 1477;
pub const S_WALLVINE_SHORT: state = 1476;
pub const S_WALLVINE_LONG: state = 1475;
pub const S_TORCHFLOWER: state = 1474;
pub const S_JUNGLEPALM: state = 1473;
pub const S_BIGFERN2: state = 1472;
pub const S_BIGFERN1: state = 1471;
pub const S_BIGFERNLEAF: state = 1470;
pub const S_ROLLOUTROCK: state = 1469;
pub const S_ROLLOUTSPAWN: state = 1468;
pub const S_LAVAFALLROCK: state = 1467;
pub const S_LAVAFALL_LAVA3: state = 1466;
pub const S_LAVAFALL_LAVA2: state = 1465;
pub const S_LAVAFALL_LAVA1: state = 1464;
pub const S_LAVAFALL_SHOOT: state = 1463;
pub const S_LAVAFALL_TELL: state = 1462;
pub const S_LAVAFALL_DORMANT: state = 1461;
pub const S_FLAMEJETFLAMEB3: state = 1460;
pub const S_FLAMEJETFLAMEB2: state = 1459;
pub const S_FLAMEJETFLAMEB1: state = 1458;
pub const S_FJSPINAXISB2: state = 1457;
pub const S_FJSPINAXISB1: state = 1456;
pub const S_FJSPINAXISA2: state = 1455;
pub const S_FJSPINAXISA1: state = 1454;
pub const S_FLAMEJETFLAME9: state = 1453;
pub const S_FLAMEJETFLAME8: state = 1452;
pub const S_FLAMEJETFLAME7: state = 1451;
pub const S_FLAMEJETFLAME6: state = 1450;
pub const S_FLAMEJETFLAME5: state = 1449;
pub const S_FLAMEJETFLAME4: state = 1448;
pub const S_FLAMEJETFLAME3: state = 1447;
pub const S_FLAMEJETFLAME2: state = 1446;
pub const S_FLAMEJETFLAME1: state = 1445;
pub const S_FLAMEJETSTOP: state = 1444;
pub const S_FLAMEJETSTART: state = 1443;
pub const S_FLAMEJETSTND: state = 1442;
pub const S_TRAINSTEAM: state = 1441;
pub const S_TRAINDUST: state = 1440;
pub const S_TRAINPUFFMAKER: state = 1439;
pub const S_TRAINCAMEOSPAWNER_5: state = 1438;
pub const S_TRAINCAMEOSPAWNER_4: state = 1437;
pub const S_TRAINCAMEOSPAWNER_3: state = 1436;
pub const S_TRAINCAMEOSPAWNER_2: state = 1435;
pub const S_TRAINCAMEOSPAWNER_1: state = 1434;
pub const S_SALOONDOORCENTER: state = 1433;
pub const S_SALOONDOOR: state = 1432;
pub const S_MINECARTSPARK: state = 1431;
pub const S_MINECARTSIDEMARK2: state = 1430;
pub const S_MINECARTSIDEMARK1: state = 1429;
pub const S_MINECARTSEG_RIGHT: state = 1428;
pub const S_MINECARTSEG_LEFT: state = 1427;
pub const S_MINECARTSEG_BACK: state = 1426;
pub const S_MINECARTSEG_FRONT: state = 1425;
pub const S_MINECARTEND: state = 1424;
pub const S_MINECART_DTH1: state = 1423;
pub const S_MINECART_IDLE: state = 1422;
pub const S_ARIDDUST3: state = 1421;
pub const S_ARIDDUST2: state = 1420;
pub const S_ARIDDUST1: state = 1419;
pub const S_DUSTLAYER5: state = 1418;
pub const S_DUSTLAYER4: state = 1417;
pub const S_DUSTLAYER3: state = 1416;
pub const S_DUSTLAYER2: state = 1415;
pub const S_DUSTLAYER1: state = 1414;
pub const S_DUSTDEVIL: state = 1413;
pub const S_PROXIMITY_TNT_TRIGGER23: state = 1412;
pub const S_PROXIMITY_TNT_TRIGGER22: state = 1411;
pub const S_PROXIMITY_TNT_TRIGGER21: state = 1410;
pub const S_PROXIMITY_TNT_TRIGGER20: state = 1409;
pub const S_PROXIMITY_TNT_TRIGGER19: state = 1408;
pub const S_PROXIMITY_TNT_TRIGGER18: state = 1407;
pub const S_PROXIMITY_TNT_TRIGGER17: state = 1406;
pub const S_PROXIMITY_TNT_TRIGGER16: state = 1405;
pub const S_PROXIMITY_TNT_TRIGGER15: state = 1404;
pub const S_PROXIMITY_TNT_TRIGGER14: state = 1403;
pub const S_PROXIMITY_TNT_TRIGGER13: state = 1402;
pub const S_PROXIMITY_TNT_TRIGGER12: state = 1401;
pub const S_PROXIMITY_TNT_TRIGGER11: state = 1400;
pub const S_PROXIMITY_TNT_TRIGGER10: state = 1399;
pub const S_PROXIMITY_TNT_TRIGGER9: state = 1398;
pub const S_PROXIMITY_TNT_TRIGGER8: state = 1397;
pub const S_PROXIMITY_TNT_TRIGGER7: state = 1396;
pub const S_PROXIMITY_TNT_TRIGGER6: state = 1395;
pub const S_PROXIMITY_TNT_TRIGGER5: state = 1394;
pub const S_PROXIMITY_TNT_TRIGGER4: state = 1393;
pub const S_PROXIMITY_TNT_TRIGGER3: state = 1392;
pub const S_PROXIMITY_TNT_TRIGGER2: state = 1391;
pub const S_PROXIMITY_TNT_TRIGGER1: state = 1390;
pub const S_PROXIMITY_TNT: state = 1389;
pub const S_TNTBARREL_FLYING: state = 1388;
pub const S_TNTBARREL_EXPL7: state = 1387;
pub const S_TNTBARREL_EXPL6: state = 1386;
pub const S_TNTBARREL_EXPL5: state = 1385;
pub const S_TNTBARREL_EXPL4: state = 1384;
pub const S_TNTBARREL_EXPL3: state = 1383;
pub const S_TNTBARREL_EXPL2: state = 1382;
pub const S_TNTBARREL_EXPL1: state = 1381;
pub const S_TNTBARREL_STND1: state = 1380;
pub const S_OILLAMPFLARE: state = 1379;
pub const S_OILLAMP: state = 1378;
pub const S_ARIDSIGN_SHARPTURN: state = 1377;
pub const S_ARIDSIGN_CACTI: state = 1376;
pub const S_ARIDSIGN_CAUTION: state = 1375;
pub const S_CACTISMALLSEG: state = 1374;
pub const S_CACTITINYSEG: state = 1373;
pub const S_CACTI11: state = 1372;
pub const S_CACTI10: state = 1371;
pub const S_CACTI9: state = 1370;
pub const S_CACTI8: state = 1369;
pub const S_CACTI7: state = 1368;
pub const S_CACTI6: state = 1367;
pub const S_CACTI5: state = 1366;
pub const S_CACTI4: state = 1365;
pub const S_CACTI3: state = 1364;
pub const S_CACTI2: state = 1363;
pub const S_CACTI1: state = 1362;
pub const S_LITTLETUMBLEWEED_ROLL8: state = 1361;
pub const S_LITTLETUMBLEWEED_ROLL7: state = 1360;
pub const S_LITTLETUMBLEWEED_ROLL6: state = 1359;
pub const S_LITTLETUMBLEWEED_ROLL5: state = 1358;
pub const S_LITTLETUMBLEWEED_ROLL4: state = 1357;
pub const S_LITTLETUMBLEWEED_ROLL3: state = 1356;
pub const S_LITTLETUMBLEWEED_ROLL2: state = 1355;
pub const S_LITTLETUMBLEWEED_ROLL1: state = 1354;
pub const S_LITTLETUMBLEWEED: state = 1353;
pub const S_BIGTUMBLEWEED_ROLL8: state = 1352;
pub const S_BIGTUMBLEWEED_ROLL7: state = 1351;
pub const S_BIGTUMBLEWEED_ROLL6: state = 1350;
pub const S_BIGTUMBLEWEED_ROLL5: state = 1349;
pub const S_BIGTUMBLEWEED_ROLL4: state = 1348;
pub const S_BIGTUMBLEWEED_ROLL3: state = 1347;
pub const S_BIGTUMBLEWEED_ROLL2: state = 1346;
pub const S_BIGTUMBLEWEED_ROLL1: state = 1345;
pub const S_BIGTUMBLEWEED: state = 1344;
pub const S_BRAMBLES: state = 1343;
pub const S_SUSPICIOUSFACESTABBERSTATUE_BURST2: state = 1342;
pub const S_SUSPICIOUSFACESTABBERSTATUE_BURST1: state = 1341;
pub const S_SUSPICIOUSFACESTABBERSTATUE_WAIT: state = 1340;
pub const S_FACESTABBERSTATUE: state = 1339;
pub const S_CRAWLASTATUE: state = 1338;
pub const S_WAVINGFLAGSEG2: state = 1337;
pub const S_WAVINGFLAGSEG1: state = 1336;
pub const S_WAVINGFLAG: state = 1335;
pub const S_FIRETORCH: state = 1334;
pub const S_FLAMEHOLDER: state = 1333;
pub const S_CANDLEPRICKET: state = 1332;
pub const S_CANDLE: state = 1331;
pub const S_CEZBUSH2: state = 1330;
pub const S_CEZBUSH1: state = 1329;
pub const S_PINETREE: state = 1328;
pub const S_CEZBANNER2: state = 1327;
pub const S_CEZBANNER1: state = 1326;
pub const S_CEZPOLE: state = 1325;
pub const S_CEZFLOWER: state = 1324;
pub const S_BIGFIREBAR16: state = 1323;
pub const S_BIGFIREBAR15: state = 1322;
pub const S_BIGFIREBAR14: state = 1321;
pub const S_BIGFIREBAR13: state = 1320;
pub const S_BIGFIREBAR12: state = 1319;
pub const S_BIGFIREBAR11: state = 1318;
pub const S_BIGFIREBAR10: state = 1317;
pub const S_BIGFIREBAR9: state = 1316;
pub const S_BIGFIREBAR8: state = 1315;
pub const S_BIGFIREBAR7: state = 1314;
pub const S_BIGFIREBAR6: state = 1313;
pub const S_BIGFIREBAR5: state = 1312;
pub const S_BIGFIREBAR4: state = 1311;
pub const S_BIGFIREBAR3: state = 1310;
pub const S_BIGFIREBAR2: state = 1309;
pub const S_BIGFIREBAR1: state = 1308;
pub const S_SMALLFIREBAR16: state = 1307;
pub const S_SMALLFIREBAR15: state = 1306;
pub const S_SMALLFIREBAR14: state = 1305;
pub const S_SMALLFIREBAR13: state = 1304;
pub const S_SMALLFIREBAR12: state = 1303;
pub const S_SMALLFIREBAR11: state = 1302;
pub const S_SMALLFIREBAR10: state = 1301;
pub const S_SMALLFIREBAR9: state = 1300;
pub const S_SMALLFIREBAR8: state = 1299;
pub const S_SMALLFIREBAR7: state = 1298;
pub const S_SMALLFIREBAR6: state = 1297;
pub const S_SMALLFIREBAR5: state = 1296;
pub const S_SMALLFIREBAR4: state = 1295;
pub const S_SMALLFIREBAR3: state = 1294;
pub const S_SMALLFIREBAR2: state = 1293;
pub const S_SMALLFIREBAR1: state = 1292;
pub const S_REDSPRINGBALL5: state = 1291;
pub const S_REDSPRINGBALL4: state = 1290;
pub const S_REDSPRINGBALL3: state = 1289;
pub const S_REDSPRINGBALL2: state = 1288;
pub const S_REDSPRINGBALL: state = 1287;
pub const S_YELLOWSPRINGBALL5: state = 1286;
pub const S_YELLOWSPRINGBALL4: state = 1285;
pub const S_YELLOWSPRINGBALL3: state = 1284;
pub const S_YELLOWSPRINGBALL2: state = 1283;
pub const S_YELLOWSPRINGBALL: state = 1282;
pub const S_BIGGRABCHAIN: state = 1281;
pub const S_SMALLGRABCHAIN: state = 1280;
pub const S_BIGMACE: state = 1279;
pub const S_SMALLMACE: state = 1278;
pub const S_BIGMACECHAIN: state = 1277;
pub const S_SMALLMACECHAIN: state = 1276;
pub const S_SLING2: state = 1275;
pub const S_SLING1: state = 1274;
pub const S_EGGSTATUE1: state = 1273;
pub const S_FLAMEREST: state = 1272;
pub const S_FLAMEPARTICLE: state = 1271;
pub const S_FLAME: state = 1270;
pub const S_CEZCHAIN: state = 1269;
pub const S_LIGHTBEAM12: state = 1268;
pub const S_LIGHTBEAM11: state = 1267;
pub const S_LIGHTBEAM10: state = 1266;
pub const S_LIGHTBEAM9: state = 1265;
pub const S_LIGHTBEAM8: state = 1264;
pub const S_LIGHTBEAM7: state = 1263;
pub const S_LIGHTBEAM6: state = 1262;
pub const S_LIGHTBEAM5: state = 1261;
pub const S_LIGHTBEAM4: state = 1260;
pub const S_LIGHTBEAM3: state = 1259;
pub const S_LIGHTBEAM2: state = 1258;
pub const S_LIGHTBEAM1: state = 1257;
pub const S_DSZ2STALAGMITE: state = 1256;
pub const S_DSZSTALAGMITE: state = 1255;
pub const S_ANIMALGAESEG: state = 1254;
pub const S_ANIMALGAETOP2: state = 1253;
pub const S_ANIMALGAETOP1: state = 1252;
pub const S_KELP: state = 1251;
pub const S_BLUECRYSTAL1: state = 1250;
pub const S_CORAL5: state = 1249;
pub const S_CORAL4: state = 1248;
pub const S_CORAL3: state = 1247;
pub const S_CORAL2: state = 1246;
pub const S_CORAL1: state = 1245;
pub const S_DRIPC2: state = 1244;
pub const S_DRIPC1: state = 1243;
pub const S_DRIPB1: state = 1242;
pub const S_DRIPA4: state = 1241;
pub const S_DRIPA3: state = 1240;
pub const S_DRIPA2: state = 1239;
pub const S_DRIPA1: state = 1238;
pub const S_SEAWEED6: state = 1237;
pub const S_SEAWEED5: state = 1236;
pub const S_SEAWEED4: state = 1235;
pub const S_SEAWEED3: state = 1234;
pub const S_SEAWEED2: state = 1233;
pub const S_SEAWEED1: state = 1232;
pub const S_BIGGARGOYLE: state = 1231;
pub const S_GARGOYLE: state = 1230;
pub const S_ALARM1: state = 1229;
pub const S_THZTREEBRANCH13: state = 1228;
pub const S_THZTREEBRANCH12: state = 1227;
pub const S_THZTREEBRANCH11: state = 1226;
pub const S_THZTREEBRANCH10: state = 1225;
pub const S_THZTREEBRANCH9: state = 1224;
pub const S_THZTREEBRANCH8: state = 1223;
pub const S_THZTREEBRANCH7: state = 1222;
pub const S_THZTREEBRANCH6: state = 1221;
pub const S_THZTREEBRANCH5: state = 1220;
pub const S_THZTREEBRANCH4: state = 1219;
pub const S_THZTREEBRANCH3: state = 1218;
pub const S_THZTREEBRANCH2: state = 1217;
pub const S_THZTREEBRANCH1: state = 1216;
pub const S_THZTREE: state = 1215;
pub const S_THZFLOWERC: state = 1214;
pub const S_THZFLOWERB: state = 1213;
pub const S_THZFLOWERA: state = 1212;
pub const S_SPRINGTREE: state = 1211;
pub const S_BUSHREDTREE: state = 1210;
pub const S_BUSHTREE: state = 1209;
pub const S_POLYGONTREE: state = 1208;
pub const S_FHZPINKTREE: state = 1207;
pub const S_FHZTREE: state = 1206;
pub const S_CHECKERSUNSETTREE: state = 1205;
pub const S_CHECKERTREE: state = 1204;
pub const S_GFZCHERRYTREE: state = 1203;
pub const S_GFZBERRYTREE: state = 1202;
pub const S_GFZTREE: state = 1201;
pub const S_BUSH: state = 1200;
pub const S_BERRYBUSH: state = 1199;
pub const S_BLUEBERRYBUSH: state = 1198;
pub const S_GFZFLOWERC: state = 1197;
pub const S_GFZFLOWERB: state = 1196;
pub const S_GFZFLOWERA: state = 1195;
pub const S_TUTORIALFLOWERF16: state = 1194;
pub const S_TUTORIALFLOWERF15: state = 1193;
pub const S_TUTORIALFLOWERF14: state = 1192;
pub const S_TUTORIALFLOWERF13: state = 1191;
pub const S_TUTORIALFLOWERF12: state = 1190;
pub const S_TUTORIALFLOWERF11: state = 1189;
pub const S_TUTORIALFLOWERF10: state = 1188;
pub const S_TUTORIALFLOWERF9: state = 1187;
pub const S_TUTORIALFLOWERF8: state = 1186;
pub const S_TUTORIALFLOWERF7: state = 1185;
pub const S_TUTORIALFLOWERF6: state = 1184;
pub const S_TUTORIALFLOWERF5: state = 1183;
pub const S_TUTORIALFLOWERF4: state = 1182;
pub const S_TUTORIALFLOWERF3: state = 1181;
pub const S_TUTORIALFLOWERF2: state = 1180;
pub const S_TUTORIALFLOWERF1: state = 1179;
pub const S_TUTORIALFLOWER16: state = 1178;
pub const S_TUTORIALFLOWER15: state = 1177;
pub const S_TUTORIALFLOWER14: state = 1176;
pub const S_TUTORIALFLOWER13: state = 1175;
pub const S_TUTORIALFLOWER12: state = 1174;
pub const S_TUTORIALFLOWER11: state = 1173;
pub const S_TUTORIALFLOWER10: state = 1172;
pub const S_TUTORIALFLOWER9: state = 1171;
pub const S_TUTORIALFLOWER8: state = 1170;
pub const S_TUTORIALFLOWER7: state = 1169;
pub const S_TUTORIALFLOWER6: state = 1168;
pub const S_TUTORIALFLOWER5: state = 1167;
pub const S_TUTORIALFLOWER4: state = 1166;
pub const S_TUTORIALFLOWER3: state = 1165;
pub const S_TUTORIALFLOWER2: state = 1164;
pub const S_TUTORIALFLOWER1: state = 1163;
pub const S_TUTORIALLEAF16: state = 1162;
pub const S_TUTORIALLEAF15: state = 1161;
pub const S_TUTORIALLEAF14: state = 1160;
pub const S_TUTORIALLEAF13: state = 1159;
pub const S_TUTORIALLEAF12: state = 1158;
pub const S_TUTORIALLEAF11: state = 1157;
pub const S_TUTORIALLEAF10: state = 1156;
pub const S_TUTORIALLEAF9: state = 1155;
pub const S_TUTORIALLEAF8: state = 1154;
pub const S_TUTORIALLEAF7: state = 1153;
pub const S_TUTORIALLEAF6: state = 1152;
pub const S_TUTORIALLEAF5: state = 1151;
pub const S_TUTORIALLEAF4: state = 1150;
pub const S_TUTORIALLEAF3: state = 1149;
pub const S_TUTORIALLEAF2: state = 1148;
pub const S_TUTORIALLEAF1: state = 1147;
pub const S_LETTER: state = 1146;
pub const S_DEMONFIRE: state = 1145;
pub const S_ARROWBONK: state = 1144;
pub const S_ARROW: state = 1143;
pub const S_CANNONBALL1: state = 1142;
pub const S_TURRETLASEREXPLODE2: state = 1141;
pub const S_TURRETLASEREXPLODE1: state = 1140;
pub const S_TURRETLASER: state = 1139;
pub const S_JETBULLET2: state = 1138;
pub const S_JETBULLET1: state = 1137;
pub const S_MINE_BOOM4: state = 1136;
pub const S_MINE_BOOM3: state = 1135;
pub const S_MINE_BOOM2: state = 1134;
pub const S_MINE_BOOM1: state = 1133;
pub const S_MINE1: state = 1132;
pub const S_ENERGYBALL2: state = 1131;
pub const S_ENERGYBALL1: state = 1130;
pub const S_TORPEDO: state = 1129;
pub const S_LASERFLAME5: state = 1128;
pub const S_LASERFLAME4: state = 1127;
pub const S_LASERFLAME3: state = 1126;
pub const S_LASERFLAME2: state = 1125;
pub const S_LASERFLAME1: state = 1124;
pub const S_LASERFLASH: state = 1123;
pub const S_LASER2: state = 1122;
pub const S_LASER: state = 1121;
pub const S_ROCKET: state = 1120;
pub const S_THUNDERCOIN_ICON2: state = 1119;
pub const S_THUNDERCOIN_ICON1: state = 1118;
pub const S_BUBBLEWRAP_ICON2: state = 1117;
pub const S_BUBBLEWRAP_ICON1: state = 1116;
pub const S_FLAMEAURA_ICON2: state = 1115;
pub const S_FLAMEAURA_ICON1: state = 1114;
pub const S_SCORE10K_ICON2: state = 1113;
pub const S_SCORE10K_ICON1: state = 1112;
pub const S_SCORE1K_ICON2: state = 1111;
pub const S_SCORE1K_ICON1: state = 1110;
pub const S_RECYCLER_ICON2: state = 1109;
pub const S_RECYCLER_ICON1: state = 1108;
pub const S_GRAVITY_ICON2: state = 1107;
pub const S_GRAVITY_ICON1: state = 1106;
pub const S_MIXUP_ICON2: state = 1105;
pub const S_MIXUP_ICON1: state = 1104;
pub const S_EGGMAN_ICON2: state = 1103;
pub const S_EGGMAN_ICON1: state = 1102;
pub const S_1UP_ICON2: state = 1101;
pub const S_1UP_ICON1: state = 1100;
pub const S_INVULN_ICON2: state = 1099;
pub const S_INVULN_ICON1: state = 1098;
pub const S_SNEAKERS_ICON2: state = 1097;
pub const S_SNEAKERS_ICON1: state = 1096;
pub const S_ELEMENTAL_ICON2: state = 1095;
pub const S_ELEMENTAL_ICON1: state = 1094;
pub const S_WHIRLWIND_ICON2: state = 1093;
pub const S_WHIRLWIND_ICON1: state = 1092;
pub const S_ARMAGEDDON_ICON2: state = 1091;
pub const S_ARMAGEDDON_ICON1: state = 1090;
pub const S_FORCE_ICON2: state = 1089;
pub const S_FORCE_ICON1: state = 1088;
pub const S_ATTRACT_ICON2: state = 1087;
pub const S_ATTRACT_ICON1: state = 1086;
pub const S_PITY_ICON2: state = 1085;
pub const S_PITY_ICON1: state = 1084;
pub const S_RING_ICON2: state = 1083;
pub const S_RING_ICON1: state = 1082;
pub const S_BLUEBOX_POP2: state = 1081;
pub const S_BLUEBOX_POP1: state = 1080;
pub const S_RING_BLUEBOX2: state = 1079;
pub const S_RING_BLUEBOX1: state = 1078;
pub const S_REDBOX_POP2: state = 1077;
pub const S_REDBOX_POP1: state = 1076;
pub const S_RING_REDBOX2: state = 1075;
pub const S_RING_REDBOX1: state = 1074;
pub const S_THUNDERCOIN_GOLDBOX: state = 1073;
pub const S_BUBBLEWRAP_GOLDBOX: state = 1072;
pub const S_FLAMEAURA_GOLDBOX: state = 1071;
pub const S_GRAVITY_GOLDBOX: state = 1070;
pub const S_EGGMAN_GOLDBOX: state = 1069;
pub const S_INVULN_GOLDBOX: state = 1068;
pub const S_SNEAKERS_GOLDBOX: state = 1067;
pub const S_ELEMENTAL_GOLDBOX: state = 1066;
pub const S_WHIRLWIND_GOLDBOX: state = 1065;
pub const S_ARMAGEDDON_GOLDBOX: state = 1064;
pub const S_FORCE_GOLDBOX: state = 1063;
pub const S_ATTRACT_GOLDBOX: state = 1062;
pub const S_PITY_GOLDBOX: state = 1061;
pub const S_THUNDERCOIN_BOX: state = 1060;
pub const S_BUBBLEWRAP_BOX: state = 1059;
pub const S_FLAMEAURA_BOX: state = 1058;
pub const S_SCORE10K_BOX: state = 1057;
pub const S_SCORE1K_BOX: state = 1056;
pub const S_RECYCLER_BOX: state = 1055;
pub const S_GRAVITY_BOX: state = 1054;
pub const S_MIXUP_BOX: state = 1053;
pub const S_EGGMAN_BOX: state = 1052;
pub const S_1UP_BOX: state = 1051;
pub const S_INVULN_BOX: state = 1050;
pub const S_SNEAKERS_BOX: state = 1049;
pub const S_ELEMENTAL_BOX: state = 1048;
pub const S_WHIRLWIND_BOX: state = 1047;
pub const S_ARMAGEDDON_BOX: state = 1046;
pub const S_FORCE_BOX: state = 1045;
pub const S_ATTRACT_BOX: state = 1044;
pub const S_PITY_BOX: state = 1043;
pub const S_RING_BOX: state = 1042;
pub const S_MYSTERY_BOX: state = 1041;
pub const S_GOLDBOX_OFF7: state = 1040;
pub const S_GOLDBOX_OFF6: state = 1039;
pub const S_GOLDBOX_OFF5: state = 1038;
pub const S_GOLDBOX_OFF4: state = 1037;
pub const S_GOLDBOX_OFF3: state = 1036;
pub const S_GOLDBOX_OFF2: state = 1035;
pub const S_GOLDBOX_OFF1: state = 1034;
pub const S_GOLDBOX_FLICKER: state = 1033;
pub const S_BOX_POP2: state = 1032;
pub const S_BOX_POP1: state = 1031;
pub const S_BOX_FLICKER: state = 1030;
pub const S_BOXSPARKLE4: state = 1029;
pub const S_BOXSPARKLE3: state = 1028;
pub const S_BOXSPARKLE2: state = 1027;
pub const S_BOXSPARKLE1: state = 1026;
pub const S_CANNONLAUNCHER3: state = 1025;
pub const S_CANNONLAUNCHER2: state = 1024;
pub const S_CANNONLAUNCHER1: state = 1023;
pub const S_BIGMINE_BLAST5: state = 1022;
pub const S_BIGMINE_BLAST4: state = 1021;
pub const S_BIGMINE_BLAST3: state = 1020;
pub const S_BIGMINE_BLAST2: state = 1019;
pub const S_BIGMINE_BLAST1: state = 1018;
pub const S_BIGMINE_SET3: state = 1017;
pub const S_BIGMINE_SET2: state = 1016;
pub const S_BIGMINE_SET1: state = 1015;
pub const S_BIGMINE_ALERT3: state = 1014;
pub const S_BIGMINE_ALERT2: state = 1013;
pub const S_BIGMINE_ALERT1: state = 1012;
pub const S_BIGMINE_IDLE: state = 1011;
pub const S_STARPOST_ENDSPIN: state = 1010;
pub const S_STARPOST_SPIN: state = 1009;
pub const S_STARPOST_STARTSPIN: state = 1008;
pub const S_STARPOST_FLASH: state = 1007;
pub const S_STARPOST_IDLE: state = 1006;
pub const S_WALLSPIKED2: state = 1005;
pub const S_WALLSPIKED1: state = 1004;
pub const S_WALLSPIKEBASE: state = 1003;
pub const S_WALLSPIKE6: state = 1002;
pub const S_WALLSPIKE5: state = 1001;
pub const S_WALLSPIKE4: state = 1000;
pub const S_WALLSPIKE3: state = 999;
pub const S_WALLSPIKE2: state = 998;
pub const S_WALLSPIKE1: state = 997;
pub const S_SPIKED2: state = 996;
pub const S_SPIKED1: state = 995;
pub const S_SPIKE6: state = 994;
pub const S_SPIKE5: state = 993;
pub const S_SPIKE4: state = 992;
pub const S_SPIKE3: state = 991;
pub const S_SPIKE2: state = 990;
pub const S_SPIKE1: state = 989;
pub const S_TEAM_SPINFIRE6: state = 988;
pub const S_TEAM_SPINFIRE5: state = 987;
pub const S_TEAM_SPINFIRE4: state = 986;
pub const S_TEAM_SPINFIRE3: state = 985;
pub const S_TEAM_SPINFIRE2: state = 984;
pub const S_TEAM_SPINFIRE1: state = 983;
pub const S_SPINFIRE6: state = 982;
pub const S_SPINFIRE5: state = 981;
pub const S_SPINFIRE4: state = 980;
pub const S_SPINFIRE3: state = 979;
pub const S_SPINFIRE2: state = 978;
pub const S_SPINFIRE1: state = 977;
pub const S_SPIKEBALL8: state = 976;
pub const S_SPIKEBALL7: state = 975;
pub const S_SPIKEBALL6: state = 974;
pub const S_SPIKEBALL5: state = 973;
pub const S_SPIKEBALL4: state = 972;
pub const S_SPIKEBALL3: state = 971;
pub const S_SPIKEBALL2: state = 970;
pub const S_SPIKEBALL1: state = 969;
pub const S_CLEARSIGN: state = 968;
pub const S_EGGMANSIGN: state = 967;
pub const S_SIGNBOARD: state = 966;
pub const S_SIGNSTOP: state = 965;
pub const S_SIGNSLOW: state = 964;
pub const S_SIGNPLAYER: state = 963;
pub const S_SIGNSPIN6: state = 962;
pub const S_SIGNSPIN5: state = 961;
pub const S_SIGNSPIN4: state = 960;
pub const S_SIGNSPIN3: state = 959;
pub const S_SIGNSPIN2: state = 958;
pub const S_SIGNSPIN1: state = 957;
pub const S_SIGN: state = 956;
pub const S_BUBBLES4: state = 955;
pub const S_BUBBLES3: state = 954;
pub const S_BUBBLES2: state = 953;
pub const S_BUBBLES1: state = 952;
pub const S_SHRD3: state = 951;
pub const S_SHRD2: state = 950;
pub const S_SHRD1: state = 949;
pub const S_CEMG7: state = 948;
pub const S_CEMG6: state = 947;
pub const S_CEMG5: state = 946;
pub const S_CEMG4: state = 945;
pub const S_CEMG3: state = 944;
pub const S_CEMG2: state = 943;
pub const S_CEMG1: state = 942;
pub const S_EMBLEM26: state = 941;
pub const S_EMBLEM25: state = 940;
pub const S_EMBLEM24: state = 939;
pub const S_EMBLEM23: state = 938;
pub const S_EMBLEM22: state = 937;
pub const S_EMBLEM21: state = 936;
pub const S_EMBLEM20: state = 935;
pub const S_EMBLEM19: state = 934;
pub const S_EMBLEM18: state = 933;
pub const S_EMBLEM17: state = 932;
pub const S_EMBLEM16: state = 931;
pub const S_EMBLEM15: state = 930;
pub const S_EMBLEM14: state = 929;
pub const S_EMBLEM13: state = 928;
pub const S_EMBLEM12: state = 927;
pub const S_EMBLEM11: state = 926;
pub const S_EMBLEM10: state = 925;
pub const S_EMBLEM9: state = 924;
pub const S_EMBLEM8: state = 923;
pub const S_EMBLEM7: state = 922;
pub const S_EMBLEM6: state = 921;
pub const S_EMBLEM5: state = 920;
pub const S_EMBLEM4: state = 919;
pub const S_EMBLEM3: state = 918;
pub const S_EMBLEM2: state = 917;
pub const S_EMBLEM1: state = 916;
pub const S_BLUEFLAG: state = 915;
pub const S_REDFLAG: state = 914;
pub const S_TOKEN: state = 913;
pub const S_TEAMRING: state = 912;
pub const S_GRAVWELLRED: state = 911;
pub const S_GRAVWELLGREEN: state = 910;
pub const S_NIGHTSSTARXMAS: state = 909;
pub const S_NIGHTSSTAR: state = 908;
pub const S_NIGHTSCHIPBONUS: state = 907;
pub const S_NIGHTSCHIP: state = 906;
pub const S_BOMBSPHERE4: state = 905;
pub const S_BOMBSPHERE3: state = 904;
pub const S_BOMBSPHERE2: state = 903;
pub const S_BOMBSPHERE1: state = 902;
pub const S_BLUESPHERESPARK: state = 901;
pub const S_BLUESPHEREBONUS: state = 900;
pub const S_BLUESPHERE: state = 899;
pub const S_RING: state = 898;
pub const S_MSSHIELD_F2: state = 897;
pub const S_MSSHIELD_F1: state = 896;
pub const S_METALSONIC_FLEE2: state = 895;
pub const S_METALSONIC_FLEE1: state = 894;
pub const S_METALSONIC_DEATH4: state = 893;
pub const S_METALSONIC_DEATH3: state = 892;
pub const S_METALSONIC_DEATH2: state = 891;
pub const S_METALSONIC_DEATH1: state = 890;
pub const S_METALSONIC_PAIN: state = 889;
pub const S_METALSONIC_SHOOT: state = 888;
pub const S_METALSONIC_BADBOUNCE: state = 887;
pub const S_METALSONIC_BOUNCE: state = 886;
pub const S_METALSONIC_DASH: state = 885;
pub const S_METALSONIC_GATHER: state = 884;
pub const S_METALSONIC_RAISE: state = 883;
pub const S_METALSONIC_STUN: state = 882;
pub const S_METALSONIC_VECTOR: state = 881;
pub const S_METALSONIC_FLOAT: state = 880;
pub const S_METALSONIC_RACE: state = 879;
pub const S_CYBRAKDEMONVILEEXPLOSION3: state = 878;
pub const S_CYBRAKDEMONVILEEXPLOSION2: state = 877;
pub const S_CYBRAKDEMONVILEEXPLOSION1: state = 876;
pub const S_CYBRAKDEMONNAPALMFLAME_DIE: state = 875;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY6: state = 874;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY5: state = 873;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY4: state = 872;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY3: state = 871;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY2: state = 870;
pub const S_CYBRAKDEMONNAPALMFLAME_FLY1: state = 869;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE5: state = 868;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE4: state = 867;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE3: state = 866;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE2: state = 865;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL_DIE1: state = 864;
pub const S_CYBRAKDEMONNAPALMBOMBSMALL: state = 863;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE4: state = 862;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE3: state = 861;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE2: state = 860;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_DIE1: state = 859;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY4: state = 858;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY3: state = 857;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY2: state = 856;
pub const S_CYBRAKDEMONNAPALMBOMBLARGE_FLY1: state = 855;
pub const S_CYBRAKDEMONTARGETDOT: state = 854;
pub const S_CYBRAKDEMONTARGETRETICULE14: state = 853;
pub const S_CYBRAKDEMONTARGETRETICULE13: state = 852;
pub const S_CYBRAKDEMONTARGETRETICULE12: state = 851;
pub const S_CYBRAKDEMONTARGETRETICULE11: state = 850;
pub const S_CYBRAKDEMONTARGETRETICULE10: state = 849;
pub const S_CYBRAKDEMONTARGETRETICULE9: state = 848;
pub const S_CYBRAKDEMONTARGETRETICULE8: state = 847;
pub const S_CYBRAKDEMONTARGETRETICULE7: state = 846;
pub const S_CYBRAKDEMONTARGETRETICULE6: state = 845;
pub const S_CYBRAKDEMONTARGETRETICULE5: state = 844;
pub const S_CYBRAKDEMONTARGETRETICULE4: state = 843;
pub const S_CYBRAKDEMONTARGETRETICULE3: state = 842;
pub const S_CYBRAKDEMONTARGETRETICULE2: state = 841;
pub const S_CYBRAKDEMONTARGETRETICULE1: state = 840;
pub const S_CYBRAKDEMONELECTRICBARRIER_REVIVE3: state = 839;
pub const S_CYBRAKDEMONELECTRICBARRIER_REVIVE2: state = 838;
pub const S_CYBRAKDEMONELECTRICBARRIER_REVIVE1: state = 837;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMLOOP: state = 836;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMFAIL: state = 835;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM12: state = 834;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM11: state = 833;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM10: state = 832;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM9: state = 831;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM8: state = 830;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM7: state = 829;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM6: state = 828;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM5: state = 827;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM4: state = 826;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM3: state = 825;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM2: state = 824;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOM1: state = 823;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMCHOOSE: state = 822;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMSUCCESS: state = 821;
pub const S_CYBRAKDEMONELECTRICBARRIER_SPARK_RANDOMCHECK: state = 820;
pub const S_CYBRAKDEMONELECTRICBARRIER_DIE3: state = 819;
pub const S_CYBRAKDEMONELECTRICBARRIER_DIE2: state = 818;
pub const S_CYBRAKDEMONELECTRICBARRIER_DIE1: state = 817;
pub const S_CYBRAKDEMONELECTRICBARRIER24: state = 816;
pub const S_CYBRAKDEMONELECTRICBARRIER23: state = 815;
pub const S_CYBRAKDEMONELECTRICBARRIER22: state = 814;
pub const S_CYBRAKDEMONELECTRICBARRIER21: state = 813;
pub const S_CYBRAKDEMONELECTRICBARRIER20: state = 812;
pub const S_CYBRAKDEMONELECTRICBARRIER19: state = 811;
pub const S_CYBRAKDEMONELECTRICBARRIER18: state = 810;
pub const S_CYBRAKDEMONELECTRICBARRIER17: state = 809;
pub const S_CYBRAKDEMONELECTRICBARRIER16: state = 808;
pub const S_CYBRAKDEMONELECTRICBARRIER15: state = 807;
pub const S_CYBRAKDEMONELECTRICBARRIER14: state = 806;
pub const S_CYBRAKDEMONELECTRICBARRIER13: state = 805;
pub const S_CYBRAKDEMONELECTRICBARRIER12: state = 804;
pub const S_CYBRAKDEMONELECTRICBARRIER11: state = 803;
pub const S_CYBRAKDEMONELECTRICBARRIER10: state = 802;
pub const S_CYBRAKDEMONELECTRICBARRIER9: state = 801;
pub const S_CYBRAKDEMONELECTRICBARRIER8: state = 800;
pub const S_CYBRAKDEMONELECTRICBARRIER7: state = 799;
pub const S_CYBRAKDEMONELECTRICBARRIER6: state = 798;
pub const S_CYBRAKDEMONELECTRICBARRIER5: state = 797;
pub const S_CYBRAKDEMONELECTRICBARRIER4: state = 796;
pub const S_CYBRAKDEMONELECTRICBARRIER3: state = 795;
pub const S_CYBRAKDEMONELECTRICBARRIER2: state = 794;
pub const S_CYBRAKDEMONELECTRICBARRIER1: state = 793;
pub const S_CYBRAKDEMONELECTRICBARRIER_PLAYSOUND: state = 792;
pub const S_CYBRAKDEMONELECTRICBARRIER_INIT2: state = 791;
pub const S_CYBRAKDEMONELECTRICBARRIER_INIT1: state = 790;
pub const S_CYBRAKDEMONFLAMEREST: state = 789;
pub const S_CYBRAKDEMONFLAMESHOT_DIE: state = 788;
pub const S_CYBRAKDEMONFLAMESHOT_FLY3: state = 787;
pub const S_CYBRAKDEMONFLAMESHOT_FLY2: state = 786;
pub const S_CYBRAKDEMONFLAMESHOT_FLY1: state = 785;
pub const S_CYBRAKDEMONMISSILE_EXPLODE3: state = 784;
pub const S_CYBRAKDEMONMISSILE_EXPLODE2: state = 783;
pub const S_CYBRAKDEMONMISSILE_EXPLODE1: state = 782;
pub const S_CYBRAKDEMONMISSILE: state = 781;
pub const S_CYBRAKDEMON_INVINCIBLERIZE: state = 780;
pub const S_CYBRAKDEMON_DEINVINCIBLERIZE: state = 779;
pub const S_CYBRAKDEMON_DIE8: state = 778;
pub const S_CYBRAKDEMON_DIE7: state = 777;
pub const S_CYBRAKDEMON_DIE6: state = 776;
pub const S_CYBRAKDEMON_DIE5: state = 775;
pub const S_CYBRAKDEMON_DIE4: state = 774;
pub const S_CYBRAKDEMON_DIE3: state = 773;
pub const S_CYBRAKDEMON_DIE2: state = 772;
pub const S_CYBRAKDEMON_DIE1: state = 771;
pub const S_CYBRAKDEMON_PAIN3: state = 770;
pub const S_CYBRAKDEMON_PAIN2: state = 769;
pub const S_CYBRAKDEMON_PAIN1: state = 768;
pub const S_CYBRAKDEMON_FINISH_ATTACK2: state = 767;
pub const S_CYBRAKDEMON_FINISH_ATTACK1: state = 766;
pub const S_CYBRAKDEMON_NAPALM_ATTACK3: state = 765;
pub const S_CYBRAKDEMON_NAPALM_ATTACK2: state = 764;
pub const S_CYBRAKDEMON_NAPALM_ATTACK1: state = 763;
pub const S_CYBRAKDEMON_VILE_ATTACK6: state = 762;
pub const S_CYBRAKDEMON_VILE_ATTACK5: state = 761;
pub const S_CYBRAKDEMON_VILE_ATTACK4: state = 760;
pub const S_CYBRAKDEMON_VILE_ATTACK3: state = 759;
pub const S_CYBRAKDEMON_VILE_ATTACK2: state = 758;
pub const S_CYBRAKDEMON_VILE_ATTACK1: state = 757;
pub const S_CYBRAKDEMON_CHOOSE_ATTACK2: state = 756;
pub const S_CYBRAKDEMON_FLAME_ATTACK4: state = 755;
pub const S_CYBRAKDEMON_FLAME_ATTACK3: state = 754;
pub const S_CYBRAKDEMON_FLAME_ATTACK2: state = 753;
pub const S_CYBRAKDEMON_FLAME_ATTACK1: state = 752;
pub const S_CYBRAKDEMON_MISSILE_ATTACK6: state = 751;
pub const S_CYBRAKDEMON_MISSILE_ATTACK5: state = 750;
pub const S_CYBRAKDEMON_MISSILE_ATTACK4: state = 749;
pub const S_CYBRAKDEMON_MISSILE_ATTACK3: state = 748;
pub const S_CYBRAKDEMON_MISSILE_ATTACK2: state = 747;
pub const S_CYBRAKDEMON_MISSILE_ATTACK1: state = 746;
pub const S_CYBRAKDEMON_CHOOSE_ATTACK1: state = 745;
pub const S_CYBRAKDEMON_WALK6: state = 744;
pub const S_CYBRAKDEMON_WALK5: state = 743;
pub const S_CYBRAKDEMON_WALK4: state = 742;
pub const S_CYBRAKDEMON_WALK3: state = 741;
pub const S_CYBRAKDEMON_WALK2: state = 740;
pub const S_CYBRAKDEMON_WALK1: state = 739;
pub const S_CYBRAKDEMON_IDLE: state = 738;
pub const S_BLACKEGG_MISSILE: state = 737;
pub const S_BLACKEGG_GOOP7: state = 736;
pub const S_BLACKEGG_GOOP6: state = 735;
pub const S_BLACKEGG_GOOP5: state = 734;
pub const S_BLACKEGG_GOOP4: state = 733;
pub const S_BLACKEGG_GOOP3: state = 732;
pub const S_BLACKEGG_GOOP2: state = 731;
pub const S_BLACKEGG_GOOP1: state = 730;
pub const S_BLACKEGG_HELPER: state = 729;
pub const S_BLACKEGG_DESTROYPLAT3: state = 728;
pub const S_BLACKEGG_DESTROYPLAT2: state = 727;
pub const S_BLACKEGG_DESTROYPLAT1: state = 726;
pub const S_BLACKEGG_JUMP2: state = 725;
pub const S_BLACKEGG_JUMP1: state = 724;
pub const S_BLACKEGG_GOOP: state = 723;
pub const S_BLACKEGG_MISSILE3: state = 722;
pub const S_BLACKEGG_MISSILE2: state = 721;
pub const S_BLACKEGG_MISSILE1: state = 720;
pub const S_BLACKEGG_DIE5: state = 719;
pub const S_BLACKEGG_DIE4: state = 718;
pub const S_BLACKEGG_DIE3: state = 717;
pub const S_BLACKEGG_DIE2: state = 716;
pub const S_BLACKEGG_DIE1: state = 715;
pub const S_BLACKEGG_HITFACE4: state = 714;
pub const S_BLACKEGG_HITFACE3: state = 713;
pub const S_BLACKEGG_HITFACE2: state = 712;
pub const S_BLACKEGG_HITFACE1: state = 711;
pub const S_BLACKEGG_PAIN35: state = 710;
pub const S_BLACKEGG_PAIN34: state = 709;
pub const S_BLACKEGG_PAIN33: state = 708;
pub const S_BLACKEGG_PAIN32: state = 707;
pub const S_BLACKEGG_PAIN31: state = 706;
pub const S_BLACKEGG_PAIN30: state = 705;
pub const S_BLACKEGG_PAIN29: state = 704;
pub const S_BLACKEGG_PAIN28: state = 703;
pub const S_BLACKEGG_PAIN27: state = 702;
pub const S_BLACKEGG_PAIN26: state = 701;
pub const S_BLACKEGG_PAIN25: state = 700;
pub const S_BLACKEGG_PAIN24: state = 699;
pub const S_BLACKEGG_PAIN23: state = 698;
pub const S_BLACKEGG_PAIN22: state = 697;
pub const S_BLACKEGG_PAIN21: state = 696;
pub const S_BLACKEGG_PAIN20: state = 695;
pub const S_BLACKEGG_PAIN19: state = 694;
pub const S_BLACKEGG_PAIN18: state = 693;
pub const S_BLACKEGG_PAIN17: state = 692;
pub const S_BLACKEGG_PAIN16: state = 691;
pub const S_BLACKEGG_PAIN15: state = 690;
pub const S_BLACKEGG_PAIN14: state = 689;
pub const S_BLACKEGG_PAIN13: state = 688;
pub const S_BLACKEGG_PAIN12: state = 687;
pub const S_BLACKEGG_PAIN11: state = 686;
pub const S_BLACKEGG_PAIN10: state = 685;
pub const S_BLACKEGG_PAIN9: state = 684;
pub const S_BLACKEGG_PAIN8: state = 683;
pub const S_BLACKEGG_PAIN7: state = 682;
pub const S_BLACKEGG_PAIN6: state = 681;
pub const S_BLACKEGG_PAIN5: state = 680;
pub const S_BLACKEGG_PAIN4: state = 679;
pub const S_BLACKEGG_PAIN3: state = 678;
pub const S_BLACKEGG_PAIN2: state = 677;
pub const S_BLACKEGG_PAIN1: state = 676;
pub const S_BLACKEGG_SHOOT2: state = 675;
pub const S_BLACKEGG_SHOOT1: state = 674;
pub const S_BLACKEGG_WALK6: state = 673;
pub const S_BLACKEGG_WALK5: state = 672;
pub const S_BLACKEGG_WALK4: state = 671;
pub const S_BLACKEGG_WALK3: state = 670;
pub const S_BLACKEGG_WALK2: state = 669;
pub const S_BLACKEGG_WALK1: state = 668;
pub const S_BLACKEGG_STND2: state = 667;
pub const S_BLACKEGG_STND: state = 666;
pub const S_FSGND: state = 665;
pub const S_FSGNC: state = 664;
pub const S_FSGNB: state = 663;
pub const S_FSGNA: state = 662;
pub const S_TNTDUST_8: state = 661;
pub const S_TNTDUST_7: state = 660;
pub const S_TNTDUST_6: state = 659;
pub const S_TNTDUST_5: state = 658;
pub const S_TNTDUST_4: state = 657;
pub const S_TNTDUST_3: state = 656;
pub const S_TNTDUST_2: state = 655;
pub const S_TNTDUST_1: state = 654;
pub const S_FBOMB_EXPL6: state = 653;
pub const S_FBOMB_EXPL5: state = 652;
pub const S_FBOMB_EXPL4: state = 651;
pub const S_FBOMB_EXPL3: state = 650;
pub const S_FBOMB_EXPL2: state = 649;
pub const S_FBOMB_EXPL1: state = 648;
pub const S_FBOMB2: state = 647;
pub const S_FBOMB1: state = 646;
pub const S_PROJECTORLIGHT5: state = 645;
pub const S_PROJECTORLIGHT4: state = 644;
pub const S_PROJECTORLIGHT3: state = 643;
pub const S_PROJECTORLIGHT2: state = 642;
pub const S_PROJECTORLIGHT1: state = 641;
pub const S_VWREB: state = 640;
pub const S_VWREF: state = 639;
pub const S_ALART2: state = 638;
pub const S_ALART1: state = 637;
pub const S_BROKENROBOTF: state = 636;
pub const S_BROKENROBOTE: state = 635;
pub const S_BROKENROBOTD: state = 634;
pub const S_BROKENROBOTC: state = 633;
pub const S_BROKENROBOTB: state = 632;
pub const S_BROKENROBOTA: state = 631;
pub const S_BROKENROBOTRANDOM: state = 630;
pub const S_FANG_KO: state = 629;
pub const S_FANG_FLEEBOUNCE2: state = 628;
pub const S_FANG_FLEEBOUNCE1: state = 627;
pub const S_FANG_FLEEPATHING2: state = 626;
pub const S_FANG_FLEEPATHING1: state = 625;
pub const S_FANG_DIE8: state = 624;
pub const S_FANG_DIE7: state = 623;
pub const S_FANG_DIE6: state = 622;
pub const S_FANG_DIE5: state = 621;
pub const S_FANG_DIE4: state = 620;
pub const S_FANG_DIE3: state = 619;
pub const S_FANG_DIE2: state = 618;
pub const S_FANG_DIE1: state = 617;
pub const S_FANG_PINCHLOBSHOT4: state = 616;
pub const S_FANG_PINCHLOBSHOT3: state = 615;
pub const S_FANG_PINCHLOBSHOT2: state = 614;
pub const S_FANG_PINCHLOBSHOT1: state = 613;
pub const S_FANG_PINCHLOBSHOT0: state = 612;
pub const S_FANG_PINCHSKID2: state = 611;
pub const S_FANG_PINCHSKID1: state = 610;
pub const S_FANG_PINCHFALL2: state = 609;
pub const S_FANG_PINCHFALL1: state = 608;
pub const S_FANG_PINCHFALL0: state = 607;
pub const S_FANG_PINCHBOUNCE4: state = 606;
pub const S_FANG_PINCHBOUNCE3: state = 605;
pub const S_FANG_PINCHBOUNCE2: state = 604;
pub const S_FANG_PINCHBOUNCE1: state = 603;
pub const S_FANG_PINCHBOUNCE0: state = 602;
pub const S_FANG_PINCHPATHING: state = 601;
pub const S_FANG_PINCHPATHINGSTART2: state = 600;
pub const S_FANG_PINCHPATHINGSTART1: state = 599;
pub const S_FANG_WALLHIT: state = 598;
pub const S_FANG_WAIT2: state = 597;
pub const S_FANG_WAIT1: state = 596;
pub const S_FANG_LOBSHOT2: state = 595;
pub const S_FANG_LOBSHOT1: state = 594;
pub const S_FANG_LOBSHOT0: state = 593;
pub const S_FANG_FIREREPEAT: state = 592;
pub const S_FANG_FIRE4: state = 591;
pub const S_FANG_FIRE3: state = 590;
pub const S_FANG_FIRE2: state = 589;
pub const S_FANG_FIRE1: state = 588;
pub const S_FANG_FIRESTART2: state = 587;
pub const S_FANG_FIRESTART1: state = 586;
pub const S_FANG_CHOOSEATTACK: state = 585;
pub const S_FANG_SKID3: state = 584;
pub const S_FANG_SKID2: state = 583;
pub const S_FANG_SKID1: state = 582;
pub const S_FANG_PATHINGCONT3: state = 581;
pub const S_FANG_PATHINGCONT2: state = 580;
pub const S_FANG_PATHINGCONT1: state = 579;
pub const S_FANG_CHECKPATH2: state = 578;
pub const S_FANG_CHECKPATH1: state = 577;
pub const S_FANG_FALL2: state = 576;
pub const S_FANG_FALL1: state = 575;
pub const S_FANG_BOUNCE4: state = 574;
pub const S_FANG_BOUNCE3: state = 573;
pub const S_FANG_BOUNCE2: state = 572;
pub const S_FANG_BOUNCE1: state = 571;
pub const S_FANG_PATHING: state = 570;
pub const S_FANG_PATHINGSTART2: state = 569;
pub const S_FANG_PATHINGSTART1: state = 568;
pub const S_FANG_PAIN2: state = 567;
pub const S_FANG_PAIN1: state = 566;
pub const S_FANG_IDLE8: state = 565;
pub const S_FANG_IDLE7: state = 564;
pub const S_FANG_IDLE6: state = 563;
pub const S_FANG_IDLE5: state = 562;
pub const S_FANG_IDLE4: state = 561;
pub const S_FANG_IDLE3: state = 560;
pub const S_FANG_IDLE2: state = 559;
pub const S_FANG_IDLE1: state = 558;
pub const S_FANG_IDLE0: state = 557;
pub const S_FANG_CLONE4: state = 556;
pub const S_FANG_CLONE3: state = 555;
pub const S_FANG_CLONE2: state = 554;
pub const S_FANG_CLONE1: state = 553;
pub const S_FANG_INTRO12: state = 552;
pub const S_FANG_INTRO11: state = 551;
pub const S_FANG_INTRO10: state = 550;
pub const S_FANG_INTRO9: state = 549;
pub const S_FANG_INTRO8: state = 548;
pub const S_FANG_INTRO7: state = 547;
pub const S_FANG_INTRO6: state = 546;
pub const S_FANG_INTRO5: state = 545;
pub const S_FANG_INTRO4: state = 544;
pub const S_FANG_INTRO3: state = 543;
pub const S_FANG_INTRO2: state = 542;
pub const S_FANG_INTRO1: state = 541;
pub const S_FANG_INTRO0: state = 540;
pub const S_FANG_SETUP: state = 539;
pub const S_EGGROBOJET: state = 538;
pub const S_EGGROBO1_PISSED: state = 537;
pub const S_EGGROBO1_BSLAP2: state = 536;
pub const S_EGGROBO1_BSLAP1: state = 535;
pub const S_EGGROBO1_STND: state = 534;
pub const S_JETFLAME: state = 533;
pub const S_EGGMOBILE4_MACE_DIE3: state = 532;
pub const S_EGGMOBILE4_MACE_DIE2: state = 531;
pub const S_EGGMOBILE4_MACE_DIE1: state = 530;
pub const S_EGGMOBILE4_MACE: state = 529;
pub const S_EGGMOBILE4_FLEE2: state = 528;
pub const S_EGGMOBILE4_FLEE1: state = 527;
pub const S_EGGMOBILE4_DIE4: state = 526;
pub const S_EGGMOBILE4_DIE3: state = 525;
pub const S_EGGMOBILE4_DIE2: state = 524;
pub const S_EGGMOBILE4_DIE1: state = 523;
pub const S_EGGMOBILE4_PAIN2: state = 522;
pub const S_EGGMOBILE4_PAIN1: state = 521;
pub const S_EGGMOBILE4_RAISE2: state = 520;
pub const S_EGGMOBILE4_RAISE1: state = 519;
pub const S_EGGMOBILE4_RATK6: state = 518;
pub const S_EGGMOBILE4_RATK5: state = 517;
pub const S_EGGMOBILE4_RATK4: state = 516;
pub const S_EGGMOBILE4_RATK3: state = 515;
pub const S_EGGMOBILE4_RATK2: state = 514;
pub const S_EGGMOBILE4_RATK1: state = 513;
pub const S_EGGMOBILE4_LATK6: state = 512;
pub const S_EGGMOBILE4_LATK5: state = 511;
pub const S_EGGMOBILE4_LATK4: state = 510;
pub const S_EGGMOBILE4_LATK3: state = 509;
pub const S_EGGMOBILE4_LATK2: state = 508;
pub const S_EGGMOBILE4_LATK1: state = 507;
pub const S_EGGMOBILE4_STND: state = 506;
pub const S_SHOCKWAVE2: state = 505;
pub const S_SHOCKWAVE1: state = 504;
pub const S_BOSSSEBH2: state = 503;
pub const S_BOSSSEBH1: state = 502;
pub const S_FAKEMOBILE_DIE2: state = 501;
pub const S_FAKEMOBILE_DIE1: state = 500;
pub const S_FAKEMOBILE_ATK3D: state = 499;
pub const S_FAKEMOBILE_ATK3C: state = 498;
pub const S_FAKEMOBILE_ATK3B: state = 497;
pub const S_FAKEMOBILE_ATK3A: state = 496;
pub const S_FAKEMOBILE_ATK2: state = 495;
pub const S_FAKEMOBILE_ATK1: state = 494;
pub const S_FAKEMOBILE: state = 493;
pub const S_FAKEMOBILE_INIT: state = 492;
pub const S_EGGMOBILE3_FLEE2: state = 491;
pub const S_EGGMOBILE3_FLEE1: state = 490;
pub const S_EGGMOBILE3_DIE4: state = 489;
pub const S_EGGMOBILE3_DIE3: state = 488;
pub const S_EGGMOBILE3_DIE2: state = 487;
pub const S_EGGMOBILE3_DIE1: state = 486;
pub const S_EGGMOBILE3_PAIN2: state = 485;
pub const S_EGGMOBILE3_PAIN: state = 484;
pub const S_EGGMOBILE3_ROFL: state = 483;
pub const S_EGGMOBILE3_ATK5: state = 482;
pub const S_EGGMOBILE3_ATK4: state = 481;
pub const S_EGGMOBILE3_ATK3D: state = 480;
pub const S_EGGMOBILE3_ATK3C: state = 479;
pub const S_EGGMOBILE3_ATK3B: state = 478;
pub const S_EGGMOBILE3_ATK3A: state = 477;
pub const S_EGGMOBILE3_ATK2: state = 476;
pub const S_EGGMOBILE3_ATK1: state = 475;
pub const S_EGGMOBILE3_SHOCK: state = 474;
pub const S_EGGMOBILE3_STND: state = 473;
pub const S_GOOPTRAIL: state = 472;
pub const S_GOOP3: state = 471;
pub const S_GOOP2: state = 470;
pub const S_GOOP1: state = 469;
pub const S_BOSSSPIGOT: state = 468;
pub const S_BOSSTANK2: state = 467;
pub const S_BOSSTANK1: state = 466;
pub const S_EGGMOBILE2_FLEE2: state = 465;
pub const S_EGGMOBILE2_FLEE1: state = 464;
pub const S_EGGMOBILE2_DIE4: state = 463;
pub const S_EGGMOBILE2_DIE3: state = 462;
pub const S_EGGMOBILE2_DIE2: state = 461;
pub const S_EGGMOBILE2_DIE1: state = 460;
pub const S_EGGMOBILE2_PAIN2: state = 459;
pub const S_EGGMOBILE2_PAIN: state = 458;
pub const S_EGGMOBILE2_POGO7: state = 457;
pub const S_EGGMOBILE2_POGO6: state = 456;
pub const S_EGGMOBILE2_POGO5: state = 455;
pub const S_EGGMOBILE2_POGO4: state = 454;
pub const S_EGGMOBILE2_POGO3: state = 453;
pub const S_EGGMOBILE2_POGO2: state = 452;
pub const S_EGGMOBILE2_POGO1: state = 451;
pub const S_EGGMOBILE2_STND: state = 450;
pub const S_BOSSEGLZ2: state = 449;
pub const S_BOSSEGLZ1: state = 448;
pub const S_EGGMOBILE_TARGET: state = 447;
pub const S_EGGMOBILE_BALL: state = 446;
pub const S_EGGMOBILE_FLEE2: state = 445;
pub const S_EGGMOBILE_FLEE1: state = 444;
pub const S_EGGMOBILE_DIE4: state = 443;
pub const S_EGGMOBILE_DIE3: state = 442;
pub const S_EGGMOBILE_DIE2: state = 441;
pub const S_EGGMOBILE_DIE1: state = 440;
pub const S_EGGMOBILE_PAIN2: state = 439;
pub const S_EGGMOBILE_PAIN: state = 438;
pub const S_EGGMOBILE_PANIC15: state = 437;
pub const S_EGGMOBILE_PANIC14: state = 436;
pub const S_EGGMOBILE_PANIC13: state = 435;
pub const S_EGGMOBILE_PANIC12: state = 434;
pub const S_EGGMOBILE_PANIC11: state = 433;
pub const S_EGGMOBILE_PANIC10: state = 432;
pub const S_EGGMOBILE_PANIC9: state = 431;
pub const S_EGGMOBILE_PANIC8: state = 430;
pub const S_EGGMOBILE_PANIC7: state = 429;
pub const S_EGGMOBILE_PANIC6: state = 428;
pub const S_EGGMOBILE_PANIC5: state = 427;
pub const S_EGGMOBILE_PANIC4: state = 426;
pub const S_EGGMOBILE_PANIC3: state = 425;
pub const S_EGGMOBILE_PANIC2: state = 424;
pub const S_EGGMOBILE_PANIC1: state = 423;
pub const S_EGGMOBILE_RATK9: state = 422;
pub const S_EGGMOBILE_RATK8: state = 421;
pub const S_EGGMOBILE_RATK7: state = 420;
pub const S_EGGMOBILE_RATK6: state = 419;
pub const S_EGGMOBILE_RATK5: state = 418;
pub const S_EGGMOBILE_RATK4: state = 417;
pub const S_EGGMOBILE_RATK3: state = 416;
pub const S_EGGMOBILE_RATK2: state = 415;
pub const S_EGGMOBILE_RATK1: state = 414;
pub const S_EGGMOBILE_LATK9: state = 413;
pub const S_EGGMOBILE_LATK8: state = 412;
pub const S_EGGMOBILE_LATK7: state = 411;
pub const S_EGGMOBILE_LATK6: state = 410;
pub const S_EGGMOBILE_LATK5: state = 409;
pub const S_EGGMOBILE_LATK4: state = 408;
pub const S_EGGMOBILE_LATK3: state = 407;
pub const S_EGGMOBILE_LATK2: state = 406;
pub const S_EGGMOBILE_LATK1: state = 405;
pub const S_EGGMOBILE_ROFL: state = 404;
pub const S_EGGMOBILE_STND: state = 403;
pub const S_JETFUME1: state = 402;
pub const S_SONIC3KBOSSEXPLOSION6: state = 401;
pub const S_SONIC3KBOSSEXPLOSION5: state = 400;
pub const S_SONIC3KBOSSEXPLOSION4: state = 399;
pub const S_SONIC3KBOSSEXPLOSION3: state = 398;
pub const S_SONIC3KBOSSEXPLOSION2: state = 397;
pub const S_SONIC3KBOSSEXPLOSION1: state = 396;
pub const S_BOSSEXPLODE: state = 395;
pub const S_DRAGONMINE_FASTLOOP: state = 394;
pub const S_DRAGONMINE_FASTFLASH2: state = 393;
pub const S_DRAGONMINE_FASTFLASH1: state = 392;
pub const S_DRAGONMINE_SLOWLOOP: state = 391;
pub const S_DRAGONMINE_SLOWFLASH2: state = 390;
pub const S_DRAGONMINE_SLOWFLASH1: state = 389;
pub const S_DRAGONMINE_LAND2: state = 388;
pub const S_DRAGONMINE_LAND1: state = 387;
pub const S_DRAGONMINE: state = 386;
pub const S_DRAGONTAIL_RELOAD: state = 385;
pub const S_DRAGONTAIL_EMPTYLOOP: state = 384;
pub const S_DRAGONTAIL_EMPTY: state = 383;
pub const S_DRAGONTAIL_LOADED: state = 382;
pub const S_DRAGONWING4: state = 381;
pub const S_DRAGONWING3: state = 380;
pub const S_DRAGONWING2: state = 379;
pub const S_DRAGONWING1: state = 378;
pub const S_DRAGONBOMBER: state = 377;
pub const S_PTERABYTE_SWOOPUP: state = 376;
pub const S_PTERABYTE_SWOOPDOWN: state = 375;
pub const S_PTERABYTE_FLY4: state = 374;
pub const S_PTERABYTE_FLY3: state = 373;
pub const S_PTERABYTE_FLY2: state = 372;
pub const S_PTERABYTE_FLY1: state = 371;
pub const S_PTERABYTEWAYPOINT: state = 370;
pub const S_PTERABYTESPAWNER: state = 369;
pub const S_PYREFIRE2: state = 368;
pub const S_PYREFIRE1: state = 367;
pub const S_PYREFLY_BURN: state = 366;
pub const S_PYREFLY_FLY: state = 365;
pub const S_CANARIVOREGAS_8: state = 364;
pub const S_CANARIVOREGAS_7: state = 363;
pub const S_CANARIVOREGAS_6: state = 362;
pub const S_CANARIVOREGAS_5: state = 361;
pub const S_CANARIVOREGAS_4: state = 360;
pub const S_CANARIVOREGAS_3: state = 359;
pub const S_CANARIVOREGAS_2: state = 358;
pub const S_CANARIVOREGAS_1: state = 357;
pub const S_CANARIVORE_CLOSE2: state = 356;
pub const S_CANARIVORE_CLOSE1: state = 355;
pub const S_CANARIVORE_GASREPEAT: state = 354;
pub const S_CANARIVORE_GAS5: state = 353;
pub const S_CANARIVORE_GAS4: state = 352;
pub const S_CANARIVORE_GAS3: state = 351;
pub const S_CANARIVORE_GAS2: state = 350;
pub const S_CANARIVORE_GAS1: state = 349;
pub const S_CANARIVORE_AWAKEN3: state = 348;
pub const S_CANARIVORE_AWAKEN2: state = 347;
pub const S_CANARIVORE_AWAKEN1: state = 346;
pub const S_CANARIVORE_LOOK: state = 345;
pub const S_UNIDUS_BALL: state = 344;
pub const S_UNIDUS_RUN: state = 343;
pub const S_UNIDUS_STND: state = 342;
pub const S_YSHELL_SPRING4: state = 341;
pub const S_YSHELL_SPRING3: state = 340;
pub const S_YSHELL_SPRING2: state = 339;
pub const S_YSHELL_SPRING1: state = 338;
pub const S_YSHELL_RUN4: state = 337;
pub const S_YSHELL_RUN3: state = 336;
pub const S_YSHELL_RUN2: state = 335;
pub const S_YSHELL_RUN1: state = 334;
pub const S_YSHELL_STND: state = 333;
pub const S_SSHELL_SPRING4: state = 332;
pub const S_SSHELL_SPRING3: state = 331;
pub const S_SSHELL_SPRING2: state = 330;
pub const S_SSHELL_SPRING1: state = 329;
pub const S_SSHELL_RUN4: state = 328;
pub const S_SSHELL_RUN3: state = 327;
pub const S_SSHELL_RUN2: state = 326;
pub const S_SSHELL_RUN1: state = 325;
pub const S_SSHELL_STND: state = 324;
pub const S_MINUSDIRT7: state = 323;
pub const S_MINUSDIRT6: state = 322;
pub const S_MINUSDIRT5: state = 321;
pub const S_MINUSDIRT4: state = 320;
pub const S_MINUSDIRT3: state = 319;
pub const S_MINUSDIRT2: state = 318;
pub const S_MINUSDIRT1: state = 317;
pub const S_MINUS_AERIAL4: state = 316;
pub const S_MINUS_AERIAL3: state = 315;
pub const S_MINUS_AERIAL2: state = 314;
pub const S_MINUS_AERIAL1: state = 313;
pub const S_MINUS_POPUP: state = 312;
pub const S_MINUS_BURST5: state = 311;
pub const S_MINUS_BURST4: state = 310;
pub const S_MINUS_BURST3: state = 309;
pub const S_MINUS_BURST2: state = 308;
pub const S_MINUS_BURST1: state = 307;
pub const S_MINUS_BURST0: state = 306;
pub const S_MINUS_DIGGING4: state = 305;
pub const S_MINUS_DIGGING3: state = 304;
pub const S_MINUS_DIGGING2: state = 303;
pub const S_MINUS_DIGGING1: state = 302;
pub const S_MINUS_STND: state = 301;
pub const S_MINUS_INIT: state = 300;
pub const S_SNAPPER_HEAD: state = 299;
pub const S_SNAPPER_LEGRAISE: state = 298;
pub const S_SNAPPER_LEG: state = 297;
pub const S_SNAPPER_XPLD: state = 296;
pub const S_GSNAPPER4: state = 295;
pub const S_GSNAPPER3: state = 294;
pub const S_GSNAPPER2: state = 293;
pub const S_GSNAPPER1: state = 292;
pub const S_GSNAPPER_STND: state = 291;
pub const S_SNAPPER_SPAWN2: state = 290;
pub const S_SNAPPER_SPAWN: state = 289;
pub const S_EGGSHIELDBREAK: state = 288;
pub const S_EGGSHIELD: state = 287;
pub const S_EGGGUARD_RUN4: state = 286;
pub const S_EGGGUARD_RUN3: state = 285;
pub const S_EGGGUARD_RUN2: state = 284;
pub const S_EGGGUARD_RUN1: state = 283;
pub const S_EGGGUARD_MAD3: state = 282;
pub const S_EGGGUARD_MAD2: state = 281;
pub const S_EGGGUARD_MAD1: state = 280;
pub const S_EGGGUARD_WALK4: state = 279;
pub const S_EGGGUARD_WALK3: state = 278;
pub const S_EGGGUARD_WALK2: state = 277;
pub const S_EGGGUARD_WALK1: state = 276;
pub const S_EGGGUARD_STND: state = 275;
pub const S_FACESTABBERSPEAR: state = 274;
pub const S_FACESTABBER_DIE3: state = 273;
pub const S_FACESTABBER_DIE2: state = 272;
pub const S_FACESTABBER_DIE1: state = 271;
pub const S_FACESTABBER_PAIN: state = 270;
pub const S_FACESTABBER_CHARGE4: state = 269;
pub const S_FACESTABBER_CHARGE3: state = 268;
pub const S_FACESTABBER_CHARGE2: state = 267;
pub const S_FACESTABBER_CHARGE1: state = 266;
pub const S_FACESTABBER_STND6: state = 265;
pub const S_FACESTABBER_STND5: state = 264;
pub const S_FACESTABBER_STND4: state = 263;
pub const S_FACESTABBER_STND3: state = 262;
pub const S_FACESTABBER_STND2: state = 261;
pub const S_FACESTABBER_STND1: state = 260;
pub const S_ROBOHOOD_JUMP3: state = 259;
pub const S_ROBOHOOD_JUMP2: state = 258;
pub const S_ROBOHOOD_JUMP1: state = 257;
pub const S_ROBOHOOD_FIRE2: state = 256;
pub const S_ROBOHOOD_FIRE1: state = 255;
pub const S_ROBOHOOD_STAND: state = 254;
pub const S_ROBOHOOD_LOOK: state = 253;
pub const S_POINTYBALL1: state = 252;
pub const S_POINTY1: state = 251;
pub const S_VULTURE_STUNNED: state = 250;
pub const S_VULTURE_ZOOM2: state = 249;
pub const S_VULTURE_ZOOM1: state = 248;
pub const S_VULTURE_DRIFT: state = 247;
pub const S_VULTURE_STND: state = 246;
pub const S_SNAILER_FLICKY: state = 245;
pub const S_SNAILER1: state = 244;
pub const S_JETJAW_SOUND: state = 243;
pub const S_JETJAW_CHOMP16: state = 242;
pub const S_JETJAW_CHOMP15: state = 241;
pub const S_JETJAW_CHOMP14: state = 240;
pub const S_JETJAW_CHOMP13: state = 239;
pub const S_JETJAW_CHOMP12: state = 238;
pub const S_JETJAW_CHOMP11: state = 237;
pub const S_JETJAW_CHOMP10: state = 236;
pub const S_JETJAW_CHOMP9: state = 235;
pub const S_JETJAW_CHOMP8: state = 234;
pub const S_JETJAW_CHOMP7: state = 233;
pub const S_JETJAW_CHOMP6: state = 232;
pub const S_JETJAW_CHOMP5: state = 231;
pub const S_JETJAW_CHOMP4: state = 230;
pub const S_JETJAW_CHOMP3: state = 229;
pub const S_JETJAW_CHOMP2: state = 228;
pub const S_JETJAW_CHOMP1: state = 227;
pub const S_JETJAW_ROAM8: state = 226;
pub const S_JETJAW_ROAM7: state = 225;
pub const S_JETJAW_ROAM6: state = 224;
pub const S_JETJAW_ROAM5: state = 223;
pub const S_JETJAW_ROAM4: state = 222;
pub const S_JETJAW_ROAM3: state = 221;
pub const S_JETJAW_ROAM2: state = 220;
pub const S_JETJAW_ROAM1: state = 219;
pub const S_CDIAG8: state = 218;
pub const S_CDIAG7: state = 217;
pub const S_CDIAG6: state = 216;
pub const S_CDIAG5: state = 215;
pub const S_CDIAG4: state = 214;
pub const S_CDIAG3: state = 213;
pub const S_CDIAG2: state = 212;
pub const S_CDIAG1: state = 211;
pub const S_BANPYURA_ROAMPAUSE: state = 210;
pub const S_BANPYURA_ROAM4: state = 209;
pub const S_BANPYURA_ROAM3: state = 208;
pub const S_BANPYURA_ROAM2: state = 207;
pub const S_BANPYURA_ROAM1: state = 206;
pub const S_CRUSHCHAIN: state = 205;
pub const S_CRUSHCLAW_WAIT: state = 204;
pub const S_CRUSHCLAW_IN: state = 203;
pub const S_CRUSHCLAW_STAY: state = 202;
pub const S_CRUSHCLAW_OUT: state = 201;
pub const S_CRUSHCLAW_AIM: state = 200;
pub const S_CRUSHSTACEAN_PUNCH2: state = 199;
pub const S_CRUSHSTACEAN_PUNCH1: state = 198;
pub const S_CRUSHSTACEAN_ROAMPAUSE: state = 197;
pub const S_CRUSHSTACEAN_ROAM4: state = 196;
pub const S_CRUSHSTACEAN_ROAM3: state = 195;
pub const S_CRUSHSTACEAN_ROAM2: state = 194;
pub const S_CRUSHSTACEAN_ROAM1: state = 193;
pub const S_SPINCUSHION_STOP4: state = 192;
pub const S_SPINCUSHION_STOP3: state = 191;
pub const S_SPINCUSHION_STOP2: state = 190;
pub const S_SPINCUSHION_STOP1: state = 189;
pub const S_SPINCUSHION_SPIN4: state = 188;
pub const S_SPINCUSHION_SPIN3: state = 187;
pub const S_SPINCUSHION_SPIN2: state = 186;
pub const S_SPINCUSHION_SPIN1: state = 185;
pub const S_SPINCUSHION_AIM5: state = 184;
pub const S_SPINCUSHION_AIM4: state = 183;
pub const S_SPINCUSHION_AIM3: state = 182;
pub const S_SPINCUSHION_AIM2: state = 181;
pub const S_SPINCUSHION_AIM1: state = 180;
pub const S_SPINCUSHION_CHASE4: state = 179;
pub const S_SPINCUSHION_CHASE3: state = 178;
pub const S_SPINCUSHION_CHASE2: state = 177;
pub const S_SPINCUSHION_CHASE1: state = 176;
pub const S_SPINCUSHION_LOOK: state = 175;
pub const S_TURRETPOPDOWN8: state = 174;
pub const S_TURRETPOPDOWN7: state = 173;
pub const S_TURRETPOPDOWN6: state = 172;
pub const S_TURRETPOPDOWN5: state = 171;
pub const S_TURRETPOPDOWN4: state = 170;
pub const S_TURRETPOPDOWN3: state = 169;
pub const S_TURRETPOPDOWN2: state = 168;
pub const S_TURRETPOPDOWN1: state = 167;
pub const S_TURRETSHOOT: state = 166;
pub const S_TURRETPOPUP8: state = 165;
pub const S_TURRETPOPUP7: state = 164;
pub const S_TURRETPOPUP6: state = 163;
pub const S_TURRETPOPUP5: state = 162;
pub const S_TURRETPOPUP4: state = 161;
pub const S_TURRETPOPUP3: state = 160;
pub const S_TURRETPOPUP2: state = 159;
pub const S_TURRETPOPUP1: state = 158;
pub const S_TURRETSEE: state = 157;
pub const S_TURRETLOOK: state = 156;
pub const S_TURRETSHOCK9: state = 155;
pub const S_TURRETSHOCK8: state = 154;
pub const S_TURRETSHOCK7: state = 153;
pub const S_TURRETSHOCK6: state = 152;
pub const S_TURRETSHOCK5: state = 151;
pub const S_TURRETSHOCK4: state = 150;
pub const S_TURRETSHOCK3: state = 149;
pub const S_TURRETSHOCK2: state = 148;
pub const S_TURRETSHOCK1: state = 147;
pub const S_TURRETFIRE: state = 146;
pub const S_TURRET: state = 145;
pub const S_SKIM4: state = 144;
pub const S_SKIM3: state = 143;
pub const S_SKIM2: state = 142;
pub const S_SKIM1: state = 141;
pub const S_DETON15: state = 140;
pub const S_DETON14: state = 139;
pub const S_DETON13: state = 138;
pub const S_DETON12: state = 137;
pub const S_DETON11: state = 136;
pub const S_DETON10: state = 135;
pub const S_DETON9: state = 134;
pub const S_DETON8: state = 133;
pub const S_DETON7: state = 132;
pub const S_DETON6: state = 131;
pub const S_DETON5: state = 130;
pub const S_DETON4: state = 129;
pub const S_DETON3: state = 128;
pub const S_DETON2: state = 127;
pub const S_DETON1: state = 126;
pub const S_CCOMMAND4: state = 125;
pub const S_CCOMMAND3: state = 124;
pub const S_CCOMMAND2: state = 123;
pub const S_CCOMMAND1: state = 122;
pub const S_JETGSHOOT2: state = 121;
pub const S_JETGSHOOT1: state = 120;
pub const S_JETGZOOM2: state = 119;
pub const S_JETGZOOM1: state = 118;
pub const S_JETGLOOK2: state = 117;
pub const S_JETGLOOK1: state = 116;
pub const S_JETBZOOM2: state = 115;
pub const S_JETBZOOM1: state = 114;
pub const S_JETBLOOK2: state = 113;
pub const S_JETBLOOK1: state = 112;
pub const S_RBUZZFLY2: state = 111;
pub const S_RBUZZFLY1: state = 110;
pub const S_RBUZZLOOK2: state = 109;
pub const S_RBUZZLOOK1: state = 108;
pub const S_BUZZFLY2: state = 107;
pub const S_BUZZFLY1: state = 106;
pub const S_BUZZLOOK2: state = 105;
pub const S_BUZZLOOK1: state = 104;
pub const S_FISH4: state = 103;
pub const S_FISH3: state = 102;
pub const S_FISH2: state = 101;
pub const S_FISH1: state = 100;
pub const S_SPOS_RUN6: state = 99;
pub const S_SPOS_RUN5: state = 98;
pub const S_SPOS_RUN4: state = 97;
pub const S_SPOS_RUN3: state = 96;
pub const S_SPOS_RUN2: state = 95;
pub const S_SPOS_RUN1: state = 94;
pub const S_SPOS_STND: state = 93;
pub const S_POSS_RUN6: state = 92;
pub const S_POSS_RUN5: state = 91;
pub const S_POSS_RUN4: state = 90;
pub const S_POSS_RUN3: state = 89;
pub const S_POSS_RUN2: state = 88;
pub const S_POSS_RUN1: state = 87;
pub const S_POSS_STND: state = 86;
pub const S_JETFUMEFLASH: state = 85;
pub const S_TAILSOVERLAY_DASH: state = 84;
pub const S_TAILSOVERLAY_EDGE: state = 83;
pub const S_TAILSOVERLAY_GASP: state = 82;
pub const S_TAILSOVERLAY_PAIN: state = 81;
pub const S_TAILSOVERLAY_TIRE: state = 80;
pub const S_TAILSOVERLAY_FLY: state = 79;
pub const S_TAILSOVERLAY_RUN: state = 78;
pub const S_TAILSOVERLAY_MINUS60DEGREES: state = 77;
pub const S_TAILSOVERLAY_MINUS30DEGREES: state = 76;
pub const S_TAILSOVERLAY_PLUS60DEGREES: state = 75;
pub const S_TAILSOVERLAY_PLUS30DEGREES: state = 74;
pub const S_TAILSOVERLAY_0DEGREES: state = 73;
pub const S_TAILSOVERLAY_STAND: state = 72;
pub const S_PLAY_NIGHTS_ATTACK: state = 71;
pub const S_PLAY_NIGHTS_PULL: state = 70;
pub const S_PLAY_NIGHTS_STUN: state = 69;
pub const S_PLAY_NIGHTS_DRILL: state = 68;
pub const S_PLAY_NIGHTS_FLY: state = 67;
pub const S_PLAY_NIGHTS_FLOAT: state = 66;
pub const S_PLAY_NIGHTS_STAND: state = 65;
pub const S_PLAY_NIGHTS_TRANS6: state = 64;
pub const S_PLAY_NIGHTS_TRANS5: state = 63;
pub const S_PLAY_NIGHTS_TRANS4: state = 62;
pub const S_PLAY_NIGHTS_TRANS3: state = 61;
pub const S_PLAY_NIGHTS_TRANS2: state = 60;
pub const S_PLAY_NIGHTS_TRANS1: state = 59;
pub const S_PLAY_SIGN: state = 58;
pub const S_PLAY_ICON3: state = 57;
pub const S_PLAY_ICON2: state = 56;
pub const S_PLAY_ICON1: state = 55;
pub const S_PLAY_BOX2: state = 54;
pub const S_PLAY_BOX1: state = 53;
pub const S_OBJPLACE_DUMMY: state = 52;
pub const S_PLAY_SUPER_TRANS6: state = 51;
pub const S_PLAY_SUPER_TRANS5: state = 50;
pub const S_PLAY_SUPER_TRANS4: state = 49;
pub const S_PLAY_SUPER_TRANS3: state = 48;
pub const S_PLAY_SUPER_TRANS2: state = 47;
pub const S_PLAY_SUPER_TRANS1: state = 46;
pub const S_PLAY_MELEE_LANDING: state = 45;
pub const S_PLAY_MELEE_FINISH: state = 44;
pub const S_PLAY_MELEE: state = 43;
pub const S_PLAY_TWINSPIN: state = 42;
pub const S_PLAY_FIRE_FINISH: state = 41;
pub const S_PLAY_FIRE: state = 40;
pub const S_PLAY_BOUNCE_LANDING: state = 39;
pub const S_PLAY_BOUNCE: state = 38;
pub const S_PLAY_FLOAT_RUN: state = 37;
pub const S_PLAY_FLOAT: state = 36;
pub const S_PLAY_CLIMB: state = 35;
pub const S_PLAY_CLING: state = 34;
pub const S_PLAY_GLIDE_LANDING: state = 33;
pub const S_PLAY_GLIDE: state = 32;
pub const S_PLAY_FLY_TIRED: state = 31;
pub const S_PLAY_SWIM: state = 30;
pub const S_PLAY_FLY: state = 29;
pub const S_PLAY_SPINDASH: state = 28;
pub const S_PLAY_RIDE: state = 27;
pub const S_PLAY_EDGE: state = 26;
pub const S_PLAY_FALL: state = 25;
pub const S_PLAY_SPRING: state = 24;
pub const S_PLAY_JUMP: state = 23;
pub const S_PLAY_GASP: state = 22;
pub const S_PLAY_ROLL: state = 21;
pub const S_PLAY_DRWN: state = 20;
pub const S_PLAY_DEAD: state = 19;
pub const S_PLAY_STUN: state = 18;
pub const S_PLAY_PAIN: state = 17;
pub const S_PLAY_DASH: state = 16;
pub const S_PLAY_RUN: state = 15;
pub const S_PLAY_SKID: state = 14;
pub const S_PLAY_WALK: state = 13;
pub const S_PLAY_WAIT: state = 12;
pub const S_PLAY_STND: state = 11;
pub const S_THOK: state = 10;
pub const S_RAISESTATE: state = 9;
pub const S_XDEATHSTATE: state = 8;
pub const S_DEATHSTATE: state = 7;
pub const S_MISSILESTATE: state = 6;
pub const S_MELEESTATE: state = 5;
pub const S_SEESTATE: state = 4;
pub const S_SPAWNSTATE: state = 3;
pub const S_INVISIBLE: state = 2;
pub const S_UNKNOWN: state = 1;
pub const S_NULL: state = 0;
pub type sfxenum_t = libc::c_uint;
pub const NUMSFX: sfxenum_t = 3008;
pub const sfx_lastskinsoundslot: sfxenum_t = 3007;
pub const sfx_skinsoundslot0: sfxenum_t = 2336;
pub const sfx_lastfreeslot: sfxenum_t = 2335;
pub const sfx_freeslot0: sfxenum_t = 736;
pub const sfx_kc6e: sfxenum_t = 735;
pub const sfx_kc6d: sfxenum_t = 734;
pub const sfx_kc6c: sfxenum_t = 733;
pub const sfx_kc6b: sfxenum_t = 732;
pub const sfx_kc69: sfxenum_t = 731;
pub const sfx_kc68: sfxenum_t = 730;
pub const sfx_kc67: sfxenum_t = 729;
pub const sfx_kc66: sfxenum_t = 728;
pub const sfx_kc65: sfxenum_t = 727;
pub const sfx_kc64: sfxenum_t = 726;
pub const sfx_kc63: sfxenum_t = 725;
pub const sfx_kc62: sfxenum_t = 724;
pub const sfx_kc61: sfxenum_t = 723;
pub const sfx_kc60: sfxenum_t = 722;
pub const sfx_kc5f: sfxenum_t = 721;
pub const sfx_kc5e: sfxenum_t = 720;
pub const sfx_kc5d: sfxenum_t = 719;
pub const sfx_kc5c: sfxenum_t = 718;
pub const sfx_kc5b: sfxenum_t = 717;
pub const sfx_kc5a: sfxenum_t = 716;
pub const sfx_kc59: sfxenum_t = 715;
pub const sfx_kc58: sfxenum_t = 714;
pub const sfx_kc57: sfxenum_t = 713;
pub const sfx_kc56: sfxenum_t = 712;
pub const sfx_kc55: sfxenum_t = 711;
pub const sfx_kc54: sfxenum_t = 710;
pub const sfx_kc53: sfxenum_t = 709;
pub const sfx_kc52: sfxenum_t = 708;
pub const sfx_kc51: sfxenum_t = 707;
pub const sfx_kc50: sfxenum_t = 706;
pub const sfx_kc4f: sfxenum_t = 705;
pub const sfx_kc4e: sfxenum_t = 704;
pub const sfx_kc4d: sfxenum_t = 703;
pub const sfx_kc4c: sfxenum_t = 702;
pub const sfx_kc4b: sfxenum_t = 701;
pub const sfx_kc4a: sfxenum_t = 700;
pub const sfx_kc49: sfxenum_t = 699;
pub const sfx_kc48: sfxenum_t = 698;
pub const sfx_kc47: sfxenum_t = 697;
pub const sfx_kc46: sfxenum_t = 696;
pub const sfx_kc45: sfxenum_t = 695;
pub const sfx_kc44: sfxenum_t = 694;
pub const sfx_kc43: sfxenum_t = 693;
pub const sfx_kc42: sfxenum_t = 692;
pub const sfx_kc41: sfxenum_t = 691;
pub const sfx_kc40: sfxenum_t = 690;
pub const sfx_kc3f: sfxenum_t = 689;
pub const sfx_kc3e: sfxenum_t = 688;
pub const sfx_kc3d: sfxenum_t = 687;
pub const sfx_kc3c: sfxenum_t = 686;
pub const sfx_kc3b: sfxenum_t = 685;
pub const sfx_kc3a: sfxenum_t = 684;
pub const sfx_kc39: sfxenum_t = 683;
pub const sfx_kc38: sfxenum_t = 682;
pub const sfx_kc37: sfxenum_t = 681;
pub const sfx_kc36: sfxenum_t = 680;
pub const sfx_kc35: sfxenum_t = 679;
pub const sfx_kc34: sfxenum_t = 678;
pub const sfx_kc33: sfxenum_t = 677;
pub const sfx_kc32: sfxenum_t = 676;
pub const sfx_kc31: sfxenum_t = 675;
pub const sfx_kc30: sfxenum_t = 674;
pub const sfx_kc2f: sfxenum_t = 673;
pub const sfx_kc2e: sfxenum_t = 672;
pub const sfx_kc2d: sfxenum_t = 671;
pub const sfx_kc2c: sfxenum_t = 670;
pub const sfx_kc2b: sfxenum_t = 669;
pub const sfx_kc2a: sfxenum_t = 668;
pub const sfx_cdpcm9: sfxenum_t = 667;
pub const sfx_cdpcm8: sfxenum_t = 666;
pub const sfx_cdpcm7: sfxenum_t = 665;
pub const sfx_cdpcm6: sfxenum_t = 664;
pub const sfx_cdpcm5: sfxenum_t = 663;
pub const sfx_cdpcm4: sfxenum_t = 662;
pub const sfx_cdpcm3: sfxenum_t = 661;
pub const sfx_cdpcm2: sfxenum_t = 660;
pub const sfx_cdpcm1: sfxenum_t = 659;
pub const sfx_cdpcm0: sfxenum_t = 658;
pub const sfx_cdfm79: sfxenum_t = 657;
pub const sfx_cdfm78: sfxenum_t = 656;
pub const sfx_cdfm77: sfxenum_t = 655;
pub const sfx_cdfm76: sfxenum_t = 654;
pub const sfx_cdfm75: sfxenum_t = 653;
pub const sfx_cdfm74: sfxenum_t = 652;
pub const sfx_cdfm73: sfxenum_t = 651;
pub const sfx_cdfm72: sfxenum_t = 650;
pub const sfx_cdfm71: sfxenum_t = 649;
pub const sfx_cdfm70: sfxenum_t = 648;
pub const sfx_cdfm69: sfxenum_t = 647;
pub const sfx_cdfm68: sfxenum_t = 646;
pub const sfx_cdfm67: sfxenum_t = 645;
pub const sfx_cdfm66: sfxenum_t = 644;
pub const sfx_cdfm65: sfxenum_t = 643;
pub const sfx_cdfm64: sfxenum_t = 642;
pub const sfx_cdfm63: sfxenum_t = 641;
pub const sfx_cdfm62: sfxenum_t = 640;
pub const sfx_cdfm61: sfxenum_t = 639;
pub const sfx_cdfm60: sfxenum_t = 638;
pub const sfx_cdfm59: sfxenum_t = 637;
pub const sfx_cdfm58: sfxenum_t = 636;
pub const sfx_cdfm57: sfxenum_t = 635;
pub const sfx_cdfm56: sfxenum_t = 634;
pub const sfx_cdfm55: sfxenum_t = 633;
pub const sfx_cdfm54: sfxenum_t = 632;
pub const sfx_cdfm53: sfxenum_t = 631;
pub const sfx_cdfm52: sfxenum_t = 630;
pub const sfx_cdfm51: sfxenum_t = 629;
pub const sfx_cdfm50: sfxenum_t = 628;
pub const sfx_cdfm49: sfxenum_t = 627;
pub const sfx_cdfm48: sfxenum_t = 626;
pub const sfx_cdfm47: sfxenum_t = 625;
pub const sfx_cdfm46: sfxenum_t = 624;
pub const sfx_cdfm45: sfxenum_t = 623;
pub const sfx_cdfm44: sfxenum_t = 622;
pub const sfx_cdfm43: sfxenum_t = 621;
pub const sfx_cdfm42: sfxenum_t = 620;
pub const sfx_cdfm41: sfxenum_t = 619;
pub const sfx_cdfm40: sfxenum_t = 618;
pub const sfx_cdfm39: sfxenum_t = 617;
pub const sfx_cdfm38: sfxenum_t = 616;
pub const sfx_cdfm37: sfxenum_t = 615;
pub const sfx_cdfm36: sfxenum_t = 614;
pub const sfx_cdfm35: sfxenum_t = 613;
pub const sfx_cdfm34: sfxenum_t = 612;
pub const sfx_cdfm33: sfxenum_t = 611;
pub const sfx_cdfm32: sfxenum_t = 610;
pub const sfx_cdfm31: sfxenum_t = 609;
pub const sfx_cdfm30: sfxenum_t = 608;
pub const sfx_cdfm29: sfxenum_t = 607;
pub const sfx_cdfm28: sfxenum_t = 606;
pub const sfx_cdfm27: sfxenum_t = 605;
pub const sfx_cdfm26: sfxenum_t = 604;
pub const sfx_cdfm25: sfxenum_t = 603;
pub const sfx_cdfm24: sfxenum_t = 602;
pub const sfx_cdfm23: sfxenum_t = 601;
pub const sfx_cdfm22: sfxenum_t = 600;
pub const sfx_cdfm21: sfxenum_t = 599;
pub const sfx_cdfm20: sfxenum_t = 598;
pub const sfx_cdfm19: sfxenum_t = 597;
pub const sfx_cdfm18: sfxenum_t = 596;
pub const sfx_cdfm17: sfxenum_t = 595;
pub const sfx_cdfm16: sfxenum_t = 594;
pub const sfx_cdfm15: sfxenum_t = 593;
pub const sfx_cdfm14: sfxenum_t = 592;
pub const sfx_cdfm13: sfxenum_t = 591;
pub const sfx_cdfm12: sfxenum_t = 590;
pub const sfx_cdfm11: sfxenum_t = 589;
pub const sfx_cdfm10: sfxenum_t = 588;
pub const sfx_cdfm09: sfxenum_t = 587;
pub const sfx_cdfm08: sfxenum_t = 586;
pub const sfx_cdfm07: sfxenum_t = 585;
pub const sfx_cdfm06: sfxenum_t = 584;
pub const sfx_cdfm05: sfxenum_t = 583;
pub const sfx_cdfm04: sfxenum_t = 582;
pub const sfx_cdfm03: sfxenum_t = 581;
pub const sfx_cdfm02: sfxenum_t = 580;
pub const sfx_cdfm01: sfxenum_t = 579;
pub const sfx_cdfm00: sfxenum_t = 578;
pub const sfx_3db16: sfxenum_t = 577;
pub const sfx_3db14: sfxenum_t = 576;
pub const sfx_3db09: sfxenum_t = 575;
pub const sfx_3db06: sfxenum_t = 574;
pub const sfx_s3kdbl: sfxenum_t = 573;
pub const sfx_s3kdbs: sfxenum_t = 572;
pub const sfx_s3kdal: sfxenum_t = 571;
pub const sfx_s3kdas: sfxenum_t = 570;
pub const sfx_s3kd9l: sfxenum_t = 569;
pub const sfx_s3kd9s: sfxenum_t = 568;
pub const sfx_s3kd8l: sfxenum_t = 567;
pub const sfx_s3kd8s: sfxenum_t = 566;
pub const sfx_s3kd7l: sfxenum_t = 565;
pub const sfx_s3kd7s: sfxenum_t = 564;
pub const sfx_s3kd6l: sfxenum_t = 563;
pub const sfx_s3kd6s: sfxenum_t = 562;
pub const sfx_s3kd5l: sfxenum_t = 561;
pub const sfx_s3kd5s: sfxenum_t = 560;
pub const sfx_s3kd4l: sfxenum_t = 559;
pub const sfx_s3kd4s: sfxenum_t = 558;
pub const sfx_s3kd3l: sfxenum_t = 557;
pub const sfx_s3kd3s: sfxenum_t = 556;
pub const sfx_s3kd2l: sfxenum_t = 555;
pub const sfx_s3kd2s: sfxenum_t = 554;
pub const sfx_s3kd1l: sfxenum_t = 553;
pub const sfx_s3kd1s: sfxenum_t = 552;
pub const sfx_s3kd0l: sfxenum_t = 551;
pub const sfx_s3kd0s: sfxenum_t = 550;
pub const sfx_s3kcfl: sfxenum_t = 549;
pub const sfx_s3kcfs: sfxenum_t = 548;
pub const sfx_s3kcel: sfxenum_t = 547;
pub const sfx_s3kces: sfxenum_t = 546;
pub const sfx_s3kcdl: sfxenum_t = 545;
pub const sfx_s3kcds: sfxenum_t = 544;
pub const sfx_s3kccl: sfxenum_t = 543;
pub const sfx_s3kccs: sfxenum_t = 542;
pub const sfx_s3kcbl: sfxenum_t = 541;
pub const sfx_s3kcbs: sfxenum_t = 540;
pub const sfx_s3kcal: sfxenum_t = 539;
pub const sfx_s3kcas: sfxenum_t = 538;
pub const sfx_s3kc9l: sfxenum_t = 537;
pub const sfx_s3kc9s: sfxenum_t = 536;
pub const sfx_s3kc8l: sfxenum_t = 535;
pub const sfx_s3kc8s: sfxenum_t = 534;
pub const sfx_s3kc7l: sfxenum_t = 533;
pub const sfx_s3kc7s: sfxenum_t = 532;
pub const sfx_s3kc6l: sfxenum_t = 531;
pub const sfx_s3kc6s: sfxenum_t = 530;
pub const sfx_s3kc5l: sfxenum_t = 529;
pub const sfx_s3kc5s: sfxenum_t = 528;
pub const sfx_s3kc4l: sfxenum_t = 527;
pub const sfx_s3kc4s: sfxenum_t = 526;
pub const sfx_s3kc3l: sfxenum_t = 525;
pub const sfx_s3kc3s: sfxenum_t = 524;
pub const sfx_s3kc2l: sfxenum_t = 523;
pub const sfx_s3kc2s: sfxenum_t = 522;
pub const sfx_s3kc1l: sfxenum_t = 521;
pub const sfx_s3kc1s: sfxenum_t = 520;
pub const sfx_s3kc0l: sfxenum_t = 519;
pub const sfx_s3kc0s: sfxenum_t = 518;
pub const sfx_s3kbfl: sfxenum_t = 517;
pub const sfx_s3kbfs: sfxenum_t = 516;
pub const sfx_s3kbel: sfxenum_t = 515;
pub const sfx_s3kbes: sfxenum_t = 514;
pub const sfx_s3kbdl: sfxenum_t = 513;
pub const sfx_s3kbds: sfxenum_t = 512;
pub const sfx_s3kbcl: sfxenum_t = 511;
pub const sfx_s3kbcs: sfxenum_t = 510;
pub const sfx_s3kbb: sfxenum_t = 509;
pub const sfx_s3kba: sfxenum_t = 508;
pub const sfx_s3kb9: sfxenum_t = 507;
pub const sfx_s3kb8: sfxenum_t = 506;
pub const sfx_s3kb7: sfxenum_t = 505;
pub const sfx_s3kb6: sfxenum_t = 504;
pub const sfx_s3kb5: sfxenum_t = 503;
pub const sfx_s3kb4: sfxenum_t = 502;
pub const sfx_s3kb3: sfxenum_t = 501;
pub const sfx_s3kb2: sfxenum_t = 500;
pub const sfx_s3kb1: sfxenum_t = 499;
pub const sfx_s3kb0: sfxenum_t = 498;
pub const sfx_s3kaf: sfxenum_t = 497;
pub const sfx_s3kae: sfxenum_t = 496;
pub const sfx_s3kad: sfxenum_t = 495;
pub const sfx_s3kac: sfxenum_t = 494;
pub const sfx_s3kabf: sfxenum_t = 493;
pub const sfx_s3kabe: sfxenum_t = 492;
pub const sfx_s3kabd: sfxenum_t = 491;
pub const sfx_s3kabc: sfxenum_t = 490;
pub const sfx_s3kabb: sfxenum_t = 489;
pub const sfx_s3kaba: sfxenum_t = 488;
pub const sfx_s3kab9: sfxenum_t = 487;
pub const sfx_s3kab8: sfxenum_t = 486;
pub const sfx_s3kab7: sfxenum_t = 485;
pub const sfx_s3kab6: sfxenum_t = 484;
pub const sfx_s3kab5: sfxenum_t = 483;
pub const sfx_s3kab4: sfxenum_t = 482;
pub const sfx_s3kab3: sfxenum_t = 481;
pub const sfx_s3kab2: sfxenum_t = 480;
pub const sfx_s3kab1: sfxenum_t = 479;
pub const sfx_s3kab: sfxenum_t = 478;
pub const sfx_s3kaa: sfxenum_t = 477;
pub const sfx_s3ka9: sfxenum_t = 476;
pub const sfx_s3ka8: sfxenum_t = 475;
pub const sfx_s3ka7: sfxenum_t = 474;
pub const sfx_s3ka6: sfxenum_t = 473;
pub const sfx_s3ka5: sfxenum_t = 472;
pub const sfx_s3ka4: sfxenum_t = 471;
pub const sfx_s3ka3: sfxenum_t = 470;
pub const sfx_s3ka2: sfxenum_t = 469;
pub const sfx_s3ka1: sfxenum_t = 468;
pub const sfx_s3ka0: sfxenum_t = 467;
pub const sfx_s3k9f: sfxenum_t = 466;
pub const sfx_s3k9e: sfxenum_t = 465;
pub const sfx_s3k9d: sfxenum_t = 464;
pub const sfx_s3k9c: sfxenum_t = 463;
pub const sfx_s3k9b: sfxenum_t = 462;
pub const sfx_s3k9a: sfxenum_t = 461;
pub const sfx_s3k99: sfxenum_t = 460;
pub const sfx_s3k98: sfxenum_t = 459;
pub const sfx_s3k97: sfxenum_t = 458;
pub const sfx_s3k96: sfxenum_t = 457;
pub const sfx_s3k95: sfxenum_t = 456;
pub const sfx_s3k94: sfxenum_t = 455;
pub const sfx_s3k93: sfxenum_t = 454;
pub const sfx_s3k92: sfxenum_t = 453;
pub const sfx_s3k91: sfxenum_t = 452;
pub const sfx_s3k90: sfxenum_t = 451;
pub const sfx_s3k8f: sfxenum_t = 450;
pub const sfx_s3k8e: sfxenum_t = 449;
pub const sfx_s3k8d: sfxenum_t = 448;
pub const sfx_s3k8c: sfxenum_t = 447;
pub const sfx_s3k8b: sfxenum_t = 446;
pub const sfx_s3k8a: sfxenum_t = 445;
pub const sfx_s3k89: sfxenum_t = 444;
pub const sfx_s3k88: sfxenum_t = 443;
pub const sfx_s3k87: sfxenum_t = 442;
pub const sfx_s3k86: sfxenum_t = 441;
pub const sfx_s3k85: sfxenum_t = 440;
pub const sfx_s3k84: sfxenum_t = 439;
pub const sfx_s3k83: sfxenum_t = 438;
pub const sfx_s3k82: sfxenum_t = 437;
pub const sfx_s3k81: sfxenum_t = 436;
pub const sfx_s3k80: sfxenum_t = 435;
pub const sfx_s3k7f: sfxenum_t = 434;
pub const sfx_s3k7e: sfxenum_t = 433;
pub const sfx_s3k7d: sfxenum_t = 432;
pub const sfx_s3k7c: sfxenum_t = 431;
pub const sfx_s3k7b: sfxenum_t = 430;
pub const sfx_s3k7a: sfxenum_t = 429;
pub const sfx_s3k79: sfxenum_t = 428;
pub const sfx_s3k78: sfxenum_t = 427;
pub const sfx_s3k77: sfxenum_t = 426;
pub const sfx_s3k76: sfxenum_t = 425;
pub const sfx_s3k75: sfxenum_t = 424;
pub const sfx_s3k74: sfxenum_t = 423;
pub const sfx_s3k73: sfxenum_t = 422;
pub const sfx_s3k72: sfxenum_t = 421;
pub const sfx_s3k71: sfxenum_t = 420;
pub const sfx_s3k70: sfxenum_t = 419;
pub const sfx_s3k6f: sfxenum_t = 418;
pub const sfx_s3k6e: sfxenum_t = 417;
pub const sfx_s3k6d: sfxenum_t = 416;
pub const sfx_s3k6c: sfxenum_t = 415;
pub const sfx_s3k6b: sfxenum_t = 414;
pub const sfx_s3k6a: sfxenum_t = 413;
pub const sfx_s3k69: sfxenum_t = 412;
pub const sfx_s3k68: sfxenum_t = 411;
pub const sfx_s3k67: sfxenum_t = 410;
pub const sfx_s3k66: sfxenum_t = 409;
pub const sfx_s3k65: sfxenum_t = 408;
pub const sfx_s3k64: sfxenum_t = 407;
pub const sfx_s3k63: sfxenum_t = 406;
pub const sfx_s3k62: sfxenum_t = 405;
pub const sfx_s3k61: sfxenum_t = 404;
pub const sfx_s3k60: sfxenum_t = 403;
pub const sfx_s3k5f: sfxenum_t = 402;
pub const sfx_s3k5e: sfxenum_t = 401;
pub const sfx_s3k5d: sfxenum_t = 400;
pub const sfx_s3k5c: sfxenum_t = 399;
pub const sfx_s3k5b: sfxenum_t = 398;
pub const sfx_s3k5a: sfxenum_t = 397;
pub const sfx_s3k59: sfxenum_t = 396;
pub const sfx_s3k58: sfxenum_t = 395;
pub const sfx_s3k57: sfxenum_t = 394;
pub const sfx_s3k56: sfxenum_t = 393;
pub const sfx_s3k55: sfxenum_t = 392;
pub const sfx_s3k54: sfxenum_t = 391;
pub const sfx_s3k53: sfxenum_t = 390;
pub const sfx_s3k52: sfxenum_t = 389;
pub const sfx_s3k51: sfxenum_t = 388;
pub const sfx_s3k50: sfxenum_t = 387;
pub const sfx_s3k4f: sfxenum_t = 386;
pub const sfx_s3k4e: sfxenum_t = 385;
pub const sfx_s3k4d: sfxenum_t = 384;
pub const sfx_s3k4c: sfxenum_t = 383;
pub const sfx_s3k4b: sfxenum_t = 382;
pub const sfx_s3k4a: sfxenum_t = 381;
pub const sfx_s3k49: sfxenum_t = 380;
pub const sfx_s3k48: sfxenum_t = 379;
pub const sfx_s3k47: sfxenum_t = 378;
pub const sfx_s3k46: sfxenum_t = 377;
pub const sfx_s3k45: sfxenum_t = 376;
pub const sfx_s3k44: sfxenum_t = 375;
pub const sfx_s3k43: sfxenum_t = 374;
pub const sfx_s3k42: sfxenum_t = 373;
pub const sfx_s3k41: sfxenum_t = 372;
pub const sfx_s3k40: sfxenum_t = 371;
pub const sfx_s3k3f: sfxenum_t = 370;
pub const sfx_s3k3e: sfxenum_t = 369;
pub const sfx_s3k3d: sfxenum_t = 368;
pub const sfx_s3k3c: sfxenum_t = 367;
pub const sfx_s3k3b: sfxenum_t = 366;
pub const sfx_s3k3a: sfxenum_t = 365;
pub const sfx_s3k39: sfxenum_t = 364;
pub const sfx_s3k38: sfxenum_t = 363;
pub const sfx_s3k37: sfxenum_t = 362;
pub const sfx_s3k36: sfxenum_t = 361;
pub const sfx_s3k35: sfxenum_t = 360;
pub const sfx_s3k34: sfxenum_t = 359;
pub const sfx_s3k33: sfxenum_t = 358;
pub const sfx_s3k2b: sfxenum_t = 357;
pub const sfx_s260: sfxenum_t = 356;
pub const sfx_s25f: sfxenum_t = 355;
pub const sfx_s25e: sfxenum_t = 354;
pub const sfx_s25d: sfxenum_t = 353;
pub const sfx_s25c: sfxenum_t = 352;
pub const sfx_s25b: sfxenum_t = 351;
pub const sfx_s25a: sfxenum_t = 350;
pub const sfx_s259: sfxenum_t = 349;
pub const sfx_s258: sfxenum_t = 348;
pub const sfx_s257: sfxenum_t = 347;
pub const sfx_s256: sfxenum_t = 346;
pub const sfx_s255: sfxenum_t = 345;
pub const sfx_s254: sfxenum_t = 344;
pub const sfx_s253: sfxenum_t = 343;
pub const sfx_s252: sfxenum_t = 342;
pub const sfx_s251: sfxenum_t = 341;
pub const sfx_s250: sfxenum_t = 340;
pub const sfx_s24f: sfxenum_t = 339;
pub const sfx_s24e: sfxenum_t = 338;
pub const sfx_s24d: sfxenum_t = 337;
pub const sfx_s24c: sfxenum_t = 336;
pub const sfx_s24b: sfxenum_t = 335;
pub const sfx_s24a: sfxenum_t = 334;
pub const sfx_s249: sfxenum_t = 333;
pub const sfx_s248: sfxenum_t = 332;
pub const sfx_s247: sfxenum_t = 331;
pub const sfx_s246: sfxenum_t = 330;
pub const sfx_s245: sfxenum_t = 329;
pub const sfx_s244: sfxenum_t = 328;
pub const sfx_s243: sfxenum_t = 327;
pub const sfx_s242: sfxenum_t = 326;
pub const sfx_s241: sfxenum_t = 325;
pub const sfx_s240: sfxenum_t = 324;
pub const sfx_s23f: sfxenum_t = 323;
pub const sfx_s23e: sfxenum_t = 322;
pub const sfx_s23d: sfxenum_t = 321;
pub const sfx_s23c: sfxenum_t = 320;
pub const sfx_s23b: sfxenum_t = 319;
pub const sfx_s23a: sfxenum_t = 318;
pub const sfx_s239: sfxenum_t = 317;
pub const sfx_s238: sfxenum_t = 316;
pub const sfx_s237: sfxenum_t = 315;
pub const sfx_s236: sfxenum_t = 314;
pub const sfx_s235: sfxenum_t = 313;
pub const sfx_s234: sfxenum_t = 312;
pub const sfx_s233: sfxenum_t = 311;
pub const sfx_s232: sfxenum_t = 310;
pub const sfx_s231: sfxenum_t = 309;
pub const sfx_s230: sfxenum_t = 308;
pub const sfx_s22f: sfxenum_t = 307;
pub const sfx_s22e: sfxenum_t = 306;
pub const sfx_s22d: sfxenum_t = 305;
pub const sfx_s22c: sfxenum_t = 304;
pub const sfx_s22b: sfxenum_t = 303;
pub const sfx_s22a: sfxenum_t = 302;
pub const sfx_s229: sfxenum_t = 301;
pub const sfx_s228: sfxenum_t = 300;
pub const sfx_s227: sfxenum_t = 299;
pub const sfx_s226: sfxenum_t = 298;
pub const sfx_s225: sfxenum_t = 297;
pub const sfx_s224: sfxenum_t = 296;
pub const sfx_s223: sfxenum_t = 295;
pub const sfx_s222: sfxenum_t = 294;
pub const sfx_s221: sfxenum_t = 293;
pub const sfx_s220: sfxenum_t = 292;
pub const sfx_s1cf: sfxenum_t = 291;
pub const sfx_s1ce: sfxenum_t = 290;
pub const sfx_s1cd: sfxenum_t = 289;
pub const sfx_s1cc: sfxenum_t = 288;
pub const sfx_s1cb: sfxenum_t = 287;
pub const sfx_s1ca: sfxenum_t = 286;
pub const sfx_s1c9: sfxenum_t = 285;
pub const sfx_s1c8: sfxenum_t = 284;
pub const sfx_s1c7: sfxenum_t = 283;
pub const sfx_s1c6: sfxenum_t = 282;
pub const sfx_s1c5: sfxenum_t = 281;
pub const sfx_s1c4: sfxenum_t = 280;
pub const sfx_s1c3: sfxenum_t = 279;
pub const sfx_s1c2: sfxenum_t = 278;
pub const sfx_s1c1: sfxenum_t = 277;
pub const sfx_s1c0: sfxenum_t = 276;
pub const sfx_s1bf: sfxenum_t = 275;
pub const sfx_s1be: sfxenum_t = 274;
pub const sfx_s1bd: sfxenum_t = 273;
pub const sfx_s1bc: sfxenum_t = 272;
pub const sfx_s1bb: sfxenum_t = 271;
pub const sfx_s1ba: sfxenum_t = 270;
pub const sfx_s1b9: sfxenum_t = 269;
pub const sfx_s1b8: sfxenum_t = 268;
pub const sfx_s1b7: sfxenum_t = 267;
pub const sfx_s1b6: sfxenum_t = 266;
pub const sfx_s1b5: sfxenum_t = 265;
pub const sfx_s1b4: sfxenum_t = 264;
pub const sfx_s1b3: sfxenum_t = 263;
pub const sfx_s1b2: sfxenum_t = 262;
pub const sfx_s1b1: sfxenum_t = 261;
pub const sfx_s1b0: sfxenum_t = 260;
pub const sfx_s1af: sfxenum_t = 259;
pub const sfx_s1ae: sfxenum_t = 258;
pub const sfx_s1ad: sfxenum_t = 257;
pub const sfx_s1ac: sfxenum_t = 256;
pub const sfx_s1ab: sfxenum_t = 255;
pub const sfx_s1aa: sfxenum_t = 254;
pub const sfx_s1a9: sfxenum_t = 253;
pub const sfx_s1a8: sfxenum_t = 252;
pub const sfx_s1a7: sfxenum_t = 251;
pub const sfx_s1a6: sfxenum_t = 250;
pub const sfx_s1a5: sfxenum_t = 249;
pub const sfx_s1a4: sfxenum_t = 248;
pub const sfx_s1a3: sfxenum_t = 247;
pub const sfx_s1a2: sfxenum_t = 246;
pub const sfx_s1a1: sfxenum_t = 245;
pub const sfx_s1a0: sfxenum_t = 244;
pub const sfx_brakrx: sfxenum_t = 243;
pub const sfx_brakrl: sfxenum_t = 242;
pub const sfx_beelec: sfxenum_t = 241;
pub const sfx_bgxpld: sfxenum_t = 240;
pub const sfx_bexpld: sfxenum_t = 239;
pub const sfx_bewar4: sfxenum_t = 238;
pub const sfx_bewar3: sfxenum_t = 237;
pub const sfx_bewar2: sfxenum_t = 236;
pub const sfx_bewar1: sfxenum_t = 235;
pub const sfx_bestp2: sfxenum_t = 234;
pub const sfx_bestep: sfxenum_t = 233;
pub const sfx_beshot: sfxenum_t = 232;
pub const sfx_beragh: sfxenum_t = 231;
pub const sfx_beoutb: sfxenum_t = 230;
pub const sfx_belnch: sfxenum_t = 229;
pub const sfx_bejet1: sfxenum_t = 228;
pub const sfx_behurt: sfxenum_t = 227;
pub const sfx_begrnd: sfxenum_t = 226;
pub const sfx_begoop: sfxenum_t = 225;
pub const sfx_beflap: sfxenum_t = 224;
pub const sfx_befire: sfxenum_t = 223;
pub const sfx_befall: sfxenum_t = 222;
pub const sfx_beeyow: sfxenum_t = 221;
pub const sfx_bedie2: sfxenum_t = 220;
pub const sfx_bedie1: sfxenum_t = 219;
pub const sfx_bedeen: sfxenum_t = 218;
pub const sfx_becrsh: sfxenum_t = 217;
pub const sfx_bechrg: sfxenum_t = 216;
pub const sfx_bebomb: sfxenum_t = 215;
pub const sfx_thwomp: sfxenum_t = 214;
pub const sfx_marioa: sfxenum_t = 213;
pub const sfx_mario9: sfxenum_t = 212;
pub const sfx_mario8: sfxenum_t = 211;
pub const sfx_mario7: sfxenum_t = 210;
pub const sfx_mario6: sfxenum_t = 209;
pub const sfx_mario5: sfxenum_t = 208;
pub const sfx_mario4: sfxenum_t = 207;
pub const sfx_mario3: sfxenum_t = 206;
pub const sfx_mario2: sfxenum_t = 205;
pub const sfx_mario1: sfxenum_t = 204;
pub const sfx_koopfr: sfxenum_t = 203;
pub const sfx_ghosty: sfxenum_t = 202;
pub const sfx_pumpkn: sfxenum_t = 201;
pub const sfx_lntdie: sfxenum_t = 200;
pub const sfx_lntsit: sfxenum_t = 199;
pub const sfx_peww: sfxenum_t = 198;
pub const sfx_ngjump: sfxenum_t = 197;
pub const sfx_timeup: sfxenum_t = 196;
pub const sfx_prloop: sfxenum_t = 195;
pub const sfx_hidden: sfxenum_t = 194;
pub const sfx_hoop3: sfxenum_t = 193;
pub const sfx_hoop2: sfxenum_t = 192;
pub const sfx_hoop1: sfxenum_t = 191;
pub const sfx_ngskid: sfxenum_t = 190;
pub const sfx_nghurt: sfxenum_t = 189;
pub const sfx_ncspec: sfxenum_t = 188;
pub const sfx_drill2: sfxenum_t = 187;
pub const sfx_drill1: sfxenum_t = 186;
pub const sfx_nxdone: sfxenum_t = 185;
pub const sfx_ngdone: sfxenum_t = 184;
pub const sfx_nxitem: sfxenum_t = 183;
pub const sfx_ncitem: sfxenum_t = 182;
pub const sfx_ncchip: sfxenum_t = 181;
pub const sfx_nxbump: sfxenum_t = 180;
pub const sfx_nbmper: sfxenum_t = 179;
pub const sfx_xideya: sfxenum_t = 178;
pub const sfx_ideya: sfxenum_t = 177;
pub const sfx_addfil: sfxenum_t = 176;
pub const sfx_notadd: sfxenum_t = 175;
pub const sfx_adderr: sfxenum_t = 174;
pub const sfx_zelda: sfxenum_t = 173;
pub const sfx_wtrdng: sfxenum_t = 172;
pub const sfx_wepchg: sfxenum_t = 171;
pub const sfx_radio: sfxenum_t = 170;
pub const sfx_ptally: sfxenum_t = 169;
pub const sfx_oneup: sfxenum_t = 168;
pub const sfx_menu1: sfxenum_t = 167;
pub const sfx_flgcap: sfxenum_t = 166;
pub const sfx_emfind: sfxenum_t = 165;
pub const sfx_dwnind: sfxenum_t = 164;
pub const sfx_chchng: sfxenum_t = 163;
pub const sfx_antiri: sfxenum_t = 162;
pub const sfx_shattr: sfxenum_t = 161;
pub const sfx_iceb: sfxenum_t = 160;
pub const sfx_pscree: sfxenum_t = 159;
pub const sfx_lvfal1: sfxenum_t = 158;
pub const sfx_sprong: sfxenum_t = 157;
pub const sfx_bsnipe: sfxenum_t = 156;
pub const sfx_chuchu: sfxenum_t = 155;
pub const sfx_bowl: sfxenum_t = 154;
pub const sfx_vwre: sfxenum_t = 153;
pub const sfx_alart: sfxenum_t = 152;
pub const sfx_corkh: sfxenum_t = 151;
pub const sfx_corkp: sfxenum_t = 150;
pub const sfx_boingf: sfxenum_t = 149;
pub const sfx_mspogo: sfxenum_t = 148;
pub const sfx_mswarp: sfxenum_t = 147;
pub const sfx_shrpgo: sfxenum_t = 146;
pub const sfx_shrpsp: sfxenum_t = 145;
pub const sfx_wdjump: sfxenum_t = 144;
pub const sfx_turhit: sfxenum_t = 143;
pub const sfx_trpowr: sfxenum_t = 142;
pub const sfx_trfire: sfxenum_t = 141;
pub const sfx_token: sfxenum_t = 140;
pub const sfx_tink: sfxenum_t = 139;
pub const sfx_telept: sfxenum_t = 138;
pub const sfx_supert: sfxenum_t = 137;
pub const sfx_strpst: sfxenum_t = 136;
pub const sfx_statu2: sfxenum_t = 135;
pub const sfx_statu1: sfxenum_t = 134;
pub const sfx_spring: sfxenum_t = 133;
pub const sfx_spkdth: sfxenum_t = 132;
pub const sfx_spdpad: sfxenum_t = 131;
pub const sfx_shldls: sfxenum_t = 130;
pub const sfx_attrsg: sfxenum_t = 129;
pub const sfx_armasg: sfxenum_t = 128;
pub const sfx_elemsg: sfxenum_t = 127;
pub const sfx_frcssg: sfxenum_t = 126;
pub const sfx_forcsg: sfxenum_t = 125;
pub const sfx_wirlsg: sfxenum_t = 124;
pub const sfx_shield: sfxenum_t = 123;
pub const sfx_rlaunc: sfxenum_t = 122;
pub const sfx_rail2: sfxenum_t = 121;
pub const sfx_rail1: sfxenum_t = 120;
pub const sfx_pop: sfxenum_t = 119;
pub const sfx_pogo: sfxenum_t = 118;
pub const sfx_monton: sfxenum_t = 117;
pub const sfx_mixup: sfxenum_t = 116;
pub const sfx_mindig: sfxenum_t = 115;
pub const sfx_lvpass: sfxenum_t = 114;
pub const sfx_lose: sfxenum_t = 113;
pub const sfx_jshard: sfxenum_t = 112;
pub const sfx_jet: sfxenum_t = 111;
pub const sfx_itemup: sfxenum_t = 110;
pub const sfx_gravch: sfxenum_t = 109;
pub const sfx_gspray: sfxenum_t = 108;
pub const sfx_gloop: sfxenum_t = 107;
pub const sfx_ghit: sfxenum_t = 106;
pub const sfx_wepfir: sfxenum_t = 105;
pub const sfx_gbeep: sfxenum_t = 104;
pub const sfx_fizzle: sfxenum_t = 103;
pub const sfx_drown: sfxenum_t = 102;
pub const sfx_dmpain: sfxenum_t = 101;
pub const sfx_ding: sfxenum_t = 100;
pub const sfx_deton: sfxenum_t = 99;
pub const sfx_cybdth: sfxenum_t = 98;
pub const sfx_cgot: sfxenum_t = 97;
pub const sfx_cannon: sfxenum_t = 96;
pub const sfx_bnce2: sfxenum_t = 95;
pub const sfx_bnce1: sfxenum_t = 94;
pub const sfx_bkpoof: sfxenum_t = 93;
pub const sfx_appear: sfxenum_t = 92;
pub const sfx_rumble: sfxenum_t = 91;
pub const sfx_rumbam: sfxenum_t = 90;
pub const sfx_rocks4: sfxenum_t = 89;
pub const sfx_rocks3: sfxenum_t = 88;
pub const sfx_rocks2: sfxenum_t = 87;
pub const sfx_rocks1: sfxenum_t = 86;
pub const sfx_lavbub: sfxenum_t = 85;
pub const sfx_ambin2: sfxenum_t = 84;
pub const sfx_elevb3: sfxenum_t = 83;
pub const sfx_elevb2: sfxenum_t = 82;
pub const sfx_elevb1: sfxenum_t = 81;
pub const sfx_eleva3: sfxenum_t = 80;
pub const sfx_eleva2: sfxenum_t = 79;
pub const sfx_eleva1: sfxenum_t = 78;
pub const sfx_doord2: sfxenum_t = 77;
pub const sfx_doord1: sfxenum_t = 76;
pub const sfx_doorc2: sfxenum_t = 75;
pub const sfx_doorc1: sfxenum_t = 74;
pub const sfx_doorb1: sfxenum_t = 73;
pub const sfx_doora1: sfxenum_t = 72;
pub const sfx_wslap: sfxenum_t = 71;
pub const sfx_wdrip8: sfxenum_t = 70;
pub const sfx_wdrip7: sfxenum_t = 69;
pub const sfx_wdrip6: sfxenum_t = 68;
pub const sfx_wdrip5: sfxenum_t = 67;
pub const sfx_wdrip4: sfxenum_t = 66;
pub const sfx_wdrip3: sfxenum_t = 65;
pub const sfx_wdrip2: sfxenum_t = 64;
pub const sfx_wdrip1: sfxenum_t = 63;
pub const sfx_splish: sfxenum_t = 62;
pub const sfx_splash: sfxenum_t = 61;
pub const sfx_floush: sfxenum_t = 60;
pub const sfx_bubbl5: sfxenum_t = 59;
pub const sfx_bubbl4: sfxenum_t = 58;
pub const sfx_bubbl3: sfxenum_t = 57;
pub const sfx_bubbl2: sfxenum_t = 56;
pub const sfx_bubbl1: sfxenum_t = 55;
pub const sfx_amwtr8: sfxenum_t = 54;
pub const sfx_amwtr7: sfxenum_t = 53;
pub const sfx_amwtr6: sfxenum_t = 52;
pub const sfx_amwtr5: sfxenum_t = 51;
pub const sfx_amwtr4: sfxenum_t = 50;
pub const sfx_amwtr3: sfxenum_t = 49;
pub const sfx_amwtr2: sfxenum_t = 48;
pub const sfx_amwtr1: sfxenum_t = 47;
pub const sfx_athun2: sfxenum_t = 46;
pub const sfx_athun1: sfxenum_t = 45;
pub const sfx_litng4: sfxenum_t = 44;
pub const sfx_litng3: sfxenum_t = 43;
pub const sfx_litng2: sfxenum_t = 42;
pub const sfx_litng1: sfxenum_t = 41;
pub const sfx_rainin: sfxenum_t = 40;
pub const sfx_spsmsh: sfxenum_t = 39;
pub const sfx_ambmac: sfxenum_t = 38;
pub const sfx_wbreak: sfxenum_t = 37;
pub const sfx_steam2: sfxenum_t = 36;
pub const sfx_steam1: sfxenum_t = 35;
pub const sfx_pstop: sfxenum_t = 34;
pub const sfx_pstart: sfxenum_t = 33;
pub const sfx_mswing: sfxenum_t = 32;
pub const sfx_laser: sfxenum_t = 31;
pub const sfx_grind: sfxenum_t = 30;
pub const sfx_fire: sfxenum_t = 29;
pub const sfx_crumbl: sfxenum_t = 28;
pub const sfx_buzz4: sfxenum_t = 27;
pub const sfx_buzz3: sfxenum_t = 26;
pub const sfx_buzz2: sfxenum_t = 25;
pub const sfx_buzz1: sfxenum_t = 24;
pub const sfx_alarm: sfxenum_t = 23;
pub const sfx_ambint: sfxenum_t = 22;
pub const sfx_skid: sfxenum_t = 21;
pub const sfx_zoom: sfxenum_t = 20;
pub const sfx_thok: sfxenum_t = 19;
pub const sfx_spndsh: sfxenum_t = 18;
pub const sfx_spin: sfxenum_t = 17;
pub const sfx_putput: sfxenum_t = 16;
pub const sfx_pudpud: sfxenum_t = 15;
pub const sfx_jump: sfxenum_t = 14;
pub const sfx_gasp: sfxenum_t = 13;
pub const sfx_victr4: sfxenum_t = 12;
pub const sfx_victr3: sfxenum_t = 11;
pub const sfx_victr2: sfxenum_t = 10;
pub const sfx_victr1: sfxenum_t = 9;
pub const sfx_altow4: sfxenum_t = 8;
pub const sfx_altow3: sfxenum_t = 7;
pub const sfx_altow2: sfxenum_t = 6;
pub const sfx_altow1: sfxenum_t = 5;
pub const sfx_altdi4: sfxenum_t = 4;
pub const sfx_altdi3: sfxenum_t = 3;
pub const sfx_altdi2: sfxenum_t = 2;
pub const sfx_altdi1: sfxenum_t = 1;
pub const sfx_None: sfxenum_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct state_t {
    pub sprite: spritenum_t,
    pub frame: uint32_t,
    pub tics: int32_t,
    pub action: actionf_t,
    pub var1: int32_t,
    pub var2: int32_t,
    pub nextstate: statenum_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union actionf_t {
    pub acv: actionf_v,
    pub acp1: actionf_p1,
}
pub type actionf_p1 = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type actionf_v = Option::<unsafe extern "C" fn() -> ()>;
pub type spritenum_t = sprite;
pub type sprite = libc::c_uint;
pub const NUMSPRITES: sprite = 907;
pub const SPR_LASTFREESLOT: sprite = 906;
pub const SPR_FIRSTFREESLOT: sprite = 395;
pub const SPR_GWLR: sprite = 394;
pub const SPR_GWLG: sprite = 393;
pub const SPR_BRIY: sprite = 392;
pub const SPR_BRIB: sprite = 391;
pub const SPR_BRIR: sprite = 390;
pub const SPR_WDDB: sprite = 389;
pub const SPR_BRIC: sprite = 388;
pub const SPR_GFZD: sprite = 387;
pub const SPR_ROIP: sprite = 386;
pub const SPR_ROIO: sprite = 385;
pub const SPR_ROIN: sprite = 384;
pub const SPR_ROIM: sprite = 383;
pub const SPR_ROIL: sprite = 382;
pub const SPR_ROIK: sprite = 381;
pub const SPR_ROIJ: sprite = 380;
pub const SPR_ROII: sprite = 379;
pub const SPR_ROIH: sprite = 378;
pub const SPR_ROIG: sprite = 377;
pub const SPR_ROIF: sprite = 376;
pub const SPR_ROIE: sprite = 375;
pub const SPR_ROID: sprite = 374;
pub const SPR_ROIC: sprite = 373;
pub const SPR_ROIB: sprite = 372;
pub const SPR_ROIA: sprite = 371;
pub const SPR_BMNB: sprite = 370;
pub const SPR_BOM4: sprite = 369;
pub const SPR_BOM3: sprite = 368;
pub const SPR_BOM2: sprite = 367;
pub const SPR_BOM1: sprite = 366;
pub const SPR_SPRK: sprite = 365;
pub const SPR_HBAT: sprite = 364;
pub const SPR_SBSK: sprite = 363;
pub const SPR_SBFL: sprite = 362;
pub const SPR_SBOB: sprite = 361;
pub const SPR_BAL2: sprite = 360;
pub const SPR_CACO: sprite = 359;
pub const SPR_HMCE: sprite = 358;
pub const SPR_FMCE: sprite = 357;
pub const SPR_BBUZ: sprite = 356;
pub const SPR_BUMB: sprite = 355;
pub const SPR_HIVE: sprite = 354;
pub const SPR_POPH: sprite = 353;
pub const SPR_PENG: sprite = 352;
pub const SPR_SHLP: sprite = 351;
pub const SPR_NTPN: sprite = 350;
pub const SPR_IDYA: sprite = 349;
pub const SPR_CAPS: sprite = 348;
pub const SPR_NPRU: sprite = 347;
pub const SPR_NSCR: sprite = 346;
pub const SPR_HOOP: sprite = 345;
pub const SPR_NBMP: sprite = 344;
pub const SPR_NSPK: sprite = 343;
pub const SPR_NDRN: sprite = 342;
pub const SPR_TOAD: sprite = 341;
pub const SPR_MUS2: sprite = 340;
pub const SPR_MUS1: sprite = 339;
pub const SPR_MAXE: sprite = 338;
pub const SPR_BFLM: sprite = 337;
pub const SPR_KOOP: sprite = 336;
pub const SPR_HAMM: sprite = 335;
pub const SPR_PUMA: sprite = 334;
pub const SPR_SHLL: sprite = 333;
pub const SPR_FBLL: sprite = 332;
pub const SPR_FFWR: sprite = 331;
pub const SPR_BGOM: sprite = 330;
pub const SPR_GOOM: sprite = 329;
pub const SPR_CPRK: sprite = 328;
pub const SPR_COIN: sprite = 327;
pub const SPR_TSCR: sprite = 326;
pub const SPR_TGRE: sprite = 325;
pub const SPR_TAUT: sprite = 324;
pub const SPR_PIKG: sprite = 323;
pub const SPR_PIKS: sprite = 322;
pub const SPR_PIKE: sprite = 321;
pub const SPR_PIKA: sprite = 320;
pub const SPR_PIKR: sprite = 319;
pub const SPR_PIKB: sprite = 318;
pub const SPR_RNGG: sprite = 317;
pub const SPR_RNGS: sprite = 316;
pub const SPR_RNGE: sprite = 315;
pub const SPR_RNGA: sprite = 314;
pub const SPR_RNGI: sprite = 313;
pub const SPR_RNGR: sprite = 312;
pub const SPR_RNGB: sprite = 311;
pub const SPR_RRNG: sprite = 310;
pub const SPR_LHRT: sprite = 309;
pub const SPR_CORK: sprite = 308;
pub const SPR_FNSF: sprite = 307;
pub const SPR_GFLG: sprite = 306;
pub const SPR_TTAG: sprite = 305;
pub const SPR_LCKN: sprite = 304;
pub const SPR_FLII: sprite = 303;
pub const SPR_DRWN: sprite = 302;
pub const SPR_SCOR: sprite = 301;
pub const SPR_PRTL: sprite = 300;
pub const SPR_SEED: sprite = 299;
pub const SPR_TFOG: sprite = 298;
pub const SPR_FPRT: sprite = 297;
pub const SPR_DUST: sprite = 296;
pub const SPR_WZAP: sprite = 295;
pub const SPR_BUBL: sprite = 294;
pub const SPR_SMOK: sprite = 293;
pub const SPR_SPLA: sprite = 292;
pub const SPR_LSPL: sprite = 291;
pub const SPR_SPLH: sprite = 290;
pub const SPR_SNO1: sprite = 289;
pub const SPR_RAIN: sprite = 288;
pub const SPR_BSTR: sprite = 287;
pub const SPR_BSTY: sprite = 286;
pub const SPR_SSWB: sprite = 285;
pub const SPR_SSWR: sprite = 284;
pub const SPR_SSWY: sprite = 283;
pub const SPR_BSPR: sprite = 282;
pub const SPR_RSPR: sprite = 281;
pub const SPR_YSPR: sprite = 280;
pub const SPR_SPRB: sprite = 279;
pub const SPR_SPRR: sprite = 278;
pub const SPR_SPRY: sprite = 277;
pub const SPR_BLON: sprite = 276;
pub const SPR_BUMP: sprite = 275;
pub const SPR_STEM: sprite = 274;
pub const SPR_FANS: sprite = 273;
pub const SPR_FS02: sprite = 272;
pub const SPR_FS01: sprite = 271;
pub const SPR_FL16: sprite = 270;
pub const SPR_FL15: sprite = 269;
pub const SPR_FL14: sprite = 268;
pub const SPR_FL13: sprite = 267;
pub const SPR_FL12: sprite = 266;
pub const SPR_FL11: sprite = 265;
pub const SPR_FL10: sprite = 264;
pub const SPR_FL09: sprite = 263;
pub const SPR_FL08: sprite = 262;
pub const SPR_FL07: sprite = 261;
pub const SPR_FL06: sprite = 260;
pub const SPR_FL05: sprite = 259;
pub const SPR_FL04: sprite = 258;
pub const SPR_FL03: sprite = 257;
pub const SPR_FL02: sprite = 256;
pub const SPR_FL01: sprite = 255;
pub const SPR_FBUB: sprite = 254;
pub const SPR_GOAL: sprite = 253;
pub const SPR_SSPK: sprite = 252;
pub const SPR_IVSP: sprite = 251;
pub const SPR_ZAPS: sprite = 250;
pub const SPR_BUBS: sprite = 249;
pub const SPR_FIRS: sprite = 248;
pub const SPR_PITY: sprite = 247;
pub const SPR_FORC: sprite = 246;
pub const SPR_ELEM: sprite = 245;
pub const SPR_MAGN: sprite = 244;
pub const SPR_WIND: sprite = 243;
pub const SPR_ARMB: sprite = 242;
pub const SPR_ARMF: sprite = 241;
pub const SPR_ARMA: sprite = 240;
pub const SPR_DBAL: sprite = 239;
pub const SPR_STLG: sprite = 238;
pub const SPR_BSZ8: sprite = 237;
pub const SPR_BSZ7: sprite = 236;
pub const SPR_BSZ6: sprite = 235;
pub const SPR_BSZ5: sprite = 234;
pub const SPR_BST6: sprite = 233;
pub const SPR_BST5: sprite = 232;
pub const SPR_BST4: sprite = 231;
pub const SPR_BST3: sprite = 230;
pub const SPR_BST2: sprite = 229;
pub const SPR_BST1: sprite = 228;
pub const SPR_BSZ3: sprite = 227;
pub const SPR_BSZ2: sprite = 226;
pub const SPR_BSZ1: sprite = 225;
pub const SPR_CFLM: sprite = 224;
pub const SPR_RCRY: sprite = 223;
pub const SPR_BGAR: sprite = 222;
pub const SPR_HHZM: sprite = 221;
pub const SPR_SHRM: sprite = 220;
pub const SPR_HHPL: sprite = 219;
pub const SPR_PUMK: sprite = 218;
pub const SPR_ROSY: sprite = 217;
pub const SPR_FHZI: sprite = 216;
pub const SPR_XMS6: sprite = 215;
pub const SPR_XMS5: sprite = 214;
pub const SPR_XMS4: sprite = 213;
pub const SPR_XMS3: sprite = 212;
pub const SPR_XMS2: sprite = 211;
pub const SPR_XMS1: sprite = 210;
pub const SPR_WVIN: sprite = 209;
pub const SPR_TFLO: sprite = 208;
pub const SPR_JPLA: sprite = 207;
pub const SPR_LFAL: sprite = 206;
pub const SPR_DFLM: sprite = 205;
pub const SPR_FLME: sprite = 204;
pub const SPR_STEA: sprite = 203;
pub const SPR_TRAI: sprite = 202;
pub const SPR_TRAE: sprite = 201;
pub const SPR_SALD: sprite = 200;
pub const SPR_MCSP: sprite = 199;
pub const SPR_MCRT: sprite = 198;
pub const SPR_ADST: sprite = 197;
pub const SPR_TAZD: sprite = 196;
pub const SPR_REMT: sprite = 195;
pub const SPR_BARR: sprite = 194;
pub const SPR_OILF: sprite = 193;
pub const SPR_OILL: sprite = 192;
pub const SPR_WWS3: sprite = 191;
pub const SPR_WWS2: sprite = 190;
pub const SPR_WWSG: sprite = 189;
pub const SPR_CACT: sprite = 188;
pub const SPR_STBL: sprite = 187;
pub const SPR_BTBL: sprite = 186;
pub const SPR_CABR: sprite = 185;
pub const SPR_CBBS: sprite = 184;
pub const SPR_CSTA: sprite = 183;
pub const SPR_CFLG: sprite = 182;
pub const SPR_CTRC: sprite = 181;
pub const SPR_FLMH: sprite = 180;
pub const SPR_CNDL: sprite = 179;
pub const SPR_CEZB: sprite = 178;
pub const SPR_PINE: sprite = 177;
pub const SPR_BANR: sprite = 176;
pub const SPR_BFBR: sprite = 175;
pub const SPR_SFBR: sprite = 174;
pub const SPR_RSPB: sprite = 173;
pub const SPR_YSPB: sprite = 172;
pub const SPR_BMCE: sprite = 171;
pub const SPR_SMCE: sprite = 170;
pub const SPR_BMCH: sprite = 169;
pub const SPR_SMCH: sprite = 168;
pub const SPR_ESTA: sprite = 167;
pub const SPR_FLAM: sprite = 166;
pub const SPR_CHAN: sprite = 165;
pub const SPR_LIBE: sprite = 164;
pub const SPR_DSTG: sprite = 163;
pub const SPR_ALGB: sprite = 162;
pub const SPR_ALGA: sprite = 161;
pub const SPR_KELP: sprite = 160;
pub const SPR_BCRY: sprite = 159;
pub const SPR_CORL: sprite = 158;
pub const SPR_DRIP: sprite = 157;
pub const SPR_SEWE: sprite = 156;
pub const SPR_GARG: sprite = 155;
pub const SPR_ALRM: sprite = 154;
pub const SPR_THZT: sprite = 153;
pub const SPR_FWR6: sprite = 152;
pub const SPR_FWR5: sprite = 151;
pub const SPR_THZP: sprite = 150;
pub const SPR_TRE6: sprite = 149;
pub const SPR_TRE5: sprite = 148;
pub const SPR_TRE4: sprite = 147;
pub const SPR_TRE3: sprite = 146;
pub const SPR_TRE2: sprite = 145;
pub const SPR_TRE1: sprite = 144;
pub const SPR_BUS3: sprite = 143;
pub const SPR_BUS2: sprite = 142;
pub const SPR_BUS1: sprite = 141;
pub const SPR_FWR4: sprite = 140;
pub const SPR_FWR3: sprite = 139;
pub const SPR_FWR2: sprite = 138;
pub const SPR_FWR1: sprite = 137;
pub const SPR_TUPF: sprite = 136;
pub const SPR_TUPL: sprite = 135;
pub const SPR_LETR: sprite = 134;
pub const SPR_CFIR: sprite = 133;
pub const SPR_AROW: sprite = 132;
pub const SPR_CBLL: sprite = 131;
pub const SPR_TRLS: sprite = 130;
pub const SPR_JBUL: sprite = 129;
pub const SPR_MINE: sprite = 128;
pub const SPR_ENRG: sprite = 127;
pub const SPR_TORP: sprite = 126;
pub const SPR_LASF: sprite = 125;
pub const SPR_LASR: sprite = 124;
pub const SPR_MISL: sprite = 123;
pub const SPR_TVZP: sprite = 122;
pub const SPR_TVBB: sprite = 121;
pub const SPR_TVFL: sprite = 120;
pub const SPR_TVTK: sprite = 119;
pub const SPR_TV1K: sprite = 118;
pub const SPR_TVRC: sprite = 117;
pub const SPR_TVGV: sprite = 116;
pub const SPR_TVMY: sprite = 115;
pub const SPR_TVMX: sprite = 114;
pub const SPR_TVEG: sprite = 113;
pub const SPR_TV1P: sprite = 112;
pub const SPR_TV1U: sprite = 111;
pub const SPR_TVIV: sprite = 110;
pub const SPR_TVSS: sprite = 109;
pub const SPR_TVEL: sprite = 108;
pub const SPR_TVWW: sprite = 107;
pub const SPR_TVAR: sprite = 106;
pub const SPR_TVFO: sprite = 105;
pub const SPR_TVAT: sprite = 104;
pub const SPR_TVPI: sprite = 103;
pub const SPR_TVRI: sprite = 102;
pub const SPR_TBRI: sprite = 101;
pub const SPR_TRRI: sprite = 100;
pub const SPR_XLTV: sprite = 99;
pub const SPR_MSTV: sprite = 98;
pub const SPR_PUMI: sprite = 97;
pub const SPR_BMNE: sprite = 96;
pub const SPR_STPT: sprite = 95;
pub const SPR_WSPB: sprite = 94;
pub const SPR_WSPK: sprite = 93;
pub const SPR_USPK: sprite = 92;
pub const SPR_TFLM: sprite = 91;
pub const SPR_SFLM: sprite = 90;
pub const SPR_SPIK: sprite = 89;
pub const SPR_SIGN: sprite = 88;
pub const SPR_BBLS: sprite = 87;
pub const SPR_SHRD: sprite = 86;
pub const SPR_CEMG: sprite = 85;
pub const SPR_EMBM: sprite = 84;
pub const SPR_NSTR: sprite = 83;
pub const SPR_NCHP: sprite = 82;
pub const SPR_SPHR: sprite = 81;
pub const SPR_BFLG: sprite = 80;
pub const SPR_RFLG: sprite = 79;
pub const SPR_TOKE: sprite = 78;
pub const SPR_TRNG: sprite = 77;
pub const SPR_RING: sprite = 76;
pub const SPR_MSCB: sprite = 75;
pub const SPR_MSCF: sprite = 74;
pub const SPR_METL: sprite = 73;
pub const SPR_MNPL: sprite = 72;
pub const SPR_NPLM: sprite = 71;
pub const SPR_TARG: sprite = 70;
pub const SPR_ELEC: sprite = 69;
pub const SPR_RCKT: sprite = 68;
pub const SPR_EGGT: sprite = 67;
pub const SPR_BMSL: sprite = 66;
pub const SPR_BGOO: sprite = 65;
pub const SPR_BRAK: sprite = 64;
pub const SPR_EGGR: sprite = 63;
pub const SPR_BARD: sprite = 62;
pub const SPR_BARX: sprite = 61;
pub const SPR_FSGN: sprite = 60;
pub const SPR_FBOM: sprite = 59;
pub const SPR_PROJ: sprite = 58;
pub const SPR_VWRE: sprite = 57;
pub const SPR_WHAT: sprite = 56;
pub const SPR_BRKN: sprite = 55;
pub const SPR_FANG: sprite = 54;
pub const SPR_EGR1: sprite = 53;
pub const SPR_EFIR: sprite = 52;
pub const SPR_EGGP: sprite = 51;
pub const SPR_SHCK: sprite = 50;
pub const SPR_FAKE: sprite = 49;
pub const SPR_SEBH: sprite = 48;
pub const SPR_EGGO: sprite = 47;
pub const SPR_GOOP: sprite = 46;
pub const SPR_TANK: sprite = 45;
pub const SPR_EGGN: sprite = 44;
pub const SPR_EGLZ: sprite = 43;
pub const SPR_EGGM: sprite = 42;
pub const SPR_JETF: sprite = 41;
pub const SPR_DRAB: sprite = 40;
pub const SPR_PTER: sprite = 39;
pub const SPR_PYRE: sprite = 38;
pub const SPR_CANG: sprite = 37;
pub const SPR_CANA: sprite = 36;
pub const SPR_UNID: sprite = 35;
pub const SPR_SSHL: sprite = 34;
pub const SPR_MNUD: sprite = 33;
pub const SPR_MNUS: sprite = 32;
pub const SPR_GSNH: sprite = 31;
pub const SPR_GSNL: sprite = 30;
pub const SPR_GSNP: sprite = 29;
pub const SPR_ESHI: sprite = 28;
pub const SPR_SPSH: sprite = 27;
pub const SPR_STAB: sprite = 26;
pub const SPR_CBFS: sprite = 25;
pub const SPR_ARCH: sprite = 24;
pub const SPR_PNTY: sprite = 23;
pub const SPR_VLTR: sprite = 22;
pub const SPR_SNLR: sprite = 21;
pub const SPR_JJAW: sprite = 20;
pub const SPR_CSPR: sprite = 19;
pub const SPR_CR2B: sprite = 18;
pub const SPR_CRAB: sprite = 17;
pub const SPR_SHRP: sprite = 16;
pub const SPR_TURR: sprite = 15;
pub const SPR_TRET: sprite = 14;
pub const SPR_SKIM: sprite = 13;
pub const SPR_DETN: sprite = 12;
pub const SPR_CCOM: sprite = 11;
pub const SPR_JETG: sprite = 10;
pub const SPR_JETB: sprite = 9;
pub const SPR_RBUZ: sprite = 8;
pub const SPR_BUZZ: sprite = 7;
pub const SPR_FISH: sprite = 6;
pub const SPR_SPOS: sprite = 5;
pub const SPR_POSS: sprite = 4;
pub const SPR_PLAY: sprite = 3;
pub const SPR_THOK: sprite = 2;
pub const SPR_UNKN: sprite = 1;
pub const SPR_NULL: sprite = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ffloor_s {
    pub topheight: *mut fixed_t,
    pub toppic: *mut int32_t,
    pub toplightlevel: *mut int16_t,
    pub topxoffs: *mut fixed_t,
    pub topyoffs: *mut fixed_t,
    pub topangle: *mut angle_t,
    pub bottomheight: *mut fixed_t,
    pub bottompic: *mut int32_t,
    pub bottomxoffs: *mut fixed_t,
    pub bottomyoffs: *mut fixed_t,
    pub bottomangle: *mut angle_t,
    pub t_slope: *mut *mut pslope_s,
    pub b_slope: *mut *mut pslope_s,
    pub secnum: size_t,
    pub fofflags: ffloortype_e,
    pub master: *mut line_s,
    pub target: *mut sector_s,
    pub next: *mut ffloor_s,
    pub prev: *mut ffloor_s,
    pub lastlight: int32_t,
    pub alpha: int32_t,
    pub blend: uint8_t,
    pub norender: tic_t,
    pub bustflags: ffloorbustflags_e,
    pub busttype: uint8_t,
    pub busttag: int16_t,
    pub sinkspeed: fixed_t,
    pub friction: fixed_t,
    pub bouncestrength: fixed_t,
    pub spawnflags: ffloortype_e,
    pub spawnalpha: int32_t,
    pub fadingdata: *mut libc::c_void,
}
pub type ffloortype_e = libc::c_uint;
pub const FOF_SPLAT: ffloortype_e = 1073741824;
pub const FOF_BOUNCY: ffloortype_e = 536870912;
pub const FOF_COLORMAPONLY: ffloortype_e = 268435456;
pub const FOF_RIPPLE: ffloortype_e = 134217728;
pub const FOF_INTANGIBLEFLATS: ffloortype_e = 100663296;
pub const FOF_REVERSEPLATFORM: ffloortype_e = 67108864;
pub const FOF_PLATFORM: ffloortype_e = 33554432;
pub const FOF_QUICKSAND: ffloortype_e = 16777216;
pub const FOF_BUSTUP: ffloortype_e = 8388608;
pub const FOF_MARIO: ffloortype_e = 4194304;
pub const FOF_GOOWATER: ffloortype_e = 2097152;
pub const FOF_CRUMBLE: ffloortype_e = 1048576;
pub const FOF_NORETURN: ffloortype_e = 524288;
pub const FOF_FLOATBOB: ffloortype_e = 262144;
pub const FOF_DOUBLESHADOW: ffloortype_e = 131072;
pub const FOF_INVERTSIDES: ffloortype_e = 65536;
pub const FOF_ALLSIDES: ffloortype_e = 32768;
pub const FOF_INVERTPLANES: ffloortype_e = 16384;
pub const FOF_FOG: ffloortype_e = 8192;
pub const FOF_TRANSLUCENT: ffloortype_e = 4096;
pub const FOF_EXTRA: ffloortype_e = 2048;
pub const FOF_BOTHPLANES: ffloortype_e = 1024;
pub const FOF_CUTSPRITES: ffloortype_e = 512;
pub const FOF_CUTLEVEL: ffloortype_e = 384;
pub const FOF_CUTEXTRA: ffloortype_e = 256;
pub const FOF_CUTSOLIDS: ffloortype_e = 128;
pub const FOF_NOSHADE: ffloortype_e = 64;
pub const FOF_SWIMMABLE: ffloortype_e = 32;
pub const FOF_RENDERALL: ffloortype_e = 24;
pub const FOF_RENDERPLANES: ffloortype_e = 16;
pub const FOF_RENDERSIDES: ffloortype_e = 8;
pub const FOF_SOLID: ffloortype_e = 6;
pub const FOF_BLOCKOTHERS: ffloortype_e = 4;
pub const FOF_BLOCKPLAYER: ffloortype_e = 2;
pub const FOF_EXISTS: ffloortype_e = 1;
pub type ffloorbustflags_e = libc::c_uint;
pub const FB_ONLYBOTTOM: ffloorbustflags_e = 4;
pub const FB_EXECUTOR: ffloorbustflags_e = 2;
pub const FB_PUSHABLES: ffloorbustflags_e = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sector_s {
    pub floorheight: fixed_t,
    pub ceilingheight: fixed_t,
    pub floorpic: int32_t,
    pub ceilingpic: int32_t,
    pub lightlevel: int16_t,
    pub special: int16_t,
    pub tags: taglist_t,
    pub soundorg: degenmobj_t,
    pub validcount: size_t,
    pub thinglist: *mut mobj_t,
    pub floordata: *mut libc::c_void,
    pub ceilingdata: *mut libc::c_void,
    pub lightingdata: *mut libc::c_void,
    pub fadecolormapdata: *mut libc::c_void,
    pub floorxoffset: fixed_t,
    pub flooryoffset: fixed_t,
    pub ceilingxoffset: fixed_t,
    pub ceilingyoffset: fixed_t,
    pub floorangle: angle_t,
    pub ceilingangle: angle_t,
    pub heightsec: int32_t,
    pub camsec: int32_t,
    pub floorlightlevel: int16_t,
    pub ceilinglightlevel: int16_t,
    pub floorlightabsolute: boolean,
    pub ceilinglightabsolute: boolean,
    pub floorlightsec: int32_t,
    pub ceilinglightsec: int32_t,
    pub crumblestate: int32_t,
    pub touching_thinglist: *mut msecnode_s,
    pub linecount: size_t,
    pub lines: *mut *mut line_s,
    pub ffloors: *mut ffloor_t,
    pub attached: *mut size_t,
    pub attachedsolid: *mut boolean,
    pub numattached: size_t,
    pub maxattached: size_t,
    pub lightlist: *mut lightlist_t,
    pub numlights: int32_t,
    pub moved: boolean,
    pub extra_colormap: *mut extracolormap_t,
    pub colormap_protected: boolean,
    pub gravity: fixed_t,
    pub gravityptr: *mut fixed_t,
    pub flags: sectorflags_t,
    pub specialflags: sectorspecialflags_t,
    pub damagetype: uint8_t,
    pub triggertag: mtag_t,
    pub triggerer: uint8_t,
    pub friction: fixed_t,
    pub cullheight: *mut line_s,
    pub floorspeed: fixed_t,
    pub ceilspeed: fixed_t,
    pub preciplist: *mut precipmobj_t,
    pub touching_preciplist: *mut mprecipsecnode_s,
    pub f_slope: *mut pslope_t,
    pub c_slope: *mut pslope_t,
    pub hasslope: boolean,
    pub spawn_lightlevel: int16_t,
    pub spawn_extra_colormap: *mut extracolormap_t,
}
pub type extracolormap_t = extracolormap_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct extracolormap_s {
    pub fadestart: uint8_t,
    pub fadeend: uint8_t,
    pub flags: uint8_t,
    pub rgba: int32_t,
    pub fadergba: int32_t,
    pub colormap: *mut lighttable_t,
    pub next: *mut extracolormap_s,
    pub prev: *mut extracolormap_s,
}
pub type lighttable_t = uint8_t;
pub type pslope_t = pslope_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mprecipsecnode_s {
    pub m_sector: *mut sector_t,
    pub m_thing: *mut precipmobj_s,
    pub m_sectorlist_prev: *mut mprecipsecnode_s,
    pub m_sectorlist_next: *mut mprecipsecnode_s,
    pub m_thinglist_prev: *mut mprecipsecnode_s,
    pub m_thinglist_next: *mut mprecipsecnode_s,
    pub visited: boolean,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct precipmobj_s {
    pub thinker: thinker_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub old_x: fixed_t,
    pub old_y: fixed_t,
    pub old_z: fixed_t,
    pub old_x2: fixed_t,
    pub old_y2: fixed_t,
    pub old_z2: fixed_t,
    pub snext: *mut precipmobj_s,
    pub sprev: *mut *mut precipmobj_s,
    pub angle: angle_t,
    pub pitch: angle_t,
    pub roll: angle_t,
    pub old_angle: angle_t,
    pub old_pitch: angle_t,
    pub old_roll: angle_t,
    pub old_angle2: angle_t,
    pub old_pitch2: angle_t,
    pub old_roll2: angle_t,
    pub spriteroll: angle_t,
    pub old_spriteroll: angle_t,
    pub old_spriteroll2: angle_t,
    pub sprite: spritenum_t,
    pub frame: uint32_t,
    pub sprite2: uint8_t,
    pub anim_duration: uint16_t,
    pub renderflags: uint32_t,
    pub blendmode: int32_t,
    pub spritexscale: fixed_t,
    pub spriteyscale: fixed_t,
    pub spritexoffset: fixed_t,
    pub spriteyoffset: fixed_t,
    pub old_spritexscale: fixed_t,
    pub old_spriteyscale: fixed_t,
    pub old_spritexoffset: fixed_t,
    pub old_spriteyoffset: fixed_t,
    pub floorspriteslope: *mut pslope_s,
    pub touching_sectorlist: *mut mprecipsecnode_s,
    pub subsector: *mut subsector_s,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
    pub floorrover: *mut ffloor_s,
    pub ceilingrover: *mut ffloor_s,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub momx: fixed_t,
    pub momy: fixed_t,
    pub momz: fixed_t,
    pub precipflags: fixed_t,
    pub tics: int32_t,
    pub state: *mut state_t,
    pub flags: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct subsector_s {
    pub sector: *mut sector_t,
    pub numlines: int16_t,
    pub firstline: uint32_t,
    pub polyList: *mut polyobj_s,
    pub validcount: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct polyobj_s {
    pub link: mdllistitem_t,
    pub id: int32_t,
    pub first: int32_t,
    pub next: int32_t,
    pub parent: int32_t,
    pub segCount: size_t,
    pub numSegsAlloc: size_t,
    pub segs: *mut *mut seg_s,
    pub numVertices: size_t,
    pub numVerticesAlloc: size_t,
    pub origVerts: *mut vertex_t,
    pub tmpVerts: *mut vertex_t,
    pub vertices: *mut *mut vertex_t,
    pub numLines: size_t,
    pub numLinesAlloc: size_t,
    pub lines: *mut *mut line_s,
    pub spawnSpot: degenmobj_t,
    pub centerPt: vertex_t,
    pub zdist: fixed_t,
    pub angle: angle_t,
    pub attached: uint8_t,
    pub blockbox: [fixed_t; 4],
    pub linked: uint8_t,
    pub validcount: size_t,
    pub damage: int32_t,
    pub thrust: fixed_t,
    pub flags: int32_t,
    pub thinker: *mut thinker_t,
    pub isBad: uint8_t,
    pub translucency: int32_t,
    pub triggertag: int16_t,
    pub visplane: *mut visplane_s,
    pub spawnflags: int32_t,
    pub spawntrans: int32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct visplane_s {
    pub next: *mut visplane_s,
    pub height: fixed_t,
    pub viewx: fixed_t,
    pub viewy: fixed_t,
    pub viewz: fixed_t,
    pub viewangle: angle_t,
    pub plangle: angle_t,
    pub picnum: int32_t,
    pub lightlevel: int32_t,
    pub minx: int32_t,
    pub maxx: int32_t,
    pub extra_colormap: *mut extracolormap_t,
    pub padtopstart: uint16_t,
    pub top: [uint16_t; 1920],
    pub padtopend: uint16_t,
    pub padbottomstart: uint16_t,
    pub bottom: [uint16_t; 1920],
    pub padbottomend: uint16_t,
    pub high: int32_t,
    pub low: int32_t,
    pub xoffs: fixed_t,
    pub yoffs: fixed_t,
    pub ffloor: *mut ffloor_s,
    pub polyobj: *mut polyobj_t,
    pub slope: *mut pslope_t,
}
pub type polyobj_t = polyobj_s;
pub type thinker_t = thinker_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct thinker_s {
    pub prev: *mut thinker_s,
    pub next: *mut thinker_s,
    pub function: think_t,
    pub references: int32_t,
}
pub type think_t = actionf_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct vertex_t {
    pub x: fixed_t,
    pub y: fixed_t,
    pub floorzset: boolean,
    pub ceilingzset: boolean,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct degenmobj_t {
    pub thinker: thinker_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct line_s {
    pub v1: *mut vertex_t,
    pub v2: *mut vertex_t,
    pub dx: fixed_t,
    pub dy: fixed_t,
    pub angle: angle_t,
    pub flags: int16_t,
    pub special: int16_t,
    pub tags: taglist_t,
    pub args: [int32_t; 10],
    pub stringargs: [*mut libc::c_char; 2],
    pub sidenum: [uint16_t; 2],
    pub alpha: fixed_t,
    pub blendmode: uint8_t,
    pub executordelay: int32_t,
    pub bbox: [fixed_t; 4],
    pub slopetype: slopetype_t,
    pub frontsector: *mut sector_t,
    pub backsector: *mut sector_t,
    pub validcount: size_t,
    pub polyobj: *mut polyobj_t,
    pub callcount: int16_t,
}
pub type sector_t = sector_s;
pub type slopetype_t = libc::c_uint;
pub const ST_NEGATIVE: slopetype_t = 3;
pub const ST_POSITIVE: slopetype_t = 2;
pub const ST_VERTICAL: slopetype_t = 1;
pub const ST_HORIZONTAL: slopetype_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct seg_s {
    pub v1: *mut vertex_t,
    pub v2: *mut vertex_t,
    pub side: int32_t,
    pub offset: fixed_t,
    pub angle: angle_t,
    pub sidedef: *mut side_t,
    pub linedef: *mut line_t,
    pub frontsector: *mut sector_t,
    pub backsector: *mut sector_t,
    pub length: fixed_t,
    pub numlights: size_t,
    pub rlights: *mut r_lightlist_t,
    pub polyseg: *mut polyobj_t,
    pub dontrenderme: boolean,
    pub glseg: boolean,
}
pub type r_lightlist_t = r_lightlist_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct r_lightlist_s {
    pub height: fixed_t,
    pub heightstep: fixed_t,
    pub botheight: fixed_t,
    pub botheightstep: fixed_t,
    pub startheight: fixed_t,
    pub lightlevel: int16_t,
    pub extra_colormap: *mut extracolormap_t,
    pub rcolormap: *mut lighttable_t,
    pub flags: ffloortype_e,
    pub lightnum: int32_t,
}
pub type line_t = line_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct side_t {
    pub textureoffset: fixed_t,
    pub rowoffset: fixed_t,
    pub offsetx_top: fixed_t,
    pub offsetx_mid: fixed_t,
    pub offsetx_bot: fixed_t,
    pub offsety_top: fixed_t,
    pub offsety_mid: fixed_t,
    pub offsety_bot: fixed_t,
    pub toptexture: int32_t,
    pub bottomtexture: int32_t,
    pub midtexture: int32_t,
    pub line: *mut line_t,
    pub sector: *mut sector_t,
    pub special: int16_t,
    pub repeatcnt: int16_t,
    pub colormap_data: *mut extracolormap_t,
}
pub type mdllistitem_t = mdllistitem_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mdllistitem_s {
    pub next: *mut mdllistitem_s,
    pub prev: *mut *mut mdllistitem_s,
}
pub type precipmobj_t = precipmobj_s;
pub type sectorspecialflags_t = libc::c_uint;
pub const SSF_GRAVITYOVERRIDE: sectorspecialflags_t = 1048576;
pub const SSF_JUMPFLIP: sectorspecialflags_t = 524288;
pub const SSF_ROPEHANG: sectorspecialflags_t = 262144;
pub const SSF_FINISHLINE: sectorspecialflags_t = 131072;
pub const SSF_ZOOMTUBEEND: sectorspecialflags_t = 65536;
pub const SSF_ZOOMTUBESTART: sectorspecialflags_t = 32768;
pub const SSF_FORCESPIN: sectorspecialflags_t = 16384;
pub const SSF_SUPERTRANSFORM: sectorspecialflags_t = 8192;
pub const SSF_FAN: sectorspecialflags_t = 4096;
pub const SSF_BLUETEAMBASE: sectorspecialflags_t = 2048;
pub const SSF_REDTEAMBASE: sectorspecialflags_t = 1024;
pub const SSF_RETURNFLAG: sectorspecialflags_t = 512;
pub const SSF_SPECIALSTAGEPIT: sectorspecialflags_t = 256;
pub const SSF_EXIT: sectorspecialflags_t = 128;
pub const SSF_STARPOSTACTIVATOR: sectorspecialflags_t = 64;
pub const SSF_SPEEDPAD: sectorspecialflags_t = 32;
pub const SSF_CONVEYOR: sectorspecialflags_t = 16;
pub const SSF_WINDCURRENT: sectorspecialflags_t = 8;
pub const SSF_NOSTEPDOWN: sectorspecialflags_t = 4;
pub const SSF_DOUBLESTEPUP: sectorspecialflags_t = 2;
pub const SSF_OUTERSPACE: sectorspecialflags_t = 1;
pub type sectorflags_t = libc::c_uint;
pub const MSF_NOCLIPCAMERA: sectorflags_t = 512;
pub const MSF_HEATWAVE: sectorflags_t = 256;
pub const MSF_GRAVITYFLIP: sectorflags_t = 128;
pub const MSF_INVERTPRECIP: sectorflags_t = 64;
pub const MSF_TRIGGERLINE_MOBJ: sectorflags_t = 32;
pub const MSF_TRIGGERLINE_PLANE: sectorflags_t = 16;
pub const MSF_TRIGGERSPECIAL_HEADBUMP: sectorflags_t = 8;
pub const MSF_TRIGGERSPECIAL_TOUCH: sectorflags_t = 4;
pub const MSF_FLIPSPECIAL_BOTH: sectorflags_t = 3;
pub const MSF_FLIPSPECIAL_CEILING: sectorflags_t = 2;
pub const MSF_FLIPSPECIAL_FLOOR: sectorflags_t = 1;
pub type lightlist_t = lightlist_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lightlist_s {
    pub height: fixed_t,
    pub lightlevel: *mut int16_t,
    pub extra_colormap: *mut *mut extracolormap_t,
    pub flags: int32_t,
    pub caster: *mut ffloor_t,
    pub slope: *mut pslope_s,
}
pub type ffloor_t = ffloor_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct msecnode_s {
    pub m_sector: *mut sector_t,
    pub m_thing: *mut mobj_s,
    pub m_sectorlist_prev: *mut msecnode_s,
    pub m_sectorlist_next: *mut msecnode_s,
    pub m_thinglist_prev: *mut msecnode_s,
    pub m_thinglist_next: *mut msecnode_s,
    pub visited: boolean,
}
pub type playersprite = libc::c_uint;
pub const NUMPLAYERSPRITES: playersprite = 128;
pub const SPR2_LASTFREESLOT: playersprite = 127;
pub const SPR2_FIRSTFREESLOT: playersprite = 60;
pub const SPR2_XTRA: playersprite = 59;
pub const SPR2_LIFE: playersprite = 58;
pub const SPR2_SIGN: playersprite = 57;
pub const SPR2_CNT4: playersprite = 56;
pub const SPR2_CNT3: playersprite = 55;
pub const SPR2_CNT2: playersprite = 54;
pub const SPR2_CNT1: playersprite = 53;
pub const SPR2_TALC: playersprite = 52;
pub const SPR2_TALB: playersprite = 51;
pub const SPR2_TALA: playersprite = 50;
pub const SPR2_TAL9: playersprite = 49;
pub const SPR2_TAL8: playersprite = 48;
pub const SPR2_TAL7: playersprite = 47;
pub const SPR2_TAL6: playersprite = 46;
pub const SPR2_TAL5: playersprite = 45;
pub const SPR2_TAL4: playersprite = 44;
pub const SPR2_TAL3: playersprite = 43;
pub const SPR2_TAL2: playersprite = 42;
pub const SPR2_TAL1: playersprite = 41;
pub const SPR2_TAL0: playersprite = 40;
pub const SPR2_NATK: playersprite = 39;
pub const SPR2_NPUL: playersprite = 38;
pub const SPR2_NSTN: playersprite = 37;
pub const SPR2_NDRL: playersprite = 36;
pub const SPR2_NFLY: playersprite = 35;
pub const SPR2_NFLT: playersprite = 34;
pub const SPR2_NSTD: playersprite = 33;
pub const SPR2_TRNS: playersprite = 32;
pub const SPR2_MLEL: playersprite = 31;
pub const SPR2_MLEE: playersprite = 30;
pub const SPR2_TWIN: playersprite = 29;
pub const SPR2_FIRE: playersprite = 28;
pub const SPR2_BNCE: playersprite = 27;
pub const SPR2_FRUN: playersprite = 26;
pub const SPR2_FLT: playersprite = 25;
pub const SPR2_CLMB: playersprite = 24;
pub const SPR2_CLNG: playersprite = 23;
pub const SPR2_LAND: playersprite = 22;
pub const SPR2_GLID: playersprite = 21;
pub const SPR2_TIRE: playersprite = 20;
pub const SPR2_SWIM: playersprite = 19;
pub const SPR2_FLY: playersprite = 18;
pub const SPR2_SPIN: playersprite = 17;
pub const SPR2_RIDE: playersprite = 16;
pub const SPR2_EDGE: playersprite = 15;
pub const SPR2_FALL: playersprite = 14;
pub const SPR2_SPNG: playersprite = 13;
pub const SPR2_JUMP: playersprite = 12;
pub const SPR2_GASP: playersprite = 11;
pub const SPR2_ROLL: playersprite = 10;
pub const SPR2_DRWN: playersprite = 9;
pub const SPR2_DEAD: playersprite = 8;
pub const SPR2_STUN: playersprite = 7;
pub const SPR2_PAIN: playersprite = 6;
pub const SPR2_DASH: playersprite = 5;
pub const SPR2_RUN: playersprite = 4;
pub const SPR2_SKID: playersprite = 3;
pub const SPR2_WALK: playersprite = 2;
pub const SPR2_WAIT: playersprite = 1;
pub const SPR2_STND: playersprite = 0;
pub type C2RustUnnamed_0 = libc::c_uint;
pub const NUMTRANSMAPS: C2RustUnnamed_0 = 10;
pub const tr_trans90: C2RustUnnamed_0 = 9;
pub const tr_trans80: C2RustUnnamed_0 = 8;
pub const tr_trans70: C2RustUnnamed_0 = 7;
pub const tr_trans60: C2RustUnnamed_0 = 6;
pub const tr_trans50: C2RustUnnamed_0 = 5;
pub const tr_trans40: C2RustUnnamed_0 = 4;
pub const tr_trans30: C2RustUnnamed_0 = 3;
pub const tr_trans20: C2RustUnnamed_0 = 2;
pub const tr_trans10: C2RustUnnamed_0 = 1;
pub type mobjflag_t = libc::c_uint;
pub const MF_RUNSPAWNFUNC: mobjflag_t = 536870912;
pub const MF_GRENADEBOUNCE: mobjflag_t = 268435456;
pub const MF_NOCLIPTHING: mobjflag_t = 134217728;
pub const MF_NIGHTSITEM: mobjflag_t = 67108864;
pub const MF_STICKY: mobjflag_t = 33554432;
pub const MF_PAIN: mobjflag_t = 16777216;
pub const MF_SCENERY: mobjflag_t = 8388608;
pub const MF_ENEMY: mobjflag_t = 4194304;
pub const MF_NOCLIPHEIGHT: mobjflag_t = 2097152;
pub const MF_FIRE: mobjflag_t = 1048576;
pub const MF_NOTHINK: mobjflag_t = 524288;
pub const MF_MONITOR: mobjflag_t = 262144;
pub const MF_BOUNCE: mobjflag_t = 131072;
pub const MF_SPRING: mobjflag_t = 65536;
pub const MF_MISSILE: mobjflag_t = 32768;
pub const MF_BOXICON: mobjflag_t = 16384;
pub const MF_FLOAT: mobjflag_t = 8192;
pub const MF_NOCLIP: mobjflag_t = 4096;
pub const MF_SLIDEME: mobjflag_t = 2048;
pub const MF_AMBIENT: mobjflag_t = 1024;
pub const MF_NOGRAVITY: mobjflag_t = 512;
pub const MF_SPAWNCEILING: mobjflag_t = 256;
pub const MF_BOSS: mobjflag_t = 128;
pub const MF_PUSHABLE: mobjflag_t = 64;
pub const MF_PAPERCOLLISION: mobjflag_t = 32;
pub const MF_NOBLOCKMAP: mobjflag_t = 16;
pub const MF_NOSECTOR: mobjflag_t = 8;
pub const MF_SHOOTABLE: mobjflag_t = 4;
pub const MF_SOLID: mobjflag_t = 2;
pub const MF_SPECIAL: mobjflag_t = 1;
pub type mobjflag2_t = libc::c_uint;
pub const MF2_SPLAT: mobjflag2_t = 1073741824;
pub const MF2_SHIELD: mobjflag2_t = 536870912;
pub const MF2_LINKDRAW: mobjflag2_t = 268435456;
pub const MF2_AMBUSH: mobjflag2_t = 134217728;
pub const MF2_BOSSDEAD: mobjflag2_t = 67108864;
pub const MF2_BOSSFLEE: mobjflag2_t = 33554432;
pub const MF2_BOSSNOTRAP: mobjflag2_t = 16777216;
pub const MF2_FRET: mobjflag2_t = 8388608;
pub const MF2_SKULLFLY: mobjflag2_t = 4194304;
pub const MF2_OBJECTFLIP: mobjflag2_t = 2097152;
pub const MF2_STRONGBOX: mobjflag2_t = 1048576;
pub const MF2_SHADOW: mobjflag2_t = 524288;
pub const MF2_SUPERFIRE: mobjflag2_t = 262144;
pub const MF2_FIRING: mobjflag2_t = 131072;
pub const MF2_JUSTATTACKED: mobjflag2_t = 65536;
pub const MF2_NIGHTSPULL: mobjflag2_t = 32768;
pub const MF2_DEBRIS: mobjflag2_t = 16384;
pub const MF2_INFLOAT: mobjflag2_t = 8192;
pub const MF2_INVERTAIMABLE: mobjflag2_t = 4096;
pub const MF2_CLASSICPUSH: mobjflag2_t = 2048;
pub const MF2_SLIDEPUSH: mobjflag2_t = 1024;
pub const MF2_BEYONDTHEGRAVE: mobjflag2_t = 512;
pub const MF2_SCATTER: mobjflag2_t = 256;
pub const MF2_EXPLOSION: mobjflag2_t = 128;
pub const MF2_BOUNCERING: mobjflag2_t = 64;
pub const MF2_RAILRING: mobjflag2_t = 32;
pub const MF2_AUTOMATIC: mobjflag2_t = 16;
pub const MF2_DONTDRAW: mobjflag2_t = 8;
pub const MF2_DONTRESPAWN: mobjflag2_t = 4;
pub const MF2_TWOD: mobjflag2_t = 2;
pub const MF2_AXIS: mobjflag2_t = 1;
pub type mobjeflag_t = libc::c_uint;
pub const MFE_REVERSESUPER: mobjeflag_t = 12288;
pub const MFE_FORCENOSUPER: mobjeflag_t = 8192;
pub const MFE_FORCESUPER: mobjeflag_t = 4096;
pub const MFE_TRACERANGLE: mobjeflag_t = 2048;
pub const MFE_APPLYPMOMZ: mobjeflag_t = 1024;
pub const MFE_SPRUNG: mobjeflag_t = 512;
pub const MFE_PUSHED: mobjeflag_t = 256;
pub const MFE_TOUCHLAVA: mobjeflag_t = 128;
pub const MFE_GOOWATER: mobjeflag_t = 64;
pub const MFE_VERTICALFLIP: mobjeflag_t = 32;
pub const MFE_JUSTSTEPPEDDOWN: mobjeflag_t = 16;
pub const MFE_UNDERWATER: mobjeflag_t = 8;
pub const MFE_TOUCHWATER: mobjeflag_t = 4;
pub const MFE_JUSTHITFLOOR: mobjeflag_t = 2;
pub const MFE_ONGROUND: mobjeflag_t = 1;
pub type C2RustUnnamed_1 = libc::c_uint;
pub const PCF_THUNK: C2RustUnnamed_1 = 32;
pub const PCF_RAIN: C2RustUnnamed_1 = 16;
pub const PCF_MOVINGFOF: C2RustUnnamed_1 = 8;
pub const PCF_FOF: C2RustUnnamed_1 = 4;
pub const PCF_PIT: C2RustUnnamed_1 = 2;
pub const PCF_INVISIBLE: C2RustUnnamed_1 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct actioncache_s {
    pub next: *mut actioncache_s,
    pub prev: *mut actioncache_s,
    pub mobj: *mut mobj_s,
    pub statenum: int32_t,
}
pub type actioncache_t = actioncache_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spritedef_t {
    pub numframes: size_t,
    pub spriteframes: *mut spriteframe_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spriteframe_t {
    pub rotate: uint8_t,
    pub lumppat: [lumpnum_t; 16],
    pub lumpid: [size_t; 16],
    pub flip: uint16_t,
    pub rotated: [[*mut rotsprite_t; 16]; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rotsprite_t {
    pub angles: int32_t,
    pub patches: *mut *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct skin_t {
    pub name: [libc::c_char; 17],
    pub wadnum: uint16_t,
    pub flags: skinflags_t,
    pub realname: [libc::c_char; 17],
    pub hudname: [libc::c_char; 17],
    pub supername: [libc::c_char; 23],
    pub ability: uint8_t,
    pub ability2: uint8_t,
    pub thokitem: int32_t,
    pub spinitem: int32_t,
    pub revitem: int32_t,
    pub followitem: int32_t,
    pub actionspd: fixed_t,
    pub mindash: fixed_t,
    pub maxdash: fixed_t,
    pub normalspeed: fixed_t,
    pub runspeed: fixed_t,
    pub thrustfactor: uint8_t,
    pub accelstart: uint8_t,
    pub acceleration: uint8_t,
    pub jumpfactor: fixed_t,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub spinheight: fixed_t,
    pub shieldscale: fixed_t,
    pub camerascale: fixed_t,
    pub starttranscolor: uint8_t,
    pub prefcolor: uint16_t,
    pub supercolor: uint16_t,
    pub prefoppositecolor: uint16_t,
    pub highresscale: fixed_t,
    pub contspeed: uint8_t,
    pub contangle: uint8_t,
    pub soundsid: [sfxenum_t; 21],
    pub sprites: [spritedef_t; 256],
    pub sprinfo: [spriteinfo_t; 256],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spriteinfo_t {
    pub pivot: [spriteframepivot_t; 64],
    pub available: boolean,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct spriteframepivot_t {
    pub x: int32_t,
    pub y: int32_t,
}
pub type skinflags_t = libc::c_uint;
pub const SF_NOSHIELDABILITY: skinflags_t = 524288;
pub const SF_CANBUSTWALLS: skinflags_t = 262144;
pub const SF_NOSUPERJUMPBOOST: skinflags_t = 131072;
pub const SF_NOSUPERSPRITES: skinflags_t = 65536;
pub const SF_NONIGHTSSUPER: skinflags_t = 32768;
pub const SF_NONIGHTSROTATION: skinflags_t = 16384;
pub const SF_MULTIABILITY: skinflags_t = 8192;
pub const SF_FASTEDGE: skinflags_t = 4096;
pub const SF_DASHMODE: skinflags_t = 2048;
pub const SF_MACHINE: skinflags_t = 1024;
pub const SF_MARIODAMAGE: skinflags_t = 768;
pub const SF_STOMPDAMAGE: skinflags_t = 512;
pub const SF_NOJUMPDAMAGE: skinflags_t = 256;
pub const SF_NOJUMPSPIN: skinflags_t = 128;
pub const SF_RUNONWATER: skinflags_t = 64;
pub const SF_NOSPEEDADJUST: skinflags_t = 32;
pub const SF_NOSKID: skinflags_t = 16;
pub const SF_HIRES: skinflags_t = 8;
pub const SF_NOSPINDASHDUST: skinflags_t = 4;
pub const SF_NOSUPERSPIN: skinflags_t = 2;
pub const SF_SUPER: skinflags_t = 1;
pub type player_t = player_s;
pub type thinklistnum_t = libc::c_uint;
pub const NUM_THINKERLISTS: thinklistnum_t = 5;
pub const THINK_PRECIP: thinklistnum_t = 4;
pub const THINK_DYNSLOPE: thinklistnum_t = 3;
pub const THINK_MOBJ: thinklistnum_t = 2;
pub const THINK_MAIN: thinklistnum_t = 1;
pub const THINK_POLYOBJ: thinklistnum_t = 0;
pub type msecnode_t = msecnode_s;
pub const mobjhook_MobjRemoved: C2RustUnnamed_30 = 12;
pub const pw_super: C2RustUnnamed_7 = 12;
pub const CA_SLOWFALL: C2RustUnnamed_4 = 8;
pub const CA_FLOAT: C2RustUnnamed_4 = 7;
pub const CA2_SPINDASH: C2RustUnnamed_5 = 1;
pub const pw_flashing: C2RustUnnamed_7 = 2;
pub const CA_GLIDEANDCLIMB: C2RustUnnamed_4 = 3;
pub const SD_DEATHPITNOTILT: C2RustUnnamed_13 = 8;
pub const SD_DEATHPITTILT: C2RustUnnamed_13 = 7;
pub const TOL_NIGHTS: TypeOfLevel = 1024;
pub type camera_t = camera_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct camera_s {
    pub chase: boolean,
    pub aiming: angle_t,
    pub viewheight: fixed_t,
    pub startangle: angle_t,
    pub x: fixed_t,
    pub y: fixed_t,
    pub z: fixed_t,
    pub reset: boolean,
    pub angle: angle_t,
    pub subsector: *mut subsector_s,
    pub floorz: fixed_t,
    pub ceilingz: fixed_t,
    pub radius: fixed_t,
    pub height: fixed_t,
    pub relativex: fixed_t,
    pub momx: fixed_t,
    pub momy: fixed_t,
    pub momz: fixed_t,
}
pub const CR_NIGHTSMODE: C2RustUnnamed_6 = 3;
pub const pw_carry: C2RustUnnamed_7 = 4;
pub const pw_gravityboots: C2RustUnnamed_7 = 13;
pub const CA_FLY: C2RustUnnamed_4 = 2;
pub const PU_LEVEL: C2RustUnnamed_29 = 50;
pub const mobjhook_MobjSpawn: C2RustUnnamed_30 = 0;
pub const AST_TRANSLUCENT: patchalphastyle = 1;
pub const TOL_ERZ3: TypeOfLevel = 2048;
pub type subsector_t = subsector_s;
pub const POF_CLIPPLANES: C2RustUnnamed_10 = 2;
pub const POF_SOLID: C2RustUnnamed_10 = 3;
pub const SD_LAVA: C2RustUnnamed_13 = 4;
pub const BOXTOP: C2RustUnnamed_15 = 0;
pub const BOXBOTTOM: C2RustUnnamed_15 = 1;
pub const BOXRIGHT: C2RustUnnamed_15 = 3;
pub const BOXLEFT: C2RustUnnamed_15 = 2;
pub const SL_NOPHYSICS: C2RustUnnamed_12 = 1;
pub const TOL_2D: TypeOfLevel = 256;
pub const pw_justlaunched: C2RustUnnamed_7 = 27;
pub const pw_pushing: C2RustUnnamed_7 = 9;
pub const BT_SPINBUST: C2RustUnnamed_11 = 1;
pub const BT_TOUCH: C2RustUnnamed_11 = 0;
pub const CRUMBLE_NONE: C2RustUnnamed_14 = 0;
pub const mobjhook_MobjFuse: C2RustUnnamed_30 = 5;
pub const SH_BUBBLEWRAP: shieldtype_t = 2049;
pub const SH_NOSTACK: shieldtype_t = -513;
pub const pw_shield: C2RustUnnamed_7 = 3;
pub const SH_ELEMENTAL: shieldtype_t = 3073;
pub const pw_underwater: C2RustUnnamed_7 = 6;
pub const TOL_MARIO: TypeOfLevel = 512;
pub const SH_PROTECTWATER: shieldtype_t = 2048;
pub const SH_STACK: shieldtype_t = 512;
pub const SH_PROTECTELECTRIC: shieldtype_t = 4096;
pub const SH_PROTECTFIRE: shieldtype_t = 1024;
pub const pw_invulnerability: C2RustUnnamed_7 = 0;
pub const SD_FIRE: C2RustUnnamed_13 = 3;
pub const TMPP_NONEXCLUSIVE: C2RustUnnamed_28 = 4;
pub const TMPP_PUSHZ: C2RustUnnamed_28 = 2;
pub const TMPP_NOZFADE: C2RustUnnamed_28 = 1;
pub const CR_ROPEHANG: C2RustUnnamed_6 = 7;
pub const POF_LDEXEC: C2RustUnnamed_10 = 1024;
pub const CR_MACESPIN: C2RustUnnamed_6 = 8;
pub const CR_ZOOMTUBE: C2RustUnnamed_6 = 6;
pub const TMED_LEFT: C2RustUnnamed_24 = 2;
pub const TMED_NONE: C2RustUnnamed_24 = 0;
pub type ceiling_e = libc::c_uint;
pub const bounceCeilingCrush: ceiling_e = 11;
pub const bounceCeiling: ceiling_e = 10;
pub const moveCeilingByDistance: ceiling_e = 9;
pub const instantMoveCeilingByFrontSector: ceiling_e = 8;
pub const moveCeilingByFrontSector: ceiling_e = 7;
pub const crushBothOnce: ceiling_e = 6;
pub const crushCeilOnce: ceiling_e = 5;
pub const raiseAndCrush: ceiling_e = 4;
pub const crushAndRaise: ceiling_e = 3;
pub const instantRaise: ceiling_e = 2;
pub const lowerToLowestFast: ceiling_e = 1;
pub const raiseToHighest: ceiling_e = 0;
pub const BOT_2PHUMAN: C2RustUnnamed_8 = 2;
pub const BOT_2PAI: C2RustUnnamed_8 = 1;
pub const pw_tailsfly: C2RustUnnamed_7 = 5;
pub const CR_BRAKGOOP: C2RustUnnamed_6 = 5;
pub const mobjhook_BossThinker: C2RustUnnamed_30 = 7;
pub const CR_MINECART: C2RustUnnamed_6 = 9;
pub const mobjhook_MobjThinker: C2RustUnnamed_30 = 6;
pub type consvar_t = consvar_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct consvar_s {
    pub name: *const libc::c_char,
    pub defaultvalue: *const libc::c_char,
    pub flags: int32_t,
    pub PossibleValue: *mut CV_PossibleValue_t,
    pub func: Option::<unsafe extern "C" fn() -> ()>,
    pub value: int32_t,
    pub string: *const libc::c_char,
    pub zstring: *mut libc::c_char,
    pub revert: C2RustUnnamed_2,
    pub netid: uint16_t,
    pub changed: libc::c_char,
    pub next: *mut consvar_s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub allocated: libc::c_char,
    pub v: C2RustUnnamed_3,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub string: *mut libc::c_char,
    pub const_munge: *const libc::c_char,
}
pub type CV_PossibleValue_t = CV_PossibleValue_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CV_PossibleValue_s {
    pub value: int32_t,
    pub strvalue: *const libc::c_char,
}
pub const pw_spacetime: C2RustUnnamed_7 = 7;
pub type shieldtype_t = libc::c_int;
pub const SH_FIREFLOWER: shieldtype_t = 512;
pub const SH_FORCEHP: shieldtype_t = 255;
pub const SH_FORCE: shieldtype_t = 256;
pub const SH_THUNDERCOIN: shieldtype_t = 4098;
pub const SH_FLAMEAURA: shieldtype_t = 1025;
pub const SH_ATTRACT: shieldtype_t = 4097;
pub const SH_PINK: shieldtype_t = 4;
pub const SH_ARMAGEDDON: shieldtype_t = 3;
pub const SH_WHIRLWIND: shieldtype_t = 2;
pub const SH_PITY: shieldtype_t = 1;
pub const SH_PROTECTSPIKE: shieldtype_t = 8192;
pub const SH_NONE: shieldtype_t = 0;
pub const GTR_SPAWNINVUL: GameTypeRules = 134217728;
pub type netxcmd_t = libc::c_uint;
pub const MAXNETXCMD: netxcmd_t = 25;
pub const XD_LUAFILE: netxcmd_t = 24;
pub const XD_LUAVAR: netxcmd_t = 23;
pub const XD_LUACMD: netxcmd_t = 22;
pub const XD_DEMOTED: netxcmd_t = 21;
pub const XD_SUICIDE: netxcmd_t = 20;
pub const XD_SETMOTD: netxcmd_t = 19;
pub const XD_REQADDFOLDER: netxcmd_t = 18;
pub const XD_REQADDFILE: netxcmd_t = 17;
pub const XD_RUNSOC: netxcmd_t = 16;
pub const XD_RANDOMSEED: netxcmd_t = 15;
pub const XD_VERIFIED: netxcmd_t = 14;
pub const XD_CLEARSCORES: netxcmd_t = 13;
pub const XD_TEAMCHANGE: netxcmd_t = 12;
pub const XD_ADDPLAYER: netxcmd_t = 11;
pub const XD_PAUSE: netxcmd_t = 10;
pub const XD_ADDFOLDER: netxcmd_t = 9;
pub const XD_ADDFILE: netxcmd_t = 8;
pub const XD_EXITLEVEL: netxcmd_t = 7;
pub const XD_MAP: netxcmd_t = 6;
pub const XD_SAY: netxcmd_t = 5;
pub const XD_NETVAR: netxcmd_t = 4;
pub const XD_KICK: netxcmd_t = 3;
pub const XD_WEAPONPREF: netxcmd_t = 2;
pub const XD_NAMEANDCOLOR: netxcmd_t = 1;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct changeteam_value_t {
    pub l: uint16_t,
    pub b: uint16_t,
}
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub union changeteam_union {
    pub packet: changeteam_packet_t,
    pub value: changeteam_value_t,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C, packed)]
pub struct changeteam_packet_t {
    #[bitfield(name = "playernum", ty = "uint32_t", bits = "0..=4")]
    #[bitfield(name = "newteam", ty = "uint32_t", bits = "5..=9")]
    #[bitfield(name = "verification", ty = "uint32_t", bits = "10..=10")]
    #[bitfield(name = "autobalance", ty = "uint32_t", bits = "11..=11")]
    #[bitfield(name = "scrambled", ty = "uint32_t", bits = "12..=12")]
    pub playernum_newteam_verification_autobalance_scrambled: [u8; 2],
}
pub const GTR_NOSPECTATORSPAWN: GameTypeRules = 33554432;
pub const TMMR_STRONG: C2RustUnnamed_25 = 2;
pub const TMMR_WEAK: C2RustUnnamed_25 = 1;
pub const TMMR_SAME: C2RustUnnamed_25 = 0;
pub const TMP_CLASSIC: C2RustUnnamed_23 = 3;
pub const TMP_IMMOVABLE: C2RustUnnamed_23 = 2;
pub const TMP_SLIDE: C2RustUnnamed_23 = 1;
pub const TMP_NORMAL: C2RustUnnamed_23 = 0;
pub const TMNI_REVEAL: C2RustUnnamed_22 = 2;
pub const TMNI_BONUSONLY: C2RustUnnamed_22 = 1;
pub const TMDS_ROTATEEXTRA: C2RustUnnamed_20 = 2;
pub const TMDS_NOGRAVITY: C2RustUnnamed_20 = 1;
pub const TOL_XMAS: TypeOfLevel = 4096;
pub const TMSF_INTANGIBLE: C2RustUnnamed_18 = 2;
pub const TMSF_RETRACTED: C2RustUnnamed_18 = 1;
pub const TMB_BARRIER: C2RustUnnamed_27 = 2;
pub const TMDA_TOP: C2RustUnnamed_17 = 8;
pub const TMDA_MIDDLE: C2RustUnnamed_17 = 4;
pub const TMDA_BOTTOM: C2RustUnnamed_17 = 2;
pub const TMDA_BOTTOMOFFSET: C2RustUnnamed_17 = 1;
pub const TMM_MACELINKS: C2RustUnnamed_16 = 16;
pub const TMM_DOUBLESIZE: C2RustUnnamed_16 = 1;
pub const TMM_SWING: C2RustUnnamed_16 = 8;
pub const TMM_CENTERLINK: C2RustUnnamed_16 = 32;
pub const TMM_SILENT: C2RustUnnamed_16 = 2;
pub const TMM_CLIP: C2RustUnnamed_16 = 64;
pub const TMM_ALWAYSTHINK: C2RustUnnamed_16 = 128;
pub const TMM_ALLOWYAWCONTROL: C2RustUnnamed_16 = 4;
pub const TMFH_CORONA: C2RustUnnamed_19 = 2;
pub const TMFH_NOFLAME: C2RustUnnamed_19 = 1;
pub const TMF_SKIPINTRO: C2RustUnnamed_26 = 2;
pub const TMF_GRAYSCALE: C2RustUnnamed_26 = 1;
pub const TMF_NODISTANCECHECK: C2RustUnnamed_21 = 2;
pub const TMF_INVISIBLE: C2RustUnnamed_21 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct emblem_t {
    pub type_0: uint8_t,
    pub tag: int16_t,
    pub level: int16_t,
    pub sprite: uint8_t,
    pub color: uint16_t,
    pub var: int32_t,
    pub stringVar: *mut libc::c_char,
    pub hint: [libc::c_char; 110],
}
pub const GTR_TEAMS: GameTypeRules = 16;
pub const GTR_RACE: GameTypeRules = 4096;
pub const GTR_TEAMFLAGS: GameTypeRules = 128;
pub const GTR_ALLOWEXIT: GameTypeRules = 536870912;
pub const GTR_SPAWNENEMIES: GameTypeRules = 268435456;
pub const GTR_EMERALDTOKENS: GameTypeRules = 1024;
pub const GTR_POWERSTONES: GameTypeRules = 64;
pub const GTR_EMERALDHUNT: GameTypeRules = 2048;
pub type mprecipsecnode_t = mprecipsecnode_s;
pub const pw_emeralds: C2RustUnnamed_7 = 21;
pub type C2RustUnnamed_4 = libc::c_uint;
pub const CA_TWINSPIN: C2RustUnnamed_4 = 15;
pub const CA_BOUNCE: C2RustUnnamed_4 = 14;
pub const CA_JUMPTHOK: C2RustUnnamed_4 = 13;
pub const CA_AIRDRILL: C2RustUnnamed_4 = 12;
pub const CA_JUMPBOOST: C2RustUnnamed_4 = 11;
pub const CA_FALLSWITCH: C2RustUnnamed_4 = 10;
pub const CA_TELEKINESIS: C2RustUnnamed_4 = 9;
pub const CA_DOUBLEJUMP: C2RustUnnamed_4 = 6;
pub const CA_SWIM: C2RustUnnamed_4 = 5;
pub const CA_HOMINGTHOK: C2RustUnnamed_4 = 4;
pub const CA_THOK: C2RustUnnamed_4 = 1;
pub const CA_NONE: C2RustUnnamed_4 = 0;
pub type C2RustUnnamed_5 = libc::c_uint;
pub const CA2_MELEE: C2RustUnnamed_5 = 3;
pub const CA2_GUNSLINGER: C2RustUnnamed_5 = 2;
pub const CA2_NONE: C2RustUnnamed_5 = 0;
pub type C2RustUnnamed_6 = libc::c_uint;
pub const CR_FAN: C2RustUnnamed_6 = 13;
pub const CR_DUSTDEVIL: C2RustUnnamed_6 = 12;
pub const CR_PTERABYTE: C2RustUnnamed_6 = 11;
pub const CR_ROLLOUT: C2RustUnnamed_6 = 10;
pub const CR_NIGHTSFALL: C2RustUnnamed_6 = 4;
pub const CR_PLAYER: C2RustUnnamed_6 = 2;
pub const CR_GENERIC: C2RustUnnamed_6 = 1;
pub const CR_NONE: C2RustUnnamed_6 = 0;
pub type C2RustUnnamed_7 = libc::c_uint;
pub const NUMPOWERS: C2RustUnnamed_7 = 30;
pub const pw_strong: C2RustUnnamed_7 = 29;
pub const pw_ignorelatch: C2RustUnnamed_7 = 28;
pub const pw_dye: C2RustUnnamed_7 = 26;
pub const pw_nocontrol: C2RustUnnamed_7 = 25;
pub const pw_nights_linkfreeze: C2RustUnnamed_7 = 24;
pub const pw_nights_helper: C2RustUnnamed_7 = 23;
pub const pw_nights_superloop: C2RustUnnamed_7 = 22;
pub const pw_railring: C2RustUnnamed_7 = 20;
pub const pw_explosionring: C2RustUnnamed_7 = 19;
pub const pw_grenadering: C2RustUnnamed_7 = 18;
pub const pw_scatterring: C2RustUnnamed_7 = 17;
pub const pw_bouncering: C2RustUnnamed_7 = 16;
pub const pw_automaticring: C2RustUnnamed_7 = 15;
pub const pw_infinityring: C2RustUnnamed_7 = 14;
pub const pw_noautobrake: C2RustUnnamed_7 = 11;
pub const pw_justsprung: C2RustUnnamed_7 = 10;
pub const pw_extralife: C2RustUnnamed_7 = 8;
pub const pw_sneakers: C2RustUnnamed_7 = 1;
pub type C2RustUnnamed_8 = libc::c_uint;
pub const BOT_MPAI: C2RustUnnamed_8 = 3;
pub const BOT_NONE: C2RustUnnamed_8 = 0;
pub type GameTypeRules = libc::c_int;
pub const GTR_CUTSCENES: GameTypeRules = -2147483648;
pub const GTR_NOTITLECARD: GameTypeRules = 1073741824;
pub const GTR_DEATHMATCHSTARTS: GameTypeRules = 67108864;
pub const GTR_DEATHPENALTY: GameTypeRules = 16777216;
pub const GTR_PITYSHIELD: GameTypeRules = 8388608;
pub const GTR_RESPAWNDELAY: GameTypeRules = 4194304;
pub const GTR_BLINDFOLDED: GameTypeRules = 2097152;
pub const GTR_HIDEFROZEN: GameTypeRules = 1048576;
pub const GTR_STARTCOUNTDOWN: GameTypeRules = 524288;
pub const GTR_FRIENDLYFIRE: GameTypeRules = 262144;
pub const GTR_HURTMESSAGES: GameTypeRules = 131072;
pub const GTR_OVERTIME: GameTypeRules = 65536;
pub const GTR_TIMELIMIT: GameTypeRules = 32768;
pub const GTR_POINTLIMIT: GameTypeRules = 16384;
pub const GTR_TAG: GameTypeRules = 8192;
pub const GTR_SPECIALSTAGES: GameTypeRules = 512;
pub const GTR_FRIENDLY: GameTypeRules = 256;
pub const GTR_FIRSTPERSON: GameTypeRules = 32;
pub const GTR_LIVES: GameTypeRules = 8;
pub const GTR_SPECTATORS: GameTypeRules = 4;
pub const GTR_RINGSLINGER: GameTypeRules = 2;
pub const GTR_CAMPAIGN: GameTypeRules = 1;
pub type TypeOfLevel = libc::c_uint;
pub const TOL_CTF: TypeOfLevel = 64;
pub const TOL_TAG: TypeOfLevel = 32;
pub const TOL_MATCH: TypeOfLevel = 16;
pub const TOL_RACE: TypeOfLevel = 8;
pub const TOL_COMPETITION: TypeOfLevel = 4;
pub const TOL_COOP: TypeOfLevel = 2;
pub const TOL_SP: TypeOfLevel = 1;
pub type C2RustUnnamed_9 = libc::c_uint;
pub const CV_ALLOWLUA: C2RustUnnamed_9 = 4096;
pub const CV_CHEAT: C2RustUnnamed_9 = 2048;
pub const CV_HIDEN: C2RustUnnamed_9 = 1024;
pub const CV_NOSHOWHELP: C2RustUnnamed_9 = 512;
pub const CV_SHOWMODIFONETIME: C2RustUnnamed_9 = 256;
pub const CV_SHOWMODIF: C2RustUnnamed_9 = 128;
pub const CV_MODIFIED: C2RustUnnamed_9 = 64;
pub const CV_NOTINNET: C2RustUnnamed_9 = 32;
pub const CV_FLOAT: C2RustUnnamed_9 = 16;
pub const CV_NOINIT: C2RustUnnamed_9 = 8;
pub const CV_NETVAR: C2RustUnnamed_9 = 4;
pub const CV_CALL: C2RustUnnamed_9 = 2;
pub const CV_SAVE: C2RustUnnamed_9 = 1;
pub type C2RustUnnamed_10 = libc::c_uint;
pub const POF_SPLAT: C2RustUnnamed_10 = 8192;
pub const POF_NOSPECIALS: C2RustUnnamed_10 = 4096;
pub const POF_ONESIDE: C2RustUnnamed_10 = 2048;
pub const POF_PUSHABLESTOP: C2RustUnnamed_10 = 512;
pub const POF_INVERTPLANESONLY: C2RustUnnamed_10 = 256;
pub const POF_INVERTPLANES: C2RustUnnamed_10 = 128;
pub const POF_INVERT: C2RustUnnamed_10 = 64;
pub const POF_RENDERALL: C2RustUnnamed_10 = 56;
pub const POF_RENDERPLANES: C2RustUnnamed_10 = 48;
pub const POF_RENDERBOTTOM: C2RustUnnamed_10 = 32;
pub const POF_RENDERTOP: C2RustUnnamed_10 = 16;
pub const POF_RENDERSIDES: C2RustUnnamed_10 = 8;
pub const POF_TESTHEIGHT: C2RustUnnamed_10 = 4;
pub const POF_CLIPLINES: C2RustUnnamed_10 = 1;
pub type C2RustUnnamed_11 = libc::c_uint;
pub const BT_STRONG: C2RustUnnamed_11 = 3;
pub const BT_REGULAR: C2RustUnnamed_11 = 2;
pub type C2RustUnnamed_12 = libc::c_uint;
pub const SL_DYNAMIC: C2RustUnnamed_12 = 2;
pub type C2RustUnnamed_13 = libc::c_uint;
pub const SD_SPECIALSTAGE: C2RustUnnamed_13 = 10;
pub const SD_INSTAKILL: C2RustUnnamed_13 = 9;
pub const SD_SPIKE: C2RustUnnamed_13 = 6;
pub const SD_ELECTRIC: C2RustUnnamed_13 = 5;
pub const SD_WATER: C2RustUnnamed_13 = 2;
pub const SD_GENERIC: C2RustUnnamed_13 = 1;
pub const SD_NONE: C2RustUnnamed_13 = 0;
pub type C2RustUnnamed_14 = libc::c_uint;
pub const CRUMBLE_RESTORE: C2RustUnnamed_14 = 4;
pub const CRUMBLE_FALL: C2RustUnnamed_14 = 3;
pub const CRUMBLE_ACTIVATED: C2RustUnnamed_14 = 2;
pub const CRUMBLE_WAIT: C2RustUnnamed_14 = 1;
pub type patchalphastyle = libc::c_uint;
pub const AST_FOG: patchalphastyle = 7;
pub const AST_OVERLAY: patchalphastyle = 6;
pub const AST_MODULATE: patchalphastyle = 5;
pub const AST_REVERSESUBTRACT: patchalphastyle = 4;
pub const AST_SUBTRACT: patchalphastyle = 3;
pub const AST_ADD: patchalphastyle = 2;
pub const AST_COPY: patchalphastyle = 0;
pub type C2RustUnnamed_15 = libc::c_uint;
pub type C2RustUnnamed_16 = libc::c_uint;
pub type C2RustUnnamed_17 = libc::c_uint;
pub type C2RustUnnamed_18 = libc::c_uint;
pub type C2RustUnnamed_19 = libc::c_uint;
pub type C2RustUnnamed_20 = libc::c_uint;
pub type C2RustUnnamed_21 = libc::c_uint;
pub type C2RustUnnamed_22 = libc::c_uint;
pub type C2RustUnnamed_23 = libc::c_uint;
pub type C2RustUnnamed_24 = libc::c_uint;
pub const TMED_RIGHT: C2RustUnnamed_24 = 1;
pub type C2RustUnnamed_25 = libc::c_uint;
pub type C2RustUnnamed_26 = libc::c_uint;
pub type C2RustUnnamed_27 = libc::c_uint;
pub const TMB_NODEATHFLING: C2RustUnnamed_27 = 1;
pub type C2RustUnnamed_28 = libc::c_uint;
pub type C2RustUnnamed_29 = libc::c_uint;
pub const PU_HWRMODELTEXTURE_UNLOCKED: C2RustUnnamed_29 = 103;
pub const PU_HWRCACHE_UNLOCKED: C2RustUnnamed_29 = 102;
pub const PU_CACHE_UNLOCKED: C2RustUnnamed_29 = 101;
pub const PU_PURGELEVEL: C2RustUnnamed_29 = 100;
pub const PU_HWRPLANE: C2RustUnnamed_29 = 52;
pub const PU_LEVSPEC: C2RustUnnamed_29 = 51;
pub const PU_CACHE: C2RustUnnamed_29 = 49;
pub const PU_HWRCACHE: C2RustUnnamed_29 = 48;
pub const PU_HWRMODELTEXTURE: C2RustUnnamed_29 = 23;
pub const PU_HWRPATCHCOLMIPMAP: C2RustUnnamed_29 = 22;
pub const PU_HWRPATCHINFO: C2RustUnnamed_29 = 21;
pub const PU_HUDGFX: C2RustUnnamed_29 = 19;
pub const PU_SPRITE: C2RustUnnamed_29 = 18;
pub const PU_PATCH_DATA: C2RustUnnamed_29 = 17;
pub const PU_PATCH_ROTATED: C2RustUnnamed_29 = 16;
pub const PU_PATCH_LOWPRIORITY: C2RustUnnamed_29 = 15;
pub const PU_PATCH: C2RustUnnamed_29 = 14;
pub const PU_MUSIC: C2RustUnnamed_29 = 12;
pub const PU_SOUND: C2RustUnnamed_29 = 11;
pub const PU_PERFSTATS: C2RustUnnamed_29 = 3;
pub const PU_LUA: C2RustUnnamed_29 = 2;
pub const PU_STATIC: C2RustUnnamed_29 = 1;
pub type C2RustUnnamed_30 = libc::c_uint;
pub const mobjhook_MAX: C2RustUnnamed_30 = 18;
pub const mobjhook_HurtMsg: C2RustUnnamed_30 = 17;
pub const mobjhook_FollowMobj: C2RustUnnamed_30 = 16;
pub const mobjhook_MapThingSpawn: C2RustUnnamed_30 = 15;
pub const mobjhook_MobjMoveBlocked: C2RustUnnamed_30 = 14;
pub const mobjhook_BotRespawn: C2RustUnnamed_30 = 13;
pub const mobjhook_BossDeath: C2RustUnnamed_30 = 11;
pub const mobjhook_MobjDeath: C2RustUnnamed_30 = 10;
pub const mobjhook_MobjDamage: C2RustUnnamed_30 = 9;
pub const mobjhook_ShouldDamage: C2RustUnnamed_30 = 8;
pub const mobjhook_TouchSpecial: C2RustUnnamed_30 = 4;
pub const mobjhook_MobjMoveCollide: C2RustUnnamed_30 = 3;
pub const mobjhook_MobjLineCollide: C2RustUnnamed_30 = 2;
pub const mobjhook_MobjCollide: C2RustUnnamed_30 = 1;
#[inline(always)]
unsafe extern "C" fn FixedMul(mut a: fixed_t, mut b: fixed_t) -> fixed_t {
    return ((a as int64_t * b as int64_t) as uint64_t >> 16 as libc::c_int) as fixed_t;
}
#[inline(always)]
unsafe extern "C" fn FixedDiv2(mut a: fixed_t, mut b: fixed_t) -> fixed_t {
    return (a as int64_t * ((1 as libc::c_int) << 16 as libc::c_int) as int64_t
        / b as int64_t) as fixed_t;
}
#[inline(always)]
unsafe extern "C" fn FixedDiv(mut a: fixed_t, mut b: fixed_t) -> fixed_t {
    if abs(a) >> 16 as libc::c_int - 2 as libc::c_int >= abs(b) {
        return if a ^ b < 0 as libc::c_int {
            -(2147483647 as libc::c_int) - 1 as libc::c_int
        } else {
            2147483647 as libc::c_int
        };
    }
    return FixedDiv2(a, b);
}
#[inline(always)]
unsafe extern "C" fn InvAngle(mut a: angle_t) -> angle_t {
    return (0xffffffff as libc::c_uint)
        .wrapping_sub(a)
        .wrapping_add(1 as libc::c_int as libc::c_uint);
}
static mut CV_BobSpeed: [CV_PossibleValue_t; 3] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"MIN\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
            strvalue: b"MAX\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut cv_movebob: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"movebob\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"1.0\0" as *const u8 as *const libc::c_char,
            flags: CV_FLOAT as libc::c_int | CV_SAVE as libc::c_int,
            PossibleValue: CV_BobSpeed.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_2 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_3 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut actioncachehead: actioncache_t = actioncache_s {
    next: 0 as *const actioncache_s as *mut actioncache_s,
    prev: 0 as *const actioncache_s as *mut actioncache_s,
    mobj: 0 as *const mobj_s as *mut mobj_s,
    statenum: 0,
};
static mut overlaycap: *mut mobj_t = 0 as *const mobj_t as *mut mobj_t;
#[no_mangle]
pub unsafe extern "C" fn P_InitCachedActions() {
    actioncachehead.next = &mut actioncachehead;
    actioncachehead.prev = actioncachehead.next;
}
#[no_mangle]
pub unsafe extern "C" fn P_RunCachedActions() {
    let mut ac: *mut actioncache_t = 0 as *mut actioncache_t;
    let mut next: *mut actioncache_t = 0 as *mut actioncache_t;
    ac = actioncachehead.next;
    while ac != &mut actioncachehead as *mut actioncache_t {
        var1 = states[(*ac).statenum as usize].var1;
        var2 = states[(*ac).statenum as usize].var2;
        astate = &mut *states.as_mut_ptr().offset((*ac).statenum as isize)
            as *mut state_t;
        if !((*ac).mobj).is_null() && P_MobjWasRemoved((*ac).mobj) == 0 {
            (states[(*ac).statenum as usize].action.acp1)
                .expect("non-null function pointer")((*ac).mobj as *mut libc::c_void);
        }
        next = (*ac).next;
        Z_Free(ac as *mut libc::c_void);
        ac = next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_AddCachedAction(
    mut mobj: *mut mobj_t,
    mut statenum: int32_t,
) {
    let mut newaction: *mut actioncache_t = Z_CallocAlign(
        ::core::mem::size_of::<actioncache_t>() as libc::c_ulong,
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut actioncache_t;
    (*newaction).mobj = mobj;
    (*newaction).statenum = statenum;
    (*actioncachehead.prev).next = newaction;
    (*newaction).next = &mut actioncachehead;
    (*newaction).prev = actioncachehead.prev;
    actioncachehead.prev = newaction;
}
unsafe extern "C" fn P_SetupStateAnimation(mut mobj: *mut mobj_t, mut st: *mut state_t) {
    let mut animlength: int32_t = if (*mobj).sprite as libc::c_uint
        == SPR_PLAY as libc::c_int as libc::c_uint && !((*mobj).skin).is_null()
    {
        (*((*mobj).skin as *mut skin_t)).sprites[(*mobj).sprite2 as usize].numframes
            as int32_t - 1 as libc::c_int
    } else {
        (*st).var1
    };
    if (*st).frame & 0x10000000 as libc::c_int as uint32_t == 0 {
        return;
    }
    if animlength <= 0 as libc::c_int || (*st).var2 == 0 as libc::c_int {
        (*mobj).frame &= !(0x10000000 as libc::c_int) as uint32_t;
        return;
    }
    (*mobj).anim_duration = (*st).var2 as uint16_t;
    if (*st).frame & 0x20000000 as libc::c_int as uint32_t != 0 {
        if leveltime == 0 {
            return;
        }
        (*mobj)
            .anim_duration = ((*mobj).anim_duration as tic_t)
            .wrapping_sub(
                leveltime.wrapping_add(2 as libc::c_int as tic_t) % (*st).var2 as tic_t,
            ) as uint16_t as uint16_t;
        (*mobj)
            .frame = ((*mobj).frame)
            .wrapping_add(
                leveltime.wrapping_add(2 as libc::c_int as tic_t) / (*st).var2 as tic_t
                    % (animlength + 1 as libc::c_int) as tic_t,
            );
    } else if (*st).frame & 0x40000000 as libc::c_int as uint32_t != 0 {
        (*mobj)
            .frame = ((*mobj).frame)
            .wrapping_add(P_RandomKey(animlength + 1 as libc::c_int) as uint32_t);
        (*mobj)
            .anim_duration = ((*mobj).anim_duration as libc::c_int
            - P_RandomKey((*st).var2)) as uint16_t;
    }
}
#[inline(always)]
unsafe extern "C" fn P_CycleStateAnimation(mut mobj: *mut mobj_t) {
    if (*mobj).frame & 0x10000000 as libc::c_int as uint32_t == 0
        || {
            (*mobj).anim_duration = ((*mobj).anim_duration).wrapping_sub(1);
            (*mobj).anim_duration as libc::c_int != 0 as libc::c_int
        }
    {
        return;
    }
    (*mobj).anim_duration = (*(*mobj).state).var2 as uint16_t;
    if (*mobj).sprite as libc::c_uint != SPR_PLAY as libc::c_int as libc::c_uint {
        (*mobj).frame = ((*mobj).frame).wrapping_add(1);
        if ((*mobj).frame & 0xff as libc::c_int as uint32_t)
            .wrapping_sub((*(*mobj).state).frame & 0xff as libc::c_int as uint32_t)
            > (*(*mobj).state).var1 as uint32_t
        {
            (*mobj)
                .frame = (*(*mobj).state).frame & 0xff as libc::c_int as uint32_t
                | (*mobj).frame & !(0xff as libc::c_int) as uint32_t;
        }
        return;
    }
    if !((*mobj).skin).is_null()
        && {
            (*mobj).frame = ((*mobj).frame).wrapping_add(1);
            (*mobj).frame & 0xff as libc::c_int as uint32_t
                >= (*((*mobj).skin as *mut skin_t))
                    .sprites[(*mobj).sprite2 as usize]
                    .numframes as uint32_t
        }
    {
        (*mobj).frame &= !(0xff as libc::c_int) as uint32_t;
    }
}
unsafe extern "C" fn P_CycleMobjState(mut mobj: *mut mobj_t) {
    P_CycleStateAnimation(mobj);
    if (*mobj).tics != -(1 as libc::c_int) {
        (*mobj).tics -= 1;
        (*mobj).tics;
        if (*mobj).tics == 0 && !((*mobj).state).is_null() {
            if P_SetMobjState(mobj, (*(*mobj).state).nextstate) == 0 {
                return;
            }
        }
    }
}
unsafe extern "C" fn P_CyclePlayerMobjState(mut mobj: *mut mobj_t) {
    P_CycleStateAnimation(mobj);
    if (*mobj).tics != -(1 as libc::c_int) {
        (*mobj).tics -= 1;
        (*mobj).tics;
        if (*mobj).tics == 0 && !((*mobj).state).is_null() {
            if P_SetPlayerMobjState(mobj, (*(*mobj).state).nextstate) == 0 {
                return;
            }
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_SetPlayerMobjState(
    mut mobj: *mut mobj_t,
    mut state: statenum_t,
) -> boolean {
    let mut st: *mut state_t = 0 as *mut state_t;
    let mut player: *mut player_t = (*mobj).player;
    static mut seenstate_tab: [statenum_t; 6735] = [S_NULL; 6735];
    let mut seenstate: *mut statenum_t = seenstate_tab.as_mut_ptr();
    static mut recursion: int32_t = 0;
    let mut i: statenum_t = S_NULL;
    let mut tempstate: [statenum_t; 6735] = [S_NULL; 6735];
    if state as libc::c_uint == S_PLAY_JUMP as libc::c_int as libc::c_uint
        && (*player).charflags & SF_NOJUMPSPIN as libc::c_int as uint32_t != 0
        && P_MobjFlip(mobj) as libc::c_int * (*mobj).momz < 0 as libc::c_int
    {
        return P_SetPlayerMobjState(mobj, S_PLAY_FALL);
    }
    if (state as libc::c_uint == S_PLAY_FLY as libc::c_int as libc::c_uint
        || state as libc::c_uint == S_PLAY_GLIDE as libc::c_int as libc::c_uint
            && skins[(*player).skin as usize]
                .sprites[SPR2_SWIM as libc::c_int as usize]
                .numframes != 0)
        && (*(*player).mo).eflags as libc::c_int & MFE_UNDERWATER as libc::c_int != 0
        && (*player).skidtime == 0
    {
        return P_SetPlayerMobjState((*player).mo, S_PLAY_SWIM)
    } else if state as libc::c_uint == S_PLAY_SWIM as libc::c_int as libc::c_uint
        && (*(*player).mo).eflags as libc::c_int & MFE_UNDERWATER as libc::c_int == 0
    {
        if (*player).charability as libc::c_int == CA_GLIDEANDCLIMB as libc::c_int {
            return P_SetPlayerMobjState((*player).mo, S_PLAY_GLIDE)
        } else {
            return P_SetPlayerMobjState((*player).mo, S_PLAY_FLY)
        }
    }
    if (*player).powers[pw_super as libc::c_int as usize] as libc::c_int != 0
        && (*player).charflags & SF_NOSUPERSPIN as libc::c_int as uint32_t != 0
    {
        if state as libc::c_uint == S_PLAY_JUMP as libc::c_int as libc::c_uint {
            if ((*(*player).mo).state).offset_from(states.as_mut_ptr()) as libc::c_long
                == S_PLAY_WALK as libc::c_int as libc::c_long
            {
                return P_SetPlayerMobjState(mobj, S_PLAY_FLOAT);
            }
            return true_0 as libc::c_int;
        } else if ((*(*player).mo).state).offset_from(states.as_mut_ptr())
            as libc::c_long == S_PLAY_FLOAT as libc::c_int as libc::c_long
            && state as libc::c_uint == S_PLAY_STND as libc::c_int as libc::c_uint
        {
            return true_0 as libc::c_int
        }
    } else if (*mobj).state
        == &mut *states.as_mut_ptr().offset((*(*mobj).info).painstate as isize)
            as *mut state_t
        && (*player).powers[pw_flashing as libc::c_int as usize] as libc::c_int
            == flashingtics as libc::c_int
        && state as libc::c_uint != (*(*mobj).info).painstate as libc::c_uint
    {
        (*player)
            .powers[pw_flashing as libc::c_int
            as usize] = (flashingtics as libc::c_int - 1 as libc::c_int) as uint16_t;
        P_DoPityCheck(player);
    }
    match state as libc::c_uint {
        11 | 12 | 65 => {
            (*player).panim = PA_IDLE;
        }
        26 => {
            (*player).panim = PA_EDGE;
        }
        13 | 14 | 36 => {
            (*player).panim = PA_WALK;
        }
        15 | 37 => {
            (*player).panim = PA_RUN;
        }
        16 => {
            (*player).panim = PA_DASH;
        }
        17 | 18 => {
            (*player).panim = PA_PAIN;
        }
        21 | 71 => {
            (*player).panim = PA_ROLL;
        }
        23 => {
            (*player).panim = PA_JUMP;
        }
        24 => {
            (*player).panim = PA_SPRING;
        }
        25 | 66 => {
            (*player).panim = PA_FALL;
        }
        29 | 31 | 30 | 32 | 38 | 39 | 42 => {
            (*player).panim = PA_ABILITY;
        }
        28 | 40 | 41 | 43 | 44 | 45 => {
            (*player).panim = PA_ABILITY2;
        }
        27 => {
            (*player).panim = PA_RIDE;
        }
        _ => {
            (*player).panim = PA_ETC;
        }
    }
    let fresh0 = recursion;
    recursion = recursion + 1;
    if fresh0 != 0 {
        seenstate = tempstate.as_mut_ptr();
        memset(
            seenstate as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<[statenum_t; 6735]>() as libc::c_ulong,
        );
    }
    i = state;
    loop {
        if state as libc::c_uint == S_NULL as libc::c_int as libc::c_uint {
            CONS_Alert(
                CONS_ERROR,
                b"Cannot remove player mobj by setting its state to S_NULL.\n\0"
                    as *const u8 as *const libc::c_char,
            );
            return false_0 as libc::c_int;
        }
        st = &mut *states.as_mut_ptr().offset(state as isize) as *mut state_t;
        (*mobj).state = st;
        (*mobj).tics = (*st).tics;
        if (*player).panim as libc::c_uint == PA_EDGE as libc::c_int as libc::c_uint
            && (*player).charflags & SF_FASTEDGE as libc::c_int as uint32_t != 0
        {
            (*mobj).tics = 2 as libc::c_int;
        } else if !(disableSpeedAdjust != 0
            || (*player).charflags & SF_NOSPEEDADJUST as libc::c_int as uint32_t != 0)
        {
            let mut speed: fixed_t = 0;
            if (*player).panim as libc::c_uint == PA_FALL as libc::c_int as libc::c_uint
            {
                speed = FixedDiv(abs((*mobj).momz), (*mobj).scale);
                if speed < (10 as libc::c_int) << 16 as libc::c_int {
                    (*mobj).tics = 4 as libc::c_int;
                } else if speed < (20 as libc::c_int) << 16 as libc::c_int {
                    (*mobj).tics = 3 as libc::c_int;
                } else if speed < (30 as libc::c_int) << 16 as libc::c_int {
                    (*mobj).tics = 2 as libc::c_int;
                } else {
                    (*mobj).tics = 1 as libc::c_int;
                }
            } else if (*player).panim as libc::c_uint
                == PA_ABILITY2 as libc::c_int as libc::c_uint
                && (*player).charability2 as libc::c_int == CA2_SPINDASH as libc::c_int
            {
                let mut step: fixed_t = ((*player).maxdash - (*player).mindash)
                    / 4 as libc::c_int;
                speed = (*player).dashspeed - (*player).mindash;
                if speed > 3 as libc::c_int * step {
                    (*mobj).tics = 1 as libc::c_int;
                } else if speed > step {
                    (*mobj).tics = 2 as libc::c_int;
                } else {
                    (*mobj).tics = 3 as libc::c_int;
                }
            } else {
                speed = FixedDiv(
                    (*player).speed,
                    FixedMul((*mobj).scale, (*(*player).mo).movefactor),
                );
                if (*player).panim as libc::c_uint
                    == PA_ROLL as libc::c_int as libc::c_uint
                    || (*player).panim as libc::c_uint
                        == PA_JUMP as libc::c_int as libc::c_uint
                {
                    if speed > (16 as libc::c_int) << 16 as libc::c_int {
                        (*mobj).tics = 1 as libc::c_int;
                    } else {
                        (*mobj).tics = 2 as libc::c_int;
                    }
                } else if P_IsObjectOnGround(mobj) != 0
                    || ((*player).charability as libc::c_int == CA_FLOAT as libc::c_int
                        || (*player).charability as libc::c_int
                            == CA_SLOWFALL as libc::c_int)
                        && (*player).secondjump as libc::c_int == 1 as libc::c_int
                    || (*player).powers[pw_super as libc::c_int as usize] as libc::c_int
                        != 0
                {
                    if (*player).panim as libc::c_uint
                        == PA_WALK as libc::c_int as libc::c_uint
                    {
                        if speed > (12 as libc::c_int) << 16 as libc::c_int {
                            (*mobj).tics = 2 as libc::c_int;
                        } else if speed > (6 as libc::c_int) << 16 as libc::c_int {
                            (*mobj).tics = 3 as libc::c_int;
                        } else {
                            (*mobj).tics = 4 as libc::c_int;
                        }
                    } else if (*player).panim as libc::c_uint
                        == PA_RUN as libc::c_int as libc::c_uint
                        || (*player).panim as libc::c_uint
                            == PA_DASH as libc::c_int as libc::c_uint
                    {
                        if speed > (52 as libc::c_int) << 16 as libc::c_int {
                            (*mobj).tics = 1 as libc::c_int;
                        } else {
                            (*mobj).tics = 2 as libc::c_int;
                        }
                    }
                }
            }
        }
        if (*st).sprite as libc::c_uint == SPR_PLAY as libc::c_int as libc::c_uint {
            let mut skin: *mut skin_t = (*mobj).skin as *mut skin_t;
            let mut frame: uint16_t = ((*mobj).frame & 0xff as libc::c_int as uint32_t)
                .wrapping_add(1 as libc::c_int as uint32_t) as uint16_t;
            let mut numframes: uint8_t = 0;
            let mut spr2: uint8_t = 0;
            if !skin.is_null() {
                let mut stateframe: uint16_t = (*st).frame as uint16_t;
                if (*player).charflags & SF_NOSUPERSPRITES as libc::c_int as uint32_t
                    != 0
                {
                    stateframe = (stateframe as libc::c_int & !(0x80 as libc::c_int))
                        as uint16_t;
                } else if (*player).powers[pw_super as libc::c_int as usize] != 0 {
                    stateframe = (stateframe as libc::c_int | 0x80 as libc::c_int)
                        as uint16_t;
                }
                if stateframe as libc::c_int & 0x80 as libc::c_int != 0 {
                    if (*mobj).eflags as libc::c_int & MFE_FORCENOSUPER as libc::c_int
                        != 0
                    {
                        stateframe = (stateframe as libc::c_int & !(0x80 as libc::c_int))
                            as uint16_t;
                    }
                } else if (*mobj).eflags as libc::c_int & MFE_FORCESUPER as libc::c_int
                    != 0
                {
                    stateframe = (stateframe as libc::c_int | 0x80 as libc::c_int)
                        as uint16_t;
                }
                spr2 = P_GetSkinSprite2(
                    skin,
                    (stateframe as libc::c_int & 0xff as libc::c_int) as uint8_t,
                    (*mobj).player,
                );
                numframes = (*skin).sprites[spr2 as usize].numframes as uint8_t;
                if state as libc::c_uint == S_PLAY_STND as libc::c_int as libc::c_uint
                    && spr2 as libc::c_int & 0x80 as libc::c_int != 0
                    && (*skin)
                        .sprites[(SPR2_WAIT as libc::c_int | 0x80 as libc::c_int)
                            as usize]
                        .numframes == 0 as libc::c_int as size_t
                {
                    (*mobj).tics = -(1 as libc::c_int);
                }
            } else {
                spr2 = 0 as libc::c_int as uint8_t;
                frame = 0 as libc::c_int as uint16_t;
                numframes = 0 as libc::c_int as uint8_t;
            }
            if (*mobj).sprite as libc::c_uint != SPR_PLAY as libc::c_int as libc::c_uint
            {
                (*mobj).sprite = SPR_PLAY;
                frame = 0 as libc::c_int as uint16_t;
            } else if (*mobj).sprite2 as libc::c_int != spr2 as libc::c_int {
                if (*st).frame & 0x200 as libc::c_int as uint32_t != 0
                    && numframes as libc::c_int != 0
                    && P_RandomFixed()
                        < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
                {
                    frame = (numframes as libc::c_int / 2 as libc::c_int) as uint16_t;
                } else {
                    frame = 0 as libc::c_int as uint16_t;
                }
            }
            if frame as libc::c_int >= numframes as libc::c_int {
                if (*st).frame & 0x100 as libc::c_int as uint32_t != 0 {
                    if (*st).var1 as libc::c_long
                        == ((*mobj).state).offset_from(states.as_mut_ptr())
                            as libc::c_long
                    {
                        frame = frame.wrapping_sub(1);
                        frame;
                    } else {
                        if (*mobj).frame & 0xff as libc::c_int as uint32_t != 0 {
                            (*mobj).frame = ((*mobj).frame).wrapping_sub(1);
                            (*mobj).frame;
                        }
                        return P_SetPlayerMobjState(mobj, (*st).var1 as statenum_t);
                    }
                } else {
                    frame = 0 as libc::c_int as uint16_t;
                }
            }
            (*mobj).sprite2 = spr2;
            (*mobj)
                .frame = frame as uint32_t
                | (*st).frame & !(0xff as libc::c_int) as uint32_t;
            if P_PlayerFullbright(player) != 0 {
                (*mobj).frame |= 0x100000 as libc::c_int as uint32_t;
            }
        } else {
            (*mobj).sprite = (*st).sprite;
            (*mobj).frame = (*st).frame;
        }
        P_SetupStateAnimation(mobj, st);
        if ((*st).action.acp1).is_some() {
            var1 = (*st).var1;
            var2 = (*st).var2;
            astate = st;
            ((*st).action.acp1)
                .expect("non-null function pointer")(mobj as *mut libc::c_void);
            if P_MobjWasRemoved(mobj) != 0 {
                return false_0 as libc::c_int;
            }
        }
        *seenstate
            .offset(
                state as isize,
            ) = (1 as libc::c_int as libc::c_uint)
            .wrapping_add((*st).nextstate as libc::c_uint) as statenum_t;
        state = (*st).nextstate;
        if !((*mobj).tics == 0 && *seenstate.offset(state as isize) as u64 == 0) {
            break;
        }
    }
    if (*mobj).tics == 0 {
        CONS_Alert(
            CONS_WARNING,
            b"State cycle detected, exiting.\n\0" as *const u8 as *const libc::c_char,
        );
    }
    recursion -= 1;
    if recursion == 0 {
        loop {
            state = *seenstate.offset(i as isize);
            if !(state as libc::c_uint > S_NULL as libc::c_int as libc::c_uint) {
                break;
            }
            *seenstate.offset(i as isize) = S_NULL;
            i = (state as libc::c_uint).wrapping_sub(1 as libc::c_int as libc::c_uint)
                as statenum_t;
        }
    }
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_SetMobjState(
    mut mobj: *mut mobj_t,
    mut state: statenum_t,
) -> boolean {
    let mut st: *mut state_t = 0 as *mut state_t;
    static mut seenstate_tab: [statenum_t; 6735] = [S_NULL; 6735];
    let mut seenstate: *mut statenum_t = seenstate_tab.as_mut_ptr();
    static mut recursion: int32_t = 0;
    let mut i: statenum_t = state;
    let mut tempstate: [statenum_t; 6735] = [S_NULL; 6735];
    let fresh1 = recursion;
    recursion = recursion + 1;
    if fresh1 != 0 {
        seenstate = tempstate.as_mut_ptr();
        memset(
            seenstate as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<[statenum_t; 6735]>() as libc::c_ulong,
        );
    }
    loop {
        if state as libc::c_uint == S_NULL as libc::c_int as libc::c_uint {
            P_RemoveMobj(mobj);
            return false_0 as libc::c_int;
        }
        st = &mut *states.as_mut_ptr().offset(state as isize) as *mut state_t;
        (*mobj).state = st;
        (*mobj).tics = (*st).tics;
        if (*st).sprite as libc::c_uint == SPR_PLAY as libc::c_int as libc::c_uint {
            let mut skin: *mut skin_t = (*mobj).skin as *mut skin_t;
            let mut frame: uint16_t = ((*mobj).frame & 0xff as libc::c_int as uint32_t)
                .wrapping_add(1 as libc::c_int as uint32_t) as uint16_t;
            let mut numframes: uint8_t = 0;
            let mut spr2: uint8_t = 0;
            if !skin.is_null() {
                let mut stateframe: uint16_t = (*st).frame as uint16_t;
                if stateframe as libc::c_int & 0x80 as libc::c_int != 0 {
                    if (*mobj).eflags as libc::c_int & MFE_FORCENOSUPER as libc::c_int
                        != 0
                    {
                        stateframe = (stateframe as libc::c_int & !(0x80 as libc::c_int))
                            as uint16_t;
                    }
                } else if (*mobj).eflags as libc::c_int & MFE_FORCESUPER as libc::c_int
                    != 0
                {
                    stateframe = (stateframe as libc::c_int | 0x80 as libc::c_int)
                        as uint16_t;
                }
                spr2 = P_GetSkinSprite2(
                    skin,
                    (stateframe as libc::c_int & 0xff as libc::c_int) as uint8_t,
                    0 as *mut player_t,
                );
                numframes = (*skin).sprites[spr2 as usize].numframes as uint8_t;
                if state as libc::c_uint == S_PLAY_STND as libc::c_int as libc::c_uint
                    && spr2 as libc::c_int & 0x80 as libc::c_int != 0
                    && (*skin)
                        .sprites[(SPR2_WAIT as libc::c_int | 0x80 as libc::c_int)
                            as usize]
                        .numframes == 0 as libc::c_int as size_t
                {
                    (*mobj).tics = -(1 as libc::c_int);
                }
            } else {
                spr2 = 0 as libc::c_int as uint8_t;
                frame = 0 as libc::c_int as uint16_t;
                numframes = 0 as libc::c_int as uint8_t;
            }
            if (*mobj).sprite as libc::c_uint != SPR_PLAY as libc::c_int as libc::c_uint
            {
                (*mobj).sprite = SPR_PLAY;
                frame = 0 as libc::c_int as uint16_t;
            } else if (*mobj).sprite2 as libc::c_int != spr2 as libc::c_int {
                if (*st).frame & 0x200 as libc::c_int as uint32_t != 0
                    && numframes as libc::c_int != 0
                    && P_RandomFixed()
                        < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
                {
                    frame = (numframes as libc::c_int / 2 as libc::c_int) as uint16_t;
                } else {
                    frame = 0 as libc::c_int as uint16_t;
                }
            }
            if frame as libc::c_int >= numframes as libc::c_int {
                if (*st).frame & 0x100 as libc::c_int as uint32_t != 0 {
                    if (*st).var1 as libc::c_long
                        == ((*mobj).state).offset_from(states.as_mut_ptr())
                            as libc::c_long
                    {
                        frame = frame.wrapping_sub(1);
                        frame;
                    } else {
                        if (*mobj).frame & 0xff as libc::c_int as uint32_t != 0 {
                            (*mobj).frame = ((*mobj).frame).wrapping_sub(1);
                            (*mobj).frame;
                        }
                        return P_SetMobjState(mobj, (*st).var1 as statenum_t);
                    }
                } else {
                    frame = 0 as libc::c_int as uint16_t;
                }
            }
            (*mobj).sprite2 = spr2;
            (*mobj)
                .frame = frame as uint32_t
                | (*st).frame & !(0xff as libc::c_int) as uint32_t;
        } else {
            (*mobj).sprite = (*st).sprite;
            (*mobj).frame = (*st).frame;
        }
        P_SetupStateAnimation(mobj, st);
        if ((*st).action.acp1).is_some() {
            var1 = (*st).var1;
            var2 = (*st).var2;
            astate = st;
            ((*st).action.acp1)
                .expect("non-null function pointer")(mobj as *mut libc::c_void);
            if P_MobjWasRemoved(mobj) != 0 {
                return false_0 as libc::c_int;
            }
        }
        *seenstate
            .offset(
                state as isize,
            ) = (1 as libc::c_int as libc::c_uint)
            .wrapping_add((*st).nextstate as libc::c_uint) as statenum_t;
        state = (*st).nextstate;
        if !((*mobj).tics == 0 && *seenstate.offset(state as isize) as u64 == 0) {
            break;
        }
    }
    if (*mobj).tics == 0 {
        CONS_Alert(
            CONS_WARNING,
            b"State cycle detected, exiting.\n\0" as *const u8 as *const libc::c_char,
        );
    }
    recursion -= 1;
    if recursion == 0 {
        loop {
            state = *seenstate.offset(i as isize);
            if !(state as libc::c_uint > S_NULL as libc::c_int as libc::c_uint) {
                break;
            }
            *seenstate.offset(i as isize) = S_NULL;
            i = (state as libc::c_uint).wrapping_sub(1 as libc::c_int as libc::c_uint)
                as statenum_t;
        }
    }
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_SetMobjStateNF(
    mut mobj: *mut mobj_t,
    mut state: statenum_t,
) -> boolean {
    let mut st: *mut state_t = 0 as *mut state_t;
    if state as libc::c_uint == S_NULL as libc::c_int as libc::c_uint {
        P_RemoveMobj(mobj);
        return false_0 as libc::c_int;
    }
    st = &mut *states.as_mut_ptr().offset(state as isize) as *mut state_t;
    (*mobj).state = st;
    (*mobj).tics = (*st).tics;
    (*mobj).sprite = (*st).sprite;
    (*mobj).frame = (*st).frame;
    P_SetupStateAnimation(mobj, st);
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_SetPrecipMobjState(
    mut mobj: *mut precipmobj_t,
    mut state: statenum_t,
) -> boolean {
    let mut st: *mut state_t = 0 as *mut state_t;
    if state as libc::c_uint == S_NULL as libc::c_int as libc::c_uint {
        P_RemovePrecipMobj(mobj);
        return false_0 as libc::c_int;
    }
    st = &mut *states.as_mut_ptr().offset(state as isize) as *mut state_t;
    (*mobj).state = st;
    (*mobj).tics = (*st).tics;
    (*mobj).sprite = (*st).sprite;
    (*mobj).frame = (*st).frame;
    P_SetupStateAnimation(mobj as *mut mobj_t, st);
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_MobjFlip(mut mobj: *mut mobj_t) -> int8_t {
    if !mobj.is_null()
        && (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
    {
        return -(1 as libc::c_int) as int8_t;
    }
    return 1 as libc::c_int as int8_t;
}
#[no_mangle]
pub unsafe extern "C" fn P_WeaponOrPanel(mut type_0: mobjtype_t) -> boolean {
    if type_0 as libc::c_uint == MT_BOUNCERING as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_AUTOMATICRING as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_INFINITYRING as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_RAILRING as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_EXPLOSIONRING as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_SCATTERRING as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_GRENADERING as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_BOUNCEPICKUP as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_RAILPICKUP as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_AUTOPICKUP as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_EXPLODEPICKUP as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_SCATTERPICKUP as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_GRENADEPICKUP as libc::c_int as libc::c_uint
    {
        return true_0 as libc::c_int;
    }
    return false_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_EmeraldManager() {
    let mut think: *mut thinker_t = 0 as *mut thinker_t;
    let mut mo: *mut mobj_t = 0 as *mut mobj_t;
    let mut i: int32_t = 0;
    let mut j: int32_t = 0;
    let mut numtospawn: int32_t = 0;
    let mut emeraldsspawned: int32_t = 0 as libc::c_int;
    let mut hasemerald: [boolean; 64] = [0; 64];
    let mut numwithemerald: int32_t = 0 as libc::c_int;
    let mut spawnpoints: [*mut mobj_t; 64] = [0 as *mut mobj_t; 64];
    let mut numspawnpoints: int32_t = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < 64 as libc::c_int {
        hasemerald[i as usize] = false_0 as libc::c_int;
        spawnpoints[i as usize] = 0 as *mut mobj_t;
        i += 1;
        i;
    }
    think = (*thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)).next;
    while think
        != &mut *thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)
            as *mut thinker_t
    {
        if !((*think).function.acp1
            == ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut thinker_t) -> ()>,
                actionf_p1,
            >(
                Some(
                    P_RemoveThinkerDelayed as unsafe extern "C" fn(*mut thinker_t) -> (),
                ),
            ))
        {
            mo = think as *mut mobj_t;
            if (*mo).type_0 as libc::c_uint
                == MT_EMERALDSPAWN as libc::c_int as libc::c_uint
            {
                if (*mo).threshold != 0 || !((*mo).target).is_null() {
                    numwithemerald += 1;
                    numwithemerald;
                    emeraldsspawned |= mobjinfo[(*mo).reactiontime as usize].speed;
                } else if numspawnpoints < 64 as libc::c_int {
                    let fresh2 = numspawnpoints;
                    numspawnpoints = numspawnpoints + 1;
                    spawnpoints[fresh2 as usize] = mo;
                }
            } else if (*mo).type_0 as libc::c_uint
                == MT_FLINGEMERALD as libc::c_int as libc::c_uint
            {
                numwithemerald += 1;
                numwithemerald;
                emeraldsspawned |= (*mo).threshold;
            }
        }
        think = (*think).next;
    }
    if numspawnpoints == 0 as libc::c_int {
        return;
    }
    i = 0 as libc::c_int;
    while i < 32 as libc::c_int {
        if !(playeringame[i as usize] == 0 || players[i as usize].spectator != 0) {
            if !(players[i as usize].mo).is_null() {
                if players[i as usize].powers[pw_emeralds as libc::c_int as usize]
                    as libc::c_int & 1 as libc::c_int != 0
                {
                    numwithemerald += 1;
                    numwithemerald;
                    emeraldsspawned |= 1 as libc::c_int;
                }
                if players[i as usize].powers[pw_emeralds as libc::c_int as usize]
                    as libc::c_int & 2 as libc::c_int != 0
                {
                    numwithemerald += 1;
                    numwithemerald;
                    emeraldsspawned |= 2 as libc::c_int;
                }
                if players[i as usize].powers[pw_emeralds as libc::c_int as usize]
                    as libc::c_int & 4 as libc::c_int != 0
                {
                    numwithemerald += 1;
                    numwithemerald;
                    emeraldsspawned |= 4 as libc::c_int;
                }
                if players[i as usize].powers[pw_emeralds as libc::c_int as usize]
                    as libc::c_int & 8 as libc::c_int != 0
                {
                    numwithemerald += 1;
                    numwithemerald;
                    emeraldsspawned |= 8 as libc::c_int;
                }
                if players[i as usize].powers[pw_emeralds as libc::c_int as usize]
                    as libc::c_int & 16 as libc::c_int != 0
                {
                    numwithemerald += 1;
                    numwithemerald;
                    emeraldsspawned |= 16 as libc::c_int;
                }
                if players[i as usize].powers[pw_emeralds as libc::c_int as usize]
                    as libc::c_int & 32 as libc::c_int != 0
                {
                    numwithemerald += 1;
                    numwithemerald;
                    emeraldsspawned |= 32 as libc::c_int;
                }
                if players[i as usize].powers[pw_emeralds as libc::c_int as usize]
                    as libc::c_int & 64 as libc::c_int != 0
                {
                    numwithemerald += 1;
                    numwithemerald;
                    emeraldsspawned |= 64 as libc::c_int;
                }
            }
        }
        i += 1;
        i;
    }
    if numwithemerald >= 7 as libc::c_int {
        return;
    }
    numtospawn = 7 as libc::c_int - numwithemerald;
    i = 0 as libc::c_int;
    j = 0 as libc::c_int;
    while i < numtospawn {
        let mut tries: int32_t = 0 as libc::c_int;
        while true_0 as libc::c_int != 0 {
            tries += 1;
            tries;
            if tries > 50 as libc::c_int {
                break;
            }
            j = P_RandomKey(numspawnpoints);
            if hasemerald[j as usize] != 0 {
                continue;
            }
            hasemerald[j as usize] = true_0 as libc::c_int;
            if emeraldsspawned & 1 as libc::c_int == 0 {
                (*spawnpoints[j as usize]).reactiontime = MT_EMERALD1 as libc::c_int;
                emeraldsspawned |= 1 as libc::c_int;
            } else if emeraldsspawned & 2 as libc::c_int == 0 {
                (*spawnpoints[j as usize]).reactiontime = MT_EMERALD2 as libc::c_int;
                emeraldsspawned |= 2 as libc::c_int;
            } else if emeraldsspawned & 4 as libc::c_int == 0 {
                (*spawnpoints[j as usize]).reactiontime = MT_EMERALD3 as libc::c_int;
                emeraldsspawned |= 4 as libc::c_int;
            } else if emeraldsspawned & 8 as libc::c_int == 0 {
                (*spawnpoints[j as usize]).reactiontime = MT_EMERALD4 as libc::c_int;
                emeraldsspawned |= 8 as libc::c_int;
            } else if emeraldsspawned & 16 as libc::c_int == 0 {
                (*spawnpoints[j as usize]).reactiontime = MT_EMERALD5 as libc::c_int;
                emeraldsspawned |= 16 as libc::c_int;
            } else if emeraldsspawned & 32 as libc::c_int == 0 {
                (*spawnpoints[j as usize]).reactiontime = MT_EMERALD6 as libc::c_int;
                emeraldsspawned |= 32 as libc::c_int;
            } else {
                if !(emeraldsspawned & 64 as libc::c_int == 0) {
                    break;
                }
                (*spawnpoints[j as usize]).reactiontime = MT_EMERALD7 as libc::c_int;
                emeraldsspawned |= 64 as libc::c_int;
            }
            (*spawnpoints[j as usize])
                .threshold = emeraldspawndelay as libc::c_int
                + P_RandomByte() as libc::c_int * (35 as libc::c_int / 5 as libc::c_int);
            break;
        }
        i += 1;
        i;
    }
    emeraldspawndelay = 0 as libc::c_int as uint16_t;
}
#[no_mangle]
pub unsafe extern "C" fn P_ExplodeMissile(mut mo: *mut mobj_t) {
    let mut explodemo: *mut mobj_t = 0 as *mut mobj_t;
    (*mo).momz = 0 as libc::c_int;
    (*mo).momy = (*mo).momz;
    (*mo).momx = (*mo).momy;
    if (*mo).flags & MF_NOCLIPTHING as libc::c_int as uint32_t != 0 {
        return;
    }
    if (*mo).type_0 as libc::c_uint == MT_DETON as libc::c_int as libc::c_uint {
        P_RadiusAttack(
            mo,
            mo,
            96 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
            0 as libc::c_int as uint8_t,
            true_0 as libc::c_int,
        );
        explodemo = P_SpawnMobj((*mo).x, (*mo).y, (*mo).z, MT_EXPLODE);
        P_SetScale(explodemo, (*mo).scale);
        (*explodemo).destscale = (*mo).destscale;
        (*explodemo).momx
            += P_RandomByte() as libc::c_int % 32 as libc::c_int
                * FixedMul(
                    ((1 as libc::c_int) << 16 as libc::c_int) / 8 as libc::c_int,
                    (*explodemo).scale,
                );
        (*explodemo).momy
            += P_RandomByte() as libc::c_int % 32 as libc::c_int
                * FixedMul(
                    ((1 as libc::c_int) << 16 as libc::c_int) / 8 as libc::c_int,
                    (*explodemo).scale,
                );
        S_StartSound(explodemo as *const libc::c_void, sfx_pop);
        explodemo = P_SpawnMobj((*mo).x, (*mo).y, (*mo).z, MT_EXPLODE);
        P_SetScale(explodemo, (*mo).scale);
        (*explodemo).destscale = (*mo).destscale;
        (*explodemo).momx
            += P_RandomByte() as libc::c_int % 64 as libc::c_int
                * FixedMul(
                    ((1 as libc::c_int) << 16 as libc::c_int) / 8 as libc::c_int,
                    (*explodemo).scale,
                );
        (*explodemo).momy
            -= P_RandomByte() as libc::c_int % 64 as libc::c_int
                * FixedMul(
                    ((1 as libc::c_int) << 16 as libc::c_int) / 8 as libc::c_int,
                    (*explodemo).scale,
                );
        S_StartSound(explodemo as *const libc::c_void, sfx_dmpain);
        explodemo = P_SpawnMobj((*mo).x, (*mo).y, (*mo).z, MT_EXPLODE);
        P_SetScale(explodemo, (*mo).scale);
        (*explodemo).destscale = (*mo).destscale;
        (*explodemo).momx
            -= P_RandomByte() as libc::c_int % 128 as libc::c_int
                * FixedMul(
                    ((1 as libc::c_int) << 16 as libc::c_int) / 8 as libc::c_int,
                    (*explodemo).scale,
                );
        (*explodemo).momy
            += P_RandomByte() as libc::c_int % 128 as libc::c_int
                * FixedMul(
                    ((1 as libc::c_int) << 16 as libc::c_int) / 8 as libc::c_int,
                    (*explodemo).scale,
                );
        S_StartSound(explodemo as *const libc::c_void, sfx_pop);
        explodemo = P_SpawnMobj((*mo).x, (*mo).y, (*mo).z, MT_EXPLODE);
        P_SetScale(explodemo, (*mo).scale);
        (*explodemo).destscale = (*mo).destscale;
        (*explodemo).momx
            -= P_RandomByte() as libc::c_int % 96 as libc::c_int
                * FixedMul(
                    ((1 as libc::c_int) << 16 as libc::c_int) / 8 as libc::c_int,
                    (*explodemo).scale,
                );
        (*explodemo).momy
            -= P_RandomByte() as libc::c_int % 96 as libc::c_int
                * FixedMul(
                    ((1 as libc::c_int) << 16 as libc::c_int) / 8 as libc::c_int,
                    (*explodemo).scale,
                );
        S_StartSound(explodemo as *const libc::c_void, sfx_cybdth);
    }
    (*mo).flags &= !(MF_MISSILE as libc::c_int) as uint32_t;
    (*mo).flags |= MF_NOGRAVITY as libc::c_int as uint32_t;
    (*mo).flags |= MF_NOCLIPTHING as libc::c_int as uint32_t;
    if (*(*mo).info).deathsound as libc::c_uint != 0
        && (*mo).flags2 & MF2_DEBRIS as libc::c_int as uint32_t == 0
    {
        S_StartSound(mo as *const libc::c_void, (*(*mo).info).deathsound);
    }
    P_SetMobjState(mo, (*(*mo).info).deathstate);
}
#[no_mangle]
pub unsafe extern "C" fn P_InsideANonSolidFFloor(
    mut mobj: *mut mobj_t,
    mut rover: *mut ffloor_t,
) -> boolean {
    let mut topheight: fixed_t = 0;
    let mut bottomheight: fixed_t = 0;
    if (*rover).fofflags as libc::c_uint & FOF_EXISTS as libc::c_int as libc::c_uint == 0
    {
        return false_0 as libc::c_int;
    }
    if (*rover).fofflags as libc::c_uint & FOF_BLOCKPLAYER as libc::c_int as libc::c_uint
        != 0 && !((*mobj).player).is_null()
        || (*rover).fofflags as libc::c_uint
            & FOF_BLOCKOTHERS as libc::c_int as libc::c_uint != 0
            && ((*mobj).player).is_null()
    {
        return false_0 as libc::c_int;
    }
    topheight = P_GetFFloorTopZAt(rover, (*mobj).x, (*mobj).y);
    bottomheight = P_GetFFloorBottomZAt(rover, (*mobj).x, (*mobj).y);
    if (*mobj).z > topheight {
        return false_0 as libc::c_int;
    }
    if (*mobj).z + (*mobj).height < bottomheight {
        return false_0 as libc::c_int;
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn HighestOnLine(
    mut radius: fixed_t,
    mut x: fixed_t,
    mut y: fixed_t,
    mut line: *mut line_t,
    mut slope: *mut pslope_t,
    mut actuallylowest: boolean,
) -> fixed_t {
    let mut v1: vertex_t = vertex_t {
        x: 0,
        y: 0,
        floorzset: 0,
        ceilingzset: 0,
        floorz: 0,
        ceilingz: 0,
    };
    let mut v2: vertex_t = vertex_t {
        x: 0,
        y: 0,
        floorzset: 0,
        ceilingzset: 0,
        floorz: 0,
        ceilingz: 0,
    };
    v1.x = (*(*line).v1).x;
    v1.y = (*(*line).v1).y;
    v2.x = (*(*line).v2).x;
    v2.y = (*(*line).v2).y;
    if abs(v1.x - x) > radius {
        let mut diff: fixed_t = abs(v1.x - x) - radius;
        if v1.x < x {
            v1.x += diff;
            v1.y += FixedMul(diff, FixedDiv((*line).dy, (*line).dx));
        } else {
            v1.x -= diff;
            v1.y -= FixedMul(diff, FixedDiv((*line).dy, (*line).dx));
        }
    }
    if abs(v1.y - y) > radius {
        let mut diff_0: fixed_t = abs(v1.y - y) - radius;
        if v1.y < y {
            v1.y += diff_0;
            v1.x += FixedMul(diff_0, FixedDiv((*line).dx, (*line).dy));
        } else {
            v1.y -= diff_0;
            v1.x -= FixedMul(diff_0, FixedDiv((*line).dx, (*line).dy));
        }
    }
    if abs(v2.x - x) > radius {
        let mut diff_1: fixed_t = abs(v2.x - x) - radius;
        if v2.x < x {
            v2.x += diff_1;
            v2.y += FixedMul(diff_1, FixedDiv((*line).dy, (*line).dx));
        } else {
            v2.x -= diff_1;
            v2.y -= FixedMul(diff_1, FixedDiv((*line).dy, (*line).dx));
        }
    }
    if abs(v2.y - y) > radius {
        let mut diff_2: fixed_t = abs(v2.y - y) - radius;
        if v2.y < y {
            v2.y += diff_2;
            v2.x += FixedMul(diff_2, FixedDiv((*line).dx, (*line).dy));
        } else {
            v2.y -= diff_2;
            v2.x -= FixedMul(diff_2, FixedDiv((*line).dx, (*line).dy));
        }
    }
    if actuallylowest != 0 {
        return if P_GetSlopeZAt(slope, v1.x, v1.y) < P_GetSlopeZAt(slope, v2.x, v2.y) {
            P_GetSlopeZAt(slope, v1.x, v1.y)
        } else {
            P_GetSlopeZAt(slope, v2.x, v2.y)
        }
    } else {
        return if P_GetSlopeZAt(slope, v1.x, v1.y) > P_GetSlopeZAt(slope, v2.x, v2.y) {
            P_GetSlopeZAt(slope, v1.x, v1.y)
        } else {
            P_GetSlopeZAt(slope, v2.x, v2.y)
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_MobjFloorZ(
    mut mobj: *mut mobj_t,
    mut sector: *mut sector_t,
    mut boundsec: *mut sector_t,
    mut x: fixed_t,
    mut y: fixed_t,
    mut line: *mut line_t,
    mut lowest: boolean,
    mut perfect: boolean,
) -> fixed_t {
    if !((*sector).f_slope).is_null() {
        let mut testx: fixed_t = 0;
        let mut testy: fixed_t = 0;
        let mut slope: *mut pslope_t = (*sector).f_slope;
        if (*slope).d.x < 0 as libc::c_int {
            testx = (*mobj).radius;
        } else {
            testx = -(*mobj).radius;
        }
        if (*slope).d.y < 0 as libc::c_int {
            testy = (*mobj).radius;
        } else {
            testy = -(*mobj).radius;
        }
        if ((*slope).zdelta > 0 as libc::c_int) as libc::c_int
            ^ (lowest != 0) as libc::c_int != 0
        {
            testx = -testx;
            testy = -testy;
        }
        testx += x;
        testy += y;
        if (*R_PointInSubsector(testx, testy)).sector
            == (if !boundsec.is_null() { boundsec } else { sector })
        {
            return P_GetSlopeZAt(slope, testx, testy);
        }
        if perfect != 0 {
            let mut i: size_t = 0;
            let mut ld: *mut line_t = 0 as *mut line_t;
            let mut bbox: [fixed_t; 4] = [0; 4];
            let mut finalheight: fixed_t = 0;
            if lowest != 0 {
                finalheight = 2147483647 as libc::c_int;
            } else {
                finalheight = -(2147483647 as libc::c_int) - 1 as libc::c_int;
            }
            bbox[BOXLEFT as libc::c_int as usize] = x - (*mobj).radius;
            bbox[BOXRIGHT as libc::c_int as usize] = x + (*mobj).radius;
            bbox[BOXTOP as libc::c_int as usize] = y + (*mobj).radius;
            bbox[BOXBOTTOM as libc::c_int as usize] = y - (*mobj).radius;
            i = 0 as libc::c_int as size_t;
            while i < (*boundsec).linecount {
                ld = *((*boundsec).lines).offset(i as isize);
                if !(bbox[BOXRIGHT as libc::c_int as usize]
                    <= (*ld).bbox[BOXLEFT as libc::c_int as usize]
                    || bbox[BOXLEFT as libc::c_int as usize]
                        >= (*ld).bbox[BOXRIGHT as libc::c_int as usize]
                    || bbox[BOXTOP as libc::c_int as usize]
                        <= (*ld).bbox[BOXBOTTOM as libc::c_int as usize]
                    || bbox[BOXBOTTOM as libc::c_int as usize]
                        >= (*ld).bbox[BOXTOP as libc::c_int as usize])
                {
                    if !(P_BoxOnLineSide(bbox.as_mut_ptr(), ld) != -(1 as libc::c_int)) {
                        if lowest != 0 {
                            finalheight = if finalheight
                                < HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    true_0 as libc::c_int,
                                )
                            {
                                finalheight
                            } else {
                                HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    true_0 as libc::c_int,
                                )
                            };
                        } else {
                            finalheight = if finalheight
                                > HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    false_0 as libc::c_int,
                                )
                            {
                                finalheight
                            } else {
                                HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    false_0 as libc::c_int,
                                )
                            };
                        }
                    }
                }
                i = i.wrapping_add(1);
                i;
            }
            return finalheight;
        }
        if line.is_null() {
            return P_GetSlopeZAt(slope, x, y);
        }
        return HighestOnLine((*mobj).radius, x, y, line, slope, lowest);
    } else {
        return (*sector).floorheight
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_MobjCeilingZ(
    mut mobj: *mut mobj_t,
    mut sector: *mut sector_t,
    mut boundsec: *mut sector_t,
    mut x: fixed_t,
    mut y: fixed_t,
    mut line: *mut line_t,
    mut lowest: boolean,
    mut perfect: boolean,
) -> fixed_t {
    if !((*sector).c_slope).is_null() {
        let mut testx: fixed_t = 0;
        let mut testy: fixed_t = 0;
        let mut slope: *mut pslope_t = (*sector).c_slope;
        if (*slope).d.x < 0 as libc::c_int {
            testx = (*mobj).radius;
        } else {
            testx = -(*mobj).radius;
        }
        if (*slope).d.y < 0 as libc::c_int {
            testy = (*mobj).radius;
        } else {
            testy = -(*mobj).radius;
        }
        if ((*slope).zdelta > 0 as libc::c_int) as libc::c_int
            ^ (lowest != 0) as libc::c_int != 0
        {
            testx = -testx;
            testy = -testy;
        }
        testx += x;
        testy += y;
        if (*R_PointInSubsector(testx, testy)).sector
            == (if !boundsec.is_null() { boundsec } else { sector })
        {
            return P_GetSlopeZAt(slope, testx, testy);
        }
        if perfect != 0 {
            let mut i: size_t = 0;
            let mut ld: *mut line_t = 0 as *mut line_t;
            let mut bbox: [fixed_t; 4] = [0; 4];
            let mut finalheight: fixed_t = 0;
            if lowest != 0 {
                finalheight = 2147483647 as libc::c_int;
            } else {
                finalheight = -(2147483647 as libc::c_int) - 1 as libc::c_int;
            }
            bbox[BOXLEFT as libc::c_int as usize] = x - (*mobj).radius;
            bbox[BOXRIGHT as libc::c_int as usize] = x + (*mobj).radius;
            bbox[BOXTOP as libc::c_int as usize] = y + (*mobj).radius;
            bbox[BOXBOTTOM as libc::c_int as usize] = y - (*mobj).radius;
            i = 0 as libc::c_int as size_t;
            while i < (*boundsec).linecount {
                ld = *((*boundsec).lines).offset(i as isize);
                if !(bbox[BOXRIGHT as libc::c_int as usize]
                    <= (*ld).bbox[BOXLEFT as libc::c_int as usize]
                    || bbox[BOXLEFT as libc::c_int as usize]
                        >= (*ld).bbox[BOXRIGHT as libc::c_int as usize]
                    || bbox[BOXTOP as libc::c_int as usize]
                        <= (*ld).bbox[BOXBOTTOM as libc::c_int as usize]
                    || bbox[BOXBOTTOM as libc::c_int as usize]
                        >= (*ld).bbox[BOXTOP as libc::c_int as usize])
                {
                    if !(P_BoxOnLineSide(bbox.as_mut_ptr(), ld) != -(1 as libc::c_int)) {
                        if lowest != 0 {
                            finalheight = if finalheight
                                < HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    true_0 as libc::c_int,
                                )
                            {
                                finalheight
                            } else {
                                HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    true_0 as libc::c_int,
                                )
                            };
                        } else {
                            finalheight = if finalheight
                                > HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    false_0 as libc::c_int,
                                )
                            {
                                finalheight
                            } else {
                                HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    false_0 as libc::c_int,
                                )
                            };
                        }
                    }
                }
                i = i.wrapping_add(1);
                i;
            }
            return finalheight;
        }
        if line.is_null() {
            return P_GetSlopeZAt(slope, x, y);
        }
        return HighestOnLine((*mobj).radius, x, y, line, slope, lowest);
    } else {
        return (*sector).ceilingheight
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_CameraFloorZ(
    mut mobj: *mut camera_t,
    mut sector: *mut sector_t,
    mut boundsec: *mut sector_t,
    mut x: fixed_t,
    mut y: fixed_t,
    mut line: *mut line_t,
    mut lowest: boolean,
    mut perfect: boolean,
) -> fixed_t {
    if !((*sector).f_slope).is_null() {
        let mut testx: fixed_t = 0;
        let mut testy: fixed_t = 0;
        let mut slope: *mut pslope_t = (*sector).f_slope;
        if (*slope).d.x < 0 as libc::c_int {
            testx = (*mobj).radius;
        } else {
            testx = -(*mobj).radius;
        }
        if (*slope).d.y < 0 as libc::c_int {
            testy = (*mobj).radius;
        } else {
            testy = -(*mobj).radius;
        }
        if ((*slope).zdelta > 0 as libc::c_int) as libc::c_int
            ^ (lowest != 0) as libc::c_int != 0
        {
            testx = -testx;
            testy = -testy;
        }
        testx += x;
        testy += y;
        if (*R_PointInSubsector(testx, testy)).sector
            == (if !boundsec.is_null() { boundsec } else { sector })
        {
            return P_GetSlopeZAt(slope, testx, testy);
        }
        if perfect != 0 {
            let mut i: size_t = 0;
            let mut ld: *mut line_t = 0 as *mut line_t;
            let mut bbox: [fixed_t; 4] = [0; 4];
            let mut finalheight: fixed_t = 0;
            if lowest != 0 {
                finalheight = 2147483647 as libc::c_int;
            } else {
                finalheight = -(2147483647 as libc::c_int) - 1 as libc::c_int;
            }
            bbox[BOXLEFT as libc::c_int as usize] = x - (*mobj).radius;
            bbox[BOXRIGHT as libc::c_int as usize] = x + (*mobj).radius;
            bbox[BOXTOP as libc::c_int as usize] = y + (*mobj).radius;
            bbox[BOXBOTTOM as libc::c_int as usize] = y - (*mobj).radius;
            i = 0 as libc::c_int as size_t;
            while i < (*boundsec).linecount {
                ld = *((*boundsec).lines).offset(i as isize);
                if !(bbox[BOXRIGHT as libc::c_int as usize]
                    <= (*ld).bbox[BOXLEFT as libc::c_int as usize]
                    || bbox[BOXLEFT as libc::c_int as usize]
                        >= (*ld).bbox[BOXRIGHT as libc::c_int as usize]
                    || bbox[BOXTOP as libc::c_int as usize]
                        <= (*ld).bbox[BOXBOTTOM as libc::c_int as usize]
                    || bbox[BOXBOTTOM as libc::c_int as usize]
                        >= (*ld).bbox[BOXTOP as libc::c_int as usize])
                {
                    if !(P_BoxOnLineSide(bbox.as_mut_ptr(), ld) != -(1 as libc::c_int)) {
                        if lowest != 0 {
                            finalheight = if finalheight
                                < HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    true_0 as libc::c_int,
                                )
                            {
                                finalheight
                            } else {
                                HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    true_0 as libc::c_int,
                                )
                            };
                        } else {
                            finalheight = if finalheight
                                > HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    false_0 as libc::c_int,
                                )
                            {
                                finalheight
                            } else {
                                HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    false_0 as libc::c_int,
                                )
                            };
                        }
                    }
                }
                i = i.wrapping_add(1);
                i;
            }
            return finalheight;
        }
        if line.is_null() {
            return P_GetSlopeZAt(slope, x, y);
        }
        return HighestOnLine((*mobj).radius, x, y, line, slope, lowest);
    } else {
        return (*sector).floorheight
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_CameraCeilingZ(
    mut mobj: *mut camera_t,
    mut sector: *mut sector_t,
    mut boundsec: *mut sector_t,
    mut x: fixed_t,
    mut y: fixed_t,
    mut line: *mut line_t,
    mut lowest: boolean,
    mut perfect: boolean,
) -> fixed_t {
    if !((*sector).c_slope).is_null() {
        let mut testx: fixed_t = 0;
        let mut testy: fixed_t = 0;
        let mut slope: *mut pslope_t = (*sector).c_slope;
        if (*slope).d.x < 0 as libc::c_int {
            testx = (*mobj).radius;
        } else {
            testx = -(*mobj).radius;
        }
        if (*slope).d.y < 0 as libc::c_int {
            testy = (*mobj).radius;
        } else {
            testy = -(*mobj).radius;
        }
        if ((*slope).zdelta > 0 as libc::c_int) as libc::c_int
            ^ (lowest != 0) as libc::c_int != 0
        {
            testx = -testx;
            testy = -testy;
        }
        testx += x;
        testy += y;
        if (*R_PointInSubsector(testx, testy)).sector
            == (if !boundsec.is_null() { boundsec } else { sector })
        {
            return P_GetSlopeZAt(slope, testx, testy);
        }
        if perfect != 0 {
            let mut i: size_t = 0;
            let mut ld: *mut line_t = 0 as *mut line_t;
            let mut bbox: [fixed_t; 4] = [0; 4];
            let mut finalheight: fixed_t = 0;
            if lowest != 0 {
                finalheight = 2147483647 as libc::c_int;
            } else {
                finalheight = -(2147483647 as libc::c_int) - 1 as libc::c_int;
            }
            bbox[BOXLEFT as libc::c_int as usize] = x - (*mobj).radius;
            bbox[BOXRIGHT as libc::c_int as usize] = x + (*mobj).radius;
            bbox[BOXTOP as libc::c_int as usize] = y + (*mobj).radius;
            bbox[BOXBOTTOM as libc::c_int as usize] = y - (*mobj).radius;
            i = 0 as libc::c_int as size_t;
            while i < (*boundsec).linecount {
                ld = *((*boundsec).lines).offset(i as isize);
                if !(bbox[BOXRIGHT as libc::c_int as usize]
                    <= (*ld).bbox[BOXLEFT as libc::c_int as usize]
                    || bbox[BOXLEFT as libc::c_int as usize]
                        >= (*ld).bbox[BOXRIGHT as libc::c_int as usize]
                    || bbox[BOXTOP as libc::c_int as usize]
                        <= (*ld).bbox[BOXBOTTOM as libc::c_int as usize]
                    || bbox[BOXBOTTOM as libc::c_int as usize]
                        >= (*ld).bbox[BOXTOP as libc::c_int as usize])
                {
                    if !(P_BoxOnLineSide(bbox.as_mut_ptr(), ld) != -(1 as libc::c_int)) {
                        if lowest != 0 {
                            finalheight = if finalheight
                                < HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    true_0 as libc::c_int,
                                )
                            {
                                finalheight
                            } else {
                                HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    true_0 as libc::c_int,
                                )
                            };
                        } else {
                            finalheight = if finalheight
                                > HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    false_0 as libc::c_int,
                                )
                            {
                                finalheight
                            } else {
                                HighestOnLine(
                                    (*mobj).radius,
                                    x,
                                    y,
                                    ld,
                                    slope,
                                    false_0 as libc::c_int,
                                )
                            };
                        }
                    }
                }
                i = i.wrapping_add(1);
                i;
            }
            return finalheight;
        }
        if line.is_null() {
            return P_GetSlopeZAt(slope, x, y);
        }
        return HighestOnLine((*mobj).radius, x, y, line, slope, lowest);
    } else {
        return (*sector).ceilingheight
    };
}
unsafe extern "C" fn P_PlayerFlip(mut mo: *mut mobj_t) {
    if ((*mo).player).is_null() {
        return;
    }
    G_GhostAddFlip();
    if !((*(*mo).player).powers[pw_carry as libc::c_int as usize] as libc::c_int
        == CR_NIGHTSMODE as libc::c_int)
    {
        if (*(*mo).player).pflags as libc::c_uint
            & PF_FLIPCAM as libc::c_int as libc::c_uint != 0
        {
            (*(*mo).player).aiming = InvAngle((*(*mo).player).aiming);
            if ((*mo).player).offset_from(players.as_mut_ptr()) as libc::c_long
                == displayplayer as libc::c_long
            {
                localaiming = (*(*mo).player).aiming as int32_t;
                if camera.chase != 0 {
                    camera.aiming = InvAngle(camera.aiming);
                    camera.z = (*mo).z - camera.z + (*mo).z;
                    if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                    {
                        camera.z
                            += FixedMul(
                                20 as libc::c_int
                                    * ((1 as libc::c_int) << 16 as libc::c_int),
                                (*mo).scale,
                            );
                    }
                }
            } else if ((*mo).player).offset_from(players.as_mut_ptr()) as libc::c_long
                == secondarydisplayplayer as libc::c_long
            {
                localaiming2 = (*(*mo).player).aiming as int32_t;
                if camera2.chase != 0 {
                    camera2.aiming = InvAngle(camera2.aiming);
                    camera2.z = (*mo).z - camera2.z + (*mo).z;
                    if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                    {
                        camera2.z
                            += FixedMul(
                                20 as libc::c_int
                                    * ((1 as libc::c_int) << 16 as libc::c_int),
                                (*mo).scale,
                            );
                    }
                }
            }
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_GetMobjGravity(mut mo: *mut mobj_t) -> fixed_t {
    let mut gravityadd: fixed_t = 0 as libc::c_int;
    let mut gravsector: *mut sector_t = 0 as *mut sector_t;
    let mut goopgravity: boolean = false_0 as libc::c_int;
    let mut wasflip: boolean = 0;
    wasflip = ((*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
        != 0 as libc::c_int) as libc::c_int;
    (*mo)
        .eflags = ((*mo).eflags as libc::c_int & !(MFE_VERTICALFLIP as libc::c_int))
        as uint16_t;
    if !((*(*(*mo).subsector).sector).ffloors).is_null() {
        let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
        rover = (*(*(*mo).subsector).sector).ffloors;
        while !rover.is_null() {
            if !((*rover).fofflags as libc::c_uint
                & FOF_EXISTS as libc::c_int as libc::c_uint == 0
                || P_InsideANonSolidFFloor(mo, rover) == 0)
            {
                if (*rover).fofflags as libc::c_uint
                    & (FOF_SWIMMABLE as libc::c_int | FOF_GOOWATER as libc::c_int)
                        as libc::c_uint
                    == (FOF_SWIMMABLE as libc::c_int | FOF_GOOWATER as libc::c_int)
                        as libc::c_uint
                {
                    goopgravity = true_0 as libc::c_int;
                }
                if !(P_GetSectorGravityFactor((*(*rover).master).frontsector)
                    == (1 as libc::c_int) << 16 as libc::c_int)
                {
                    gravsector = (*(*rover).master).frontsector;
                    break;
                }
            }
            rover = (*rover).next;
        }
    }
    if gravsector.is_null() {
        gravsector = (*(*mo).subsector).sector;
    }
    gravityadd = -FixedMul(gravity, P_GetSectorGravityFactor(gravsector));
    if (*gravsector).flags as libc::c_uint
        & MSF_GRAVITYFLIP as libc::c_int as libc::c_uint != 0
        && gravityadd > 0 as libc::c_int
    {
        if (*gravsector).specialflags as libc::c_uint
            & SSF_GRAVITYOVERRIDE as libc::c_int as libc::c_uint != 0
        {
            (*mo).flags2 &= !(MF2_OBJECTFLIP as libc::c_int) as uint32_t;
        }
        (*mo)
            .eflags = ((*mo).eflags as libc::c_int | MFE_VERTICALFLIP as libc::c_int)
            as uint16_t;
    }
    if (*mo).eflags as libc::c_int & MFE_UNDERWATER as libc::c_int != 0
        && goopgravity == 0
    {
        gravityadd = gravityadd / 3 as libc::c_int;
    }
    if !((*mo).player).is_null() {
        if (*(*mo).player).pflags as libc::c_uint
            & PF_GLIDING as libc::c_int as libc::c_uint != 0
            || (*(*mo).player).charability as libc::c_int == CA_FLY as libc::c_int
                && (*(*mo).player).panim as libc::c_uint
                    == PA_ABILITY as libc::c_int as libc::c_uint
        {
            gravityadd = gravityadd / 3 as libc::c_int;
        }
        if (*(*mo).player).climbing as libc::c_int != 0
            || (*(*mo).player).powers[pw_carry as libc::c_int as usize] as libc::c_int
                == CR_NIGHTSMODE as libc::c_int
        {
            gravityadd = 0 as libc::c_int;
        }
        if ((*mo).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t == 0) as libc::c_int
            != ((*(*mo).player).powers[pw_gravityboots as libc::c_int as usize] == 0)
                as libc::c_int
        {
            gravityadd = -gravityadd;
            (*mo)
                .eflags = ((*mo).eflags as libc::c_int ^ MFE_VERTICALFLIP as libc::c_int)
                as uint16_t;
        }
        if wasflip
            == ((*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0)
                as libc::c_int
        {
            P_PlayerFlip(mo);
        }
    } else if (*mo).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t != 0 {
        (*mo)
            .eflags = ((*mo).eflags as libc::c_int | MFE_VERTICALFLIP as libc::c_int)
            as uint16_t;
        if (*mo).z + (*mo).height >= (*mo).ceilingz {
            gravityadd = 0 as libc::c_int;
        } else if gravityadd < 0 as libc::c_int {
            gravityadd *= -(1 as libc::c_int);
        }
    } else {
        match (*mo).type_0 as libc::c_uint {
            255 | 92 => {
                gravityadd >>= 1 as libc::c_int;
            }
            _ => {}
        }
    }
    if goopgravity != 0 {
        gravityadd = -(gravityadd / 5 as libc::c_int + gravityadd / 8 as libc::c_int);
    }
    gravityadd = FixedMul(gravityadd, (*mo).scale);
    return gravityadd;
}
#[no_mangle]
pub unsafe extern "C" fn P_CheckGravity(mut mo: *mut mobj_t, mut affect: boolean) {
    let mut gravityadd: fixed_t = P_GetMobjGravity(mo);
    if (*mo).momz == 0 {
        gravityadd <<= 1 as libc::c_int;
    }
    if affect != 0 {
        (*mo).momz += gravityadd;
    }
    if (*mo).type_0 as libc::c_uint == MT_SKIM as libc::c_int as libc::c_uint
        && (*mo).z + (*mo).momz <= (*mo).watertop && (*mo).z >= (*mo).watertop
    {
        (*mo).momz = 0 as libc::c_int;
        (*mo).flags |= MF_NOGRAVITY as libc::c_int as uint32_t;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_SetPitchRollFromSlope(
    mut mo: *mut mobj_t,
    mut slope: *mut pslope_t,
) {}
unsafe extern "C" fn P_SceneryXYFriction(
    mut mo: *mut mobj_t,
    mut oldx: fixed_t,
    mut oldy: fixed_t,
) {
    if abs((*mo).momx)
        < FixedMul(
            ((1 as libc::c_int) << 16 as libc::c_int) / 32 as libc::c_int,
            (*mo).scale,
        )
        && abs((*mo).momy)
            < FixedMul(
                ((1 as libc::c_int) << 16 as libc::c_int) / 32 as libc::c_int,
                (*mo).scale,
            )
    {
        (*mo).momx = 0 as libc::c_int;
        (*mo).momy = 0 as libc::c_int;
    } else {
        if oldx == (*mo).x && oldy == (*mo).y {
            (*mo)
                .momx = FixedMul(
                (*mo).momx,
                (0xe8 as libc::c_int) << 16 as libc::c_int - 8 as libc::c_int,
            );
            (*mo)
                .momy = FixedMul(
                (*mo).momy,
                (0xe8 as libc::c_int) << 16 as libc::c_int - 8 as libc::c_int,
            );
        } else {
            (*mo).momx = FixedMul((*mo).momx, (*mo).friction);
            (*mo).momy = FixedMul((*mo).momy, (*mo).friction);
        }
        if (*mo).type_0 as libc::c_uint
            == MT_CANNONBALLDECOR as libc::c_int as libc::c_uint
        {
            (*mo)
                .friction = ((1 as libc::c_int) << 16 as libc::c_int)
                - 0x100 as libc::c_int;
        } else {
            (*mo)
                .friction = (0xe8 as libc::c_int)
                << 16 as libc::c_int - 8 as libc::c_int;
        }
    };
}
unsafe extern "C" fn P_XYFriction(
    mut mo: *mut mobj_t,
    mut oldx: fixed_t,
    mut oldy: fixed_t,
) {
    let mut player: *mut player_t = 0 as *mut player_t;
    player = (*mo).player;
    if !player.is_null() {
        if (*player).pflags as libc::c_uint & PF_SPINNING as libc::c_int as libc::c_uint
            != 0 && ((*player).rmomx != 0 || (*player).rmomy != 0)
            && (*player).pflags as libc::c_uint
                & PF_STARTDASH as libc::c_int as libc::c_uint == 0
        {
            if maptol & TOL_2D as libc::c_int as uint32_t != 0
                || (*(*player).mo).flags2 & MF2_TWOD as libc::c_int as uint32_t != 0
            {
                let ns: fixed_t = FixedDiv(
                    549 as libc::c_int
                        * ((0xe8 as libc::c_int)
                            << 16 as libc::c_int - 8 as libc::c_int),
                    500 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                );
                (*mo).momx = FixedMul((*mo).momx, ns);
                (*mo).momy = FixedMul((*mo).momy, ns);
            }
        } else if abs((*player).rmomx)
            < FixedMul((1 as libc::c_int) << 16 as libc::c_int, (*mo).scale)
            && abs((*player).rmomy)
                < FixedMul((1 as libc::c_int) << 16 as libc::c_int, (*mo).scale)
            && (!((*player).cmd.forwardmove as libc::c_int != 0
                && !(maptol & TOL_2D as libc::c_int as uint32_t != 0
                    || (*mo).flags2 & MF2_TWOD as libc::c_int as uint32_t != 0))
                && (*player).cmd.sidemove == 0
                && (*player).pflags as libc::c_uint
                    & PF_SPINNING as libc::c_int as libc::c_uint == 0)
            && !(!((*(*player).mo).standingslope).is_null()
                && (*(*(*player).mo).standingslope).flags as libc::c_int
                    & SL_NOPHYSICS as libc::c_int == 0
                && abs((*(*(*player).mo).standingslope).zdelta)
                    >= ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int)
        {
            if (*player).panim as libc::c_uint == PA_WALK as libc::c_int as libc::c_uint
            {
                P_SetPlayerMobjState(mo, S_PLAY_STND);
            }
            (*mo).momx = (*player).cmomx;
            (*mo).momy = (*player).cmomy;
        } else if (*mo).eflags as libc::c_int & MFE_SPRUNG as libc::c_int == 0 {
            if oldx == (*mo).x && oldy == (*mo).y {
                (*mo)
                    .momx = FixedMul(
                    (*mo).momx,
                    (0xe8 as libc::c_int) << 16 as libc::c_int - 8 as libc::c_int,
                );
                (*mo)
                    .momy = FixedMul(
                    (*mo).momy,
                    (0xe8 as libc::c_int) << 16 as libc::c_int - 8 as libc::c_int,
                );
            } else {
                (*mo).momx = FixedMul((*mo).momx, (*mo).friction);
                (*mo).momy = FixedMul((*mo).momy, (*mo).friction);
            }
            (*mo)
                .friction = (0xe8 as libc::c_int)
                << 16 as libc::c_int - 8 as libc::c_int;
        }
    } else {
        P_SceneryXYFriction(mo, oldx, oldy);
    };
}
unsafe extern "C" fn P_PushableCheckBustables(mut mo: *mut mobj_t) {
    let mut current_block: u64;
    let mut node: *mut msecnode_t = 0 as *mut msecnode_t;
    let mut oldx: fixed_t = 0;
    let mut oldy: fixed_t = 0;
    if netgame != 0 && !((*mo).player).is_null() && (*(*mo).player).spectator != 0 {
        return;
    }
    oldx = (*mo).x;
    oldy = (*mo).y;
    P_UnsetThingPosition(mo);
    (*mo).x += (*mo).momx;
    (*mo).y += (*mo).momy;
    P_SetThingPosition(mo);
    node = (*mo).touching_sectorlist;
    's_39: while !node.is_null() {
        let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
        let mut topheight: fixed_t = 0;
        let mut bottomheight: fixed_t = 0;
        if ((*node).m_sector).is_null() {
            break;
        }
        if !((*(*node).m_sector).ffloors).is_null() {
            rover = (*(*node).m_sector).ffloors;
            while !rover.is_null() {
                if !((*rover).fofflags as libc::c_uint
                    & FOF_EXISTS as libc::c_int as libc::c_uint == 0)
                {
                    if !((*rover).fofflags as libc::c_uint
                        & FOF_BUSTUP as libc::c_int as libc::c_uint == 0)
                    {
                        if !((*rover).bustflags as libc::c_uint
                            & FB_PUSHABLES as libc::c_int as libc::c_uint == 0)
                        {
                            if !((*(*(*rover).master).frontsector).crumblestate
                                != CRUMBLE_NONE as libc::c_int)
                            {
                                topheight = P_MobjCeilingZ(
                                    mo,
                                    sectors.offset((*rover).secnum as isize),
                                    (*node).m_sector,
                                    (*mo).x,
                                    (*mo).y,
                                    0 as *mut line_t,
                                    false_0 as libc::c_int,
                                    false_0 as libc::c_int,
                                );
                                bottomheight = P_MobjFloorZ(
                                    mo,
                                    sectors.offset((*rover).secnum as isize),
                                    (*node).m_sector,
                                    (*mo).x,
                                    (*mo).y,
                                    0 as *mut line_t,
                                    true_0 as libc::c_int,
                                    false_0 as libc::c_int,
                                );
                                if (*rover).bustflags as libc::c_uint
                                    & FB_ONLYBOTTOM as libc::c_int as libc::c_uint != 0
                                {
                                    if (*mo).z + (*mo).momz + (*mo).height < bottomheight {
                                        current_block = 1856101646708284338;
                                    } else if (*mo).z + (*mo).height > bottomheight {
                                        current_block = 1856101646708284338;
                                    } else {
                                        current_block = 3275366147856559585;
                                    }
                                } else {
                                    match (*rover).busttype as libc::c_int {
                                        0 => {
                                            if (*mo).z + (*mo).momz > topheight {
                                                current_block = 1856101646708284338;
                                            } else if (*mo).z + (*mo).momz + (*mo).height < bottomheight
                                            {
                                                current_block = 1856101646708284338;
                                            } else {
                                                current_block = 3275366147856559585;
                                            }
                                        }
                                        1 => {
                                            if (*mo).z + (*mo).momz > topheight {
                                                current_block = 1856101646708284338;
                                            } else if (*mo).z + (*mo).height < bottomheight {
                                                current_block = 1856101646708284338;
                                            } else {
                                                current_block = 3275366147856559585;
                                            }
                                        }
                                        _ => {
                                            if (*mo).z >= topheight {
                                                current_block = 1856101646708284338;
                                            } else if (*mo).z + (*mo).height < bottomheight {
                                                current_block = 1856101646708284338;
                                            } else {
                                                current_block = 3275366147856559585;
                                            }
                                        }
                                    }
                                }
                                match current_block {
                                    1856101646708284338 => {}
                                    _ => {
                                        EV_CrumbleChain(0 as *mut sector_t, rover);
                                        if (*rover).bustflags as libc::c_uint
                                            & FB_EXECUTOR as libc::c_int as libc::c_uint != 0
                                        {
                                            P_LinedefExecute((*rover).busttag, mo, (*node).m_sector);
                                        }
                                        break 's_39;
                                    }
                                }
                            }
                        }
                    }
                }
                rover = (*rover).next;
            }
        }
        node = (*node).m_sectorlist_next;
    }
    P_UnsetThingPosition(mo);
    (*mo).x = oldx;
    (*mo).y = oldy;
    P_SetThingPosition(mo);
}
unsafe extern "C" fn P_CheckSkyHit(mut mo: *mut mobj_t) -> boolean {
    if !ceilingline.is_null() && !((*ceilingline).backsector).is_null()
        && (*(*ceilingline).backsector).ceilingpic == skyflatnum
        && !((*ceilingline).frontsector).is_null()
        && (*(*ceilingline).frontsector).ceilingpic == skyflatnum
        && ((*mo).z >= (*(*ceilingline).frontsector).ceilingheight
            || (*mo).z >= (*(*ceilingline).backsector).ceilingheight)
    {
        return true_0 as libc::c_int;
    }
    return false_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_XYMovement(mut mo: *mut mobj_t) {
    let mut player: *mut player_t = 0 as *mut player_t;
    let mut xmove: fixed_t = 0;
    let mut ymove: fixed_t = 0;
    let mut oldx: fixed_t = 0;
    let mut oldy: fixed_t = 0;
    let mut moved: boolean = 0;
    let mut oldslope: *mut pslope_t = 0 as *mut pslope_t;
    let mut slopemom: vector3_t = {
        let mut init = vector3_t {
            x: 0 as libc::c_int,
            y: 0 as libc::c_int,
            z: 0 as libc::c_int,
        };
        init
    };
    let mut predictedz: fixed_t = 0 as libc::c_int;
    if (*mo).momx == 0 && (*mo).momy == 0 {
        if (*mo).flags2 & MF2_SKULLFLY as libc::c_int as uint32_t != 0 {
            (*mo).flags2 &= !(MF2_SKULLFLY as libc::c_int) as uint32_t;
            (*mo).momz = 0 as libc::c_int;
            (*mo).momy = (*mo).momz;
            (*mo).momx = (*mo).momy;
            if (*mo).type_0 as libc::c_uint
                != MT_EGGMOBILE as libc::c_int as libc::c_uint
            {
                P_SetMobjState(mo, (*(*mo).info).spawnstate);
            }
            return;
        }
    }
    player = (*mo).player;
    xmove = (*mo).momx;
    ymove = (*mo).momy;
    oldx = (*mo).x;
    oldy = (*mo).y;
    if (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t != 0 {
        (*mo).standingslope = 0 as *mut pslope_s;
    }
    if !((*mo).standingslope).is_null()
        && abs((*(*mo).standingslope).zdelta)
            > (1 as libc::c_int) << 16 as libc::c_int >> 8 as libc::c_int
    {
        if P_IsObjectOnGround(mo) == 0 {
            P_SlopeLaunch(mo);
            xmove = (*mo).momx;
            ymove = (*mo).momy;
        } else {
            slopemom.x = xmove;
            slopemom.y = ymove;
            slopemom.z = 0 as libc::c_int;
            P_QuantizeMomentumToSlope(&mut slopemom, (*mo).standingslope);
            xmove = slopemom.x;
            ymove = slopemom.y;
            predictedz = (*mo).z + slopemom.z;
            oldslope = (*mo).standingslope;
        }
    } else if P_IsObjectOnGround(mo) != 0 && (*mo).momz == 0 {
        predictedz = (*mo).z;
    }
    if CheckForBustableBlocks != 0
        && ((*mo).flags & MF_PUSHABLE as libc::c_int as uint32_t != 0
            || (*(*mo).info).flags & MF_PUSHABLE as libc::c_int as uint32_t != 0
                && (*mo).fuse != 0)
    {
        P_PushableCheckBustables(mo);
    }
    if P_TryMove(mo, (*mo).x + xmove, (*mo).y + ymove, true_0 as libc::c_int) == 0
        && !(P_MobjWasRemoved(mo) != 0
            || (*mo).eflags as libc::c_int & MFE_SPRUNG as libc::c_int != 0)
    {
        moved = false_0 as libc::c_int;
        if !player.is_null() {
            B_MoveBlocked(player);
        }
        if LUA_HookMobjMoveBlocked(mo, tmhitthing, blockingline) != 0 {
            if P_MobjWasRemoved(mo) != 0 {
                return;
            }
        } else if P_MobjWasRemoved(mo) != 0 {
            return
        } else if (*mo).flags & MF_BOUNCE as libc::c_int as uint32_t != 0 {
            P_BounceMove(mo);
            ymove = 0 as libc::c_int;
            xmove = ymove;
            S_StartSound(mo as *const libc::c_void, (*(*mo).info).activesound);
            if (*mo).type_0 as libc::c_uint
                == MT_THROWNBOUNCE as libc::c_int as libc::c_uint
            {
                (*mo).threshold += 1;
                (*mo).threshold;
                if (*mo).fuse != 0 && (*mo).threshold < 5 as libc::c_int {
                    (*mo).fuse
                        += (5 as libc::c_int - (*mo).threshold) * 35 as libc::c_int;
                }
                if P_CheckSkyHit(mo) != 0 {
                    P_RemoveMobj(mo);
                    return;
                }
            }
        } else if (*mo).flags & MF_STICKY as libc::c_int as uint32_t != 0 {
            S_StartSound(mo as *const libc::c_void, (*(*mo).info).activesound);
            (*mo).momz = 0 as libc::c_int;
            (*mo).momy = (*mo).momz;
            (*mo).momx = (*mo).momy;
            (*mo).flags |= MF_NOGRAVITY as libc::c_int as uint32_t;
            (*mo).flags &= !(MF_STICKY as libc::c_int) as uint32_t;
            if P_CheckSkyHit(mo) != 0 {
                P_RemoveMobj(mo);
                return;
            }
        } else if !player.is_null()
            || (*mo).flags
                & (MF_SLIDEME as libc::c_int | MF_PUSHABLE as libc::c_int) as uint32_t
                != 0
        {
            let mut transferslope: *mut pslope_t = 0 as *mut pslope_t;
            let mut transfermomz: fixed_t = 0 as libc::c_int;
            if !oldslope.is_null()
                && P_MobjFlip(mo) as libc::c_int * (predictedz - (*mo).z)
                    > 0 as libc::c_int
            {
                transferslope = if !((*mo).standingslope).is_null() {
                    (*mo).standingslope
                } else {
                    oldslope
                };
                if (if (*transferslope).zangle < 0x80000000 as libc::c_uint {
                    (*transferslope).zangle
                } else {
                    InvAngle((*transferslope).zangle)
                }) >= 0x20000000 as libc::c_int as angle_t
                {
                    transfermomz = P_GetWallTransferMomZ(mo, transferslope);
                }
            }
            P_SlideMove(mo);
            if !player.is_null() {
                (*player)
                    .powers[pw_pushing as libc::c_int
                    as usize] = 3 as libc::c_int as uint16_t;
            }
            ymove = 0 as libc::c_int;
            xmove = ymove;
            if transfermomz != 0 && !transferslope.is_null() {
                let mut relation: angle_t = 0;
                if (*mo).momx != 0 || (*mo).momy != 0 {
                    relation = ((*transferslope).xydirection)
                        .wrapping_sub(
                            R_PointToAngle2(
                                0 as libc::c_int,
                                0 as libc::c_int,
                                (*mo).momx,
                                (*mo).momy,
                            ),
                        );
                } else {
                    relation = 0x40000000 as libc::c_int as angle_t;
                }
                transfermomz = FixedMul(
                    transfermomz,
                    abs(
                        finesine[(relation >> 19 as libc::c_int
                            & (8192 as libc::c_int - 1 as libc::c_int) as angle_t)
                            as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                    ),
                );
                if P_MobjFlip(mo) as libc::c_int * (transfermomz - (*mo).momz)
                    > 2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                {
                    (*mo).momz = transfermomz;
                    (*mo).standingslope = 0 as *mut pslope_s;
                    if !player.is_null() {
                        (*player)
                            .powers[pw_justlaunched as libc::c_int
                            as usize] = 2 as libc::c_int as uint16_t;
                        if (*player).pflags as libc::c_uint
                            & PF_SPINNING as libc::c_int as libc::c_uint != 0
                        {
                            (*player)
                                .pflags = ::core::mem::transmute::<
                                libc::c_uint,
                                pflags_t,
                            >(
                                (*player).pflags as libc::c_uint
                                    | PF_THOKKED as libc::c_int as libc::c_uint,
                            );
                        }
                    }
                }
            }
        } else if (*mo).type_0 as libc::c_uint
            == MT_SPINFIRE as libc::c_int as libc::c_uint
        {
            P_RemoveMobj(mo);
            return;
        } else if (*mo).flags & MF_MISSILE as libc::c_int as uint32_t != 0 {
            if P_CheckSkyHit(mo) != 0 {
                P_RemoveMobj(mo);
                return;
            }
            P_ExplodeMissile(mo);
            return;
        } else {
            (*mo).momy = 0 as libc::c_int;
            (*mo).momx = (*mo).momy;
        }
    } else {
        moved = true_0 as libc::c_int;
    }
    if P_MobjWasRemoved(mo) != 0 {
        return;
    }
    if moved != 0 && !oldslope.is_null()
        && (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0
    {
        if oldslope != (*mo).standingslope {
            let mut oldangle: angle_t = 0;
            let mut newangle: angle_t = 0;
            let mut moveangle: angle_t = R_PointToAngle2(
                0 as libc::c_int,
                0 as libc::c_int,
                (*mo).momx,
                (*mo).momy,
            );
            oldangle = FixedMul(
                (*oldslope).zangle as libc::c_int,
                *finecosine
                    .offset(
                        (moveangle.wrapping_sub((*oldslope).xydirection)
                            >> 19 as libc::c_int) as isize,
                    ) >> 16 as libc::c_int - 16 as libc::c_int,
            ) as angle_t;
            if !((*mo).standingslope).is_null() {
                newangle = FixedMul(
                    (*(*mo).standingslope).zangle as libc::c_int,
                    *finecosine
                        .offset(
                            (moveangle.wrapping_sub((*(*mo).standingslope).xydirection)
                                >> 19 as libc::c_int) as isize,
                        ) >> 16 as libc::c_int - 16 as libc::c_int,
                ) as angle_t;
            } else {
                newangle = 0 as libc::c_int as angle_t;
            }
            if oldangle.wrapping_sub(newangle) > 0x15555555 as libc::c_int as angle_t
                && oldangle.wrapping_sub(newangle) < 0x80000000 as libc::c_uint
            {
                (*mo).standingslope = oldslope;
                P_SetPitchRollFromSlope(mo, (*mo).standingslope);
                P_SlopeLaunch(mo);
            }
        } else if predictedz - (*mo).z > abs(slopemom.z / 2 as libc::c_int) {
            P_SlopeLaunch(mo);
        }
    } else if moved != 0 && !((*mo).standingslope).is_null() && predictedz != 0 {
        let mut moveangle_0: angle_t = R_PointToAngle2(
            0 as libc::c_int,
            0 as libc::c_int,
            (*mo).momx,
            (*mo).momy,
        );
        let mut newangle_0: angle_t = FixedMul(
            (*(*mo).standingslope).zangle as libc::c_int,
            *finecosine
                .offset(
                    (moveangle_0.wrapping_sub((*(*mo).standingslope).xydirection)
                        >> 19 as libc::c_int) as isize,
                ) >> 16 as libc::c_int - 16 as libc::c_int,
        ) as angle_t;
        if (0xffffffff as libc::c_uint).wrapping_sub(newangle_0)
            > 0x15555555 as libc::c_int as libc::c_uint
            && newangle_0 > 0x80000000 as libc::c_uint
        {
            (*mo)
                .momz = P_MobjFlip(mo) as libc::c_int
                * ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int;
            (*mo).z = predictedz + P_MobjFlip(mo) as libc::c_int;
            (*mo).standingslope = 0 as *mut pslope_s;
        }
    }
    P_CheckGravity(mo, false_0 as libc::c_int);
    if !player.is_null() && moved == 0
        && (*player).powers[pw_carry as libc::c_int as usize] as libc::c_int
            == CR_NIGHTSMODE as libc::c_int && !((*mo).target).is_null()
    {
        let mut fa: angle_t = 0;
        P_UnsetThingPosition(mo);
        (*player).angle_pos = (*player).old_angle_pos;
        (*player)
            .speed = FixedMul(
            (*player).speed,
            4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                / 5 as libc::c_int,
        );
        if (*player).flyangle >= 0 as libc::c_int
            && (*player).flyangle < 90 as libc::c_int
        {
            (*player).flyangle = 135 as libc::c_int;
        } else if (*player).flyangle >= 90 as libc::c_int
            && (*player).flyangle < 180 as libc::c_int
        {
            (*player).flyangle = 45 as libc::c_int;
        } else if (*player).flyangle >= 180 as libc::c_int
            && (*player).flyangle < 270 as libc::c_int
        {
            (*player).flyangle = 315 as libc::c_int;
        } else {
            (*player).flyangle = 225 as libc::c_int;
        }
        (*player).flyangle %= 360 as libc::c_int;
        if (*player).pflags as libc::c_uint
            & PF_TRANSFERTOCLOSEST as libc::c_int as libc::c_uint != 0
        {
            (*mo).x -= (*mo).momx;
            (*mo).y -= (*mo).momy;
        } else {
            fa = (*player).old_angle_pos >> 19 as libc::c_int;
            (*mo)
                .x = (*(*mo).target).x
                + FixedMul(
                    *finecosine.offset(fa as isize)
                        >> 16 as libc::c_int - 16 as libc::c_int,
                    (*(*mo).target).radius,
                );
            (*mo)
                .y = (*(*mo).target).y
                + FixedMul(
                    finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                    (*(*mo).target).radius,
                );
        }
        (*mo).momy = 0 as libc::c_int;
        (*mo).momx = (*mo).momy;
        P_SetThingPosition(mo);
    }
    if (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t != 0 {
        return;
    }
    if (*mo).flags & MF_MISSILE as libc::c_int as uint32_t != 0
        || (*mo).flags2 & MF2_SKULLFLY as libc::c_int as uint32_t != 0
        || (*mo).type_0 as libc::c_uint == MT_SHELL as libc::c_int as libc::c_uint
        || (*mo).type_0 as libc::c_uint == MT_VULTURE as libc::c_int as libc::c_uint
        || (*mo).type_0 as libc::c_uint == MT_PENGUINATOR as libc::c_int as libc::c_uint
    {
        return;
    }
    if !player.is_null() && (*player).homing as libc::c_int != 0 {
        return;
    }
    if !player.is_null()
        && (*player).powers[pw_carry as libc::c_int as usize] as libc::c_int
            == CR_NIGHTSMODE as libc::c_int
    {
        return;
    }
    if ((*mo).type_0 as libc::c_uint == MT_BIGTUMBLEWEED as libc::c_int as libc::c_uint
        || (*mo).type_0 as libc::c_uint
            == MT_LITTLETUMBLEWEED as libc::c_int as libc::c_uint)
        && (!((*mo).standingslope).is_null()
            && abs((*(*mo).standingslope).zdelta)
                > (1 as libc::c_int) << 16 as libc::c_int >> 8 as libc::c_int)
    {
        return;
    }
    if ((*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
        && (*mo).z > (*mo).floorz
        || (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
            && (*mo).z + (*mo).height < (*mo).ceilingz)
        && !(!player.is_null()
            && (*player).pflags as libc::c_uint
                & PF_SLIDING as libc::c_int as libc::c_uint != 0)
    {
        return;
    }
    P_XYFriction(mo, oldx, oldy);
}
#[no_mangle]
pub unsafe extern "C" fn P_RingXYMovement(mut mo: *mut mobj_t) {
    if P_SceneryTryMove(mo, (*mo).x + (*mo).momx, (*mo).y + (*mo).momy) == 0 {
        P_SlideMove(mo);
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_SceneryXYMovement(mut mo: *mut mobj_t) {
    let mut oldx: fixed_t = 0;
    let mut oldy: fixed_t = 0;
    oldx = (*mo).x;
    oldy = (*mo).y;
    if P_SceneryTryMove(mo, (*mo).x + (*mo).momx, (*mo).y + (*mo).momy) == 0 {
        P_SlideMove(mo);
    }
    if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
        && (*mo).z > (*mo).floorz
        || (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
            && (*mo).z + (*mo).height < (*mo).ceilingz
    {
        return;
    }
    if (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t != 0 {
        return;
    }
    P_SceneryXYFriction(mo, oldx, oldy);
}
#[no_mangle]
pub unsafe extern "C" fn P_AdjustMobjFloorZ_FFloors(
    mut mo: *mut mobj_t,
    mut sector: *mut sector_t,
    mut motype: uint8_t,
) {
    let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
    let mut delta1: fixed_t = 0;
    let mut delta2: fixed_t = 0;
    let mut thingtop: fixed_t = 0;
    let mut topheight: fixed_t = 0;
    let mut bottomheight: fixed_t = 0;
    thingtop = (*mo).z + (*mo).height;
    let mut current_block_25: u64;
    rover = (*sector).ffloors;
    while !rover.is_null() {
        if !((*rover).fofflags as libc::c_uint
            & FOF_EXISTS as libc::c_int as libc::c_uint == 0)
        {
            topheight = P_MobjCeilingZ(
                mo,
                sectors.offset((*rover).secnum as isize),
                sector,
                (*mo).x,
                (*mo).y,
                0 as *mut line_t,
                false_0 as libc::c_int,
                false_0 as libc::c_int,
            );
            bottomheight = P_MobjFloorZ(
                mo,
                sectors.offset((*rover).secnum as isize),
                sector,
                (*mo).x,
                (*mo).y,
                0 as *mut line_t,
                true_0 as libc::c_int,
                false_0 as libc::c_int,
            );
            if !((*mo).player).is_null()
                && (P_CheckSolidLava(rover) != 0
                    || P_CanRunOnWater((*mo).player, rover) != 0)
            {
                current_block_25 = 5399440093318478209;
            } else if motype as libc::c_int != 0 as libc::c_int
                && (*rover).fofflags as libc::c_uint
                    & FOF_SWIMMABLE as libc::c_int as libc::c_uint != 0
            {
                current_block_25 = 10680521327981672866;
            } else if (*rover).fofflags as libc::c_uint
                & FOF_QUICKSAND as libc::c_int as libc::c_uint != 0
            {
                current_block_25 = 5399440093318478209;
            } else if !((*rover).fofflags as libc::c_uint
                & (FOF_BLOCKPLAYER as libc::c_int | FOF_MARIO as libc::c_int)
                    as libc::c_uint != 0 && !((*mo).player).is_null()
                || (*rover).fofflags as libc::c_uint
                    & FOF_BLOCKOTHERS as libc::c_int as libc::c_uint != 0
                    && ((*mo).player).is_null())
            {
                current_block_25 = 10680521327981672866;
            } else {
                current_block_25 = 5399440093318478209;
            }
            match current_block_25 {
                10680521327981672866 => {}
                _ => {
                    if (*rover).fofflags as libc::c_uint
                        & FOF_QUICKSAND as libc::c_int as libc::c_uint != 0
                    {
                        match motype as libc::c_int {
                            2 => {
                                if (*mo).z < topheight && bottomheight < thingtop {
                                    if (*mo).eflags as libc::c_int
                                        & MFE_VERTICALFLIP as libc::c_int == 0
                                    {
                                        (*mo).floorz = (*mo).z;
                                    } else if (*mo).eflags as libc::c_int
                                        & MFE_VERTICALFLIP as libc::c_int != 0
                                    {
                                        (*mo).ceilingz = thingtop;
                                    }
                                    current_block_25 = 10680521327981672866;
                                } else {
                                    current_block_25 = 2232869372362427478;
                                }
                            }
                            _ => {
                                if (*mo).z < topheight && bottomheight < thingtop {
                                    if (*mo).eflags as libc::c_int
                                        & MFE_VERTICALFLIP as libc::c_int == 0
                                        && (*mo).floorz < (*mo).z
                                    {
                                        (*mo).floorz = (*mo).z;
                                    } else if (*mo).eflags as libc::c_int
                                        & MFE_VERTICALFLIP as libc::c_int != 0
                                        && (*mo).ceilingz > thingtop
                                    {
                                        (*mo).ceilingz = thingtop;
                                    }
                                }
                                current_block_25 = 10680521327981672866;
                            }
                        }
                    } else {
                        current_block_25 = 2232869372362427478;
                    }
                    match current_block_25 {
                        10680521327981672866 => {}
                        _ => {
                            delta1 = (*mo).z
                                - (bottomheight
                                    + (topheight - bottomheight) / 2 as libc::c_int);
                            delta2 = thingtop
                                - (bottomheight
                                    + (topheight - bottomheight) / 2 as libc::c_int);
                            if topheight > (*mo).floorz && abs(delta1) < abs(delta2)
                                && (*rover).fofflags as libc::c_uint
                                    & FOF_SOLID as libc::c_int as libc::c_uint != 0
                                && (*rover).fofflags as libc::c_uint
                                    & FOF_REVERSEPLATFORM as libc::c_int as libc::c_uint == 0
                                && (P_MobjFlip(mo) as libc::c_int * (*mo).momz
                                    >= 0 as libc::c_int
                                    || (*rover).fofflags as libc::c_uint
                                        & FOF_PLATFORM as libc::c_int as libc::c_uint == 0)
                            {
                                (*mo).floorz = topheight;
                            }
                            if bottomheight < (*mo).ceilingz
                                && abs(delta1) >= abs(delta2)
                                && (*rover).fofflags as libc::c_uint
                                    & FOF_PLATFORM as libc::c_int as libc::c_uint == 0
                                && (P_MobjFlip(mo) as libc::c_int * (*mo).momz
                                    >= 0 as libc::c_int
                                    || (*rover).fofflags as libc::c_uint
                                        & FOF_SOLID as libc::c_int as libc::c_uint != 0
                                        && (*rover).fofflags as libc::c_uint
                                            & FOF_REVERSEPLATFORM as libc::c_int as libc::c_uint == 0)
                            {
                                (*mo).ceilingz = bottomheight;
                            }
                        }
                    }
                }
            }
        }
        rover = (*rover).next;
    }
}
unsafe extern "C" fn P_AdjustMobjFloorZ_PolyObjs(
    mut mo: *mut mobj_t,
    mut subsec: *mut subsector_t,
) {
    let mut po: *mut polyobj_t = (*subsec).polyList;
    let mut polysec: *mut sector_t = 0 as *mut sector_t;
    let mut delta1: fixed_t = 0;
    let mut delta2: fixed_t = 0;
    let mut thingtop: fixed_t = 0;
    let mut polytop: fixed_t = 0;
    let mut polybottom: fixed_t = 0;
    thingtop = (*mo).z + (*mo).height;
    while !po.is_null() {
        if P_MobjInsidePolyobj(po, mo) == 0
            || (*po).flags & POF_SOLID as libc::c_int == 0
        {
            po = (*po).link.next as *mut polyobj_t;
        } else {
            polysec = (**((*po).lines).offset(0 as libc::c_int as isize)).backsector;
            if (*po).flags & POF_CLIPPLANES as libc::c_int != 0 {
                polytop = (*polysec).ceilingheight;
                polybottom = (*polysec).floorheight;
            } else {
                polytop = 2147483647 as libc::c_int;
                polybottom = -(2147483647 as libc::c_int) - 1 as libc::c_int;
            }
            delta1 = (*mo).z - (polybottom + (polytop - polybottom) / 2 as libc::c_int);
            delta2 = thingtop - (polybottom + (polytop - polybottom) / 2 as libc::c_int);
            if polytop > (*mo).floorz && abs(delta1) < abs(delta2) {
                (*mo).floorz = polytop;
            }
            if polybottom < (*mo).ceilingz && abs(delta1) >= abs(delta2) {
                (*mo).ceilingz = polybottom;
            }
            po = (*po).link.next as *mut polyobj_t;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_RingZMovement(mut mo: *mut mobj_t) {
    if !((*(*(*mo).subsector).sector).ffloors).is_null() {
        P_AdjustMobjFloorZ_FFloors(
            mo,
            (*(*mo).subsector).sector,
            1 as libc::c_int as uint8_t,
        );
    }
    if !((*(*mo).subsector).polyList).is_null() {
        P_AdjustMobjFloorZ_PolyObjs(mo, (*mo).subsector);
    }
    if (*mo).eflags as libc::c_int & MFE_APPLYPMOMZ as libc::c_int != 0
        && P_IsObjectOnGround(mo) == 0
    {
        (*mo).momz += (*mo).pmomz;
        (*mo).pmomz = 0 as libc::c_int;
        (*mo)
            .eflags = ((*mo).eflags as libc::c_int & !(MFE_APPLYPMOMZ as libc::c_int))
            as uint16_t;
    }
    (*mo).z += (*mo).momz;
    if (*mo).z <= (*mo).floorz
        && (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0
    {
        (*mo).z = (*mo).floorz;
        (*mo).momz = 0 as libc::c_int;
    } else if (*mo).z + (*mo).height > (*mo).ceilingz
        && (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0
    {
        (*mo).z = (*mo).ceilingz - (*mo).height;
        (*mo).momz = 0 as libc::c_int;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_CheckDeathPitCollide(mut mo: *mut mobj_t) -> boolean {
    if !((*mo).player).is_null()
        && (*(*mo).player).pflags as libc::c_uint
            & PF_GODMODE as libc::c_int as libc::c_uint != 0
    {
        return false_0 as libc::c_int;
    }
    if ((*mo).z <= (*(*(*mo).subsector).sector).floorheight
        && ((*(*(*mo).subsector).sector).flags as libc::c_uint
            & MSF_TRIGGERSPECIAL_HEADBUMP as libc::c_int as libc::c_uint != 0
            || (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0)
        && (*(*(*mo).subsector).sector).flags as libc::c_uint
            & MSF_FLIPSPECIAL_FLOOR as libc::c_int as libc::c_uint != 0
        || (*mo).z + (*mo).height >= (*(*(*mo).subsector).sector).ceilingheight
            && ((*(*(*mo).subsector).sector).flags as libc::c_uint
                & MSF_TRIGGERSPECIAL_HEADBUMP as libc::c_int as libc::c_uint != 0
                || (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0)
            && (*(*(*mo).subsector).sector).flags as libc::c_uint
                & MSF_FLIPSPECIAL_CEILING as libc::c_int as libc::c_uint != 0)
        && ((*(*(*mo).subsector).sector).damagetype as libc::c_int
            == SD_DEATHPITTILT as libc::c_int
            || (*(*(*mo).subsector).sector).damagetype as libc::c_int
                == SD_DEATHPITNOTILT as libc::c_int)
    {
        return true_0 as libc::c_int;
    }
    return false_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_CheckSolidLava(mut rover: *mut ffloor_t) -> boolean {
    return ((*rover).fofflags as libc::c_uint
        & FOF_SWIMMABLE as libc::c_int as libc::c_uint != 0
        && (*(*(*rover).master).frontsector).damagetype as libc::c_int
            == SD_LAVA as libc::c_int) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_ZMovement(mut mo: *mut mobj_t) -> boolean {
    let mut dist: fixed_t = 0;
    let mut delta: fixed_t = 0;
    let mut onground: boolean = 0;
    if !((*(*(*mo).subsector).sector).ffloors).is_null() {
        P_AdjustMobjFloorZ_FFloors(
            mo,
            (*(*mo).subsector).sector,
            0 as libc::c_int as uint8_t,
        );
    }
    if !((*(*mo).subsector).polyList).is_null() {
        P_AdjustMobjFloorZ_PolyObjs(mo, (*mo).subsector);
    }
    if (*mo).eflags as libc::c_int & MFE_APPLYPMOMZ as libc::c_int != 0
        && P_IsObjectOnGround(mo) == 0
    {
        (*mo).momz += (*mo).pmomz;
        (*mo).pmomz = 0 as libc::c_int;
        (*mo)
            .eflags = ((*mo).eflags as libc::c_int & !(MFE_APPLYPMOMZ as libc::c_int))
            as uint16_t;
    }
    (*mo).z += (*mo).momz;
    onground = P_IsObjectOnGround(mo);
    if !((*mo).standingslope).is_null() {
        if (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t != 0 {
            (*mo).standingslope = 0 as *mut pslope_s;
        } else if onground == 0 {
            P_SlopeLaunch(mo);
        }
    }
    match (*mo).type_0 as libc::c_uint {
        544 => {
            if (*mo).flags & MF_BOUNCE as libc::c_int as uint32_t != 0
                && ((*mo).z <= (*mo).floorz || (*mo).z + (*mo).height >= (*mo).ceilingz)
            {
                (*mo).momz = -(*mo).momz;
                (*mo).z += (*mo).momz;
                S_StartSound(mo as *const libc::c_void, (*(*mo).info).activesound);
                (*mo).threshold += 1;
                (*mo).threshold;
                if (*mo).fuse != 0 && (*mo).threshold < 5 as libc::c_int {
                    (*mo).fuse
                        += (5 as libc::c_int - (*mo).threshold) * 35 as libc::c_int;
                }
            }
        }
        15 => {
            if (*mo).z > (*mo).watertop && (*mo).z - (*mo).momz <= (*mo).watertop {
                (*mo).z = (*mo).watertop;
                (*mo).momz = 0 as libc::c_int;
                (*mo).flags |= MF_NOGRAVITY as libc::c_int as uint32_t;
            }
        }
        148 => {
            if P_CheckDeathPitCollide(mo) != 0 {
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
        }
        68 => {
            if P_CheckDeathPitCollide(mo) != 0 {
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
            if (*mo).z <= (*mo).floorz && (*mo).momz != 0 {
                P_SetMobjState(mo, (*(*mo).info).meleestate);
                (*mo).momz = 0 as libc::c_int;
                (*mo).momy = (*mo).momz;
                (*mo).momx = (*mo).momy;
                (*mo).z = (*mo).floorz;
                if (*(*mo).info).painsound as u64 != 0 {
                    S_StartSound(mo as *const libc::c_void, (*(*mo).info).painsound);
                }
            }
        }
        626 | 309 | 310 | 557 => {
            if P_CheckDeathPitCollide(mo) != 0 {
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
        }
        115 | 116 => {
            if P_CheckDeathPitCollide(mo) != 0 {
                (*mo).fuse = 1 as libc::c_int;
                return false_0 as libc::c_int;
            }
        }
        107 | 550 | 109 | 111 | 581 | 583 | 112 | 113 | 108 | 551 | 110 | 582 | 127 => {
            if P_CheckDeathPitCollide(mo) != 0 {
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
            if !((*mo).momx != 0 || (*mo).momy != 0 || (*mo).momz != 0) {
                return true_0 as libc::c_int;
            }
        }
        531 | 533 | 534 | 532 | 535 | 536 | 537 | 538 | 539 | 540 | 541 | 542 | 543 => {
            if P_CheckDeathPitCollide(mo) != 0
                && (*mo).flags2 & MF2_DONTRESPAWN as libc::c_int as uint32_t != 0
            {
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
            if !((*mo).momx != 0 || (*mo).momy != 0 || (*mo).momz != 0) {
                return true_0 as libc::c_int;
            }
        }
        347 | 348 => {
            if (*mo).flags & MF_BOUNCE as libc::c_int as uint32_t == 0 {
                return true_0 as libc::c_int;
            }
        }
        149 | 150 => {
            if (*mo).health == 0
                && ((*mo).z <= (*mo).floorz || (*mo).z + (*mo).height >= (*mo).ceilingz)
            {
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
        }
        _ => {}
    }
    if ((*mo).player).is_null() && P_CheckDeathPitCollide(mo) != 0 {
        match (*mo).type_0 as libc::c_uint {
            615 | 103 | 622 | 54 | 55 => {}
            _ => {
                if (*mo).flags & MF_ENEMY as libc::c_int as uint32_t != 0
                    || (*mo).flags & MF_BOSS as libc::c_int as uint32_t != 0
                    || (*mo).type_0 as libc::c_uint
                        == MT_MINECART as libc::c_int as libc::c_uint
                {
                    if (*mo).health != 0 {
                        P_KillMobj(
                            mo,
                            0 as *mut mobj_t,
                            0 as *mut mobj_t,
                            0 as libc::c_int as uint8_t,
                        );
                    }
                    return (P_MobjWasRemoved(mo) == 0) as libc::c_int;
                } else {
                    P_RemoveMobj(mo);
                    return false_0 as libc::c_int;
                }
            }
        }
    }
    if P_MobjFlip(mo) as libc::c_int * (*mo).momz < 0 as libc::c_int
        && (*mo).flags2 & MF2_CLASSICPUSH as libc::c_int as uint32_t != 0
    {
        (*mo).momy = 0 as libc::c_int;
        (*mo).momx = (*mo).momy;
    }
    if (*mo).flags & MF_FLOAT as libc::c_int as uint32_t != 0
        && !((*mo).target).is_null() && (*mo).health != 0
        && !((*mo).type_0 as libc::c_uint == MT_EGGMOBILE as libc::c_int as libc::c_uint)
        && (*(*mo).target).health > 0 as libc::c_int
    {
        if (*mo).flags2 & MF2_SKULLFLY as libc::c_int as uint32_t == 0
            && (*mo).flags2 & MF2_INFLOAT as libc::c_int as uint32_t == 0
        {
            dist = P_AproxDistance(
                (*mo).x - (*(*mo).target).x,
                (*mo).y - (*(*mo).target).y,
            );
            delta = (*(*mo).target).z + ((*mo).height >> 1 as libc::c_int) - (*mo).z;
            if delta < 0 as libc::c_int && dist < -(delta * 3 as libc::c_int) {
                (*mo).z
                    -= FixedMul(
                        ((1 as libc::c_int) << 16 as libc::c_int) * 4 as libc::c_int,
                        (*mo).scale,
                    );
            } else if delta > 0 as libc::c_int && dist < delta * 3 as libc::c_int {
                (*mo).z
                    += FixedMul(
                        ((1 as libc::c_int) << 16 as libc::c_int) * 4 as libc::c_int,
                        (*mo).scale,
                    );
            }
            if (*mo).type_0 as libc::c_uint == MT_JETJAW as libc::c_int as libc::c_uint
                && (*mo).z + (*mo).height > (*mo).watertop
            {
                (*mo).z = (*mo).watertop - (*mo).height;
            }
        }
    }
    if ((*mo).z <= (*mo).floorz
        && (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
        || (*mo).z + (*mo).height >= (*mo).ceilingz
            && (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0)
        && (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0
    {
        let mut mom: vector3_t = vector3_t { x: 0, y: 0, z: 0 };
        mom.x = (*mo).momx;
        mom.y = (*mo).momy;
        mom.z = (*mo).momz;
        if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
            (*mo).z = (*mo).ceilingz - (*mo).height;
        } else {
            (*mo).z = (*mo).floorz;
        }
        if (*mo).flags & MF_MISSILE as libc::c_int as uint32_t == 0
            && !((*mo).standingslope).is_null()
        {
            (*mo).momz = 0 as libc::c_int;
            return true_0 as libc::c_int;
        }
        P_CheckPosition(mo, (*mo).x, (*mo).y);
        if P_MobjWasRemoved(mo) != 0 {
            return false_0 as libc::c_int;
        }
        if !(if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
            tmceilingslope
        } else {
            tmfloorslope
        })
            .is_null()
            && (*mo).type_0 as libc::c_uint != MT_STEAM as libc::c_int as libc::c_uint
        {
            (*mo)
                .standingslope = if (*mo).eflags as libc::c_int
                & MFE_VERTICALFLIP as libc::c_int != 0
            {
                tmceilingslope
            } else {
                tmfloorslope
            };
            P_SetPitchRollFromSlope(mo, (*mo).standingslope);
            P_ReverseQuantizeMomentumToSlope(&mut mom, (*mo).standingslope);
        }
        if (*mo).type_0 as libc::c_uint == MT_FIREBALL as libc::c_int as libc::c_uint {
            mom
                .z = P_MobjFlip(mo) as libc::c_int
                * FixedMul(
                    5 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*mo).scale,
                );
        } else if !((*mo).type_0 as libc::c_uint
            == MT_SPINFIRE as libc::c_int as libc::c_uint)
        {
            if (*mo).flags & MF_MISSILE as libc::c_int as uint32_t != 0 {
                if (*mo).flags & MF_NOCLIP as libc::c_int as uint32_t == 0 {
                    if (*mo).flags & MF_GRENADEBOUNCE as libc::c_int as uint32_t != 0 {
                        if P_MobjFlip(mo) as libc::c_int * mom.z < 0 as libc::c_int {
                            if abs(mom.z)
                                < FixedMul(
                                    (1 as libc::c_int) << 16 as libc::c_int,
                                    (*mo).scale,
                                )
                            {
                                mom.z = 0 as libc::c_int;
                                mom.y = mom.z;
                                mom.x = mom.y;
                                if (*mo).type_0 as libc::c_uint
                                    == MT_CYBRAKDEMON_NAPALM_BOMB_LARGE as libc::c_int
                                        as libc::c_uint && (*mo).fuse != 0
                                {
                                    (*mo).fuse = 1 as libc::c_int;
                                }
                            } else {
                                mom.z = -mom.z / 2 as libc::c_int;
                            }
                            S_StartSound(
                                mo as *const libc::c_void,
                                (*(*mo).info).activesound,
                            );
                        }
                    } else {
                        if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                            == 0 && (*(*(*mo).subsector).sector).floorpic == skyflatnum
                            && (*(*(*mo).subsector).sector).floorheight == (*mo).floorz
                        {
                            P_RemoveMobj(mo);
                        } else if (*mo).eflags as libc::c_int
                            & MFE_VERTICALFLIP as libc::c_int != 0
                            && (*(*(*mo).subsector).sector).ceilingpic == skyflatnum
                            && (*(*(*mo).subsector).sector).ceilingheight
                                == (*mo).ceilingz
                        {
                            P_RemoveMobj(mo);
                        } else {
                            P_ExplodeMissile(mo);
                        }
                        return false_0 as libc::c_int;
                    }
                }
            }
        }
        if P_MobjFlip(mo) as libc::c_int * mom.z < 0 as libc::c_int {
            (*mo)
                .eflags = ((*mo).eflags as libc::c_int | MFE_JUSTHITFLOOR as libc::c_int)
                as uint16_t;
            if (*mo).flags2 & MF2_SKULLFLY as libc::c_int as uint32_t != 0 {
                mom.z = -mom.z;
            } else if (*mo).type_0 as libc::c_uint
                == MT_FLINGRING as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_FLINGCOIN as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_FLINGBLUESPHERE as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_FLINGNIGHTSCHIP as libc::c_int as libc::c_uint
                || P_WeaponOrPanel((*mo).type_0) != 0
                || (*mo).type_0 as libc::c_uint
                    == MT_FLINGEMERALD as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_BIGTUMBLEWEED as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_LITTLETUMBLEWEED as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_CANNONBALLDECOR as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_FALLINGROCK as libc::c_int as libc::c_uint
            {
                if maptol & TOL_NIGHTS as libc::c_int as uint32_t != 0 {
                    mom
                        .z = -FixedDiv(
                        mom.z,
                        10 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    );
                } else {
                    mom
                        .z = -FixedMul(
                        mom.z,
                        FixedDiv(
                            17 as libc::c_int
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                            20 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                        ),
                    );
                }
                if (*mo).type_0 as libc::c_uint
                    == MT_BIGTUMBLEWEED as libc::c_int as libc::c_uint
                    || (*mo).type_0 as libc::c_uint
                        == MT_LITTLETUMBLEWEED as libc::c_int as libc::c_uint
                {
                    if abs(mom.x)
                        < FixedMul((1 as libc::c_int) << 16 as libc::c_int, (*mo).scale)
                        && abs(mom.y)
                            < FixedMul(
                                (1 as libc::c_int) << 16 as libc::c_int,
                                (*mo).scale,
                            )
                        && abs(mom.z)
                            < FixedMul(
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    * 3 as libc::c_int,
                                (*mo).scale,
                            )
                    {
                        if (*mo).flags2 & MF2_AMBUSH as libc::c_int as uint32_t != 0 {
                            mom.z
                                += P_MobjFlip(mo) as libc::c_int
                                    * FixedMul(
                                        6 as libc::c_int
                                            * ((1 as libc::c_int) << 16 as libc::c_int),
                                        (*mo).scale,
                                    );
                            if P_RandomFixed()
                                < ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 2 as libc::c_int
                            {
                                mom.x
                                    += FixedMul(
                                        6 as libc::c_int
                                            * ((1 as libc::c_int) << 16 as libc::c_int),
                                        (*mo).scale,
                                    );
                            } else {
                                mom.x
                                    -= FixedMul(
                                        6 as libc::c_int
                                            * ((1 as libc::c_int) << 16 as libc::c_int),
                                        (*mo).scale,
                                    );
                            }
                            if P_RandomFixed()
                                < ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 2 as libc::c_int
                            {
                                mom.y
                                    += FixedMul(
                                        6 as libc::c_int
                                            * ((1 as libc::c_int) << 16 as libc::c_int),
                                        (*mo).scale,
                                    );
                            } else {
                                mom.y
                                    -= FixedMul(
                                        6 as libc::c_int
                                            * ((1 as libc::c_int) << 16 as libc::c_int),
                                        (*mo).scale,
                                    );
                            }
                        } else if !(!((*mo).standingslope).is_null()
                            && abs((*(*mo).standingslope).zdelta)
                                > (1 as libc::c_int) << 16 as libc::c_int
                                    >> 8 as libc::c_int)
                        {
                            mom.z = 0 as libc::c_int;
                            mom.y = mom.z;
                            mom.x = mom.y;
                            P_SetMobjState(mo, (*(*mo).info).spawnstate);
                        }
                    }
                    (*mo)
                        .friction = ((1 as libc::c_int) << 16 as libc::c_int)
                        - 0x100 as libc::c_int;
                } else if (*mo).type_0 as libc::c_uint
                    == MT_FALLINGROCK as libc::c_int as libc::c_uint
                {
                    if P_MobjFlip(mo) as libc::c_int * mom.z
                        > FixedMul(
                            2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                            (*mo).scale,
                        )
                    {
                        S_StartSound(
                            mo as *const libc::c_void,
                            ((*(*mo).info).activesound as libc::c_uint)
                                .wrapping_add(
                                    P_RandomKey((*(*mo).info).reactiontime) as libc::c_uint,
                                ) as sfxenum_t,
                        );
                    }
                    mom.z /= 2 as libc::c_int;
                    if abs(mom.x)
                        < FixedMul((1 as libc::c_int) << 16 as libc::c_int, (*mo).scale)
                        && abs(mom.y)
                            < FixedMul(
                                (1 as libc::c_int) << 16 as libc::c_int,
                                (*mo).scale,
                            )
                        && abs(mom.z)
                            < FixedMul(
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    * 3 as libc::c_int,
                                (*mo).scale,
                            )
                    {
                        P_RemoveMobj(mo);
                        return false_0 as libc::c_int;
                    }
                } else if (*mo).type_0 as libc::c_uint
                    == MT_CANNONBALLDECOR as libc::c_int as libc::c_uint
                {
                    mom.z /= 2 as libc::c_int;
                    if abs(mom.z)
                        < FixedMul(
                            ((1 as libc::c_int) << 16 as libc::c_int) * 3 as libc::c_int,
                            (*mo).scale,
                        )
                    {
                        mom.z = 0 as libc::c_int;
                    }
                }
            } else {
                mom
                    .z = if !tmfloorthing.is_null() {
                    (*tmfloorthing).momz
                } else {
                    0 as libc::c_int
                };
            }
        } else if !tmfloorthing.is_null() {
            mom.z = (*tmfloorthing).momz;
        }
        if !((*mo).standingslope).is_null() {
            P_QuantizeMomentumToSlope(&mut mom, (*mo).standingslope);
        }
        (*mo).momx = mom.x;
        (*mo).momy = mom.y;
        (*mo).momz = mom.z;
        if (*mo).type_0 as libc::c_uint == MT_STEAM as libc::c_int as libc::c_uint {
            return true_0 as libc::c_int;
        }
    } else if (*mo).flags & MF_NOGRAVITY as libc::c_int as uint32_t == 0 {
        (*mo)
            .eflags = ((*mo).eflags as libc::c_int & !(MFE_JUSTHITFLOOR as libc::c_int))
            as uint16_t;
        P_CheckGravity(mo, true_0 as libc::c_int);
    }
    if ((*mo).z + (*mo).height > (*mo).ceilingz
        && (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
        || (*mo).z < (*mo).floorz
            && (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0)
        && (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0
    {
        if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
            (*mo).z = (*mo).floorz;
        } else {
            (*mo).z = (*mo).ceilingz - (*mo).height;
        }
        if !((*mo).type_0 as libc::c_uint == MT_SPINFIRE as libc::c_int as libc::c_uint)
        {
            if (*mo).flags & MF_MISSILE as libc::c_int as uint32_t != 0
                && (*mo).flags & MF_NOCLIP as libc::c_int as uint32_t == 0
            {
                if (*mo).flags & MF_GRENADEBOUNCE as libc::c_int as uint32_t != 0 {
                    if P_MobjFlip(mo) as libc::c_int * (*mo).momz >= 0 as libc::c_int {
                        (*mo).momz = -(*mo).momz;
                        S_StartSound(
                            mo as *const libc::c_void,
                            (*(*mo).info).activesound,
                        );
                    }
                } else {
                    if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                        && (*(*(*mo).subsector).sector).ceilingpic == skyflatnum
                        && (*(*(*mo).subsector).sector).ceilingheight == (*mo).ceilingz
                    {
                        P_RemoveMobj(mo);
                    } else if (*mo).eflags as libc::c_int
                        & MFE_VERTICALFLIP as libc::c_int != 0
                        && (*(*(*mo).subsector).sector).floorpic == skyflatnum
                        && (*(*(*mo).subsector).sector).floorheight == (*mo).floorz
                    {
                        P_RemoveMobj(mo);
                    } else {
                        P_ExplodeMissile(mo);
                    }
                    return false_0 as libc::c_int;
                }
            }
        }
        if P_MobjFlip(mo) as libc::c_int * (*mo).momz > 0 as libc::c_int {
            if (*mo).flags2 & MF2_SKULLFLY as libc::c_int as uint32_t != 0 {
                (*mo).momz = -(*mo).momz;
            } else if (*mo).type_0 as libc::c_uint
                == MT_REDFLAG as libc::c_int as libc::c_uint
                || (*mo).type_0 as libc::c_uint
                    == MT_BLUEFLAG as libc::c_int as libc::c_uint
            {
                if maptol & TOL_NIGHTS as libc::c_int as uint32_t != 0 {
                    (*mo)
                        .momz = -FixedDiv(
                        (*mo).momz,
                        10 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    );
                } else {
                    (*mo)
                        .momz = -FixedMul(
                        (*mo).momz,
                        FixedDiv(
                            17 as libc::c_int
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                            20 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                        ),
                    );
                }
            } else {
                (*mo).momz = 0 as libc::c_int;
            }
        }
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_CheckMarioBlocks(mut mo: *mut mobj_t) {
    let mut node: *mut msecnode_t = 0 as *mut msecnode_t;
    if netgame != 0 && (*(*mo).player).spectator != 0 {
        return;
    }
    node = (*mo).touching_sectorlist;
    while !node.is_null() {
        let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
        if !((*(*node).m_sector).ffloors).is_null() {
            rover = (*(*node).m_sector).ffloors;
            while !rover.is_null() {
                if !((*rover).fofflags as libc::c_uint
                    & FOF_EXISTS as libc::c_int as libc::c_uint == 0)
                {
                    if !((*rover).fofflags as libc::c_uint
                        & FOF_MARIO as libc::c_int as libc::c_uint == 0)
                    {
                        if !((*mo).eflags as libc::c_int
                            & MFE_VERTICALFLIP as libc::c_int != 0)
                        {
                            if !(*(*rover).bottomheight != (*mo).ceilingz) {
                                if (*rover).fofflags as libc::c_uint
                                    & FOF_GOOWATER as libc::c_int as libc::c_uint != 0
                                {
                                    EV_CrumbleChain((*node).m_sector, rover);
                                } else {
                                    EV_MarioBlock(rover, (*node).m_sector, mo);
                                }
                            }
                        }
                    }
                }
                rover = (*rover).next;
            }
        }
        node = (*node).m_sectorlist_next;
    }
}
unsafe extern "C" fn P_PlayerPolyObjectZMovement(mut mo: *mut mobj_t) -> boolean {
    let mut node: *mut msecnode_t = 0 as *mut msecnode_t;
    let mut stopmovecut: boolean = false_0 as libc::c_int;
    node = (*mo).touching_sectorlist;
    while !node.is_null() {
        let mut sec: *mut sector_t = (*node).m_sector;
        let mut newsubsec: *mut subsector_t = 0 as *mut subsector_t;
        let mut i: size_t = 0;
        i = 0 as libc::c_int as size_t;
        while i < numsubsectors {
            let mut po: *mut polyobj_t = 0 as *mut polyobj_t;
            let mut polysec: *mut sector_t = 0 as *mut sector_t;
            newsubsec = &mut *subsectors.offset(i as isize) as *mut subsector_t;
            if !((*newsubsec).sector != sec) {
                po = (*newsubsec).polyList;
                while !po.is_null() {
                    if !((*po).flags & POF_SOLID as libc::c_int == 0) {
                        if !(P_MobjInsidePolyobj(po, mo) == 0) {
                            polysec = (**((*po).lines).offset(0 as libc::c_int as isize))
                                .backsector;
                            if ((*mo).z == (*polysec).ceilingheight
                                || (*mo).z + (*mo).height == (*polysec).floorheight)
                                && !((*po).thinker).is_null()
                            {
                                stopmovecut = true_0 as libc::c_int;
                            }
                            if !((*po).flags & POF_LDEXEC as libc::c_int == 0) {
                                if !((*mo).z != (*polysec).ceilingheight) {
                                    P_LinedefExecute((*po).triggertag, mo, 0 as *mut sector_t);
                                }
                            }
                        }
                    }
                    po = (*po).link.next as *mut polyobj_t;
                }
            }
            i = i.wrapping_add(1);
            i;
        }
        node = (*node).m_sectorlist_next;
    }
    return stopmovecut;
}
#[no_mangle]
pub unsafe extern "C" fn P_PlayerZMovement(mut mo: *mut mobj_t) {
    let mut onground: boolean = 0;
    if ((*mo).player).is_null() {
        return;
    }
    if !((*(*(*mo).subsector).sector).ffloors).is_null() {
        P_AdjustMobjFloorZ_FFloors(
            mo,
            (*(*mo).subsector).sector,
            0 as libc::c_int as uint8_t,
        );
    }
    if !((*(*mo).subsector).polyList).is_null() {
        P_AdjustMobjFloorZ_PolyObjs(mo, (*mo).subsector);
    }
    if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
        && (*mo).z + (*mo).height > (*mo).ceilingz
        || (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
            && (*mo).z < (*mo).floorz
    {
        if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
            (*(*mo).player).viewheight -= (*mo).z + (*mo).height - (*mo).ceilingz;
        } else {
            (*(*mo).player).viewheight -= (*mo).floorz - (*mo).z;
        }
        (*(*mo).player)
            .deltaviewheight = FixedMul(
            41 as libc::c_int * (*(*mo).player).height / 48 as libc::c_int,
            (*mo).scale,
        ) - (*(*mo).player).viewheight >> 3 as libc::c_int;
    }
    if (*mo).eflags as libc::c_int & MFE_APPLYPMOMZ as libc::c_int != 0
        && P_IsObjectOnGround(mo) == 0
    {
        (*mo).momz += (*mo).pmomz;
        (*mo).pmomz = 0 as libc::c_int;
        (*mo)
            .eflags = ((*mo).eflags as libc::c_int & !(MFE_APPLYPMOMZ as libc::c_int))
            as uint16_t;
    }
    (*mo).z += (*mo).momz;
    onground = P_IsObjectOnGround(mo);
    if (*(*mo).player).playerstate as libc::c_uint
        == PST_DEAD as libc::c_int as libc::c_uint
        || (*(*mo).player).playerstate as libc::c_uint
            == PST_REBORN as libc::c_int as libc::c_uint
    {
        return;
    }
    if !((*mo).standingslope).is_null() {
        if (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t != 0 {
            (*mo).standingslope = 0 as *mut pslope_s;
        } else if onground == 0 {
            P_SlopeLaunch(mo);
        }
    }
    if onground != 0 && (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0 {
        if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
            (*mo).z = (*mo).ceilingz - (*mo).height;
        } else {
            (*mo).z = (*mo).floorz;
        }
        if (*(*mo).player).powers[pw_carry as libc::c_int as usize] as libc::c_int
            == CR_NIGHTSMODE as libc::c_int
        {
            if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                && (*(*mo).player).flyangle > 0 as libc::c_int
                && (*(*mo).player).flyangle < 180 as libc::c_int
                || (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                    && (*(*mo).player).flyangle > 180 as libc::c_int
                    && (*(*mo).player).flyangle <= 359 as libc::c_int
            {
                if (*(*mo).player).flyangle < 90 as libc::c_int
                    || (*(*mo).player).flyangle >= 270 as libc::c_int
                {
                    (*(*mo).player).flyangle
                        += P_MobjFlip(mo) as libc::c_int * 90 as libc::c_int;
                } else {
                    (*(*mo).player).flyangle
                        -= P_MobjFlip(mo) as libc::c_int * 90 as libc::c_int;
                }
                (*(*mo).player)
                    .speed = FixedMul(
                    (*(*mo).player).speed,
                    4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                        / 5 as libc::c_int,
                );
            }
        } else {
            if (*(*mo).player).panim as libc::c_uint
                == PA_PAIN as libc::c_int as libc::c_uint
            {
                P_SetPlayerMobjState(mo, S_PLAY_WALK);
            }
            if ((*mo).standingslope).is_null()
                && !(if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                    != 0
                {
                    tmceilingslope
                } else {
                    tmfloorslope
                })
                    .is_null()
            {
                P_HandleSlopeLanding(
                    mo,
                    if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                    {
                        tmceilingslope
                    } else {
                        tmfloorslope
                    },
                );
            }
            if P_MobjFlip(mo) as libc::c_int * (*mo).momz < 0 as libc::c_int {
                let mut clipmomz: boolean = (P_CheckDeathPitCollide(mo) == 0)
                    as libc::c_int;
                (*mo).pmomz = 0 as libc::c_int;
                if P_MobjFlip(mo) as libc::c_int * (*mo).momz
                    < -FixedMul(
                        8 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*mo).scale,
                    )
                {
                    (*(*mo).player)
                        .deltaviewheight = P_MobjFlip(mo) as libc::c_int * (*mo).momz
                        >> 3 as libc::c_int;
                }
                (*mo)
                    .eflags = ((*mo).eflags as libc::c_int
                    | MFE_JUSTHITFLOOR as libc::c_int) as uint16_t;
                clipmomz = P_PlayerHitFloor((*mo).player, true_0 as libc::c_int);
                if P_PlayerPolyObjectZMovement(mo) == 0 {
                    if !((*(*mo).player).cmd.forwardmove as libc::c_int != 0
                        || (*(*mo).player).cmd.sidemove as libc::c_int != 0)
                        && (*(*mo).player).cmomx == 0 && (*(*mo).player).cmomy == 0
                        && (*(*mo).player).pflags as libc::c_uint
                            & PF_SPINNING as libc::c_int as libc::c_uint == 0
                    {
                        (*mo).momx >>= 1 as libc::c_int;
                        (*mo).momy >>= 1 as libc::c_int;
                    }
                }
                if (*(*mo).player).pflags as libc::c_uint
                    & PF_SPINNING as libc::c_int as libc::c_uint == 0
                    && (*(*mo).player).powers[pw_carry as libc::c_int as usize]
                        as libc::c_int != CR_NIGHTSMODE as libc::c_int
                {
                    (*(*mo).player)
                        .pflags = ::core::mem::transmute::<
                        libc::c_uint,
                        pflags_t,
                    >(
                        (*(*mo).player).pflags as libc::c_uint
                            & !(PF_STARTDASH as libc::c_int) as libc::c_uint,
                    );
                }
                if clipmomz != 0 {
                    (*mo)
                        .momz = if !tmfloorthing.is_null() {
                        (*tmfloorthing).momz
                    } else {
                        0 as libc::c_int
                    };
                }
            } else if !tmfloorthing.is_null() {
                (*mo).momz = (*tmfloorthing).momz;
            }
        }
    } else if (*mo).flags & MF_NOGRAVITY as libc::c_int as uint32_t == 0 {
        if P_IsObjectInGoop(mo) != 0
            && (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0
        {
            if (*mo).z < (*mo).floorz {
                (*mo).z = (*mo).floorz;
                (*mo).momz = 0 as libc::c_int;
            } else if (*mo).z + (*mo).height > (*mo).ceilingz {
                (*mo).z = (*mo).ceilingz - (*mo).height;
                (*mo).momz = 0 as libc::c_int;
            }
        }
        (*mo)
            .eflags = ((*mo).eflags as libc::c_int & !(MFE_JUSTHITFLOOR as libc::c_int))
            as uint16_t;
        P_CheckGravity(mo, true_0 as libc::c_int);
    }
    if ((*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
        && (*mo).z < (*mo).floorz
        || (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
            && (*mo).z + (*mo).height > (*mo).ceilingz)
        && (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0
    {
        if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
            (*mo).z = (*mo).floorz;
        } else {
            (*mo).z = (*mo).ceilingz - (*mo).height;
        }
        if (*(*mo).player).powers[pw_carry as libc::c_int as usize] as libc::c_int
            == CR_NIGHTSMODE as libc::c_int
        {
            if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                && (*(*mo).player).flyangle > 180 as libc::c_int
                && (*(*mo).player).flyangle <= 359 as libc::c_int
                || (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                    && (*(*mo).player).flyangle > 0 as libc::c_int
                    && (*(*mo).player).flyangle < 180 as libc::c_int
            {
                if (*(*mo).player).flyangle < 90 as libc::c_int
                    || (*(*mo).player).flyangle >= 270 as libc::c_int
                {
                    (*(*mo).player).flyangle
                        -= P_MobjFlip(mo) as libc::c_int * 90 as libc::c_int;
                } else {
                    (*(*mo).player).flyangle
                        += P_MobjFlip(mo) as libc::c_int * 90 as libc::c_int;
                }
                (*(*mo).player).flyangle %= 360 as libc::c_int;
                (*(*mo).player)
                    .speed = FixedMul(
                    (*(*mo).player).speed,
                    4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                        / 5 as libc::c_int,
                );
            }
        }
        if P_MobjFlip(mo) as libc::c_int * (*mo).momz > 0 as libc::c_int {
            if CheckForMarioBlocks != 0 {
                P_CheckMarioBlocks(mo);
            }
            if maptol & TOL_MARIO as libc::c_int as uint32_t != 0 {
                S_StartSound(mo as *const libc::c_void, sfx_mario1);
            }
            if (*(*mo).player).climbing == 0 {
                (*mo).momz = 0 as libc::c_int;
            }
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_SceneryZMovement(mut mo: *mut mobj_t) -> boolean {
    if !((*(*(*mo).subsector).sector).ffloors).is_null() {
        P_AdjustMobjFloorZ_FFloors(
            mo,
            (*(*mo).subsector).sector,
            2 as libc::c_int as uint8_t,
        );
    }
    if !((*(*mo).subsector).polyList).is_null() {
        P_AdjustMobjFloorZ_PolyObjs(mo, (*mo).subsector);
    }
    if (*mo).eflags as libc::c_int & MFE_APPLYPMOMZ as libc::c_int != 0
        && P_IsObjectOnGround(mo) == 0
    {
        (*mo).momz += (*mo).pmomz;
        (*mo).pmomz = 0 as libc::c_int;
        (*mo)
            .eflags = ((*mo).eflags as libc::c_int & !(MFE_APPLYPMOMZ as libc::c_int))
            as uint16_t;
    }
    (*mo).z += (*mo).momz;
    match (*mo).type_0 as libc::c_uint {
        511 => {
            if (*mo).z <= (*mo).floorz || (*mo).z + (*mo).height >= (*mo).ceilingz {
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
        }
        512 => {
            if P_CheckDeathPitCollide(mo) != 0 {
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
            if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                && (*mo).z <= (*mo).floorz
                || (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                    && (*mo).z + (*mo).height >= (*mo).ceilingz
            {
                let mut explodemo: *mut mobj_t = 0 as *mut mobj_t;
                let mut prandom: uint8_t = 0;
                let mut i: uint8_t = 0;
                i = 0 as libc::c_int as uint8_t;
                while (i as libc::c_int) < 4 as libc::c_int {
                    prandom = P_RandomByte();
                    explodemo = P_SpawnMobj((*mo).x, (*mo).y, (*mo).z, MT_SMALLBUBBLE);
                    (*explodemo).momx
                        += ((prandom as libc::c_int & 0xf as libc::c_int)
                            << 16 as libc::c_int - 2 as libc::c_int)
                            * (if i as libc::c_int & 2 as libc::c_int != 0 {
                                -(1 as libc::c_int)
                            } else {
                                1 as libc::c_int
                            });
                    (*explodemo).momy
                        += ((prandom as libc::c_int & 0xf0 as libc::c_int)
                            << 16 as libc::c_int - 6 as libc::c_int)
                            * (if i as libc::c_int & 1 as libc::c_int != 0 {
                                -(1 as libc::c_int)
                            } else {
                                1 as libc::c_int
                            });
                    (*explodemo).destscale = (*mo).scale;
                    P_SetScale(explodemo, (*mo).scale);
                    i = i.wrapping_add(1);
                    i;
                }
                if (*mo).threshold != 42 as libc::c_int {
                    S_StartSound(
                        explodemo as *const libc::c_void,
                        (sfx_bubbl1 as libc::c_int + P_RandomKey(5 as libc::c_int))
                            as sfxenum_t,
                    );
                }
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            } else if (*mo).z <= (*mo).floorz || (*mo).z + (*mo).height >= (*mo).ceilingz
            {
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
        }
        505 => {
            if P_CheckDeathPitCollide(mo) != 0 {
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
            if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                && (*mo).z <= (*mo).floorz
                || (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                    && (*mo).z + (*mo).height >= (*mo).ceilingz
            {
                let mut flowertype: mobjtype_t = (if P_RandomFixed()
                    < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
                {
                    MT_GFZFLOWER1 as libc::c_int
                } else {
                    MT_GFZFLOWER3 as libc::c_int
                }) as mobjtype_t;
                let mut flower: *mut mobj_t = P_SpawnMobjFromMobj(
                    mo,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    flowertype,
                );
                if !flower.is_null() {
                    P_SetScale(flower, (*mo).scale / 16 as libc::c_int);
                    (*flower).destscale = (*mo).scale;
                    (*flower).scalespeed = (*mo).scale / 8 as libc::c_int;
                }
                P_RemoveMobj(mo);
                return false_0 as libc::c_int;
            }
        }
        _ => {}
    }
    if P_CheckDeathPitCollide(mo) != 0 {
        if (*mo).type_0 as libc::c_uint != MT_GHOST as libc::c_int as libc::c_uint {
            P_RemoveMobj(mo);
        }
        return false_0 as libc::c_int;
    }
    if ((*mo).z <= (*mo).floorz
        && (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
        || (*mo).z + (*mo).height >= (*mo).ceilingz
            && (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0)
        && (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0
    {
        if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
            (*mo).z = (*mo).ceilingz - (*mo).height;
        } else {
            (*mo).z = (*mo).floorz;
        }
        if P_MobjFlip(mo) as libc::c_int * (*mo).momz < 0 as libc::c_int {
            (*mo)
                .eflags = ((*mo).eflags as libc::c_int | MFE_JUSTHITFLOOR as libc::c_int)
                as uint16_t;
            if !tmfloorthing.is_null() {
                (*mo).momz = (*tmfloorthing).momz;
            } else if tmfloorthing.is_null() {
                (*mo).momz = 0 as libc::c_int;
            }
        }
    } else if (*mo).flags & MF_NOGRAVITY as libc::c_int as uint32_t == 0 {
        (*mo)
            .eflags = ((*mo).eflags as libc::c_int & !(MFE_JUSTHITFLOOR as libc::c_int))
            as uint16_t;
        P_CheckGravity(mo, true_0 as libc::c_int);
    }
    if ((*mo).z + (*mo).height > (*mo).ceilingz
        && (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
        || (*mo).z < (*mo).floorz
            && (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0)
        && (*mo).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0
    {
        if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
            (*mo).z = (*mo).floorz;
        } else {
            (*mo).z = (*mo).ceilingz - (*mo).height;
        }
        if P_MobjFlip(mo) as libc::c_int * (*mo).momz > 0 as libc::c_int {
            (*mo).momz = 0 as libc::c_int;
        }
    }
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_CanRunOnWater(
    mut player: *mut player_t,
    mut rover: *mut ffloor_t,
) -> boolean {
    let mut flip: boolean = (*(*player).mo).eflags as libc::c_int
        & MFE_VERTICALFLIP as libc::c_int;
    let mut surfaceheight: fixed_t = if flip != 0 {
        P_GetFFloorBottomZAt(rover, (*(*player).mo).x, (*(*player).mo).y)
    } else {
        P_GetFFloorTopZAt(rover, (*(*player).mo).x, (*(*player).mo).y)
    };
    let mut playerbottom: fixed_t = if flip != 0 {
        (*(*player).mo).z + (*(*player).mo).height
    } else {
        (*(*player).mo).z
    };
    let mut doifit: boolean = if flip != 0 {
        (surfaceheight - (*(*player).mo).floorz >= (*(*player).mo).height) as libc::c_int
    } else {
        ((*(*player).mo).ceilingz - surfaceheight >= (*(*player).mo).height)
            as libc::c_int
    };
    if (*player).powers[pw_carry as libc::c_int as usize] == 0 && (*player).homing == 0
        && (((*player).powers[pw_super as libc::c_int as usize] as libc::c_int != 0
            || (*player).charflags & SF_RUNONWATER as libc::c_int as uint32_t != 0
            || (*player).dashmode >= (3 as libc::c_int * 35 as libc::c_int) as tic_t)
            && doifit != 0)
        && (*rover).fofflags as libc::c_uint
            & FOF_SWIMMABLE as libc::c_int as libc::c_uint != 0
        && (*player).pflags as libc::c_uint & PF_SPINNING as libc::c_int as libc::c_uint
            == 0 && (*player).speed > FixedMul((*player).runspeed, (*(*player).mo).scale)
        && (*player).pflags as libc::c_uint & PF_SLIDING as libc::c_int as libc::c_uint
            == 0
        && abs(playerbottom - surfaceheight)
            < FixedMul(
                30 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*(*player).mo).scale,
            )
    {
        return true_0 as libc::c_int;
    }
    return false_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_MobjCheckWater(mut mobj: *mut mobj_t) {
    let mut waterwasnotset: boolean = ((*mobj).watertop == 2147483647 as libc::c_int)
        as libc::c_int;
    let mut wasinwater: boolean = ((*mobj).eflags as libc::c_int
        & MFE_UNDERWATER as libc::c_int == MFE_UNDERWATER as libc::c_int) as libc::c_int;
    let mut wasingoo: boolean = ((*mobj).eflags as libc::c_int
        & MFE_GOOWATER as libc::c_int == MFE_GOOWATER as libc::c_int) as libc::c_int;
    let mut thingtop: fixed_t = (*mobj).z + (*mobj).height;
    let mut sector: *mut sector_t = (*(*mobj).subsector).sector;
    let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
    let mut p: *mut player_t = (*mobj).player;
    let mut height: fixed_t = if !p.is_null() {
        FixedMul((*p).height, (*(*p).mo).scale)
    } else {
        (*mobj).height
    };
    let mut wasgroundpounding: boolean = (!p.is_null()
        && ((*p).powers[pw_shield as libc::c_int as usize] as libc::c_int
            & SH_NOSTACK as libc::c_int == SH_ELEMENTAL as libc::c_int
            || (*p).powers[pw_shield as libc::c_int as usize] as libc::c_int
                & SH_NOSTACK as libc::c_int == SH_BUBBLEWRAP as libc::c_int)
        && (*p).pflags as libc::c_uint & PF_SHIELDABILITY as libc::c_int as libc::c_uint
            != 0) as libc::c_int;
    (*mobj)
        .waterbottom = (*mobj).z
        - 1000 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
    (*mobj).watertop = (*mobj).waterbottom;
    (*mobj)
        .eflags = ((*mobj).eflags as libc::c_int
        & !(MFE_UNDERWATER as libc::c_int | MFE_TOUCHWATER as libc::c_int
            | MFE_GOOWATER as libc::c_int | MFE_TOUCHLAVA as libc::c_int)) as uint16_t;
    let mut current_block_16: u64;
    rover = (*sector).ffloors;
    while !rover.is_null() {
        let mut topheight: fixed_t = 0;
        let mut bottomheight: fixed_t = 0;
        if !((*rover).fofflags as libc::c_uint
            & FOF_EXISTS as libc::c_int as libc::c_uint == 0
            || (*rover).fofflags as libc::c_uint
                & FOF_SWIMMABLE as libc::c_int as libc::c_uint == 0
            || ((*rover).fofflags as libc::c_uint
                & FOF_BLOCKPLAYER as libc::c_int as libc::c_uint != 0
                && !((*mobj).player).is_null()
                || (*rover).fofflags as libc::c_uint
                    & FOF_BLOCKOTHERS as libc::c_int as libc::c_uint != 0
                    && ((*mobj).player).is_null()))
        {
            topheight = P_MobjCeilingZ(
                mobj,
                sectors.offset((*rover).secnum as isize),
                sector,
                (*mobj).x,
                (*mobj).y,
                0 as *mut line_t,
                (sectors.offset((*rover).secnum as isize) == sector) as libc::c_int,
                true_0 as libc::c_int,
            );
            bottomheight = P_MobjFloorZ(
                mobj,
                sectors.offset((*rover).secnum as isize),
                sector,
                (*mobj).x,
                (*mobj).y,
                0 as *mut line_t,
                (sectors.offset((*rover).secnum as isize) != sector) as libc::c_int,
                true_0 as libc::c_int,
            );
            if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
                if topheight < thingtop - (height >> 1 as libc::c_int)
                    || bottomheight > thingtop
                {
                    current_block_16 = 15240798224410183470;
                } else {
                    current_block_16 = 13586036798005543211;
                }
            } else if topheight < (*mobj).z
                || bottomheight > (*mobj).z + (height >> 1 as libc::c_int)
            {
                current_block_16 = 15240798224410183470;
            } else {
                current_block_16 = 13586036798005543211;
            }
            match current_block_16 {
                15240798224410183470 => {}
                _ => {
                    (*mobj).watertop = topheight;
                    (*mobj).waterbottom = bottomheight;
                    if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                        != 0 && thingtop - height < bottomheight
                        || (*mobj).eflags as libc::c_int
                            & MFE_VERTICALFLIP as libc::c_int == 0
                            && (*mobj).z + height > topheight
                    {
                        (*mobj)
                            .eflags = ((*mobj).eflags as libc::c_int
                            | MFE_TOUCHWATER as libc::c_int) as uint16_t;
                    }
                    if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                        != 0 && thingtop - (height >> 1 as libc::c_int) > bottomheight
                        || (*mobj).eflags as libc::c_int
                            & MFE_VERTICALFLIP as libc::c_int == 0
                            && (*mobj).z + (height >> 1 as libc::c_int) < topheight
                    {
                        (*mobj)
                            .eflags = ((*mobj).eflags as libc::c_int
                            | MFE_UNDERWATER as libc::c_int) as uint16_t;
                    }
                    if (*mobj).eflags as libc::c_int
                        & (MFE_TOUCHWATER as libc::c_int | MFE_UNDERWATER as libc::c_int)
                        != 0
                    {
                        if (*(*(*rover).master).frontsector).damagetype as libc::c_int
                            == SD_FIRE as libc::c_int
                            || (*(*(*rover).master).frontsector).damagetype
                                as libc::c_int == SD_LAVA as libc::c_int
                        {
                            (*mobj)
                                .eflags = ((*mobj).eflags as libc::c_int
                                | MFE_TOUCHLAVA as libc::c_int) as uint16_t;
                        }
                        if (*rover).fofflags as libc::c_uint
                            & FOF_GOOWATER as libc::c_int as libc::c_uint != 0
                            && (*mobj).flags & MF_NOGRAVITY as libc::c_int as uint32_t
                                == 0
                        {
                            (*mobj)
                                .eflags = ((*mobj).eflags as libc::c_int
                                | MFE_GOOWATER as libc::c_int) as uint16_t;
                        }
                    }
                }
            }
        }
        rover = (*rover).next;
    }
    if !p.is_null()
        && ((*p).spectator != 0
            || (*p).playerstate as libc::c_uint
                != PST_LIVE as libc::c_int as libc::c_uint)
    {
        return;
    }
    if !p.is_null()
        && (*mobj).eflags as libc::c_int & MFE_UNDERWATER as libc::c_int
            == MFE_UNDERWATER as libc::c_int
    {
        if !((*p).powers[pw_super as libc::c_int as usize] as libc::c_int != 0
            || (*p).powers[pw_invulnerability as libc::c_int as usize] as libc::c_int
                != 0)
        {
            let mut electric: boolean = ((*p).powers[pw_shield as libc::c_int as usize]
                as libc::c_int & SH_PROTECTELECTRIC as libc::c_int != 0) as libc::c_int;
            if electric != 0
                || (*p).powers[pw_shield as libc::c_int as usize] as libc::c_int
                    & SH_PROTECTFIRE as libc::c_int != 0
                    && (*p).powers[pw_shield as libc::c_int as usize] as libc::c_int
                        & SH_PROTECTWATER as libc::c_int == 0
                    && (*mobj).eflags as libc::c_int & MFE_TOUCHLAVA as libc::c_int == 0
            {
                if electric != 0 {
                    P_FlashPal(
                        p,
                        1 as libc::c_int as uint16_t,
                        1 as libc::c_int as uint16_t,
                    );
                }
                (*p)
                    .powers[pw_shield as libc::c_int
                    as usize] = ((*p).powers[pw_shield as libc::c_int as usize]
                    as libc::c_int & SH_STACK as libc::c_int) as uint16_t;
            }
        }
        if (*p).powers[pw_shield as libc::c_int as usize] as libc::c_int
            & SH_PROTECTWATER as libc::c_int != 0 || (*p).exiting != 0
            || (*p).pflags as libc::c_uint & PF_FINISHED as libc::c_int as libc::c_uint
                != 0 || maptol & TOL_NIGHTS as libc::c_int as uint32_t != 0
            || maptol & TOL_MARIO as libc::c_int as uint32_t != 0
        {
            (*p)
                .powers[pw_underwater as libc::c_int
                as usize] = 0 as libc::c_int as uint16_t;
        } else if (*p).powers[pw_underwater as libc::c_int as usize] as libc::c_int
            <= 0 as libc::c_int
        {
            (*p)
                .powers[pw_underwater as libc::c_int
                as usize] = (underwatertics as libc::c_int + 1 as libc::c_int)
                as uint16_t;
        }
        wasgroundpounding = ((*mobj).eflags as libc::c_int & MFE_GOOWATER as libc::c_int
            != 0 && wasgroundpounding != 0) as libc::c_int;
        if wasgroundpounding != 0 {
            (*p)
                .pflags = ::core::mem::transmute::<
                libc::c_uint,
                pflags_t,
            >(
                (*p).pflags as libc::c_uint
                    & !(PF_SHIELDABILITY as libc::c_int) as libc::c_uint,
            );
            (*mobj).momz >>= 1 as libc::c_int;
        }
    }
    if waterwasnotset != 0
        || ((*mobj).eflags as libc::c_int & MFE_UNDERWATER as libc::c_int != 0)
            as libc::c_int == wasinwater
    {
        return;
    }
    if !p.is_null() || (*mobj).flags & MF_PUSHABLE as libc::c_int as uint32_t != 0
        || (*(*mobj).info).flags & MF_PUSHABLE as libc::c_int as uint32_t != 0
            && (*mobj).fuse != 0
    {
        if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
            && (*mobj).watertop - (*mobj).floorz <= height >> 1 as libc::c_int
            || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                && (*mobj).ceilingz - (*mobj).waterbottom <= height >> 1 as libc::c_int
        {
            return;
        }
        if (*mobj).eflags as libc::c_int & MFE_GOOWATER as libc::c_int != 0
            || wasingoo != 0
        {
            if P_MobjFlip(mobj) as libc::c_int * (*mobj).momz > 0 as libc::c_int {
                (*mobj).momz -= (*mobj).momz / 8 as libc::c_int;
            } else if wasgroundpounding == 0 {
                (*mobj).momz >>= 1 as libc::c_int;
            }
        } else if wasinwater != 0
            && P_MobjFlip(mobj) as libc::c_int * (*mobj).momz > 0 as libc::c_int
        {
            (*mobj)
                .momz = FixedMul(
                (*mobj).momz,
                FixedDiv(
                    780 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    457 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                ),
            );
        }
        if P_MobjFlip(mobj) as libc::c_int * (*mobj).momz < 0 as libc::c_int {
            if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                && thingtop - (height >> 1 as libc::c_int) - (*mobj).momz
                    <= (*mobj).waterbottom
                || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                    && (*mobj).z + (height >> 1 as libc::c_int) - (*mobj).momz
                        >= (*mobj).watertop
            {
                let mut splish: *mut mobj_t = 0 as *mut mobj_t;
                let mut splishtype: mobjtype_t = (if (*mobj).eflags as libc::c_int
                    & MFE_TOUCHLAVA as libc::c_int != 0
                {
                    MT_LAVASPLISH as libc::c_int
                } else {
                    MT_SPLISH as libc::c_int
                }) as mobjtype_t;
                if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
                    splish = P_SpawnMobj(
                        (*mobj).x,
                        (*mobj).y,
                        (*mobj).waterbottom
                            - FixedMul(
                                mobjinfo[splishtype as usize].height,
                                (*mobj).scale,
                            ),
                        splishtype,
                    );
                    (*splish).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
                    (*splish)
                        .eflags = ((*splish).eflags as libc::c_int
                        | MFE_VERTICALFLIP as libc::c_int) as uint16_t;
                } else {
                    splish = P_SpawnMobj(
                        (*mobj).x,
                        (*mobj).y,
                        (*mobj).watertop,
                        splishtype,
                    );
                }
                (*splish).destscale = (*mobj).scale;
                P_SetScale(splish, (*mobj).scale);
            }
            if !p.is_null() && (*p).speed / 2 as libc::c_int > abs((*mobj).momz)
                && (*p).pflags as libc::c_uint
                    & (PF_SPINNING as libc::c_int | PF_JUMPED as libc::c_int)
                        as libc::c_uint == PF_SPINNING as libc::c_int as libc::c_uint
                && ((*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                    && thingtop - (*mobj).momz > (*mobj).watertop
                    || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                        != 0 && (*mobj).z - (*mobj).momz < (*mobj).waterbottom)
            {
                (*mobj).momz = -(*mobj).momz / 2 as libc::c_int;
                if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                    && (*mobj).momz
                        > FixedMul(
                            6 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                            (*mobj).scale,
                        )
                {
                    (*mobj)
                        .momz = FixedMul(
                        6 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*mobj).scale,
                    );
                } else if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                    != 0
                    && (*mobj).momz
                        < FixedMul(
                            -(6 as libc::c_int)
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                            (*mobj).scale,
                        )
                {
                    (*mobj)
                        .momz = FixedMul(
                        -(6 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*mobj).scale,
                    );
                }
            }
        } else if P_MobjFlip(mobj) as libc::c_int * (*mobj).momz > 0 as libc::c_int {
            if ((*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                && thingtop - (height >> 1 as libc::c_int) - (*mobj).momz
                    > (*mobj).waterbottom
                || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                    && (*mobj).z + (height >> 1 as libc::c_int) - (*mobj).momz
                        < (*mobj).watertop)
                && (*mobj).eflags as libc::c_int & MFE_UNDERWATER as libc::c_int == 0
            {
                let mut splish_0: *mut mobj_t = 0 as *mut mobj_t;
                let mut splishtype_0: mobjtype_t = (if (*mobj).eflags as libc::c_int
                    & MFE_TOUCHLAVA as libc::c_int != 0
                {
                    MT_LAVASPLISH as libc::c_int
                } else {
                    MT_SPLISH as libc::c_int
                }) as mobjtype_t;
                if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
                    splish_0 = P_SpawnMobj(
                        (*mobj).x,
                        (*mobj).y,
                        (*mobj).waterbottom
                            - FixedMul(
                                mobjinfo[splishtype_0 as usize].height,
                                (*mobj).scale,
                            ),
                        splishtype_0,
                    );
                    (*splish_0).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
                    (*splish_0)
                        .eflags = ((*splish_0).eflags as libc::c_int
                        | MFE_VERTICALFLIP as libc::c_int) as uint16_t;
                } else {
                    splish_0 = P_SpawnMobj(
                        (*mobj).x,
                        (*mobj).y,
                        (*mobj).watertop,
                        splishtype_0,
                    );
                }
                (*splish_0).destscale = (*mobj).scale;
                P_SetScale(splish_0, (*mobj).scale);
            }
        }
        let mut i: int32_t = 0;
        let mut bubblecount: int32_t = 0;
        let mut prandom: [uint8_t; 4] = [0; 4];
        let mut bubble: *mut mobj_t = 0 as *mut mobj_t;
        let mut bubbletype: mobjtype_t = MT_NULL;
        if (*mobj).eflags as libc::c_int & MFE_GOOWATER as libc::c_int != 0
            || wasingoo != 0
        {
            S_StartSound(mobj as *const libc::c_void, sfx_ghit);
        } else if (*mobj).eflags as libc::c_int & MFE_TOUCHLAVA as libc::c_int != 0 {
            S_StartSound(mobj as *const libc::c_void, sfx_splash);
        } else {
            S_StartSound(mobj as *const libc::c_void, sfx_splish);
        }
        bubblecount = FixedDiv(abs((*mobj).momz), (*mobj).scale)
            >> 16 as libc::c_int - 1 as libc::c_int;
        if bubblecount > 128 as libc::c_int {
            bubblecount = 128 as libc::c_int;
        }
        i = 0 as libc::c_int;
        while i < bubblecount {
            prandom[0 as libc::c_int as usize] = P_RandomByte();
            prandom[1 as libc::c_int as usize] = P_RandomByte();
            prandom[2 as libc::c_int as usize] = P_RandomByte();
            prandom[3 as libc::c_int as usize] = P_RandomByte();
            bubbletype = MT_SMALLBUBBLE;
            if prandom[0 as libc::c_int as usize] as libc::c_int & 0x3 as libc::c_int
                == 0
            {
                bubbletype = MT_MEDIUMBUBBLE;
            }
            bubble = P_SpawnMobj(
                (*mobj).x
                    + FixedMul(
                        ((prandom[1 as libc::c_int as usize] as libc::c_int)
                            << 16 as libc::c_int - 3 as libc::c_int)
                            * (if prandom[0 as libc::c_int as usize] as libc::c_int
                                & 0x80 as libc::c_int != 0
                            {
                                1 as libc::c_int
                            } else {
                                -(1 as libc::c_int)
                            }),
                        (*mobj).scale,
                    ),
                (*mobj).y
                    + FixedMul(
                        ((prandom[2 as libc::c_int as usize] as libc::c_int)
                            << 16 as libc::c_int - 3 as libc::c_int)
                            * (if prandom[0 as libc::c_int as usize] as libc::c_int
                                & 0x40 as libc::c_int != 0
                            {
                                1 as libc::c_int
                            } else {
                                -(1 as libc::c_int)
                            }),
                        (*mobj).scale,
                    ),
                (*mobj).z
                    + FixedMul(
                        (prandom[3 as libc::c_int as usize] as libc::c_int)
                            << 16 as libc::c_int - 2 as libc::c_int,
                        (*mobj).scale,
                    ),
                bubbletype,
            );
            if !bubble.is_null() {
                if P_MobjFlip(mobj) as libc::c_int * (*mobj).momz < 0 as libc::c_int {
                    (*bubble).momz = (*mobj).momz >> 4 as libc::c_int;
                } else {
                    (*bubble).momz = 0 as libc::c_int;
                }
                (*bubble).destscale = (*mobj).scale;
                P_SetScale(bubble, (*mobj).scale);
            }
            i += 1;
            i;
        }
    }
}
unsafe extern "C" fn P_SceneryCheckWater(mut mobj: *mut mobj_t) {
    let mut sector: *mut sector_t = 0 as *mut sector_t;
    (*mobj)
        .waterbottom = (*mobj).z
        - 1000 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
    (*mobj).watertop = (*mobj).waterbottom;
    sector = (*(*mobj).subsector).sector;
    if !((*sector).ffloors).is_null() {
        let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
        let mut topheight: fixed_t = 0;
        let mut bottomheight: fixed_t = 0;
        (*mobj)
            .eflags = ((*mobj).eflags as libc::c_int
            & !(MFE_UNDERWATER as libc::c_int | MFE_TOUCHWATER as libc::c_int))
            as uint16_t;
        rover = (*sector).ffloors;
        while !rover.is_null() {
            if !((*rover).fofflags as libc::c_uint
                & FOF_EXISTS as libc::c_int as libc::c_uint == 0
                || (*rover).fofflags as libc::c_uint
                    & FOF_SWIMMABLE as libc::c_int as libc::c_uint == 0
                || (*rover).fofflags as libc::c_uint
                    & FOF_BLOCKOTHERS as libc::c_int as libc::c_uint != 0)
            {
                topheight = P_GetFFloorTopZAt(rover, (*mobj).x, (*mobj).y);
                bottomheight = P_GetFFloorBottomZAt(rover, (*mobj).x, (*mobj).y);
                if !(topheight <= (*mobj).z
                    || bottomheight > (*mobj).z + ((*mobj).height >> 1 as libc::c_int))
                {
                    if (*mobj).z + (*mobj).height > topheight {
                        (*mobj)
                            .eflags = ((*mobj).eflags as libc::c_int
                            | MFE_TOUCHWATER as libc::c_int) as uint16_t;
                    } else {
                        (*mobj)
                            .eflags = ((*mobj).eflags as libc::c_int
                            & !(MFE_TOUCHWATER as libc::c_int)) as uint16_t;
                    }
                    (*mobj).watertop = topheight;
                    (*mobj).waterbottom = bottomheight;
                    if (*mobj).z + ((*mobj).height >> 1 as libc::c_int) < topheight {
                        (*mobj)
                            .eflags = ((*mobj).eflags as libc::c_int
                            | MFE_UNDERWATER as libc::c_int) as uint16_t;
                    } else {
                        (*mobj)
                            .eflags = ((*mobj).eflags as libc::c_int
                            & !(MFE_UNDERWATER as libc::c_int)) as uint16_t;
                    }
                }
            }
            rover = (*rover).next;
        }
    } else {
        (*mobj)
            .eflags = ((*mobj).eflags as libc::c_int
            & !(MFE_UNDERWATER as libc::c_int | MFE_TOUCHWATER as libc::c_int))
            as uint16_t;
    };
}
unsafe extern "C" fn P_CameraCheckHeat(mut thiscam: *mut camera_t) -> boolean {
    let mut sector: *mut sector_t = 0 as *mut sector_t;
    let mut halfheight: fixed_t = (*thiscam).z + ((*thiscam).height >> 1 as libc::c_int);
    sector = (*(*thiscam).subsector).sector;
    if (*sector).flags as libc::c_uint & MSF_HEATWAVE as libc::c_int as libc::c_uint != 0
    {
        return true_0 as libc::c_int;
    }
    if !((*sector).ffloors).is_null() {
        let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
        rover = (*sector).ffloors;
        while !rover.is_null() {
            if !((*rover).fofflags as libc::c_uint
                & FOF_EXISTS as libc::c_int as libc::c_uint == 0)
            {
                if !(halfheight >= P_GetFFloorTopZAt(rover, (*thiscam).x, (*thiscam).y))
                {
                    if !(halfheight
                        <= P_GetFFloorBottomZAt(rover, (*thiscam).x, (*thiscam).y))
                    {
                        if (*(*(*rover).master).frontsector).flags as libc::c_uint
                            & MSF_HEATWAVE as libc::c_int as libc::c_uint != 0
                        {
                            return true_0 as libc::c_int;
                        }
                    }
                }
            }
            rover = (*rover).next;
        }
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn P_CameraCheckWater(mut thiscam: *mut camera_t) -> boolean {
    let mut sector: *mut sector_t = 0 as *mut sector_t;
    let mut halfheight: fixed_t = (*thiscam).z + ((*thiscam).height >> 1 as libc::c_int);
    sector = (*(*thiscam).subsector).sector;
    if !((*sector).ffloors).is_null() {
        let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
        rover = (*sector).ffloors;
        while !rover.is_null() {
            if !((*rover).fofflags as libc::c_uint
                & FOF_EXISTS as libc::c_int as libc::c_uint == 0
                || (*rover).fofflags as libc::c_uint
                    & FOF_SWIMMABLE as libc::c_int as libc::c_uint == 0
                || (*rover).fofflags as libc::c_uint
                    & FOF_BLOCKOTHERS as libc::c_int as libc::c_uint != 0)
            {
                if !(halfheight >= P_GetFFloorTopZAt(rover, (*thiscam).x, (*thiscam).y))
                {
                    if !(halfheight
                        <= P_GetFFloorBottomZAt(rover, (*thiscam).x, (*thiscam).y))
                    {
                        return true_0 as libc::c_int;
                    }
                }
            }
            rover = (*rover).next;
        }
    }
    return false_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_DestroyRobots() {
    let mut mo: *mut mobj_t = 0 as *mut mobj_t;
    let mut think: *mut thinker_t = 0 as *mut thinker_t;
    think = (*thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)).next;
    while think
        != &mut *thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)
            as *mut thinker_t
    {
        if !((*think).function.acp1
            == ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut thinker_t) -> ()>,
                actionf_p1,
            >(
                Some(
                    P_RemoveThinkerDelayed as unsafe extern "C" fn(*mut thinker_t) -> (),
                ),
            ))
        {
            mo = think as *mut mobj_t;
            if !((*mo).health <= 0 as libc::c_int
                || (*mo).flags
                    & (MF_ENEMY as libc::c_int | MF_BOSS as libc::c_int) as uint32_t
                    == 0)
            {
                if !((*mo).type_0 as libc::c_uint
                    == MT_PLAYER as libc::c_int as libc::c_uint)
                {
                    P_KillMobj(
                        mo,
                        players[consoleplayer as usize].mo,
                        players[consoleplayer as usize].mo,
                        0 as libc::c_int as uint8_t,
                    );
                }
            }
        }
        think = (*think).next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_CalcChasePostImg(
    mut player: *mut player_t,
    mut thiscam: *mut camera_t,
) {
    let mut postimg: postimg_t = postimg_none;
    if (*player).pflags as libc::c_uint & PF_FLIPCAM as libc::c_int as libc::c_uint != 0
        && !((*player).powers[pw_carry as libc::c_int as usize] as libc::c_int
            == CR_NIGHTSMODE as libc::c_int)
        && (*(*player).mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
    {
        postimg = postimg_flip;
    } else if (*player).awayviewtics != 0 && !((*player).awayviewmobj).is_null()
        && P_MobjWasRemoved((*player).awayviewmobj) == 0
    {
        let mut dummycam: camera_t = camera_s {
            chase: 0,
            aiming: 0,
            viewheight: 0,
            startangle: 0,
            x: 0,
            y: 0,
            z: 0,
            reset: 0,
            angle: 0,
            subsector: 0 as *const subsector_s as *mut subsector_s,
            floorz: 0,
            ceilingz: 0,
            radius: 0,
            height: 0,
            relativex: 0,
            momx: 0,
            momy: 0,
            momz: 0,
        };
        dummycam.subsector = (*(*player).awayviewmobj).subsector;
        dummycam.x = (*(*player).awayviewmobj).x;
        dummycam.y = (*(*player).awayviewmobj).y;
        dummycam.z = (*(*player).awayviewmobj).z;
        dummycam.height = 0 as libc::c_int;
        if P_CameraCheckWater(&mut dummycam) != 0 {
            postimg = postimg_water;
        } else if P_CameraCheckHeat(&mut dummycam) != 0 {
            postimg = postimg_heat;
        }
    } else if P_CameraCheckWater(thiscam) != 0 {
        postimg = postimg_water;
    } else if P_CameraCheckHeat(thiscam) != 0 {
        postimg = postimg_heat;
    }
    if postimg as libc::c_uint == postimg_none as libc::c_int as libc::c_uint {
        return;
    }
    if splitscreen != 0
        && player
            == &mut *players.as_mut_ptr().offset(secondarydisplayplayer as isize)
                as *mut player_t
    {
        postimgtype2 = postimg;
    } else {
        postimgtype = postimg;
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_CameraThinker(
    mut player: *mut player_t,
    mut thiscam: *mut camera_t,
    mut resetcalled: boolean,
) -> boolean {
    let mut itsatwodlevel: boolean = false_0 as libc::c_int;
    if maptol & TOL_2D as libc::c_int as uint32_t != 0
        || thiscam == &mut camera as *mut camera_t
            && !(players[displayplayer as usize].mo).is_null()
            && (*players[displayplayer as usize].mo).flags2
                & MF2_TWOD as libc::c_int as uint32_t != 0
        || thiscam == &mut camera2 as *mut camera_t
            && !(players[secondarydisplayplayer as usize].mo).is_null()
            && (*players[secondarydisplayplayer as usize].mo).flags2
                & MF2_TWOD as libc::c_int as uint32_t != 0
    {
        itsatwodlevel = true_0 as libc::c_int;
    }
    P_CalcChasePostImg(player, thiscam);
    if (*thiscam).momx != 0 || (*thiscam).momy != 0 {
        if P_TryCameraMove(
            (*thiscam).x + (*thiscam).momx,
            (*thiscam).y + (*thiscam).momy,
            thiscam,
        ) == 0
        {
            let mut dummy: mobj_t = mobj_s {
                thinker: thinker_s {
                    prev: 0 as *mut thinker_s,
                    next: 0 as *mut thinker_s,
                    function: actionf_t { acv: None },
                    references: 0,
                },
                x: 0,
                y: 0,
                z: 0,
                old_x: 0,
                old_y: 0,
                old_z: 0,
                old_x2: 0,
                old_y2: 0,
                old_z2: 0,
                snext: 0 as *mut mobj_s,
                sprev: 0 as *mut *mut mobj_s,
                angle: 0,
                pitch: 0,
                roll: 0,
                old_angle: 0,
                old_pitch: 0,
                old_roll: 0,
                old_angle2: 0,
                old_pitch2: 0,
                old_roll2: 0,
                spriteroll: 0,
                old_spriteroll: 0,
                old_spriteroll2: 0,
                sprite: SPR_NULL,
                frame: 0,
                sprite2: 0,
                anim_duration: 0,
                renderflags: 0,
                blendmode: 0,
                spritexscale: 0,
                spriteyscale: 0,
                spritexoffset: 0,
                spriteyoffset: 0,
                old_spritexscale: 0,
                old_spriteyscale: 0,
                old_spritexoffset: 0,
                old_spriteyoffset: 0,
                floorspriteslope: 0 as *mut pslope_s,
                touching_sectorlist: 0 as *mut msecnode_s,
                subsector: 0 as *mut subsector_s,
                floorz: 0,
                ceilingz: 0,
                floorrover: 0 as *mut ffloor_s,
                ceilingrover: 0 as *mut ffloor_s,
                radius: 0,
                height: 0,
                momx: 0,
                momy: 0,
                momz: 0,
                pmomz: 0,
                tics: 0,
                state: 0 as *mut state_t,
                flags: 0,
                flags2: 0,
                eflags: 0,
                skin: 0 as *mut libc::c_void,
                color: 0,
                drawonlyforplayer: 0 as *mut player_s,
                dontdrawforviewmobj: 0 as *mut mobj_s,
                bnext: 0 as *mut mobj_s,
                bprev: 0 as *mut *mut mobj_s,
                hnext: 0 as *mut mobj_s,
                hprev: 0 as *mut mobj_s,
                type_0: MT_NULL,
                info: 0 as *const mobjinfo_t,
                health: 0,
                movedir: 0,
                movecount: 0,
                target: 0 as *mut mobj_s,
                reactiontime: 0,
                threshold: 0,
                player: 0 as *mut player_s,
                lastlook: 0,
                spawnpoint: 0 as *mut mapthing_t,
                tracer: 0 as *mut mobj_s,
                friction: 0,
                movefactor: 0,
                fuse: 0,
                watertop: 0,
                waterbottom: 0,
                mobjnum: 0,
                scale: 0,
                old_scale: 0,
                old_scale2: 0,
                destscale: 0,
                scalespeed: 0,
                extravalue1: 0,
                extravalue2: 0,
                cusval: 0,
                cvmem: 0,
                standingslope: 0 as *mut pslope_s,
                resetinterp: 0,
                colorized: 0,
                mirrored: 0,
                shadowscale: 0,
                dispoffset: 0,
            };
            dummy
                .thinker
                .function
                .acp1 = ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut mobj_t) -> ()>,
                actionf_p1,
            >(Some(P_MobjThinker as unsafe extern "C" fn(*mut mobj_t) -> ()));
            dummy.subsector = (*thiscam).subsector;
            dummy.x = (*thiscam).x;
            dummy.y = (*thiscam).y;
            dummy.z = (*thiscam).z;
            dummy.height = (*thiscam).height;
            if resetcalled == 0
                && !((*player).pflags as libc::c_uint
                    & PF_NOCLIP as libc::c_int as libc::c_uint != 0
                    || (*player).powers[pw_carry as libc::c_int as usize] as libc::c_int
                        == CR_NIGHTSMODE as libc::c_int)
                && P_CheckSight(&mut dummy, (*player).mo) == 0
            {
                P_ResetCamera(player, thiscam);
            } else {
                let mut camspeed: fixed_t = P_AproxDistance(
                    (*thiscam).momx,
                    (*thiscam).momy,
                );
                P_SlideCameraMove(thiscam);
                if resetcalled == 0
                    && P_AproxDistance((*thiscam).momx, (*thiscam).momy) == camspeed
                {
                    P_ResetCamera(player, thiscam);
                    resetcalled = true_0 as libc::c_int;
                }
            }
            if resetcalled != 0 {
                return true_0 as libc::c_int;
            }
        }
    }
    if itsatwodlevel == 0 {
        P_CheckCameraPosition((*thiscam).x, (*thiscam).y, thiscam);
    }
    (*thiscam).subsector = R_PointInSubsector((*thiscam).x, (*thiscam).y);
    (*thiscam).floorz = tmfloorz;
    (*thiscam).ceilingz = tmceilingz;
    if (*thiscam).momz != 0 || (*(*player).mo).pmomz != 0 {
        (*thiscam).z += (*thiscam).momz + (*(*player).mo).pmomz;
        if itsatwodlevel == 0
            && !((*player).pflags as libc::c_uint
                & PF_NOCLIP as libc::c_int as libc::c_uint != 0
                || (*player).powers[pw_carry as libc::c_int as usize] as libc::c_int
                    == CR_NIGHTSMODE as libc::c_int)
        {
            if (*thiscam).z <= (*thiscam).floorz {
                let mut cam_height: fixed_t = cv_cam_height.value;
                (*thiscam).z = (*thiscam).floorz;
                if player
                    == &mut *players.as_mut_ptr().offset(secondarydisplayplayer as isize)
                        as *mut player_t
                {
                    cam_height = cv_cam2_height.value;
                }
                if (*thiscam).z
                    > (*(*player).mo).z + (*(*player).mo).height
                        + FixedMul(
                            cam_height * ((1 as libc::c_int) << 16 as libc::c_int)
                                + 16 as libc::c_int
                                    * ((1 as libc::c_int) << 16 as libc::c_int),
                            (*(*player).mo).scale,
                        )
                {
                    if resetcalled == 0 {
                        P_ResetCamera(player, thiscam);
                    }
                    return true_0 as libc::c_int;
                }
            }
            if (*thiscam).z + (*thiscam).height > (*thiscam).ceilingz {
                if (*thiscam).momz > 0 as libc::c_int {
                    (*thiscam).momz = 0 as libc::c_int;
                }
                (*thiscam).z = (*thiscam).ceilingz - (*thiscam).height;
                if (*thiscam).z + (*thiscam).height
                    < (*(*player).mo).z - (*(*player).mo).height
                {
                    if resetcalled == 0 {
                        P_ResetCamera(player, thiscam);
                    }
                    return true_0 as libc::c_int;
                }
            }
        }
    }
    if itsatwodlevel != 0
        || (*thiscam).ceilingz - (*thiscam).z < (*thiscam).height
            && (*thiscam).ceilingz >= (*thiscam).z
    {
        (*thiscam).ceilingz = (*thiscam).z + (*thiscam).height;
        (*thiscam).floorz = (*thiscam).z;
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn P_CheckCrumblingPlatforms(mut mobj: *mut mobj_t) {
    let mut node: *mut msecnode_t = 0 as *mut msecnode_t;
    if netgame != 0 && (*(*mobj).player).spectator != 0 {
        return;
    }
    node = (*mobj).touching_sectorlist;
    while !node.is_null() {
        let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
        let mut current_block_4: u64;
        rover = (*(*node).m_sector).ffloors;
        while !rover.is_null() {
            if !((*rover).fofflags as libc::c_uint
                & FOF_EXISTS as libc::c_int as libc::c_uint == 0)
            {
                if !((*rover).fofflags as libc::c_uint
                    & FOF_CRUMBLE as libc::c_int as libc::c_uint == 0)
                {
                    if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                        != 0
                    {
                        if P_MobjFloorZ(
                            mobj,
                            sectors.offset((*rover).secnum as isize),
                            (*node).m_sector,
                            (*mobj).x,
                            (*mobj).y,
                            0 as *mut line_t,
                            (sectors.offset((*rover).secnum as isize)
                                != (*node).m_sector) as libc::c_int,
                            true_0 as libc::c_int,
                        ) != (*mobj).z + (*mobj).height
                        {
                            current_block_4 = 735147466149431745;
                        } else {
                            current_block_4 = 12209867499936983673;
                        }
                    } else if P_MobjCeilingZ(
                        mobj,
                        sectors.offset((*rover).secnum as isize),
                        (*node).m_sector,
                        (*mobj).x,
                        (*mobj).y,
                        0 as *mut line_t,
                        (sectors.offset((*rover).secnum as isize) == (*node).m_sector)
                            as libc::c_int,
                        true_0 as libc::c_int,
                    ) != (*mobj).z
                    {
                        current_block_4 = 735147466149431745;
                    } else {
                        current_block_4 = 12209867499936983673;
                    }
                    match current_block_4 {
                        735147466149431745 => {}
                        _ => {
                            EV_StartCrumble(
                                (*(*rover).master).frontsector,
                                rover,
                                ((*rover).fofflags as libc::c_uint
                                    & FOF_FLOATBOB as libc::c_int as libc::c_uint) as boolean,
                                (*mobj).player,
                                (*rover).alpha,
                                ((*rover).fofflags as libc::c_uint
                                    & FOF_NORETURN as libc::c_int as libc::c_uint == 0)
                                    as libc::c_int,
                            );
                        }
                    }
                }
            }
            rover = (*rover).next;
        }
        node = (*node).m_sectorlist_next;
    }
}
unsafe extern "C" fn P_MobjTouchesSectorWithWater(mut mobj: *mut mobj_t) -> boolean {
    let mut node: *mut msecnode_t = 0 as *mut msecnode_t;
    node = (*mobj).touching_sectorlist;
    while !node.is_null() {
        let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
        if !((*(*node).m_sector).ffloors).is_null() {
            rover = (*(*node).m_sector).ffloors;
            while !rover.is_null() {
                if !((*rover).fofflags as libc::c_uint
                    & FOF_EXISTS as libc::c_int as libc::c_uint == 0)
                {
                    if !((*rover).fofflags as libc::c_uint
                        & FOF_SWIMMABLE as libc::c_int as libc::c_uint == 0)
                    {
                        return true_0 as libc::c_int;
                    }
                }
                rover = (*rover).next;
            }
        }
        node = (*node).m_sectorlist_next;
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn P_CheckFloatbobPlatforms(mut mobj: *mut mobj_t) {
    let mut node: *mut msecnode_t = 0 as *mut msecnode_t;
    if P_MobjFlip(mobj) as libc::c_int * (*mobj).momz >= 0 as libc::c_int {
        return;
    }
    if P_MobjTouchesSectorWithWater(mobj) == 0 {
        return;
    }
    node = (*mobj).touching_sectorlist;
    while !node.is_null() {
        let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
        if !((*(*node).m_sector).ffloors).is_null() {
            let mut current_block_6: u64;
            rover = (*(*node).m_sector).ffloors;
            while !rover.is_null() {
                if !((*rover).fofflags as libc::c_uint
                    & FOF_EXISTS as libc::c_int as libc::c_uint == 0)
                {
                    if !((*rover).fofflags as libc::c_uint
                        & FOF_FLOATBOB as libc::c_int as libc::c_uint == 0)
                    {
                        if (*mobj).eflags as libc::c_int
                            & MFE_VERTICALFLIP as libc::c_int != 0
                        {
                            if abs(*(*rover).bottomheight - ((*mobj).z + (*mobj).height))
                                > abs((*mobj).momz)
                            {
                                current_block_6 = 10879442775620481940;
                            } else {
                                current_block_6 = 12599329904712511516;
                            }
                        } else if abs(*(*rover).topheight - (*mobj).z)
                            > abs((*mobj).momz)
                        {
                            current_block_6 = 10879442775620481940;
                        } else {
                            current_block_6 = 12599329904712511516;
                        }
                        match current_block_6 {
                            10879442775620481940 => {}
                            _ => {
                                EV_BounceSector(
                                    (*(*rover).master).frontsector,
                                    -(*mobj).momz,
                                    (*rover).master,
                                );
                            }
                        }
                    }
                }
                rover = (*rover).next;
            }
        }
        node = (*node).m_sectorlist_next;
    }
}
unsafe extern "C" fn P_PlayerMobjThinker(mut mobj: *mut mobj_t) {
    let mut current_block: u64;
    P_MobjCheckWater(mobj);
    P_ButteredSlope(mobj);
    (*mobj)
        .eflags = ((*mobj).eflags as libc::c_int & !(MFE_JUSTSTEPPEDDOWN as libc::c_int))
        as uint16_t;
    if !(((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
        == S_PLAY_BOUNCE_LANDING as libc::c_int as libc::c_long)
    {
        if !((*mobj).tracer).is_null() {
            if (*(*mobj).player).powers[pw_carry as libc::c_int as usize] as libc::c_int
                == CR_ZOOMTUBE as libc::c_int
                || (*(*mobj).player).powers[pw_carry as libc::c_int as usize]
                    as libc::c_int == CR_ROPEHANG as libc::c_int
            {
                P_UnsetThingPosition(mobj);
                (*mobj).x += (*mobj).momx;
                (*mobj).y += (*mobj).momy;
                (*mobj).z += (*mobj).momz;
                P_SetThingPosition(mobj);
                P_CheckPosition(mobj, (*mobj).x, (*mobj).y);
                (*mobj).floorz = tmfloorz;
                (*mobj).ceilingz = tmceilingz;
                current_block = 7221252460598509608;
            } else if (*(*mobj).player).powers[pw_carry as libc::c_int as usize]
                as libc::c_int == CR_MACESPIN as libc::c_int
            {
                P_CheckPosition(mobj, (*mobj).x, (*mobj).y);
                (*mobj).floorz = tmfloorz;
                (*mobj).ceilingz = tmceilingz;
                current_block = 7221252460598509608;
            } else {
                current_block = 9606288038608642794;
            }
        } else {
            current_block = 9606288038608642794;
        }
        match current_block {
            7221252460598509608 => {}
            _ => {
                P_CheckGravity(mobj, false_0 as libc::c_int);
                (*(*mobj).player)
                    .powers[pw_justlaunched as libc::c_int
                    as usize] = 0 as libc::c_int as uint16_t;
                if (*mobj).momx != 0 || (*mobj).momy != 0 {
                    P_XYMovement(mobj);
                    if P_MobjWasRemoved(mobj) != 0 {
                        return;
                    }
                } else {
                    P_TryMove(mobj, (*mobj).x, (*mobj).y, true_0 as libc::c_int);
                }
                P_CheckCrumblingPlatforms(mobj);
                if CheckForFloatBob != 0 {
                    P_CheckFloatbobPlatforms(mobj);
                }
                if (*mobj).eflags as libc::c_int & MFE_ONGROUND as libc::c_int == 0
                    || (*mobj).momz != 0
                    || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                        != 0 && (*mobj).z + (*mobj).height != (*mobj).ceilingz
                    || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                        == 0 && (*mobj).z != (*mobj).floorz
                    || P_IsObjectInGoop(mobj) != 0
                {
                    P_PlayerZMovement(mobj);
                    P_CheckPosition(mobj, (*mobj).x, (*mobj).y);
                    if P_MobjWasRemoved(mobj) != 0 {
                        return;
                    }
                } else {
                    (*mobj)
                        .eflags = ((*mobj).eflags as libc::c_int
                        & !(MFE_JUSTHITFLOOR as libc::c_int)) as uint16_t;
                }
            }
        }
    }
    P_CyclePlayerMobjState(mobj);
}
unsafe extern "C" fn CalculatePrecipFloor(mut mobj: *mut precipmobj_t) {
    let mut mobjsecsubsec: *const sector_t = 0 as *const sector_t;
    if !mobj.is_null() && !((*mobj).subsector).is_null()
        && !((*(*mobj).subsector).sector).is_null()
    {
        mobjsecsubsec = (*(*mobj).subsector).sector;
    } else {
        return
    }
    (*mobj).floorz = P_GetSectorFloorZAt(mobjsecsubsec, (*mobj).x, (*mobj).y);
    if !((*mobjsecsubsec).ffloors).is_null() {
        let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
        let mut topheight: fixed_t = 0;
        rover = (*mobjsecsubsec).ffloors;
        while !rover.is_null() {
            if !((*rover).fofflags as libc::c_uint
                & FOF_EXISTS as libc::c_int as libc::c_uint == 0)
            {
                if !((*rover).fofflags as libc::c_uint
                    & FOF_BLOCKOTHERS as libc::c_int as libc::c_uint == 0
                    && (*rover).fofflags as libc::c_uint
                        & FOF_SWIMMABLE as libc::c_int as libc::c_uint == 0)
                {
                    topheight = P_GetFFloorTopZAt(rover, (*mobj).x, (*mobj).y);
                    if topheight > (*mobj).floorz {
                        (*mobj).floorz = topheight;
                    }
                }
            }
            rover = (*rover).next;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_RecalcPrecipInSector(mut sector: *mut sector_t) {
    let mut psecnode: *mut mprecipsecnode_t = 0 as *mut mprecipsecnode_t;
    if sector.is_null() {
        return;
    }
    (*sector).moved = true_0 as libc::c_int;
    psecnode = (*sector).touching_preciplist;
    while !psecnode.is_null() {
        CalculatePrecipFloor((*psecnode).m_thing);
        psecnode = (*psecnode).m_thinglist_next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_NullPrecipThinker(mut mobj: *mut precipmobj_t) {
    (*mobj).precipflags &= !(PCF_THUNK as libc::c_int);
    R_ResetPrecipitationMobjInterpolationState(mobj);
}
#[no_mangle]
pub unsafe extern "C" fn P_SnowThinker(mut mobj: *mut precipmobj_t) {
    P_CycleStateAnimation(mobj as *mut mobj_t);
    (*mobj).z += (*mobj).momz;
    if (*mobj).z <= (*mobj).floorz {
        (*mobj).z = (*mobj).ceilingz;
        R_ResetPrecipitationMobjInterpolationState(mobj);
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_RainThinker(mut mobj: *mut precipmobj_t) {
    P_CycleStateAnimation(mobj as *mut mobj_t);
    if (*mobj).state
        != &mut *states.as_mut_ptr().offset(S_RAIN1 as libc::c_int as isize)
            as *mut state_t
    {
        if (*mobj).tics <= 0 as libc::c_int {
            return;
        }
        (*mobj).tics -= 1;
        if (*mobj).tics != 0 {
            return;
        }
        if P_SetPrecipMobjState(mobj, (*(*mobj).state).nextstate) == 0 {
            return;
        }
        if (*mobj).state
            != &mut *states.as_mut_ptr().offset(S_RAINRETURN as libc::c_int as isize)
                as *mut state_t
        {
            return;
        }
        (*mobj).z = (*mobj).ceilingz;
        R_ResetPrecipitationMobjInterpolationState(mobj);
        P_SetPrecipMobjState(mobj, S_RAIN1);
        return;
    }
    (*mobj).z += (*mobj).momz;
    if (*mobj).z > (*mobj).floorz {
        return;
    }
    if (*mobj).precipflags & PCF_PIT as libc::c_int != 0 {
        (*mobj).z = (*mobj).ceilingz;
        return;
    }
    (*mobj).z = (*mobj).floorz;
    P_SetPrecipMobjState(mobj, S_SPLASH1);
}
unsafe extern "C" fn P_KillRingsInLava(mut mo: *mut mobj_t) {
    let mut node: *mut msecnode_t = 0 as *mut msecnode_t;
    node = (*mo).touching_sectorlist;
    while !node.is_null() {
        if ((*node).m_sector).is_null() {
            break;
        }
        if !((*(*node).m_sector).ffloors).is_null() {
            let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
            let mut topheight: fixed_t = 0;
            let mut bottomheight: fixed_t = 0;
            rover = (*(*node).m_sector).ffloors;
            while !rover.is_null() {
                if !((*rover).fofflags as libc::c_uint
                    & FOF_EXISTS as libc::c_int as libc::c_uint == 0)
                {
                    if !((*rover).fofflags as libc::c_uint
                        & FOF_SWIMMABLE as libc::c_int as libc::c_uint == 0)
                    {
                        if !((*(*(*rover).master).frontsector).damagetype as libc::c_int
                            != SD_FIRE as libc::c_int
                            && (*(*(*rover).master).frontsector).damagetype
                                as libc::c_int != SD_LAVA as libc::c_int)
                        {
                            topheight = P_MobjCeilingZ(
                                mo,
                                sectors.offset((*rover).secnum as isize),
                                (*node).m_sector,
                                (*mo).x,
                                (*mo).y,
                                0 as *mut line_t,
                                false_0 as libc::c_int,
                                false_0 as libc::c_int,
                            );
                            bottomheight = P_MobjFloorZ(
                                mo,
                                sectors.offset((*rover).secnum as isize),
                                (*node).m_sector,
                                (*mo).x,
                                (*mo).y,
                                0 as *mut line_t,
                                true_0 as libc::c_int,
                                false_0 as libc::c_int,
                            );
                            if (*mo).z <= topheight
                                && (*mo).z + (*mo).height >= bottomheight
                            {
                                P_KillMobj(
                                    mo,
                                    0 as *mut mobj_t,
                                    0 as *mut mobj_t,
                                    2 as libc::c_int as uint8_t,
                                );
                                return;
                            }
                        }
                    }
                }
                rover = (*rover).next;
            }
        }
        node = (*node).m_sectorlist_next;
    }
}
unsafe extern "C" fn P_RingThinker(mut mobj: *mut mobj_t) {
    if (*mobj).momx != 0 || (*mobj).momy != 0 {
        P_RingXYMovement(mobj);
        if P_MobjWasRemoved(mobj) != 0 {
            return;
        }
    }
    if (*mobj).momz != 0 {
        P_RingZMovement(mobj);
        P_CheckPosition(mobj, (*mobj).x, (*mobj).y);
        if P_MobjWasRemoved(mobj) != 0 {
            return;
        }
    }
    P_CycleMobjState(mobj);
}
#[no_mangle]
pub unsafe extern "C" fn P_BossTargetPlayer(
    mut actor: *mut mobj_t,
    mut closest: boolean,
) -> boolean {
    let mut stop: int32_t = -(1 as libc::c_int);
    let mut c: int32_t = 0 as libc::c_int;
    let mut player: *mut player_t = 0 as *mut player_t;
    let mut dist: fixed_t = 0;
    let mut lastdist: fixed_t = 0 as libc::c_int;
    if (*actor).lastlook < 0 as libc::c_int {
        (*actor).lastlook = P_RandomByte() as int32_t;
    }
    (*actor).lastlook &= 32 as libc::c_int - 1 as libc::c_int;
    loop {
        if stop < 0 as libc::c_int {
            stop = (*actor).lastlook;
        } else if (*actor).lastlook == stop {
            return (closest != 0 && lastdist > 0 as libc::c_int) as libc::c_int
        }
        if !(playeringame[(*actor).lastlook as usize] == 0) {
            if closest == 0
                && {
                    let fresh3 = c;
                    c = c + 1;
                    fresh3 == 2 as libc::c_int
                }
            {
                return false_0 as libc::c_int;
            }
            player = &mut *players.as_mut_ptr().offset((*actor).lastlook as isize)
                as *mut player_t;
            if !((*player).pflags as libc::c_uint
                & PF_INVIS as libc::c_int as libc::c_uint != 0
                || (*player).bot as libc::c_int == BOT_2PAI as libc::c_int
                || (*player).bot as libc::c_int == BOT_2PHUMAN as libc::c_int
                || (*player).spectator != 0)
            {
                if !(((*player).mo).is_null() || P_MobjWasRemoved((*player).mo) != 0) {
                    if !((*(*player).mo).health <= 0 as libc::c_int) {
                        if !(P_CheckSight(actor, (*player).mo) == 0) {
                            if closest != 0 {
                                dist = P_AproxDistance(
                                    (*actor).x - (*(*player).mo).x,
                                    (*actor).y - (*(*player).mo).y,
                                );
                                if lastdist == 0 || dist < lastdist {
                                    lastdist = dist + 1 as libc::c_int;
                                    P_SetTarget2(&mut (*actor).target, (*player).mo);
                                }
                            } else {
                                P_SetTarget2(&mut (*actor).target, (*player).mo);
                                return true_0 as libc::c_int;
                            }
                        }
                    }
                }
            }
        }
        (*actor)
            .lastlook = (*actor).lastlook + 1 as libc::c_int
            & 32 as libc::c_int - 1 as libc::c_int;
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_SupermanLook4Players(mut actor: *mut mobj_t) -> boolean {
    let mut c: int32_t = 0;
    let mut stop: int32_t = 0 as libc::c_int;
    let mut playersinthegame: [*mut player_t; 32] = [0 as *mut player_t; 32];
    c = 0 as libc::c_int;
    while c < 32 as libc::c_int {
        if playeringame[c as usize] != 0 && players[c as usize].spectator == 0 {
            if !(players[c as usize].pflags as libc::c_uint
                & PF_INVIS as libc::c_int as libc::c_uint != 0)
            {
                if !((players[c as usize].mo).is_null()
                    || players[c as usize].bot as libc::c_int == BOT_2PAI as libc::c_int
                    || players[c as usize].bot as libc::c_int
                        == BOT_2PHUMAN as libc::c_int)
                {
                    if !((*players[c as usize].mo).health <= 0 as libc::c_int) {
                        playersinthegame[stop
                            as usize] = &mut *players.as_mut_ptr().offset(c as isize)
                            as *mut player_t;
                        stop += 1;
                        stop;
                    }
                }
            }
        }
        c += 1;
        c;
    }
    if stop == 0 {
        return false_0 as libc::c_int;
    }
    P_SetTarget2(
        &mut (*actor).target,
        (*playersinthegame[P_RandomKey(stop) as usize]).mo,
    );
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_GenericBossThinker(mut mobj: *mut mobj_t) {
    if (*(*mobj).state).nextstate as libc::c_uint
        == (*(*mobj).info).spawnstate as libc::c_uint && (*mobj).tics == 1 as libc::c_int
    {
        (*mobj).flags2 &= !(MF2_FRET as libc::c_int) as uint32_t;
    }
    if ((*mobj).target).is_null()
        || (*(*mobj).target).flags & MF_SHOOTABLE as libc::c_int as uint32_t == 0
    {
        if (*mobj).health <= 0 as libc::c_int {
            return;
        }
        if P_BossTargetPlayer(mobj, false_0 as libc::c_int) != 0
            && (*(*mobj).info).seesound as libc::c_uint != 0
        {
            S_StartSound(mobj as *const libc::c_void, (*(*mobj).info).seesound);
        }
        return;
    }
    if (*mobj).state
        == &mut *states.as_mut_ptr().offset((*(*mobj).info).meleestate as isize)
            as *mut state_t
        || (*mobj).state
            == &mut *states.as_mut_ptr().offset((*(*mobj).info).missilestate as isize)
                as *mut state_t && (*mobj).health > (*(*mobj).info).damage
    {
        (*mobj)
            .angle = R_PointToAngle2(
            (*mobj).x,
            (*mobj).y,
            (*(*mobj).target).x,
            (*(*mobj).target).y,
        );
    }
}
unsafe extern "C" fn P_Boss1Thinker(mut mobj: *mut mobj_t) {
    if (*mobj).flags2 & MF2_FRET as libc::c_int as uint32_t != 0
        && (*(*mobj).state).nextstate as libc::c_uint
            == (*(*mobj).info).spawnstate as libc::c_uint
        && (*mobj).tics == 1 as libc::c_int
    {
        (*mobj).flags2
            &= !(MF2_FRET as libc::c_int | MF2_SKULLFLY as libc::c_int) as uint32_t;
        (*mobj).momz = 0 as libc::c_int;
        (*mobj).momy = (*mobj).momz;
        (*mobj).momx = (*mobj).momy;
    }
    if ((*mobj).tracer).is_null() {
        var1 = 0 as libc::c_int;
        A_BossJetFume(mobj);
    }
    if ((*mobj).target).is_null()
        || (*(*mobj).target).flags & MF_SHOOTABLE as libc::c_int as uint32_t == 0
    {
        if !((*mobj).target).is_null() && (*(*mobj).target).health != 0
            && (*(*mobj).target).type_0 as libc::c_uint
                == MT_EGGMOBILE_TARGET as libc::c_int as libc::c_uint
        {
            return;
        }
        if (*mobj).health <= 0 as libc::c_int {
            return;
        }
        if P_BossTargetPlayer(mobj, false_0 as libc::c_int) != 0
            && (*(*mobj).info).seesound as libc::c_uint != 0
        {
            S_StartSound(mobj as *const libc::c_void, (*(*mobj).info).seesound);
        }
        return;
    }
    if (*mobj).flags2 & MF2_SKULLFLY as libc::c_int as uint32_t != 0 {
        let mut dist: fixed_t = if (*mobj).eflags as libc::c_int
            & MFE_VERTICALFLIP as libc::c_int != 0
        {
            (*mobj).ceilingz - 2 as libc::c_int * (*mobj).height
                - ((*mobj).z + (*mobj).height)
        } else {
            (*mobj).z - ((*mobj).floorz + 2 as libc::c_int * (*mobj).height)
        };
        if dist > 0 as libc::c_int
            && P_MobjFlip(mobj) as libc::c_int * (*mobj).momz > 0 as libc::c_int
        {
            (*mobj)
                .momz = FixedMul(
                (*mobj).momz,
                ((1 as libc::c_int) << 16 as libc::c_int) - (dist >> 12 as libc::c_int),
            );
        }
    } else if (*mobj).state
        != &mut *states.as_mut_ptr().offset((*(*mobj).info).spawnstate as isize)
            as *mut state_t && (*mobj).health > 0 as libc::c_int
        && (*mobj).flags & MF_FLOAT as libc::c_int as uint32_t != 0
    {
        (*mobj)
            .momz = FixedMul(
            (*mobj).momz,
            7 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                / 8 as libc::c_int,
        );
    }
    if (*mobj).state
        == &mut *states.as_mut_ptr().offset((*(*mobj).info).meleestate as isize)
            as *mut state_t
        || (*mobj).state
            == &mut *states.as_mut_ptr().offset((*(*mobj).info).missilestate as isize)
                as *mut state_t && (*mobj).health > (*(*mobj).info).damage
    {
        (*mobj)
            .angle = R_PointToAngle2(
            (*mobj).x,
            (*mobj).y,
            (*(*mobj).target).x,
            (*(*mobj).target).y,
        );
    }
}
unsafe extern "C" fn P_Boss2Thinker(mut mobj: *mut mobj_t) {
    if (*mobj).movecount != 0 {
        (*mobj).movecount -= 1;
        (*mobj).movecount;
    }
    if (*mobj).movecount == 0 {
        (*mobj).flags2 &= !(MF2_FRET as libc::c_int) as uint32_t;
    }
    if ((*mobj).tracer).is_null() {
        var1 = 0 as libc::c_int;
        A_BossJetFume(mobj);
    }
    if (*mobj).health <= (*(*mobj).info).damage
        && (((*mobj).target).is_null()
            || (*(*mobj).target).flags & MF_SHOOTABLE as libc::c_int as uint32_t == 0)
    {
        if (*mobj).health <= 0 as libc::c_int {
            return;
        }
        if P_BossTargetPlayer(mobj, false_0 as libc::c_int) != 0
            && (*(*mobj).info).seesound as libc::c_uint != 0
        {
            S_StartSound(mobj as *const libc::c_void, (*(*mobj).info).seesound);
        }
        return;
    }
    if (*mobj).state
        == &mut *states.as_mut_ptr().offset((*(*mobj).info).spawnstate as isize)
            as *mut state_t && (*mobj).health > (*(*mobj).info).damage
    {
        A_Boss2Chase(mobj);
    } else if (*mobj).health > 0 as libc::c_int
        && (*mobj).state
            != &mut *states.as_mut_ptr().offset((*(*mobj).info).painstate as isize)
                as *mut state_t
        && (*mobj).state
            != &mut *states
                .as_mut_ptr()
                .offset(
                    (*mobjinfo
                        .as_mut_ptr()
                        .offset((*(*mobj).info).missilestate as isize))
                        .raisestate as isize,
                ) as *mut state_t
    {
        (*mobj).flags &= !(MF_NOGRAVITY as libc::c_int) as uint32_t;
        A_Boss2Pogo(mobj);
        if !((*mobj).spawnpoint).is_null() {
            P_LinedefExecute(
                (*(*mobj).spawnpoint).args[4 as libc::c_int as usize] as int16_t,
                mobj,
                0 as *mut sector_t,
            );
        }
    }
}
unsafe extern "C" fn P_Boss3Thinker(mut mobj: *mut mobj_t) {
    if (*mobj).state
        == &mut *states.as_mut_ptr().offset((*(*mobj).info).spawnstate as isize)
            as *mut state_t
    {
        (*mobj).flags2 &= !(MF2_FRET as libc::c_int) as uint32_t;
    }
    if (*mobj).flags2 & MF2_FRET as libc::c_int as uint32_t != 0 {
        (*mobj).movedir = 1 as libc::c_int as angle_t;
    }
    if (*mobj).health <= 0 as libc::c_int {
        return;
    }
    if (*mobj).reactiontime != 0 {
        let mut i: uint32_t = 0;
        let mut curpath: int8_t = (*mobj).threshold as int8_t;
        (*mobj).threshold = P_RandomKey(8 as libc::c_int - 1 as libc::c_int);
        if (*mobj).threshold >= curpath as libc::c_int {
            (*mobj).threshold += 1;
            (*mobj).threshold;
        }
        if (*mobj).state
            != &mut *states.as_mut_ptr().offset((*(*mobj).info).spawnstate as isize)
                as *mut state_t
        {
            P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
        }
        (*mobj).reactiontime -= 1;
        (*mobj).reactiontime;
        if (*mobj).reactiontime == 0 && (*mobj).health <= (*(*mobj).info).damage {
            let mut th: *mut thinker_t = 0 as *mut thinker_t;
            let mut mo2: *mut mobj_t = 0 as *mut mobj_t;
            let mut dummy: *mut mobj_t = 0 as *mut mobj_t;
            let mut way0: int8_t = (*mobj).threshold as int8_t;
            let mut way1: int8_t = 0;
            let mut way2: int8_t = 0;
            i = 0 as libc::c_int as uint32_t;
            th = (*thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)).next;
            while th
                != &mut *thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)
                    as *mut thinker_t
            {
                if !((*th).function.acp1
                    == ::core::mem::transmute::<
                        Option::<unsafe extern "C" fn(*mut thinker_t) -> ()>,
                        actionf_p1,
                    >(
                        Some(
                            P_RemoveThinkerDelayed
                                as unsafe extern "C" fn(*mut thinker_t) -> (),
                        ),
                    ))
                {
                    mo2 = th as *mut mobj_t;
                    if !((*mo2).type_0 as libc::c_uint
                        != (*(*mobj).info).mass as mobjtype_t as libc::c_uint)
                    {
                        if !((*mo2).tracer != mobj) {
                            P_RemoveMobj(mo2);
                            i = i.wrapping_add(1);
                            if i == 2 as libc::c_int as uint32_t {
                                break;
                            }
                        }
                    }
                }
                th = (*th).next;
            }
            way1 = P_RandomKey(8 as libc::c_int - 2 as libc::c_int) as int8_t;
            if way1 as libc::c_int >= curpath as libc::c_int {
                way1 += 1;
                way1;
            }
            if way1 as libc::c_int >= way0 as libc::c_int {
                way1 += 1;
                way1;
                if way1 as libc::c_int == curpath as libc::c_int {
                    way1 += 1;
                    way1;
                }
            }
            dummy = P_SpawnMobj(
                (*mobj).x,
                (*mobj).y,
                (*mobj).z,
                (*(*mobj).info).mass as mobjtype_t,
            );
            (*dummy).angle = (*mobj).angle;
            (*dummy).threshold = way1 as int32_t;
            P_SetTarget2(&mut (*dummy).tracer, mobj);
            (*dummy).movefactor = (*mobj).movefactor;
            (*dummy).cusval = (*mobj).cusval;
            way2 = P_RandomKey(8 as libc::c_int - 3 as libc::c_int) as int8_t;
            if way2 as libc::c_int >= curpath as libc::c_int {
                way2 += 1;
                way2;
            }
            if way2 as libc::c_int >= way0 as libc::c_int {
                way2 += 1;
                way2;
                if way2 as libc::c_int == curpath as libc::c_int {
                    way2 += 1;
                    way2;
                }
            }
            if way2 as libc::c_int >= way1 as libc::c_int {
                way2 += 1;
                way2;
                if way2 as libc::c_int == curpath as libc::c_int
                    || way2 as libc::c_int == way0 as libc::c_int
                {
                    way2 += 1;
                    way2;
                }
            }
            dummy = P_SpawnMobj(
                (*mobj).x,
                (*mobj).y,
                (*mobj).z,
                (*(*mobj).info).mass as mobjtype_t,
            );
            (*dummy).angle = (*mobj).angle;
            (*dummy).threshold = way2 as int32_t;
            P_SetTarget2(&mut (*dummy).tracer, mobj);
            (*dummy).movefactor = (*mobj).movefactor;
            (*dummy).cusval = (*mobj).cusval;
            CONS_Debug(
                0x80 as libc::c_int,
                b"Eggman path %d - Dummy selected paths %d and %d\n\0" as *const u8
                    as *const libc::c_char,
                way0 as libc::c_int,
                way1 as libc::c_int,
                way2 as libc::c_int,
            );
            if !((*mobj).spawnpoint).is_null() {
                P_LinedefExecute(
                    (*(*mobj).spawnpoint).args[4 as libc::c_int as usize] as int16_t,
                    mobj,
                    0 as *mut sector_t,
                );
            }
        }
    } else if (*mobj).movecount != 0 {
        if (*mobj).state
            < &mut *states.as_mut_ptr().offset((*(*mobj).info).missilestate as isize)
                as *mut state_t
            || (*mobj).state
                > &mut *states.as_mut_ptr().offset((*(*mobj).info).raisestate as isize)
                    as *mut state_t
        {
            P_BossTargetPlayer(mobj, true_0 as libc::c_int);
            if ((*mobj).target).is_null() || ((*(*mobj).target).player).is_null() {
                return;
            }
            if (*mobj).health <= (*(*mobj).info).damage {
                (*mobj).movecount -= 1;
                (*mobj).movecount;
            }
            if (*mobj).movecount != 0 {
                P_SetMobjState(
                    mobj,
                    ((*(*mobj).info).missilestate as libc::c_uint)
                        .wrapping_add(1 as libc::c_int as libc::c_uint) as statenum_t,
                );
            }
        } else if !((*mobj).target).is_null() && !((*(*mobj).target).player).is_null() {
            let mut diff: angle_t = (R_PointToAngle2(
                (*mobj).x,
                (*mobj).y,
                (*(*mobj).target).x,
                (*(*mobj).target).y,
            ))
                .wrapping_sub((*mobj).angle);
            if diff > 0x80000000 as libc::c_uint {
                diff = InvAngle(InvAngle(diff) / 4 as libc::c_int as angle_t);
            } else {
                diff = diff / 4 as libc::c_int as angle_t;
            }
            (*mobj).angle = ((*mobj).angle).wrapping_add(diff);
        }
    } else if (*mobj).threshold >= 0 as libc::c_int {
        let mut dist: fixed_t = 0 as libc::c_int;
        let mut speed: fixed_t = 0;
        P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
        if (*mobj).state
            != &mut *states.as_mut_ptr().offset((*(*mobj).info).spawnstate as isize)
                as *mut state_t && (*mobj).health > 0 as libc::c_int
            && (*mobj).flags2 & MF2_FRET as libc::c_int as uint32_t == 0
        {
            P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
        }
        if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t == 0 {
            let mut mo2_0: *mut mobj_t = 0 as *mut mobj_t;
            let mut i_0: int32_t = 0;
            P_SetTarget2(&mut (*mobj).tracer, 0 as *mut mobj_t);
            let mut ICNT_4524: size_t = 0 as libc::c_int as size_t;
            loop {
                i_0 = Tag_Iterate_Things((*mobj).cusval as mtag_t, ICNT_4524);
                if !(i_0 >= 0 as libc::c_int) {
                    break;
                }
                mo2_0 = (*mapthings.offset(i_0 as isize)).mobj;
                if !mo2_0.is_null() {
                    if !((*mo2_0).type_0 as libc::c_uint
                        != MT_BOSS3WAYPOINT as libc::c_int as libc::c_uint)
                    {
                        if !((*mapthings.offset(i_0 as isize))
                            .args[0 as libc::c_int as usize] != (*mobj).threshold)
                        {
                            P_SetTarget2(&mut (*mobj).tracer, mo2_0);
                            break;
                        }
                    }
                }
                ICNT_4524 = ICNT_4524.wrapping_add(1);
                ICNT_4524;
            }
        }
        if ((*mobj).tracer).is_null() {
            CONS_Debug(
                0x80 as libc::c_int,
                b"Error: Boss 3 was unable to find specified waypoint: %d, %d\n\0"
                    as *const u8 as *const libc::c_char,
                (*mobj).threshold,
                (*mobj).cusval,
            );
            return;
        }
        if (*mobj).movedir != 0 || (*mobj).health <= (*(*mobj).info).damage {
            speed = (*(*mobj).info).speed * 2 as libc::c_int;
        } else {
            speed = (*(*mobj).info).speed;
        }
        if (*(*mobj).tracer).x == (*mobj).x && (*(*mobj).tracer).y == (*mobj).y {
            dist = P_AproxDistance(
                P_AproxDistance(
                    (*(*mobj).tracer).x - (*mobj).x,
                    (*(*mobj).tracer).y - (*mobj).y,
                ),
                (*(*mobj).tracer).z + (*mobj).movefactor - (*mobj).z,
            );
            if dist < 1 as libc::c_int {
                dist = 1 as libc::c_int;
            }
            (*mobj)
                .momx = FixedMul(FixedDiv((*(*mobj).tracer).x - (*mobj).x, dist), speed);
            (*mobj)
                .momy = FixedMul(FixedDiv((*(*mobj).tracer).y - (*mobj).y, dist), speed);
            (*mobj)
                .momz = FixedMul(
                FixedDiv((*(*mobj).tracer).z + (*mobj).movefactor - (*mobj).z, dist),
                speed,
            );
            if (*mobj).momx != 0 as libc::c_int || (*mobj).momy != 0 as libc::c_int {
                (*mobj)
                    .angle = R_PointToAngle2(
                    0 as libc::c_int,
                    0 as libc::c_int,
                    (*mobj).momx,
                    (*mobj).momy,
                );
            }
        }
        if dist <= speed {
            P_UnsetThingPosition(mobj);
            (*mobj).x = (*(*mobj).tracer).x;
            (*mobj).y = (*(*mobj).tracer).y;
            (*mobj).z = (*(*mobj).tracer).z + (*mobj).movefactor;
            (*mobj).momz = 0 as libc::c_int;
            (*mobj).momy = (*mobj).momz;
            (*mobj).momx = (*mobj).momy;
            P_SetThingPosition(mobj);
            if (*mobj).movefactor == 0 {
                let mut i_1: uint8_t = 0;
                let mut numtospawn: uint8_t = 24 as libc::c_int as uint8_t;
                let mut ang: angle_t = 0 as libc::c_int as angle_t;
                let mut interval: angle_t = FixedAngle(
                    ((360 as libc::c_int) << 16 as libc::c_int)
                        / numtospawn as libc::c_int,
                );
                let mut shock: *mut mobj_t = 0 as *mut mobj_t;
                let mut sfirst: *mut mobj_t = 0 as *mut mobj_t;
                let mut sprev: *mut mobj_t = 0 as *mut mobj_t;
                (*mobj).movecount = (*mobj).health + 1 as libc::c_int;
                (*mobj)
                    .movefactor = -(512 as libc::c_int)
                    * ((1 as libc::c_int) << 16 as libc::c_int);
                i_1 = 0 as libc::c_int as uint8_t;
                while (i_1 as libc::c_int) < numtospawn as libc::c_int {
                    shock = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, MT_SHOCKWAVE);
                    P_SetTarget2(&mut (*shock).target, mobj);
                    (*shock).fuse = (*(*shock).info).painchance;
                    if i_1 as libc::c_int % 2 as libc::c_int == 0 as libc::c_int {
                        P_SetMobjState(shock, (*(*shock).state).nextstate);
                    }
                    if sprev.is_null() {
                        sfirst = shock;
                    } else {
                        if i_1 as libc::c_int
                            == numtospawn as libc::c_int - 1 as libc::c_int
                        {
                            P_SetTarget2(&mut (*shock).hnext, sfirst);
                        }
                        P_SetTarget2(&mut (*sprev).hnext, shock);
                    }
                    P_Thrust(shock, ang, (*(*shock).info).speed);
                    ang = ang.wrapping_add(interval);
                    sprev = shock;
                    i_1 = i_1.wrapping_add(1);
                    i_1;
                }
                S_StartSound(mobj as *const libc::c_void, (*(*shock).info).seesound);
                P_BossTargetPlayer(mobj, true_0 as libc::c_int);
                if !((*mobj).target).is_null() && !((*(*mobj).target).player).is_null() {
                    P_SetMobjState(mobj, (*(*mobj).info).missilestate);
                }
            } else if (*mobj).flags2
                & (MF2_STRONGBOX as libc::c_int | MF2_CLASSICPUSH as libc::c_int)
                    as uint32_t != 0
            {
                (*mobj).flags2
                    &= !(MF2_STRONGBOX as libc::c_int | MF2_CLASSICPUSH as libc::c_int)
                        as uint32_t;
                (*mobj).reactiontime = 1 as libc::c_int;
                (*mobj).movedir = 0 as libc::c_int as angle_t;
            } else {
                (*mobj).flags2 |= MF2_STRONGBOX as libc::c_int as uint32_t;
                if (*mobj).health > 0 as libc::c_int {
                    (*mobj).movefactor = 0 as libc::c_int;
                }
            }
        }
    }
}
unsafe extern "C" fn P_Boss4MoveCage(
    mut mobj: *mut mobj_t,
    mut delta: fixed_t,
) -> boolean {
    let mut snum: int32_t = 0;
    let mut sector: *mut sector_t = 0 as *mut sector_t;
    let mut gotcage: boolean = false_0 as libc::c_int;
    if ((*mobj).spawnpoint).is_null() {
        return false_0 as libc::c_int;
    }
    let mut ICNT_4643: size_t = 0 as libc::c_int as size_t;
    loop {
        snum = Tag_Iterate_Sectors(
            (*(*mobj).spawnpoint).args[4 as libc::c_int as usize] as mtag_t,
            ICNT_4643,
        );
        if !(snum >= 0 as libc::c_int) {
            break;
        }
        sector = &mut *sectors.offset(snum as isize) as *mut sector_t;
        (*sector).floorheight += delta;
        (*sector).ceilingheight += delta;
        P_CheckSector(sector, true_0 as libc::c_int);
        gotcage = true_0 as libc::c_int;
        ICNT_4643 = ICNT_4643.wrapping_add(1);
        ICNT_4643;
    }
    return gotcage;
}
unsafe extern "C" fn P_Boss4MoveSpikeballs(
    mut mobj: *mut mobj_t,
    mut angle: angle_t,
    mut fz: fixed_t,
) {
    let mut s: int32_t = 0;
    let mut base: *mut mobj_t = mobj;
    let mut seg: *mut mobj_t = 0 as *mut mobj_t;
    let mut dist: fixed_t = 0;
    let mut bz: fixed_t = (*mobj).watertop + ((8 as libc::c_int) << 16 as libc::c_int);
    loop {
        base = (*base).tracer;
        if base.is_null() {
            break;
        }
        seg = base;
        dist = 172 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
        s = 9 as libc::c_int;
        while !seg.is_null() {
            P_MoveOrigin(
                seg,
                (*mobj).x + P_ReturnThrustX(mobj, angle, dist),
                (*mobj).y + P_ReturnThrustY(mobj, angle, dist),
                bz
                    + FixedMul(
                        fz,
                        FixedDiv(
                            s << 16 as libc::c_int,
                            (9 as libc::c_int) << 16 as libc::c_int,
                        ),
                    ),
            );
            seg = (*seg).hnext;
            dist += 124 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            s -= 1;
            s;
        }
        angle = (angle as libc::c_uint)
            .wrapping_add(
                (0xffffffff as libc::c_uint)
                    .wrapping_div(3 as libc::c_int as libc::c_uint),
            ) as angle_t as angle_t;
    };
}
unsafe extern "C" fn P_Boss4PinchSpikeballs(
    mut mobj: *mut mobj_t,
    mut angle: angle_t,
    mut dz: fixed_t,
) {
    let mut s: int32_t = 0;
    let mut base: *mut mobj_t = mobj;
    let mut seg: *mut mobj_t = 0 as *mut mobj_t;
    let mut workx: fixed_t = 0;
    let mut worky: fixed_t = 0;
    let mut dx: fixed_t = 0;
    let mut dy: fixed_t = 0;
    let mut bz: fixed_t = (*mobj).watertop + ((8 as libc::c_int) << 16 as libc::c_int);
    let mut rad: fixed_t = (9 as libc::c_int * 132 as libc::c_int) << 16 as libc::c_int;
    let mut originx: fixed_t = 0;
    let mut originy: fixed_t = 0;
    if !((*mobj).spawnpoint).is_null() {
        originx = ((*(*mobj).spawnpoint).x as libc::c_int) << 16 as libc::c_int;
        originy = ((*(*mobj).spawnpoint).y as libc::c_int) << 16 as libc::c_int;
    } else {
        originx = (*mobj).x;
        originy = (*mobj).y;
    }
    dz /= 9 as libc::c_int;
    loop {
        base = (*base).tracer;
        if base.is_null() {
            break;
        }
        dx = (originx + P_ReturnThrustX(mobj, angle, rad) - (*mobj).x)
            / 9 as libc::c_int;
        dy = (originy + P_ReturnThrustY(mobj, angle, rad) - (*mobj).y)
            / 9 as libc::c_int;
        workx = (*mobj).x
            + P_ReturnThrustX(mobj, angle, (112 as libc::c_int) << 16 as libc::c_int);
        worky = (*mobj).y
            + P_ReturnThrustY(mobj, angle, (112 as libc::c_int) << 16 as libc::c_int);
        seg = base;
        s = 9 as libc::c_int;
        while !seg.is_null() {
            (*seg).z = bz + dz * (9 as libc::c_int - s);
            P_TryMove(seg, workx + dx * s, worky + dy * s, true_0 as libc::c_int);
            seg = (*seg).hnext;
            s -= 1;
            s;
        }
        angle = (angle as libc::c_uint)
            .wrapping_add(
                (0xffffffff as libc::c_uint)
                    .wrapping_div(3 as libc::c_int as libc::c_uint),
            ) as angle_t as angle_t;
    };
}
unsafe extern "C" fn P_Boss4DestroyCage(mut mobj: *mut mobj_t) {
    let mut snum: int32_t = 0;
    let mut a: size_t = 0;
    let mut sector: *mut sector_t = 0 as *mut sector_t;
    let mut rsec: *mut sector_t = 0 as *mut sector_t;
    let mut rover: *mut ffloor_t = 0 as *mut ffloor_t;
    if ((*mobj).spawnpoint).is_null() {
        return;
    }
    let mut ICNT_4730: size_t = 0 as libc::c_int as size_t;
    loop {
        snum = Tag_Iterate_Sectors(
            (*(*mobj).spawnpoint).args[4 as libc::c_int as usize] as mtag_t,
            ICNT_4730,
        );
        if !(snum >= 0 as libc::c_int) {
            break;
        }
        sector = &mut *sectors.offset(snum as isize) as *mut sector_t;
        a = 0 as libc::c_int as size_t;
        while a < (*sector).numattached {
            rsec = &mut *sectors
                .offset(*((*sector).attached).offset(a as isize) as isize)
                as *mut sector_t;
            rover = (*rsec).ffloors;
            while !rover.is_null() {
                if (*rover).fofflags as libc::c_uint
                    & FOF_EXISTS as libc::c_int as libc::c_uint != 0
                    && (*rover).secnum == snum as size_t
                {
                    if (*rover).fofflags as libc::c_uint
                        & FOF_RENDERALL as libc::c_int as libc::c_uint != 0
                    {
                        EV_CrumbleChain(rsec, rover);
                    } else {
                        (*rover)
                            .fofflags = ::core::mem::transmute::<
                            libc::c_uint,
                            ffloortype_e,
                        >(
                            (*rover).fofflags as libc::c_uint
                                & !(FOF_EXISTS as libc::c_int) as libc::c_uint,
                        );
                        (*sector).moved = true_0 as libc::c_int;
                        (*rsec).moved = true_0 as libc::c_int;
                    }
                }
                rover = (*rover).next;
            }
            a = a.wrapping_add(1);
            a;
        }
        ICNT_4730 = ICNT_4730.wrapping_add(1);
        ICNT_4730;
    };
}
unsafe extern "C" fn P_Boss4PopSpikeballs(mut mobj: *mut mobj_t) {
    let mut base: *mut mobj_t = (*mobj).tracer;
    let mut seg: *mut mobj_t = 0 as *mut mobj_t;
    let mut next: *mut mobj_t = 0 as *mut mobj_t;
    P_SetTarget2(&mut (*mobj).tracer, 0 as *mut mobj_t);
    while !base.is_null() {
        next = (*base).tracer;
        P_SetTarget2(&mut (*base).tracer, 0 as *mut mobj_t);
        seg = base;
        while !seg.is_null() {
            if (*seg).health != 0 {
                P_KillMobj(
                    seg,
                    0 as *mut mobj_t,
                    0 as *mut mobj_t,
                    0 as libc::c_int as uint8_t,
                );
            }
            seg = (*seg).hnext;
        }
        base = next;
    }
}
unsafe extern "C" fn P_Boss4Thinker(mut mobj: *mut mobj_t) {
    let mut movespeed: fixed_t = 0 as libc::c_int;
    if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long as statenum_t
        as libc::c_uint == (*(*mobj).info).spawnstate as libc::c_uint
    {
        if (*mobj).flags2 & MF2_FRET as libc::c_int as uint32_t != 0
            && (*mobj).health > (*(*mobj).info).damage
        {
            (*mobj).flags2 &= !(MF2_FRET as libc::c_int) as uint32_t;
        }
        (*mobj).reactiontime = 0 as libc::c_int;
    }
    if (*mobj).health == 0 {
        if !((*mobj).tracer).is_null() {
            P_Boss4DestroyCage(mobj);
            P_Boss4PopSpikeballs(mobj);
        }
        return;
    }
    if (*mobj).movedir != 0 {
        let mut oldmovecount: int32_t = (*mobj).movecount;
        if (*mobj).movedir == 3 as libc::c_int as angle_t {
            movespeed = -((210 as libc::c_int)
                << (16 as libc::c_int >> 1 as libc::c_int));
        } else if (*mobj).movedir > 3 as libc::c_int as angle_t {
            movespeed = (420 as libc::c_int) << (16 as libc::c_int >> 1 as libc::c_int);
            movespeed
                += 420 as libc::c_int * ((*(*mobj).info).damage - (*mobj).health)
                    << (16 as libc::c_int >> 1 as libc::c_int);
            if (*mobj).movedir == 4 as libc::c_int as angle_t {
                movespeed = -movespeed;
            }
        } else {
            movespeed = (170 as libc::c_int) << (16 as libc::c_int >> 1 as libc::c_int);
            movespeed
                += 50 as libc::c_int * ((*(*mobj).info).spawnhealth - (*mobj).health)
                    << (16 as libc::c_int >> 1 as libc::c_int);
            if (*mobj).movedir == 2 as libc::c_int as angle_t {
                movespeed = -movespeed;
            }
            if (*mobj).movefactor != 0 {
                movespeed /= 2 as libc::c_int;
            } else if (*mobj).threshold != 0 {
                let mut maxtimer: int32_t = 35 as libc::c_int
                    + 35 as libc::c_int * ((*(*mobj).info).spawnhealth - (*mobj).health)
                        / 10 as libc::c_int;
                if maxtimer < 1 as libc::c_int {
                    maxtimer = 1 as libc::c_int;
                }
                maxtimer = (*mobj).threshold * movespeed / (2 as libc::c_int * maxtimer);
                movespeed -= maxtimer;
            }
        }
        (*mobj).movecount
            += movespeed
                + 360 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
        (*mobj).movecount
            %= 360 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
        if (oldmovecount >> 16 as libc::c_int) % 120 as libc::c_int >= 60 as libc::c_int
            && !(((*mobj).movecount >> 16 as libc::c_int) % 120 as libc::c_int
                >= 60 as libc::c_int)
        {
            S_StartSound(0 as *const libc::c_void, sfx_mswing);
        }
    }
    match (*mobj).movedir {
        0 => {
            if (*mobj).movecount == 0 as libc::c_int {
                let mut z: fixed_t = 0;
                let mut i: int32_t = 0;
                let mut arm: int32_t = 0;
                let mut seg: *mut mobj_t = 0 as *mut mobj_t;
                let mut base: *mut mobj_t = mobj;
                (*mobj).watertop = (*mobj).z;
                z = (*mobj).z + (*mobj).height / 2 as libc::c_int
                    - mobjinfo[MT_EGGMOBILE4_MACE as libc::c_int as usize].height
                        / 2 as libc::c_int;
                arm = 0 as libc::c_int;
                while arm < 3 as libc::c_int {
                    seg = P_SpawnMobj((*mobj).x, (*mobj).y, z, MT_EGGMOBILE4_MACE);
                    P_SetTarget2(&mut (*base).tracer, seg);
                    base = seg;
                    P_SetTarget2(&mut (*seg).target, mobj);
                    i = 0 as libc::c_int;
                    while i < 9 as libc::c_int {
                        P_SetTarget2(
                            &mut (*seg).hnext,
                            P_SpawnMobj((*mobj).x, (*mobj).y, z, MT_EGGMOBILE4_MACE),
                        );
                        P_SetTarget2(&mut (*(*seg).hnext).hprev, seg);
                        seg = (*seg).hnext;
                        i += 1;
                        i;
                    }
                    arm += 1;
                    arm;
                }
                (*mobj)
                    .movecount = 800 as libc::c_int
                    * ((1 as libc::c_int) << 16 as libc::c_int);
                if P_Boss4MoveCage(mobj, (*mobj).movecount) == 0 {
                    (*mobj).movecount = 0 as libc::c_int;
                    (*mobj).extravalue1 = 1 as libc::c_int;
                    (*mobj).movedir = ((*mobj).movedir).wrapping_add(1);
                    (*mobj).movedir;
                } else {
                    P_Boss4MoveSpikeballs(
                        mobj,
                        0 as libc::c_int as angle_t,
                        (*mobj).movecount,
                    );
                }
            } else {
                let mut oldz: fixed_t = (*mobj).movecount;
                (*mobj).threshold
                    -= 5 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
                (*mobj).movecount += (*mobj).threshold;
                if (*mobj).movecount <= 0 as libc::c_int {
                    (*mobj).flags2 &= !(MF2_INVERTAIMABLE as libc::c_int) as uint32_t;
                    (*mobj).movecount = 0 as libc::c_int;
                    (*mobj).movedir = ((*mobj).movedir).wrapping_add(1);
                    (*mobj).movedir;
                }
                P_Boss4MoveCage(mobj, (*mobj).movecount - oldz);
                P_Boss4MoveSpikeballs(
                    mobj,
                    0 as libc::c_int as angle_t,
                    (*mobj).movecount,
                );
            }
            return;
        }
        1 | 2 => {}
        3 => {
            let mut z_0: fixed_t = 0;
            if (*mobj).z < (*mobj).watertop + ((400 as libc::c_int) << 16 as libc::c_int)
            {
                (*mobj)
                    .momz = 8 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            } else {
                (*mobj).movefactor = 0 as libc::c_int;
                (*mobj).momz = (*mobj).movefactor;
                (*mobj).threshold = (1110 as libc::c_int) << 16 as libc::c_int;
                S_StartSound(0 as *const libc::c_void, sfx_s3k60);
                (*mobj).movedir = ((*mobj).movedir).wrapping_add(1);
                (*mobj).movedir;
            }
            z_0 = (*mobj).z - (*mobj).watertop
                - mobjinfo[MT_EGGMOBILE4_MACE as libc::c_int as usize].height
                - (*mobj).height / 2 as libc::c_int;
            if z_0 < (8 as libc::c_int) << 16 as libc::c_int {
                P_Boss4MoveSpikeballs(
                    mobj,
                    FixedAngle((*mobj).movecount),
                    0 as libc::c_int,
                );
            } else {
                P_Boss4PinchSpikeballs(mobj, FixedAngle((*mobj).movecount), z_0);
            }
            return;
        }
        4 | 5 => {
            (*mobj)
                .angle = ((*mobj).angle)
                .wrapping_sub(FixedAngle(movespeed / 8 as libc::c_int));
            if (*mobj).movefactor != (*mobj).threshold {
                if (*mobj).threshold - (*mobj).movefactor
                    < (1 as libc::c_int) << 16 as libc::c_int
                {
                    (*mobj).movefactor = (*mobj).threshold;
                    (*mobj).flags2 &= !(MF2_FRET as libc::c_int) as uint32_t;
                } else {
                    (*mobj).movefactor
                        += ((*mobj).threshold - (*mobj).movefactor) / 8 as libc::c_int;
                }
            }
            if !((*mobj).spawnpoint).is_null() {
                P_TryMove(
                    mobj,
                    (((*(*mobj).spawnpoint).x as libc::c_int) << 16 as libc::c_int)
                        - P_ReturnThrustX(mobj, (*mobj).angle, (*mobj).movefactor),
                    (((*(*mobj).spawnpoint).y as libc::c_int) << 16 as libc::c_int)
                        - P_ReturnThrustY(mobj, (*mobj).angle, (*mobj).movefactor),
                    true_0 as libc::c_int,
                );
            }
            P_Boss4PinchSpikeballs(
                mobj,
                FixedAngle((*mobj).movecount),
                (*mobj).z - (*mobj).watertop
                    - mobjinfo[MT_EGGMOBILE4_MACE as libc::c_int as usize].height
                    - (*mobj).height / 2 as libc::c_int,
            );
            if ((*mobj).target).is_null() || (*(*mobj).target).health == 0 {
                P_SupermanLook4Players(mobj);
            }
            return;
        }
        _ => return,
    }
    if (*mobj).reactiontime == 1 as libc::c_int {
        let mut oldz_0: fixed_t = (*mobj).movefactor;
        if (*mobj).movefactor
            != 128 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
        {
            if (*mobj).movefactor
                < 128 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
            {
                (*mobj).movefactor
                    += 8 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
                if oldz_0 == 0 {
                    (*mobj)
                        .threshold = 5 as libc::c_int * 35 as libc::c_int
                        - 35 as libc::c_int
                            * ((*(*mobj).info).spawnhealth - (*mobj).health)
                            / 2 as libc::c_int;
                    if (*mobj).threshold < 1 as libc::c_int {
                        (*mobj).threshold = 1 as libc::c_int;
                    }
                }
            } else {
                (*mobj)
                    .movefactor = 128 as libc::c_int
                    * ((1 as libc::c_int) << 16 as libc::c_int);
            }
            P_Boss4MoveCage(mobj, (*mobj).movefactor - oldz_0);
        }
    } else if (*mobj).movefactor != 0 {
        let mut oldz_1: fixed_t = (*mobj).movefactor;
        (*mobj).movefactor
            -= 4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
        if (*mobj).movefactor < 0 as libc::c_int {
            (*mobj).movefactor = 0 as libc::c_int;
        }
        P_Boss4MoveCage(mobj, (*mobj).movefactor - oldz_1);
        if (*mobj).movefactor == 0 {
            if (*mobj).health <= (*(*mobj).info).damage {
                P_Boss4DestroyCage(mobj);
                (*mobj).movedir = 3 as libc::c_int as angle_t;
                if !((*mobj).spawnpoint).is_null() {
                    P_LinedefExecute(
                        (*(*mobj).spawnpoint).args[4 as libc::c_int as usize] as int16_t,
                        mobj,
                        0 as *mut sector_t,
                    );
                }
                P_Boss4MoveSpikeballs(
                    mobj,
                    FixedAngle((*mobj).movecount),
                    0 as libc::c_int,
                );
                var1 = 3 as libc::c_int;
                A_BossJetFume(mobj);
                return;
            }
            if !((*mobj).spawnpoint).is_null() {
                P_LinedefExecute(
                    ((*(*mobj).spawnpoint).args[5 as libc::c_int as usize]
                        - ((*(*mobj).info).spawnhealth - (*mobj).health)) as int16_t,
                    mobj,
                    0 as *mut sector_t,
                );
            }
            (*mobj)
                .threshold = 35 as libc::c_int
                + 35 as libc::c_int * ((*(*mobj).info).spawnhealth - (*mobj).health)
                    / 10 as libc::c_int;
            if (*mobj).threshold < 1 as libc::c_int {
                (*mobj).threshold = 1 as libc::c_int;
            }
        }
    }
    P_Boss4MoveSpikeballs(mobj, FixedAngle((*mobj).movecount), (*mobj).movefactor);
    if (*mobj).threshold != 0 {
        if (*mobj).flags2 & MF2_FRET as libc::c_int as uint32_t == 0
            && {
                (*mobj).threshold -= 1;
                (*mobj).threshold == 0
            }
        {
            if (*mobj).reactiontime == 1 as libc::c_int {
                P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
                (*mobj).reactiontime = 0 as libc::c_int;
            }
        }
    }
    if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long as statenum_t
        as libc::c_uint != (*(*mobj).info).spawnstate as libc::c_uint
    {
        return;
    }
    if (*mobj).health <= (*(*mobj).info).damage {
        P_Boss4DestroyCage(mobj);
        (*mobj).movedir = 3 as libc::c_int as angle_t;
        if !((*mobj).spawnpoint).is_null() {
            P_LinedefExecute(
                (*(*mobj).spawnpoint).args[4 as libc::c_int as usize] as int16_t,
                mobj,
                0 as *mut sector_t,
            );
        }
        var1 = 3 as libc::c_int;
        A_BossJetFume(mobj);
        return;
    }
    (*mobj).reactiontime = 0 as libc::c_int;
    if ((*mobj).target).is_null() || (*(*mobj).target).health == 0 {
        P_SupermanLook4Players(mobj);
    }
    A_FaceTarget(mobj);
}
unsafe extern "C" fn P_Boss5Thinker(mut mobj: *mut mobj_t) {
    if (*mobj).health == 0 {
        if (*mobj).fuse != 0 {
            if (*mobj).flags2 & MF2_SLIDEPUSH as libc::c_int as uint32_t != 0 {
                let mut trans: int32_t = 10 as libc::c_int
                    - 10 as libc::c_int * (*mobj).fuse / 70 as libc::c_int;
                if trans > 9 as libc::c_int {
                    trans = 9 as libc::c_int;
                }
                if trans < 0 as libc::c_int {
                    trans = 0 as libc::c_int;
                }
                (*mobj)
                    .frame = (*mobj).frame & !(0xf0000 as libc::c_int) as uint32_t
                    | (trans << 16 as libc::c_int) as uint32_t;
                if (*mobj).fuse & 1 as libc::c_int == 0 {
                    (*mobj).colorized = ((*mobj).colorized == 0) as libc::c_int;
                    (*mobj).frame ^= 0x100000 as libc::c_int as uint32_t;
                }
            }
            return;
        }
        if (*mobj).state
            == &mut *states.as_mut_ptr().offset((*(*mobj).info).xdeathstate as isize)
                as *mut state_t
        {
            (*mobj).momz
                -= 2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                    / 3 as libc::c_int;
        } else if !((*mobj).tracer).is_null()
            && P_AproxDistance(
                (*(*mobj).tracer).x - (*mobj).x,
                (*(*mobj).tracer).y - (*mobj).y,
            ) < 2 as libc::c_int * (*mobj).radius
        {
            (*mobj).flags &= !(MF_NOCLIP as libc::c_int) as uint32_t;
        }
    } else if (*mobj).flags2 & MF2_FRET as libc::c_int as uint32_t != 0
        && leveltime & 1 as libc::c_int as tic_t != 0
        && (*mobj).state
            != &mut *states.as_mut_ptr().offset(S_FANG_PAIN1 as libc::c_int as isize)
                as *mut state_t
        && (*mobj).state
            != &mut *states.as_mut_ptr().offset(S_FANG_PAIN2 as libc::c_int as isize)
                as *mut state_t
    {
        (*mobj).flags2 |= MF2_DONTDRAW as libc::c_int as uint32_t;
    } else {
        (*mobj).flags2 &= !(MF2_DONTDRAW as libc::c_int) as uint32_t;
    }
    if (*mobj).state
        == &mut *states.as_mut_ptr().offset(S_FANG_BOUNCE3 as libc::c_int as isize)
            as *mut state_t
        || (*mobj).state
            == &mut *states.as_mut_ptr().offset(S_FANG_BOUNCE4 as libc::c_int as isize)
                as *mut state_t
        || (*mobj).state
            == &mut *states
                .as_mut_ptr()
                .offset(S_FANG_PINCHBOUNCE3 as libc::c_int as isize) as *mut state_t
        || (*mobj).state
            == &mut *states
                .as_mut_ptr()
                .offset(S_FANG_PINCHBOUNCE4 as libc::c_int as isize) as *mut state_t
    {
        if P_MobjFlip(mobj) as libc::c_int * (*mobj).momz > 0 as libc::c_int
            && abs((*mobj).momx)
                < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
            && abs((*mobj).momy)
                < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
            && P_IsObjectOnGround(mobj) == 0
        {
            let mut prevtarget: *mut mobj_t = (*mobj).target;
            P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
            var2 = 0 as libc::c_int;
            var1 = var2;
            A_DoNPCPain(mobj);
            P_SetTarget2(&mut (*mobj).target, prevtarget);
            P_SetMobjState(mobj, S_FANG_WALLHIT);
            (*mobj).extravalue2 += 1;
            (*mobj).extravalue2;
        }
    }
}
unsafe extern "C" fn P_Boss7Thinker(mut mobj: *mut mobj_t) {
    if ((*mobj).target).is_null()
        || (*(*mobj).target).flags & MF_SHOOTABLE as libc::c_int as uint32_t == 0
    {
        if P_BossTargetPlayer(mobj, false_0 as libc::c_int) != 0 {
            return;
        }
        P_SetMobjStateNF(mobj, (*(*mobj).info).spawnstate);
        return;
    }
    if (*mobj).health >= (*(*mobj).info).spawnhealth
        && leveltime & 14 as libc::c_int as tic_t == 0 as libc::c_int as tic_t
    {
        let mut smoke: *mut mobj_t = P_SpawnMobj(
            (*mobj).x,
            (*mobj).y,
            (*mobj).z + (*mobj).height,
            MT_SMOKE,
        );
        (*smoke).destscale = (*mobj).destscale;
        P_SetScale(smoke, (*smoke).destscale);
        (*smoke)
            .momz = FixedMul((1 as libc::c_int) << 16 as libc::c_int, (*smoke).scale);
    }
    if (*mobj).state
        == &mut *states.as_mut_ptr().offset(S_BLACKEGG_STND as libc::c_int as isize)
            as *mut state_t && (*mobj).tics == (*(*mobj).state).tics
    {
        (*mobj).reactiontime += P_RandomByte() as libc::c_int;
        if (*mobj).health <= (*(*mobj).info).damage {
            (*mobj).reactiontime /= 4 as libc::c_int;
        }
    } else if (*mobj).state
        == &mut *states.as_mut_ptr().offset(S_BLACKEGG_DIE4 as libc::c_int as isize)
            as *mut state_t && (*mobj).tics == (*(*mobj).state).tics
    {
        A_BossDeath(mobj);
    } else if (*mobj).state
        >= &mut *states.as_mut_ptr().offset(S_BLACKEGG_WALK1 as libc::c_int as isize)
            as *mut state_t
        && (*mobj).state
            <= &mut *states.as_mut_ptr().offset(S_BLACKEGG_WALK6 as libc::c_int as isize)
                as *mut state_t
    {
        A_Boss7Chase(mobj);
    } else if (*mobj).state
        == &mut *states.as_mut_ptr().offset(S_BLACKEGG_PAIN1 as libc::c_int as isize)
            as *mut state_t && (*mobj).tics == (*(*mobj).state).tics
    {
        if (*mobj).health > 0 as libc::c_int {
            (*mobj).health -= 1;
            (*mobj).health;
        }
        S_StartSound(
            0 as *const libc::c_void,
            (if (*mobj).health != 0 {
                sfx_behurt as libc::c_int
            } else {
                sfx_bedie2 as libc::c_int
            }) as sfxenum_t,
        );
        (*mobj).reactiontime /= 3 as libc::c_int;
        if (*mobj).health <= 0 as libc::c_int {
            let mut i: int32_t = 0;
            P_KillMobj(
                mobj,
                0 as *mut mobj_t,
                0 as *mut mobj_t,
                0 as libc::c_int as uint8_t,
            );
            i = 0 as libc::c_int;
            while i < 32 as libc::c_int {
                if !(playeringame[i as usize] == 0) {
                    P_AddPlayerScore(
                        &mut *players.as_mut_ptr().offset(i as isize),
                        1000 as libc::c_int as uint32_t,
                    );
                }
                i += 1;
                i;
            }
        }
    } else if (*mobj).state
        == &mut *states.as_mut_ptr().offset(S_BLACKEGG_PAIN35 as libc::c_int as isize)
            as *mut state_t && (*mobj).tics == 1 as libc::c_int
    {
        if (*mobj).health == (*(*mobj).info).damage {
            (*mobj).flags2 |= MF2_FRET as libc::c_int as uint32_t;
            P_SetMobjState(mobj, (*(*mobj).info).raisestate);
            if !((*mobj).spawnpoint).is_null() {
                P_LinedefExecute(
                    (*(*mobj).spawnpoint).args[4 as libc::c_int as usize] as int16_t,
                    mobj,
                    0 as *mut sector_t,
                );
            }
        }
    } else if (*mobj).state
        == &mut *states.as_mut_ptr().offset(S_BLACKEGG_HITFACE4 as libc::c_int as isize)
            as *mut state_t && (*mobj).tics == (*(*mobj).state).tics
    {
        let mut i_0: int32_t = 0;
        (*(*mobj).state).nextstate = (*(*mobj).info).painstate;
        S_StartSound(0 as *const libc::c_void, sfx_bedeen);
        i_0 = 0 as libc::c_int;
        while i_0 < 32 as libc::c_int {
            if !(playeringame[i_0 as usize] == 0 || players[i_0 as usize].spectator != 0)
            {
                if !(players[i_0 as usize].mo).is_null() {
                    if !((*players[i_0 as usize].mo).health <= 0 as libc::c_int) {
                        if !(P_AproxDistance(
                            (*players[i_0 as usize].mo).x - (*mobj).x,
                            (*players[i_0 as usize].mo).y - (*mobj).y,
                        ) > (*mobj).radius + (*players[i_0 as usize].mo).radius)
                        {
                            if (*players[i_0 as usize].mo).z
                                > (*mobj).z + (*mobj).height
                                    - ((1 as libc::c_int) << 16 as libc::c_int)
                                && (*players[i_0 as usize].mo).z
                                    < (*mobj).z + (*mobj).height
                                        + 128 as libc::c_int
                                            * ((1 as libc::c_int) << 16 as libc::c_int)
                            {
                                P_DamageMobj(
                                    players[i_0 as usize].mo,
                                    mobj,
                                    mobj,
                                    1 as libc::c_int,
                                    0 as libc::c_int as uint8_t,
                                );
                                (*(*mobj).state).nextstate = (*(*mobj).info).spawnstate;
                                S_StartSound(
                                    0 as *const libc::c_void,
                                    (sfx_bewar1 as libc::c_int + P_RandomKey(4 as libc::c_int))
                                        as sfxenum_t,
                                );
                            }
                        }
                    }
                }
            }
            i_0 += 1;
            i_0;
        }
    } else if (*mobj).state
        == &mut *states.as_mut_ptr().offset(S_BLACKEGG_GOOP as libc::c_int as isize)
            as *mut state_t
    {
        let fresh4 = (*mobj).movecount;
        (*mobj).movecount = (*mobj).movecount - 1;
        if fresh4 <= 0 as libc::c_int || ((*mobj).target).is_null() {
            P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
            return;
        }
        if leveltime & 15 as libc::c_int as tic_t == 0 as libc::c_int as tic_t {
            var1 = MT_CANNONBALL as libc::c_int;
            var2 = 2 as libc::c_int * 35 as libc::c_int
                + ((80 as libc::c_int) << 16 as libc::c_int);
            A_LobShot(mobj);
            S_StartSound(0 as *const libc::c_void, sfx_begoop);
        }
    } else if (*mobj).state
        == &mut *states.as_mut_ptr().offset(S_BLACKEGG_SHOOT2 as libc::c_int as isize)
            as *mut state_t
    {
        let mut missile: *mut mobj_t = 0 as *mut mobj_t;
        let fresh5 = (*mobj).movecount;
        (*mobj).movecount = (*mobj).movecount - 1;
        if fresh5 <= 0 as libc::c_int || ((*mobj).target).is_null() {
            P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
            return;
        }
        A_FaceTarget(mobj);
        missile = P_SpawnXYZMissile(
            mobj,
            (*mobj).target,
            MT_BLACKEGGMAN_GOOPFIRE,
            (*mobj).x
                + P_ReturnThrustX(
                    mobj,
                    ((*mobj).angle).wrapping_sub(0x40000000 as libc::c_int as angle_t),
                    FixedDiv(
                        (*mobj).radius,
                        3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                            / 2 as libc::c_int,
                    ) + 4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                ),
            (*mobj).y
                + P_ReturnThrustY(
                    mobj,
                    ((*mobj).angle).wrapping_sub(0x40000000 as libc::c_int as angle_t),
                    FixedDiv(
                        (*mobj).radius,
                        3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                            / 2 as libc::c_int,
                    ) + 4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                ),
            (*mobj).z
                + FixedDiv(
                    (*mobj).height,
                    3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                        / 2 as libc::c_int,
                ),
        );
        S_StopSound(missile as *mut libc::c_void);
        if leveltime & 1 as libc::c_int as tic_t != 0 {
            S_StartSound(0 as *const libc::c_void, sfx_beshot);
        }
    } else if (*mobj).state
        == &mut *states.as_mut_ptr().offset(S_BLACKEGG_JUMP1 as libc::c_int as isize)
            as *mut state_t && (*mobj).tics == 1 as libc::c_int
    {
        let mut hitspot: *mut mobj_t = 0 as *mut mobj_t;
        let mut mo2: *mut mobj_t = 0 as *mut mobj_t;
        let mut an: angle_t = 0;
        let mut dist: fixed_t = 0;
        let mut closestdist: fixed_t = 0;
        let mut vertical: fixed_t = 0;
        let mut horizontal: fixed_t = 0;
        let mut airtime: fixed_t = 5 as libc::c_int * 35 as libc::c_int;
        let mut waypointNum: int32_t = 0 as libc::c_int;
        let mut i_1: int32_t = 0;
        let mut j: int32_t = 0;
        let mut foundgoop: boolean = false_0 as libc::c_int;
        let mut closestNum: int32_t = 0;
        let mut bossid: uint8_t = (if !((*mobj).spawnpoint).is_null() {
            (*(*mobj).spawnpoint).args[0 as libc::c_int as usize]
        } else {
            0 as libc::c_int
        }) as uint8_t;
        i_1 = 0 as libc::c_int;
        while i_1 < 32 as libc::c_int {
            if !(playeringame[i_1 as usize] == 0 || players[i_1 as usize].spectator != 0)
            {
                if !(players[i_1 as usize].mo).is_null() {
                    if !((*players[i_1 as usize].mo).health <= 0 as libc::c_int) {
                        if players[i_1 as usize].powers[pw_carry as libc::c_int as usize]
                            as libc::c_int == CR_BRAKGOOP as libc::c_int
                        {
                            closestNum = -(1 as libc::c_int);
                            closestdist = 2147483647 as libc::c_int;
                            let mut ICNT_5298: size_t = 0 as libc::c_int as size_t;
                            loop {
                                j = Tag_Iterate_Things(bossid as mtag_t, ICNT_5298);
                                if !(j >= 0 as libc::c_int) {
                                    break;
                                }
                                mo2 = (*mapthings.offset(j as isize)).mobj;
                                if !mo2.is_null() {
                                    if !((*mo2).type_0 as libc::c_uint
                                        != MT_BOSS3WAYPOINT as libc::c_int as libc::c_uint)
                                    {
                                        if !((*mobj).health <= (*(*mobj).info).damage
                                            && (*mapthings.offset(j as isize))
                                                .args[1 as libc::c_int as usize] == 0)
                                        {
                                            dist = P_AproxDistance(
                                                (*players[i_1 as usize].mo).x - (*mo2).x,
                                                (*players[i_1 as usize].mo).y - (*mo2).y,
                                            );
                                            if closestNum == -(1 as libc::c_int) || dist < closestdist {
                                                closestNum = (*mapthings.offset(j as isize))
                                                    .args[1 as libc::c_int as usize];
                                                closestdist = dist;
                                                foundgoop = true_0 as libc::c_int;
                                            }
                                        }
                                    }
                                }
                                ICNT_5298 = ICNT_5298.wrapping_add(1);
                                ICNT_5298;
                            }
                            waypointNum = closestNum;
                            break;
                        }
                    }
                }
            }
            i_1 += 1;
            i_1;
        }
        if foundgoop == 0 {
            if (*mobj).z
                <= 1056 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                || (*mobj).health <= (*(*mobj).info).damage
            {
                waypointNum = 1 as libc::c_int + P_RandomKey(4 as libc::c_int);
            } else {
                waypointNum = 0 as libc::c_int;
            }
        }
        if !((*mobj).tracer).is_null()
            && (*(*mobj).tracer).type_0 as libc::c_uint
                == MT_BOSS3WAYPOINT as libc::c_int as libc::c_uint
            && !((*(*mobj).tracer).spawnpoint).is_null()
            && (*(*(*mobj).tracer).spawnpoint).args[1 as libc::c_int as usize]
                == waypointNum
        {
            if P_RandomFixed()
                < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
            {
                waypointNum += 1;
                waypointNum;
            } else {
                waypointNum -= 1;
                waypointNum;
            }
            if (*mobj).health <= (*(*mobj).info).damage {
                waypointNum = (waypointNum + 3 as libc::c_int) % 4 as libc::c_int
                    + 1 as libc::c_int;
            } else {
                waypointNum = (waypointNum + 5 as libc::c_int) % 5 as libc::c_int;
            }
        }
        let mut ICNT_5348: size_t = 0 as libc::c_int as size_t;
        loop {
            i_1 = Tag_Iterate_Things(bossid as mtag_t, ICNT_5348);
            if !(i_1 >= 0 as libc::c_int) {
                break;
            }
            mo2 = (*mapthings.offset(i_1 as isize)).mobj;
            if !mo2.is_null() {
                if !((*mo2).type_0 as libc::c_uint
                    != MT_BOSS3WAYPOINT as libc::c_int as libc::c_uint)
                {
                    if !((*mapthings.offset(i_1 as isize))
                        .args[1 as libc::c_int as usize] != waypointNum)
                    {
                        hitspot = mo2;
                        break;
                    }
                }
            }
            ICNT_5348 = ICNT_5348.wrapping_add(1);
            ICNT_5348;
        }
        if hitspot.is_null() {
            CONS_Debug(
                0x80 as libc::c_int,
                b"BlackEggman unable to find waypoint #%d!\n\0" as *const u8
                    as *const libc::c_char,
                waypointNum,
            );
            P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
            return;
        }
        P_SetTarget2(&mut (*mobj).tracer, hitspot);
        (*mobj)
            .angle = R_PointToAngle2((*mobj).x, (*mobj).y, (*hitspot).x, (*hitspot).y);
        an = (*mobj).angle;
        an >>= 19 as libc::c_int;
        dist = P_AproxDistance((*hitspot).x - (*mobj).x, (*hitspot).y - (*mobj).y);
        horizontal = dist / airtime;
        vertical = gravity * airtime / 2 as libc::c_int;
        (*mobj)
            .momx = FixedMul(
            horizontal,
            *finecosine.offset(an as isize) >> 16 as libc::c_int - 16 as libc::c_int,
        );
        (*mobj)
            .momy = FixedMul(
            horizontal,
            finesine[an as usize] >> 16 as libc::c_int - 16 as libc::c_int,
        );
        (*mobj).momz = vertical;
    } else if (*mobj).state
        == &mut *states.as_mut_ptr().offset(S_BLACKEGG_JUMP2 as libc::c_int as isize)
            as *mut state_t && (*mobj).z <= (*mobj).floorz
    {
        let mut i_2: int32_t = 0;
        let mut j_0: int32_t = 0;
        let mut ns: fixed_t = 0;
        let mut x: fixed_t = 0;
        let mut y: fixed_t = 0;
        let mut z: fixed_t = 0;
        let mut mo2_0: *mut mobj_t = 0 as *mut mobj_t;
        S_StartSound(0 as *const libc::c_void, sfx_befall);
        z = (*mobj).floorz;
        j_0 = 0 as libc::c_int;
        while j_0 < 2 as libc::c_int {
            i_2 = 0 as libc::c_int;
            while i_2 < 32 as libc::c_int {
                let fa: angle_t = (i_2 * 8192 as libc::c_int / 16 as libc::c_int
                    & 8192 as libc::c_int - 1 as libc::c_int) as angle_t;
                ns = 64 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
                x = (*mobj).x
                    + FixedMul(
                        finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                        ns,
                    );
                y = (*mobj).y
                    + FixedMul(
                        *finecosine.offset(fa as isize)
                            >> 16 as libc::c_int - 16 as libc::c_int,
                        ns,
                    );
                mo2_0 = P_SpawnMobj(x, y, z, MT_EXPLODE);
                ns = 16 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
                (*mo2_0)
                    .momx = FixedMul(
                    finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                    ns,
                );
                (*mo2_0)
                    .momy = FixedMul(
                    *finecosine.offset(fa as isize)
                        >> 16 as libc::c_int - 16 as libc::c_int,
                    ns,
                );
                i_2 += 1;
                i_2;
            }
            z -= 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            j_0 += 1;
            j_0;
        }
        i_2 = 0 as libc::c_int;
        while i_2 < 32 as libc::c_int {
            if !(playeringame[i_2 as usize] == 0 || players[i_2 as usize].spectator != 0)
            {
                if !(players[i_2 as usize].mo).is_null() {
                    if !((*players[i_2 as usize].mo).health <= 0 as libc::c_int) {
                        if !(P_AproxDistance(
                            (*players[i_2 as usize].mo).x - (*mobj).x,
                            (*players[i_2 as usize].mo).y - (*mobj).y,
                        ) > (*mobj).radius * 4 as libc::c_int)
                        {
                            if !((*players[i_2 as usize].mo).z
                                > (*mobj).z
                                    + 128 as libc::c_int
                                        * ((1 as libc::c_int) << 16 as libc::c_int))
                            {
                                if !((*players[i_2 as usize].mo).z
                                    < (*mobj).z
                                        - 64 as libc::c_int
                                            * ((1 as libc::c_int) << 16 as libc::c_int))
                                {
                                    P_DamageMobj(
                                        players[i_2 as usize].mo,
                                        mobj,
                                        mobj,
                                        1 as libc::c_int,
                                        0 as libc::c_int as uint8_t,
                                    );
                                    S_StartSound(
                                        0 as *const libc::c_void,
                                        (sfx_bewar1 as libc::c_int + P_RandomKey(4 as libc::c_int))
                                            as sfxenum_t,
                                    );
                                }
                            }
                        }
                    }
                }
            }
            i_2 += 1;
            i_2;
        }
        P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
    } else if (*mobj).state
        == &mut *states.as_mut_ptr().offset((*(*mobj).info).deathstate as isize)
            as *mut state_t && (*mobj).tics == (*(*mobj).state).tics
    {
        S_StartSound(
            0 as *const libc::c_void,
            (sfx_bedie1 as libc::c_int + (P_RandomFixed() & 1 as libc::c_int))
                as sfxenum_t,
        );
    }
}
unsafe extern "C" fn P_Boss9Thinker(mut mobj: *mut mobj_t) {
    let mut current_block: u64;
    if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long as statenum_t
        as libc::c_uint == (*(*mobj).info).spawnstate as libc::c_uint
    {
        (*mobj).flags2 &= !(MF2_FRET as libc::c_int) as uint32_t;
    }
    if ((*mobj).tracer).is_null() {
        let mut th: *mut thinker_t = 0 as *mut thinker_t;
        let mut mo2: *mut mobj_t = 0 as *mut mobj_t;
        let mut last: *mut mobj_t = 0 as *mut mobj_t;
        (*mobj).threshold = 0 as libc::c_int;
        (*mobj).reactiontime = 0 as libc::c_int;
        (*mobj)
            .watertop = (*mobj).floorz
            + 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
        var1 = 2 as libc::c_int;
        A_BossJetFume(mobj);
        th = (*thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)).next;
        while th
            != &mut *thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)
                as *mut thinker_t
        {
            if !((*th).function.acp1
                == ::core::mem::transmute::<
                    Option::<unsafe extern "C" fn(*mut thinker_t) -> ()>,
                    actionf_p1,
                >(
                    Some(
                        P_RemoveThinkerDelayed
                            as unsafe extern "C" fn(*mut thinker_t) -> (),
                    ),
                ))
            {
                mo2 = th as *mut mobj_t;
                if (*mo2).type_0 as libc::c_uint
                    == MT_BOSS9GATHERPOINT as libc::c_int as libc::c_uint
                {
                    if !last.is_null() {
                        P_SetTarget2(&mut (*last).hnext, mo2);
                    } else {
                        P_SetTarget2(&mut (*mobj).hnext, mo2);
                    }
                    P_SetTarget2(&mut (*mo2).hprev, last);
                    last = mo2;
                }
            }
            th = (*th).next;
        }
    }
    if (*mobj).health <= 0 as libc::c_int {
        return;
    }
    if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long as statenum_t
        as libc::c_uint == (*(*mobj).info).meleestate as libc::c_uint
    {
        P_InstaThrust(
            mobj,
            (*mobj).angle,
            -(4 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
        );
        P_TryMove(
            mobj,
            (*mobj).x + (*mobj).momx,
            (*mobj).y + (*mobj).momy,
            true_0 as libc::c_int,
        );
        (*mobj).momz -= gravity;
        if (*mobj).z < (*mobj).watertop
            || (*mobj).z
                < (*mobj).floorz
                    + 16 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
        {
            (*mobj)
                .watertop = (*mobj).floorz
                + 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
        }
        return;
    }
    if ((*mobj).target).is_null()
        || (*(*mobj).target).flags & MF_SHOOTABLE as libc::c_int as uint32_t == 0
    {
        if !((*mobj).hprev).is_null() {
            P_RemoveMobj((*mobj).hprev);
            P_SetTarget2(&mut (*mobj).hprev, 0 as *mut mobj_t);
        }
        P_BossTargetPlayer(mobj, false_0 as libc::c_int);
        if !((*mobj).target).is_null()
            && (P_IsObjectOnGround((*mobj).target) == 0
                || (*(*(*mobj).target).player).pflags as libc::c_uint
                    & PF_SPINNING as libc::c_int as libc::c_uint != 0)
        {
            P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
        }
        if ((*mobj).target).is_null() {
            if !((*mobj).hprev).is_null() {
                P_RemoveMobj((*mobj).hprev);
                P_SetTarget2(&mut (*mobj).hprev, 0 as *mut mobj_t);
            }
            P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
            (*mobj).fuse = 0 as libc::c_int;
            (*mobj)
                .momx = FixedDiv(
                (*mobj).momx,
                ((1 as libc::c_int) << 16 as libc::c_int)
                    + ((1 as libc::c_int) << 16 as libc::c_int >> 2 as libc::c_int),
            );
            (*mobj)
                .momy = FixedDiv(
                (*mobj).momy,
                ((1 as libc::c_int) << 16 as libc::c_int)
                    + ((1 as libc::c_int) << 16 as libc::c_int >> 2 as libc::c_int),
            );
            (*mobj)
                .momz = FixedDiv(
                (*mobj).momz,
                ((1 as libc::c_int) << 16 as libc::c_int)
                    + ((1 as libc::c_int) << 16 as libc::c_int >> 2 as libc::c_int),
            );
            (*mobj)
                .watertop = (*mobj).floorz
                + 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            (*mobj).momz = (*mobj).watertop - (*mobj).z >> 3 as libc::c_int;
            (*mobj).threshold = 0 as libc::c_int;
            (*mobj).movecount = 0 as libc::c_int;
            (*mobj).flags = (*(*mobj).info).flags;
            return;
        } else if (*mobj).fuse == 0 {
            (*mobj).fuse = 8 as libc::c_int * 35 as libc::c_int;
        }
    }
    let mut angle: angle_t = 0;
    if (*mobj).threshold != 0 || (*mobj).movecount != 0 {
        (*mobj).momz = ((*mobj).watertop - (*mobj).z) / 16 as libc::c_int;
    } else {
        (*mobj).momz = ((*mobj).watertop - (*mobj).z) / 40 as libc::c_int;
    }
    if (*mobj).movecount == 2 as libc::c_int {
        let mut spawner: *mut mobj_t = 0 as *mut mobj_t;
        let mut dist: fixed_t = 0 as libc::c_int;
        angle = 0x6000000 as libc::c_int as tic_t * leveltime;
        P_BossTargetPlayer(mobj, true_0 as libc::c_int);
        angle = R_PointToAngle2(
            (*mobj).x,
            (*mobj).y,
            (*(*mobj).target).x,
            (*(*mobj).target).y,
        );
        angle = angle.wrapping_sub((*mobj).angle);
        if angle < 0x80000000 as libc::c_uint {
            (*mobj)
                .angle = ((*mobj).angle)
                .wrapping_add(angle / 8 as libc::c_int as angle_t);
        } else {
            (*mobj)
                .angle = ((*mobj).angle)
                .wrapping_sub(InvAngle(angle) / 8 as libc::c_int as angle_t);
        }
        if (*mobj).health > (*(*mobj).info).damage {
            if !((*mobj).hprev).is_null() {
                (*(*mobj).hprev)
                    .destscale = ((1 as libc::c_int) << 16 as libc::c_int)
                    + (2 as libc::c_int * 35 as libc::c_int - (*mobj).fuse)
                        * (((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int)
                        / 35 as libc::c_int
                    + FixedMul(
                        *finecosine.offset((angle >> 19 as libc::c_int) as isize)
                            >> 16 as libc::c_int - 16 as libc::c_int,
                        ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                    );
                P_SetScale((*mobj).hprev, (*(*mobj).hprev).destscale);
                P_MoveOrigin(
                    (*mobj).hprev,
                    (*mobj).x,
                    (*mobj).y,
                    (*mobj).z + (*mobj).height / 2 as libc::c_int
                        - (*(*mobj).hprev).height / 2 as libc::c_int,
                );
                (*(*mobj).hprev).momx = (*mobj).momx;
                (*(*mobj).hprev).momy = (*mobj).momy;
                (*(*mobj).hprev).momz = (*mobj).momz;
            }
            if (*mobj).fuse > 35 as libc::c_int / 2 as libc::c_int {
                let mut shoottime: tic_t = 0;
                let mut worktime: tic_t = 0;
                let mut calctime: tic_t = 0;
                shoottime = (35 as libc::c_int
                    / (if (*mobj).extravalue1 == 3 as libc::c_int {
                        8 as libc::c_int
                    } else {
                        4 as libc::c_int
                    })) as tic_t;
                shoottime = shoottime.wrapping_add(shoottime >> 1 as libc::c_int);
                worktime = shoottime * ((*mobj).threshold / 2 as libc::c_int) as tic_t;
                calctime = ((*mobj).fuse - 35 as libc::c_int / 2 as libc::c_int)
                    as tic_t;
                if calctime <= worktime
                    && calctime % shoottime == 0 as libc::c_int as tic_t
                {
                    let mut missile: *mut mobj_t = 0 as *mut mobj_t;
                    missile = P_SpawnMissile(mobj, (*mobj).target, MT_MSGATHER);
                    S_StopSound(missile as *mut libc::c_void);
                    if (*mobj).extravalue1 >= 2 as libc::c_int {
                        P_SetScale(
                            missile,
                            (1 as libc::c_int) << 16 as libc::c_int >> 1 as libc::c_int,
                        );
                    }
                    (*missile).destscale = (*missile).scale >> 1 as libc::c_int;
                    (*missile).fuse = 35 as libc::c_int / 2 as libc::c_int;
                    (*missile)
                        .scalespeed = abs((*missile).destscale - (*missile).scale)
                        / (*missile).fuse;
                    (*missile).z -= (*missile).height / 2 as libc::c_int;
                    (*missile).momx *= -(1 as libc::c_int);
                    (*missile).momy *= -(1 as libc::c_int);
                    (*missile).momz *= -(1 as libc::c_int);
                    if (*mobj).extravalue1 == 2 as libc::c_int {
                        let mut i: uint8_t = 0;
                        let mut spread: *mut mobj_t = 0 as *mut mobj_t;
                        i = 0 as libc::c_int as uint8_t;
                        while (i as libc::c_int) < 5 as libc::c_int {
                            if !(i as libc::c_int == 2 as libc::c_int) {
                                spread = P_SpawnMobj(
                                    (*missile).x,
                                    (*missile).y,
                                    (*missile).z,
                                    (*missile).type_0,
                                );
                                (*spread)
                                    .angle = ((*missile).angle)
                                    .wrapping_add(
                                        (0x8000000 as libc::c_int / 2 as libc::c_int
                                            * (i as libc::c_int - 2 as libc::c_int)) as angle_t,
                                    );
                                P_InstaThrust(
                                    spread,
                                    (*spread).angle,
                                    -(*(*spread).info).speed,
                                );
                                (*spread).momz = (*missile).momz;
                                P_SetScale(spread, (*missile).scale);
                                (*spread).destscale = (*missile).destscale;
                                (*spread).scalespeed = (*missile).scalespeed;
                                (*spread).fuse = (*missile).fuse;
                                P_UnsetThingPosition(spread);
                                (*spread).x -= (*spread).fuse * (*spread).momx;
                                (*spread).y -= (*spread).fuse * (*spread).momy;
                                (*spread).z -= (*spread).fuse * (*spread).momz;
                                P_SetThingPosition(spread);
                            }
                            i = i.wrapping_add(1);
                            i;
                        }
                        P_InstaThrust(
                            missile,
                            (*missile).angle,
                            -(*(*missile).info).speed,
                        );
                    } else if (*mobj).extravalue1 >= 3 as libc::c_int {
                        let mut i_0: uint8_t = 0;
                        let mut spread_0: *mut mobj_t = 0 as *mut mobj_t;
                        (*(*mobj).target).z -= 4 as libc::c_int * (*missile).height;
                        i_0 = 0 as libc::c_int as uint8_t;
                        while (i_0 as libc::c_int) < 5 as libc::c_int {
                            if i_0 as libc::c_int != 2 as libc::c_int {
                                spread_0 = P_SpawnMissile(
                                    mobj,
                                    (*mobj).target,
                                    (*missile).type_0,
                                );
                                P_SetScale(spread_0, (*missile).scale);
                                (*spread_0).destscale = (*missile).destscale;
                                (*spread_0).fuse = (*missile).fuse;
                                (*spread_0).z -= (*spread_0).height / 2 as libc::c_int;
                                (*spread_0).momx *= -(1 as libc::c_int);
                                (*spread_0).momy *= -(1 as libc::c_int);
                                (*spread_0).momz *= -(1 as libc::c_int);
                                P_UnsetThingPosition(spread_0);
                                (*spread_0).x -= (*spread_0).fuse * (*spread_0).momx;
                                (*spread_0).y -= (*spread_0).fuse * (*spread_0).momy;
                                (*spread_0).z -= (*spread_0).fuse * (*spread_0).momz;
                                P_SetThingPosition(spread_0);
                            }
                            (*(*mobj).target).z += (*missile).height * 2 as libc::c_int;
                            i_0 = i_0.wrapping_add(1);
                            i_0;
                        }
                        (*(*mobj).target).z -= 6 as libc::c_int * (*missile).height;
                    }
                    P_UnsetThingPosition(missile);
                    (*missile).x -= (*missile).fuse * (*missile).momx;
                    (*missile).y -= (*missile).fuse * (*missile).momy;
                    (*missile).z -= (*missile).fuse * (*missile).momz;
                    P_SetThingPosition(missile);
                    S_StartSound(mobj as *const libc::c_void, sfx_s3kb3);
                }
            }
        }
        (*mobj).z += (*mobj).height / 2 as libc::c_int;
        spawner = (*mobj).hnext;
        while !spawner.is_null() {
            dist = P_AproxDistance((*spawner).x - (*mobj).x, (*spawner).y - (*mobj).y);
            if P_RandomRange(
                1 as libc::c_int,
                (dist >> 16 as libc::c_int) / 16 as libc::c_int,
            ) == 1 as libc::c_int
            {
                break;
            }
            spawner = (*spawner).hnext;
        }
        if !spawner.is_null() && dist != 0 {
            let mut missile_0: *mut mobj_t = P_SpawnMissile(spawner, mobj, MT_MSGATHER);
            (*missile_0)
                .fuse = dist / P_AproxDistance((*missile_0).momx, (*missile_0).momy);
            if (*missile_0).fuse <= 0 as libc::c_int {
                (*missile_0).fuse = 1 as libc::c_int;
            }
            if (*missile_0).fuse > (*mobj).fuse {
                P_RemoveMobj(missile_0);
            } else {
                if (*mobj).health > (*(*mobj).info).damage {
                    P_SetScale(
                        missile_0,
                        ((1 as libc::c_int) << 16 as libc::c_int) / 3 as libc::c_int,
                    );
                    (*missile_0).color = SKINCOLOR_MAGENTA as libc::c_int as uint16_t;
                } else {
                    P_SetScale(
                        missile_0,
                        ((1 as libc::c_int) << 16 as libc::c_int) / 5 as libc::c_int,
                    );
                    (*missile_0).color = SKINCOLOR_SUNSET as libc::c_int as uint16_t;
                }
                (*missile_0).destscale = (*missile_0).scale * 2 as libc::c_int;
                (*missile_0)
                    .scalespeed = abs((*missile_0).scale - (*missile_0).destscale)
                    / (*missile_0).fuse;
                (*missile_0).colorized = true_0 as libc::c_int;
            }
        }
        (*mobj).z -= (*mobj).height / 2 as libc::c_int;
    }
    if (*mobj).reactiontime != 0 && (*mobj).movecount == 3 as libc::c_int {
        (*mobj).reactiontime -= 1;
        (*mobj).reactiontime;
        if (*mobj).movedir == 0 as libc::c_int as angle_t
            || (*mobj).movedir == 2 as libc::c_int as angle_t
        {
            if (*(*(*mobj).target).player).powers[pw_tailsfly as libc::c_int as usize]
                != 0
            {
                (*mobj)
                    .watertop = (*(*mobj).target).z
                    + (*(*mobj).target).momz * 6 as libc::c_int;
            } else if (*(*mobj).target).floorz > (*mobj).floorz {
                (*mobj)
                    .watertop = (*(*mobj).target).floorz
                    + 16 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            } else {
                (*mobj)
                    .watertop = (*mobj).floorz
                    + 16 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            }
            if (*mobj).threshold % 4 as libc::c_int == 0 {
                (*mobj)
                    .angle = R_PointToAngle2(
                    (*mobj).x,
                    (*mobj).y,
                    (*(*mobj).target).x + (*(*mobj).target).momx * 4 as libc::c_int,
                    (*(*mobj).target).y + (*(*mobj).target).momy * 4 as libc::c_int,
                );
                if (*mobj).reactiontime == 0 {
                    S_StartSound(mobj as *const libc::c_void, sfx_zoom);
                }
            }
        }
        return;
    }
    if (*mobj).threshold != 0 && (*mobj).movecount != 2 as libc::c_int {
        let mut speed: fixed_t = 20 as libc::c_int
            * ((1 as libc::c_int) << 16 as libc::c_int)
            + FixedMul(
                40 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                FixedDiv(
                    (*(*mobj).info).spawnhealth - (*mobj).health << 16 as libc::c_int,
                    (*(*mobj).info).spawnhealth << 16 as libc::c_int,
                ),
            );
        let mut tries: uint8_t = 0 as libc::c_int as uint8_t;
        if (*mobj).movecount == 3 as libc::c_int
            && (*mobj).movedir == 1 as libc::c_int as angle_t
        {
            if (*mobj).threshold & 1 as libc::c_int == 0 {
                let mut missile_1: *mut mobj_t = 0 as *mut mobj_t;
                if (*(*mobj).info).seesound as u64 != 0 {
                    S_StartSound(mobj as *const libc::c_void, (*(*mobj).info).seesound);
                }
                P_SetMobjState(mobj, (*(*mobj).info).missilestate);
                if (*mobj).extravalue1 == 3 as libc::c_int {
                    (*mobj).reactiontime = 35 as libc::c_int / 16 as libc::c_int;
                } else {
                    (*mobj).reactiontime = 35 as libc::c_int / 8 as libc::c_int;
                }
                A_FaceTarget(mobj);
                missile_1 = P_SpawnMissile(
                    mobj,
                    (*mobj).target,
                    (*(*mobj).info).speed as mobjtype_t,
                );
                if (*mobj).extravalue1 >= 2 as libc::c_int {
                    (*missile_1)
                        .destscale = (1 as libc::c_int) << 16 as libc::c_int
                        >> 1 as libc::c_int;
                    P_SetScale(missile_1, (*missile_1).destscale);
                }
                (*missile_1).fuse = 3 as libc::c_int * 35 as libc::c_int;
                (*missile_1).z -= (*missile_1).height / 2 as libc::c_int;
                if (*mobj).extravalue1 == 2 as libc::c_int {
                    let mut i_1: uint8_t = 0;
                    let mut spread_1: *mut mobj_t = 0 as *mut mobj_t;
                    i_1 = 0 as libc::c_int as uint8_t;
                    while (i_1 as libc::c_int) < 5 as libc::c_int {
                        if !(i_1 as libc::c_int == 2 as libc::c_int) {
                            spread_1 = P_SpawnMobj(
                                (*missile_1).x,
                                (*missile_1).y,
                                (*missile_1).z,
                                (*missile_1).type_0,
                            );
                            (*spread_1)
                                .angle = ((*missile_1).angle)
                                .wrapping_add(
                                    (0x8000000 as libc::c_int / 2 as libc::c_int
                                        * (i_1 as libc::c_int - 2 as libc::c_int)) as angle_t,
                                );
                            P_InstaThrust(
                                spread_1,
                                (*spread_1).angle,
                                (*(*spread_1).info).speed,
                            );
                            (*spread_1).momz = (*missile_1).momz;
                            (*spread_1)
                                .destscale = (1 as libc::c_int) << 16 as libc::c_int
                                >> 1 as libc::c_int;
                            P_SetScale(spread_1, (*spread_1).destscale);
                            (*spread_1).fuse = (*missile_1).fuse;
                        }
                        i_1 = i_1.wrapping_add(1);
                        i_1;
                    }
                    P_InstaThrust(
                        missile_1,
                        (*missile_1).angle,
                        (*(*missile_1).info).speed,
                    );
                } else if (*mobj).extravalue1 >= 3 as libc::c_int {
                    let mut i_2: uint8_t = 0;
                    let mut spread_2: *mut mobj_t = 0 as *mut mobj_t;
                    (*(*mobj).target).z -= 2 as libc::c_int * (*missile_1).height;
                    i_2 = 0 as libc::c_int as uint8_t;
                    while (i_2 as libc::c_int) < 5 as libc::c_int {
                        if i_2 as libc::c_int != 2 as libc::c_int {
                            spread_2 = P_SpawnMissile(
                                mobj,
                                (*mobj).target,
                                (*missile_1).type_0,
                            );
                            (*spread_2)
                                .destscale = (1 as libc::c_int) << 16 as libc::c_int
                                >> 1 as libc::c_int;
                            P_SetScale(spread_2, (*spread_2).destscale);
                            (*spread_2).fuse = (*missile_1).fuse;
                            (*spread_2).z -= (*spread_2).height / 2 as libc::c_int;
                        }
                        (*(*mobj).target).z += (*missile_1).height;
                        i_2 = i_2.wrapping_add(1);
                        i_2;
                    }
                    (*(*mobj).target).z -= 3 as libc::c_int * (*missile_1).height;
                }
            } else {
                P_SetMobjState(mobj, (*(*mobj).state).nextstate);
                if (*mobj).extravalue1 == 3 as libc::c_int {
                    (*mobj).reactiontime = 35 as libc::c_int / 8 as libc::c_int;
                } else {
                    (*mobj).reactiontime = 35 as libc::c_int / 4 as libc::c_int;
                }
            }
            (*mobj).threshold -= 1;
            (*mobj).threshold;
            return;
        }
        if (*mobj).movecount == 3 as libc::c_int
            && ((*mobj).movedir == 0 as libc::c_int as angle_t
                || (*mobj).movedir == 2 as libc::c_int as angle_t)
        {
            if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                as statenum_t as libc::c_uint != (*(*mobj).info).seestate as libc::c_uint
            {
                P_SetMobjState(mobj, (*(*mobj).info).seestate);
            }
            if (*mobj).movedir == 0 as libc::c_int as angle_t {
                P_InstaThrust(
                    mobj,
                    (*mobj).angle,
                    38 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                );
            } else if (*mobj).health == 3 as libc::c_int {
                P_InstaThrust(
                    mobj,
                    (*mobj).angle,
                    22 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                );
            } else {
                P_InstaThrust(
                    mobj,
                    (*mobj).angle,
                    30 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                );
            }
            if P_TryMove(
                mobj,
                (*mobj).x + (*mobj).momx,
                (*mobj).y + (*mobj).momy,
                true_0 as libc::c_int,
            ) == 0
            {
                (*mobj).threshold -= 1;
                (*mobj).threshold;
                if (*mobj).threshold == 0 {
                    S_StartSound(mobj as *const libc::c_void, sfx_mspogo);
                    P_BounceMove(mobj);
                    (*mobj)
                        .angle = R_PointToAngle2(
                        (*mobj).momx,
                        (*mobj).momy,
                        0 as libc::c_int,
                        0 as libc::c_int,
                    );
                    (*mobj)
                        .momz = 4 as libc::c_int
                        * ((1 as libc::c_int) << 16 as libc::c_int);
                    (*mobj).flags &= !(MF_PAIN as libc::c_int) as uint32_t;
                    (*mobj).fuse = 8 as libc::c_int * 35 as libc::c_int;
                    (*mobj).movecount = 0 as libc::c_int;
                    P_SpawnMobjFromMobj(
                        mobj,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        MT_CYBRAKDEMON_VILE_EXPLOSION,
                    );
                    P_SetMobjState(mobj, (*(*mobj).info).meleestate);
                } else if (*mobj).threshold % 4 as libc::c_int == 0 {
                    P_SetMobjState(mobj, (*(*mobj).state).nextstate);
                    S_StartSound(mobj as *const libc::c_void, sfx_s3k5a);
                    (*mobj)
                        .angle = R_PointToAngle2(
                        (*mobj).x,
                        (*mobj).y,
                        (*(*mobj).target).x + (*(*mobj).target).momx * 4 as libc::c_int,
                        (*(*mobj).target).y + (*(*mobj).target).momy * 4 as libc::c_int,
                    );
                    (*mobj)
                        .reactiontime = 35 as libc::c_int
                        - 5 as libc::c_int * ((*(*mobj).info).damage - (*mobj).health);
                } else {
                    S_StartSound(mobj as *const libc::c_void, sfx_s3kaa);
                    P_BounceMove(mobj);
                    (*mobj)
                        .angle = R_PointToAngle2(
                        0 as libc::c_int,
                        0 as libc::c_int,
                        (*mobj).momx,
                        (*mobj).momy,
                    );
                    (*mobj).reactiontime = 1 as libc::c_int;
                }
                (*mobj).momy = 0 as libc::c_int;
                (*mobj).momx = (*mobj).momy;
            }
            return;
        }
        (*P_SpawnGhostMobj(mobj)).colorized = false_0 as libc::c_int;
        (*mobj).angle = ((*mobj).angle).wrapping_add((*mobj).movedir);
        P_InstaThrust(mobj, (*mobj).angle, -speed);
        while P_TryMove(
            mobj,
            (*mobj).x + (*mobj).momx,
            (*mobj).y + (*mobj).momy,
            true_0 as libc::c_int,
        ) == 0
            && {
                let fresh6 = tries;
                tries = tries.wrapping_add(1);
                (fresh6 as libc::c_int) < 16 as libc::c_int
            }
        {
            S_StartSound(mobj as *const libc::c_void, sfx_mspogo);
            P_BounceMove(mobj);
            (*mobj)
                .angle = R_PointToAngle2(
                (*mobj).momx,
                (*mobj).momy,
                0 as libc::c_int,
                0 as libc::c_int,
            );
        }
        (*mobj).momy = 0 as libc::c_int;
        (*mobj).momx = (*mobj).momy;
        (*mobj).threshold -= 1;
        (*mobj).threshold;
        if (*mobj).threshold == 0 {
            (*mobj)
                .reactiontime = 2 as libc::c_int * 35 as libc::c_int
                + (FixedMul(
                    (1 as libc::c_int * 35 as libc::c_int) << 16 as libc::c_int,
                    FixedDiv(
                        ((*mobj).health - 1 as libc::c_int) << 16 as libc::c_int,
                        ((*(*mobj).info).spawnhealth - 1 as libc::c_int)
                            << 16 as libc::c_int,
                    ),
                ) >> 16 as libc::c_int);
            (*mobj).flags
                |= (MF_SPECIAL as libc::c_int | MF_SHOOTABLE as libc::c_int) as uint32_t;
            P_SetMobjState(mobj, (*(*mobj).state).nextstate);
        }
        return;
    }
    angle = 0x6000000 as libc::c_int as tic_t * leveltime;
    (*mobj).momz
        += FixedMul(
            *finecosine.offset((angle >> 19 as libc::c_int) as isize)
                >> 16 as libc::c_int - 16 as libc::c_int,
            2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
    if (*mobj).flags2 & MF2_FRET as libc::c_int as uint32_t != 0
        && (*mobj).health <= (*(*mobj).info).damage
    {
        (*mobj).fuse = 0 as libc::c_int;
    }
    if (*mobj).reactiontime != 0 {
        if (*mobj).movedir > 0x80000000 as libc::c_uint {
            (*mobj)
                .angle = ((*mobj).angle)
                .wrapping_sub(
                    FixedAngle(
                        FixedMul(
                            AngleFixed(InvAngle((*mobj).movedir)),
                            FixedDiv(
                                (*mobj).reactiontime << 16 as libc::c_int,
                                (24 as libc::c_int) << 16 as libc::c_int,
                            ),
                        ),
                    ),
                );
        } else {
            (*mobj)
                .angle = ((*mobj).angle)
                .wrapping_add(
                    FixedAngle(
                        FixedMul(
                            AngleFixed((*mobj).movedir),
                            FixedDiv(
                                (*mobj).reactiontime << 16 as libc::c_int,
                                (24 as libc::c_int) << 16 as libc::c_int,
                            ),
                        ),
                    ),
                );
        }
        (*mobj).reactiontime -= 1;
        (*mobj).reactiontime;
        if (*mobj).reactiontime == 0 {
            P_SetMobjState(mobj, (*(*mobj).state).nextstate);
        }
        return;
    }
    (*mobj).flags
        &= !(MF_SPECIAL as libc::c_int | MF_SHOOTABLE as libc::c_int) as uint32_t;
    if (*mobj).health <= (*(*mobj).info).damage && (*mobj).fuse != 0
        && (*mobj).fuse % 35 as libc::c_int == 0
    {
        var1 = 1 as libc::c_int;
        var2 = 0 as libc::c_int;
        A_BossScream(mobj);
    }
    if (*mobj).flags2 & MF2_FRET as libc::c_int as uint32_t != 0 {
        return;
    }
    if (*mobj).movecount == 1 as libc::c_int || (*mobj).movecount == 2 as libc::c_int {
        if (*mobj).momx != 0 as libc::c_int || (*mobj).momy != 0 as libc::c_int {
            if abs((*mobj).momx) + abs((*mobj).momy)
                < (1 as libc::c_int) << 16 as libc::c_int
            {
                (*mobj).momy = 0 as libc::c_int;
                (*mobj).momx = (*mobj).momy;
            } else {
                P_Thrust(
                    mobj,
                    R_PointToAngle2(
                        0 as libc::c_int,
                        0 as libc::c_int,
                        (*mobj).momx,
                        (*mobj).momy,
                    ),
                    -(6 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int)
                        / 8 as libc::c_int,
                );
            }
        }
        if (*mobj).state
            == states
                .as_mut_ptr()
                .offset((*(*mobj).info).raisestate as libc::c_uint as isize)
        {
            return;
        }
    }
    if (*mobj).fuse == 0 as libc::c_int {
        (*mobj).flags2 &= !(MF2_INVERTAIMABLE as libc::c_int) as uint32_t;
        match (*mobj).movecount {
            1 => {
                if (*mobj).health > (*(*mobj).info).damage {
                    let mut shield: *mut mobj_t = P_SpawnMobj(
                        (*mobj).x,
                        (*mobj).y,
                        (*mobj).z,
                        MT_MSSHIELD_FRONT,
                    );
                    P_SetTarget2(&mut (*mobj).hprev, shield);
                    P_SetTarget2(&mut (*shield).target, mobj);
                    match (*mobj).health {
                        7 => {
                            (*mobj).extravalue1 = 4 as libc::c_int;
                            (*mobj).threshold = 2 as libc::c_int;
                        }
                        6 => {
                            (*mobj).extravalue1 = 1 as libc::c_int;
                            (*mobj).threshold = 3 as libc::c_int * 2 as libc::c_int;
                        }
                        5 => {
                            (*mobj).extravalue1 = 2 as libc::c_int;
                            (*mobj).threshold = 2 as libc::c_int;
                        }
                        4 => {
                            (*mobj).extravalue1 = 3 as libc::c_int;
                            (*mobj).threshold = 5 as libc::c_int * 2 as libc::c_int;
                        }
                        8 | _ => {
                            (*mobj).extravalue1 = 0 as libc::c_int;
                            (*mobj).threshold = 2 as libc::c_int;
                        }
                    }
                } else {
                    P_SetMobjState(mobj, S_METALSONIC_BOUNCE);
                }
                (*mobj).fuse = 3 as libc::c_int * 35 as libc::c_int;
                (*mobj).flags |= MF_PAIN as libc::c_int as uint32_t;
                if (*(*mobj).info).attacksound as u64 != 0 {
                    S_StartSound(
                        mobj as *const libc::c_void,
                        (*(*mobj).info).attacksound,
                    );
                }
                A_FaceTarget(mobj);
            }
            2 => {
                S_StopSound(mobj as *mut libc::c_void);
                if !((*mobj).hprev).is_null() {
                    P_RemoveMobj((*mobj).hprev);
                    P_SetTarget2(&mut (*mobj).hprev, 0 as *mut mobj_t);
                }
                if (*mobj).health <= (*(*mobj).info).damage {
                    if (*mobj).health == 1 as libc::c_int {
                        (*mobj).movedir = 0 as libc::c_int as angle_t;
                    } else {
                        (*mobj).movedir = 2 as libc::c_int as angle_t;
                    }
                    if (*(*mobj).info).seesound as u64 != 0 {
                        S_StartSound(
                            mobj as *const libc::c_void,
                            (*(*mobj).info).seesound,
                        );
                    }
                    P_SetMobjState(mobj, (*(*mobj).info).seestate);
                    if (*mobj).movedir == 2 as libc::c_int as angle_t {
                        (*mobj).threshold = 12 as libc::c_int;
                    } else {
                        (*mobj).threshold = 24 as libc::c_int;
                    }
                    if (*mobj).floorz >= (*(*mobj).target).floorz {
                        (*mobj)
                            .watertop = (*mobj).floorz
                            + 16 as libc::c_int
                                * ((1 as libc::c_int) << 16 as libc::c_int);
                    } else {
                        (*mobj)
                            .watertop = (*(*mobj).target).floorz
                            + 16 as libc::c_int
                                * ((1 as libc::c_int) << 16 as libc::c_int);
                    }
                    if !((*mobj).spawnpoint).is_null() {
                        P_LinedefExecute(
                            (*(*mobj).spawnpoint).args[4 as libc::c_int as usize]
                                as int16_t,
                            mobj,
                            0 as *mut sector_t,
                        );
                    }
                    P_SetMobjState((*mobj).tracer, S_JETFUMEFLASH);
                    P_SetScale((*mobj).tracer, (*mobj).scale << 1 as libc::c_int);
                } else {
                    (*mobj).movedir = 1 as libc::c_int as angle_t;
                }
            }
            3 => {
                if (*mobj).floorz >= (*(*mobj).target).floorz {
                    (*mobj)
                        .watertop = (*mobj).floorz
                        + 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
                } else {
                    (*mobj)
                        .watertop = (*(*mobj).target).floorz
                        + 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
                }
                P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
                (*mobj).flags &= !(MF_PAIN as libc::c_int) as uint32_t;
                (*mobj).fuse = 8 as libc::c_int * 35 as libc::c_int;
            }
            0 | _ => {
                S_StartSound(mobj as *const libc::c_void, sfx_beflap);
                P_SetMobjState(mobj, (*(*mobj).info).raisestate);
                if (*mobj).floorz >= (*(*mobj).target).floorz {
                    (*mobj)
                        .watertop = (*mobj).floorz
                        + 256 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
                } else {
                    (*mobj)
                        .watertop = (*(*mobj).target).floorz
                        + 256 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
                }
            }
        }
        (*mobj).movecount += 1;
        (*mobj).movecount;
        (*mobj).movecount %= 4 as libc::c_int;
        return;
    }
    if (*mobj).state
        == &mut *states.as_mut_ptr().offset((*(*mobj).info).spawnstate as isize)
            as *mut state_t
    {
        let mut dist_0: fixed_t = 0;
        P_BossTargetPlayer(mobj, true_0 as libc::c_int);
        angle = R_PointToAngle2(
            (*mobj).x,
            (*mobj).y,
            (*(*mobj).target).x,
            (*(*mobj).target).y,
        );
        angle = angle.wrapping_sub((*mobj).angle);
        if angle < 0x80000000 as libc::c_uint {
            (*mobj)
                .angle = ((*mobj).angle)
                .wrapping_add(angle / 8 as libc::c_int as angle_t);
        } else {
            (*mobj)
                .angle = ((*mobj).angle)
                .wrapping_sub(InvAngle(angle) / 8 as libc::c_int as angle_t);
        }
        if (*mobj).flags2 & MF2_CLASSICPUSH as libc::c_int as uint32_t != 0 {
            (*mobj).flags2 &= !(MF2_CLASSICPUSH as libc::c_int) as uint32_t;
            current_block = 13878384739916089420;
        } else {
            if ((*mobj).target).is_null() || ((*(*mobj).target).player).is_null()
                || P_PlayerCanDamage((*(*mobj).target).player, mobj) == 0
            {
                current_block = 3878923707049320048;
            } else if (*(*mobj).target).x + (*(*mobj).target).radius
                + abs((*(*mobj).target).momx * 2 as libc::c_int)
                < (*mobj).x - (*mobj).radius
            {
                current_block = 3878923707049320048;
            } else if (*(*mobj).target).x - (*(*mobj).target).radius
                - abs((*(*mobj).target).momx * 2 as libc::c_int)
                > (*mobj).x + (*mobj).radius
            {
                current_block = 3878923707049320048;
            } else if (*(*mobj).target).y + (*(*mobj).target).radius
                + abs((*(*mobj).target).momy * 2 as libc::c_int)
                < (*mobj).y - (*mobj).radius
            {
                current_block = 3878923707049320048;
            } else if (*(*mobj).target).y - (*(*mobj).target).radius
                - abs((*(*mobj).target).momy * 2 as libc::c_int)
                > (*mobj).y + (*mobj).radius
            {
                current_block = 3878923707049320048;
            } else if ((*(*mobj).target).z + (*(*mobj).target).height
                + (*(*mobj).target).momz * 2 as libc::c_int) < (*mobj).z
            {
                current_block = 3878923707049320048;
            } else if (*(*mobj).target).z + (*(*mobj).target).momz * 2 as libc::c_int
                > (*mobj).z + (*mobj).height
            {
                current_block = 3878923707049320048;
            } else {
                current_block = 13878384739916089420;
            }
            match current_block {
                13878384739916089420 => {}
                _ => {
                    (*mobj).flags2 |= MF2_INVERTAIMABLE as libc::c_int as uint32_t;
                    dist_0 = P_AproxDistance(
                        (*mobj).x - (*(*mobj).target).x,
                        (*mobj).y - (*(*mobj).target).y,
                    );
                    P_Thrust(
                        mobj,
                        R_PointToAngle2(
                            0 as libc::c_int,
                            0 as libc::c_int,
                            (*mobj).momx,
                            (*mobj).momy,
                        ),
                        -(3 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int)
                            / 8 as libc::c_int,
                    );
                    if dist_0
                        < 64 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                        && !(!((*(*mobj).target).player).is_null()
                            && (*(*(*mobj).target).player).homing as libc::c_int != 0)
                    {
                        P_Thrust(
                            mobj,
                            (*mobj).angle,
                            -(4 as libc::c_int)
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                        );
                    } else if dist_0
                        > 180 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                    {
                        P_Thrust(
                            mobj,
                            (*mobj).angle,
                            (1 as libc::c_int) << 16 as libc::c_int,
                        );
                    } else {
                        P_Thrust(
                            mobj,
                            ((*mobj).angle)
                                .wrapping_add(0x40000000 as libc::c_int as angle_t),
                            *finecosine
                                .offset(
                                    (leveltime * 0xb60b61 as libc::c_int as tic_t
                                        >> 19 as libc::c_int
                                        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t)
                                        as isize,
                                ) >> 16 as libc::c_int - 16 as libc::c_int
                                >> 1 as libc::c_int,
                        );
                    }
                    (*mobj).momz
                        += P_AproxDistance((*mobj).momx, (*mobj).momy)
                            / 12 as libc::c_int;
                    current_block = 4359080570876137612;
                }
            }
        }
        match current_block {
            4359080570876137612 => {}
            _ => {
                (*mobj)
                    .movedir = (0x8000000 as libc::c_int as angle_t)
                    .wrapping_sub(
                        FixedAngle(
                            FixedMul(
                                AngleFixed(0x8000000 as libc::c_int as angle_t),
                                FixedDiv(
                                    (*(*mobj).info).spawnhealth - (*mobj).health
                                        << 16 as libc::c_int,
                                    ((*(*mobj).info).spawnhealth - 1 as libc::c_int)
                                        << 16 as libc::c_int,
                                ),
                            ),
                        ),
                    );
                if P_RandomFixed()
                    < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
                {
                    (*mobj).movedir = InvAngle((*mobj).movedir);
                }
                (*mobj)
                    .threshold = 6 as libc::c_int
                    + (FixedMul(
                        (24 as libc::c_int) << 16 as libc::c_int,
                        FixedDiv(
                            (*(*mobj).info).spawnhealth - (*mobj).health
                                << 16 as libc::c_int,
                            ((*(*mobj).info).spawnhealth - 1 as libc::c_int)
                                << 16 as libc::c_int,
                        ),
                    ) >> 16 as libc::c_int);
                if (*(*mobj).info).activesound as u64 != 0 {
                    S_StartSound(
                        mobj as *const libc::c_void,
                        (*(*mobj).info).activesound,
                    );
                }
                if (*(*mobj).info).painchance != 0 {
                    P_SetMobjState(mobj, (*(*mobj).info).painchance as statenum_t);
                }
                (*mobj).flags2 &= !(MF2_INVERTAIMABLE as libc::c_int) as uint32_t;
                return;
            }
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_GetClosestAxis(mut source: *mut mobj_t) -> *mut mobj_t {
    let mut th: *mut thinker_t = 0 as *mut thinker_t;
    let mut mo2: *mut mobj_t = 0 as *mut mobj_t;
    let mut closestaxis: *mut mobj_t = 0 as *mut mobj_t;
    let mut dist1: fixed_t = 0;
    let mut dist2: fixed_t = 0 as libc::c_int;
    th = (*thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)).next;
    while th
        != &mut *thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)
            as *mut thinker_t
    {
        if !((*th).function.acp1
            == ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut thinker_t) -> ()>,
                actionf_p1,
            >(
                Some(
                    P_RemoveThinkerDelayed as unsafe extern "C" fn(*mut thinker_t) -> (),
                ),
            ))
        {
            mo2 = th as *mut mobj_t;
            if (*mo2).type_0 as libc::c_uint == MT_AXIS as libc::c_int as libc::c_uint {
                if closestaxis.is_null() {
                    closestaxis = mo2;
                    dist2 = R_PointToDist2((*source).x, (*source).y, (*mo2).x, (*mo2).y)
                        - (*mo2).radius;
                } else {
                    dist1 = R_PointToDist2((*source).x, (*source).y, (*mo2).x, (*mo2).y)
                        - (*mo2).radius;
                    if dist1 < dist2 {
                        closestaxis = mo2;
                        dist2 = dist1;
                    }
                }
            }
        }
        th = (*th).next;
    }
    if closestaxis.is_null() {
        CONS_Debug(
            0x20 as libc::c_int,
            b"ERROR: No axis points found!\n\0" as *const u8 as *const libc::c_char,
        );
    }
    return closestaxis;
}
unsafe extern "C" fn P_GimmeAxisXYPos(
    mut closestaxis: *mut mobj_t,
    mut mobj: *mut degenmobj_t,
) {
    let fa: angle_t = R_PointToAngle2(
        (*closestaxis).x,
        (*closestaxis).y,
        (*mobj).x,
        (*mobj).y,
    ) >> 19 as libc::c_int;
    (*mobj)
        .x = (*closestaxis).x
        + FixedMul(
            *finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int,
            (*closestaxis).radius,
        );
    (*mobj)
        .y = (*closestaxis).y
        + FixedMul(
            finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
            (*closestaxis).radius,
        );
}
unsafe extern "C" fn P_MoveHoop(mut mobj: *mut mobj_t) {
    let fuse: fixed_t = (*mobj).fuse * (*mobj).extravalue2;
    let fa: angle_t = (*mobj).movedir
        * (8192 as libc::c_int / (*mobj).extravalue1) as angle_t;
    let mut m: matrix_t = matrix_t { m: [0; 16] };
    let mut v: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut res: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut finalx: fixed_t = 0;
    let mut finaly: fixed_t = 0;
    let mut finalz: fixed_t = 0;
    let mut x: fixed_t = 0;
    let mut y: fixed_t = 0;
    let mut z: fixed_t = 0;
    if ((*mobj).target).is_null() {
        return;
    }
    x = (*(*mobj).target).x;
    y = (*(*mobj).target).y;
    z = (*(*mobj).target).z + (*(*mobj).target).height / 2 as libc::c_int;
    v
        .x = FixedMul(
        *finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int,
        fuse,
    );
    v.y = 0 as libc::c_int;
    v.z = FixedMul(finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int, fuse);
    v.a = (1 as libc::c_int) << 16 as libc::c_int;
    FM_RotateX(
        &mut m,
        FixedAngle(
            ((*(*mobj).target).movedir
                * ((1 as libc::c_int) << 16 as libc::c_int) as angle_t) as fixed_t,
        ),
    );
    FV4_Copy(&mut v, FM_MultMatrixVec4(&mut m, &mut v, &mut res));
    FM_RotateZ(
        &mut m,
        FixedAngle(
            (*(*mobj).target).movecount * ((1 as libc::c_int) << 16 as libc::c_int),
        ),
    );
    FV4_Copy(&mut v, FM_MultMatrixVec4(&mut m, &mut v, &mut res));
    finalx = x + v.x;
    finaly = y + v.y;
    finalz = z + v.z;
    P_UnsetThingPosition(mobj);
    (*mobj).x = finalx;
    (*mobj).y = finaly;
    P_SetThingPosition(mobj);
    (*mobj).z = finalz - (*mobj).height / 2 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnHoopOfSomething(
    mut x: fixed_t,
    mut y: fixed_t,
    mut z: fixed_t,
    mut radius: fixed_t,
    mut number: int32_t,
    mut type_0: mobjtype_t,
    mut rotangle: angle_t,
) {
    let mut mobj: *mut mobj_t = 0 as *mut mobj_t;
    let mut i: int32_t = 0;
    let mut m: matrix_t = matrix_t { m: [0; 16] };
    let mut v: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut res: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut finalx: fixed_t = 0;
    let mut finaly: fixed_t = 0;
    let mut finalz: fixed_t = 0;
    let mut hoopcenter: mobj_t = mobj_s {
        thinker: thinker_s {
            prev: 0 as *mut thinker_s,
            next: 0 as *mut thinker_s,
            function: actionf_t { acv: None },
            references: 0,
        },
        x: 0,
        y: 0,
        z: 0,
        old_x: 0,
        old_y: 0,
        old_z: 0,
        old_x2: 0,
        old_y2: 0,
        old_z2: 0,
        snext: 0 as *mut mobj_s,
        sprev: 0 as *mut *mut mobj_s,
        angle: 0,
        pitch: 0,
        roll: 0,
        old_angle: 0,
        old_pitch: 0,
        old_roll: 0,
        old_angle2: 0,
        old_pitch2: 0,
        old_roll2: 0,
        spriteroll: 0,
        old_spriteroll: 0,
        old_spriteroll2: 0,
        sprite: SPR_NULL,
        frame: 0,
        sprite2: 0,
        anim_duration: 0,
        renderflags: 0,
        blendmode: 0,
        spritexscale: 0,
        spriteyscale: 0,
        spritexoffset: 0,
        spriteyoffset: 0,
        old_spritexscale: 0,
        old_spriteyscale: 0,
        old_spritexoffset: 0,
        old_spriteyoffset: 0,
        floorspriteslope: 0 as *mut pslope_s,
        touching_sectorlist: 0 as *mut msecnode_s,
        subsector: 0 as *mut subsector_s,
        floorz: 0,
        ceilingz: 0,
        floorrover: 0 as *mut ffloor_s,
        ceilingrover: 0 as *mut ffloor_s,
        radius: 0,
        height: 0,
        momx: 0,
        momy: 0,
        momz: 0,
        pmomz: 0,
        tics: 0,
        state: 0 as *mut state_t,
        flags: 0,
        flags2: 0,
        eflags: 0,
        skin: 0 as *mut libc::c_void,
        color: 0,
        drawonlyforplayer: 0 as *mut player_s,
        dontdrawforviewmobj: 0 as *mut mobj_s,
        bnext: 0 as *mut mobj_s,
        bprev: 0 as *mut *mut mobj_s,
        hnext: 0 as *mut mobj_s,
        hprev: 0 as *mut mobj_s,
        type_0: MT_NULL,
        info: 0 as *const mobjinfo_t,
        health: 0,
        movedir: 0,
        movecount: 0,
        target: 0 as *mut mobj_s,
        reactiontime: 0,
        threshold: 0,
        player: 0 as *mut player_s,
        lastlook: 0,
        spawnpoint: 0 as *mut mapthing_t,
        tracer: 0 as *mut mobj_s,
        friction: 0,
        movefactor: 0,
        fuse: 0,
        watertop: 0,
        waterbottom: 0,
        mobjnum: 0,
        scale: 0,
        old_scale: 0,
        old_scale2: 0,
        destscale: 0,
        scalespeed: 0,
        extravalue1: 0,
        extravalue2: 0,
        cusval: 0,
        cvmem: 0,
        standingslope: 0 as *mut pslope_s,
        resetinterp: 0,
        colorized: 0,
        mirrored: 0,
        shadowscale: 0,
        dispoffset: 0,
    };
    let mut axis: *mut mobj_t = 0 as *mut mobj_t;
    let mut xypos: degenmobj_t = degenmobj_t {
        thinker: thinker_s {
            prev: 0 as *mut thinker_s,
            next: 0 as *mut thinker_s,
            function: actionf_t { acv: None },
            references: 0,
        },
        x: 0,
        y: 0,
        z: 0,
    };
    let mut degrees: angle_t = 0;
    let mut fa: angle_t = 0;
    let mut closestangle: angle_t = 0;
    hoopcenter.x = x;
    hoopcenter.y = y;
    hoopcenter.z = z;
    axis = P_GetClosestAxis(&mut hoopcenter);
    if axis.is_null() {
        CONS_Debug(
            0x20 as libc::c_int,
            b"You forgot to put axis points in the map!\n\0" as *const u8
                as *const libc::c_char,
        );
        return;
    }
    xypos.x = x;
    xypos.y = y;
    P_GimmeAxisXYPos(axis, &mut xypos);
    x = xypos.x;
    y = xypos.y;
    hoopcenter.z = z - mobjinfo[type_0 as usize].height / 2 as libc::c_int;
    hoopcenter.x = x;
    hoopcenter.y = y;
    closestangle = R_PointToAngle2(x, y, (*axis).x, (*axis).y);
    degrees = (8192 as libc::c_int / number) as angle_t;
    radius >>= 16 as libc::c_int;
    i = 0 as libc::c_int;
    while i < number {
        fa = i as angle_t * degrees;
        v
            .x = FixedMul(
            *finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int,
            radius,
        );
        v.y = 0 as libc::c_int;
        v
            .z = FixedMul(
            finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
            radius,
        );
        v.a = (1 as libc::c_int) << 16 as libc::c_int;
        FM_RotateX(&mut m, rotangle);
        FV4_Copy(&mut v, FM_MultMatrixVec4(&mut m, &mut v, &mut res));
        FM_RotateZ(&mut m, closestangle);
        FV4_Copy(&mut v, FM_MultMatrixVec4(&mut m, &mut v, &mut res));
        finalx = x + v.x;
        finaly = y + v.y;
        finalz = z + v.z;
        mobj = P_SpawnMobj(finalx, finaly, finalz, type_0);
        (*mobj).z -= (*mobj).height / 2 as libc::c_int;
        i += 1;
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnParaloop(
    mut x: fixed_t,
    mut y: fixed_t,
    mut z: fixed_t,
    mut radius: fixed_t,
    mut number: int32_t,
    mut type_0: mobjtype_t,
    mut nstate: statenum_t,
    mut rotangle: angle_t,
    mut spawncenter: boolean,
) {
    let mut mobj: *mut mobj_t = 0 as *mut mobj_t;
    let mut i: int32_t = 0;
    let mut m: matrix_t = matrix_t { m: [0; 16] };
    let mut v: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut res: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut finalx: fixed_t = 0;
    let mut finaly: fixed_t = 0;
    let mut finalz: fixed_t = 0;
    let mut dist: fixed_t = 0;
    let mut degrees: angle_t = 0;
    let mut fa: angle_t = 0;
    let mut closestangle: angle_t = 0;
    let mut mobjx: fixed_t = 0;
    let mut mobjy: fixed_t = 0;
    let mut mobjz: fixed_t = 0;
    degrees = (8192 as libc::c_int / number) as angle_t;
    radius = FixedDiv(
        radius,
        5 as libc::c_int * (((1 as libc::c_int) << 16 as libc::c_int) / 4 as libc::c_int),
    );
    closestangle = 0 as libc::c_int as angle_t;
    i = 0 as libc::c_int;
    while i < number {
        fa = i as angle_t * degrees;
        v
            .x = FixedMul(
            *finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int,
            radius,
        );
        v.y = 0 as libc::c_int;
        v
            .z = FixedMul(
            finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
            radius,
        );
        v.a = (1 as libc::c_int) << 16 as libc::c_int;
        FM_RotateX(&mut m, rotangle);
        FV4_Copy(&mut v, FM_MultMatrixVec4(&mut m, &mut v, &mut res));
        FM_RotateZ(&mut m, closestangle);
        FV4_Copy(&mut v, FM_MultMatrixVec4(&mut m, &mut v, &mut res));
        finalx = x + v.x;
        finaly = y + v.y;
        finalz = z + v.z;
        mobj = P_SpawnMobj(finalx, finaly, finalz, type_0);
        (*mobj).z -= (*mobj).height >> 1 as libc::c_int;
        (*mobj).angle = R_PointToAngle2((*mobj).x, (*mobj).y, x, y);
        dist = P_AproxDistance(
            P_AproxDistance(x - (*mobj).x, y - (*mobj).y),
            z - (*mobj).z,
        );
        if dist < 1 as libc::c_int {
            dist = 1 as libc::c_int;
        }
        mobjx = (*mobj).x;
        mobjy = (*mobj).y;
        mobjz = (*mobj).z;
        if nstate as libc::c_uint != S_NULL as libc::c_int as libc::c_uint {
            P_SetMobjState(mobj, nstate);
        }
        (*mobj)
            .momx = FixedMul(
            FixedDiv(x - mobjx, dist),
            5 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
        (*mobj)
            .momy = FixedMul(
            FixedDiv(y - mobjy, dist),
            5 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
        (*mobj)
            .momz = FixedMul(
            FixedDiv(z - mobjz, dist),
            5 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
        (*mobj)
            .fuse = (radius >> 16 as libc::c_int + 2 as libc::c_int) + 1 as libc::c_int;
        if spawncenter != 0 {
            P_SetOrigin(mobj, x, y, z);
        }
        if (*mobj).fuse <= 1 as libc::c_int {
            (*mobj).fuse = 2 as libc::c_int;
        }
        (*mobj).flags |= MF_NOCLIPTHING as libc::c_int as uint32_t;
        (*mobj).flags &= !(MF_SPECIAL as libc::c_int) as uint32_t;
        if (*mobj).fuse > 7 as libc::c_int {
            (*mobj).tics = (*mobj).fuse - 7 as libc::c_int;
        } else {
            (*mobj).tics = 1 as libc::c_int;
        }
        i += 1;
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_SetScale(mut mobj: *mut mobj_t, mut newscale: fixed_t) {
    let mut player: *mut player_t = 0 as *mut player_t;
    let mut oldscale: fixed_t = 0;
    if mobj.is_null() {
        return;
    }
    oldscale = (*mobj).scale;
    (*mobj).scale = newscale;
    (*mobj).radius = FixedMul(FixedDiv((*mobj).radius, oldscale), newscale);
    (*mobj).height = FixedMul(FixedDiv((*mobj).height, oldscale), newscale);
    player = (*mobj).player;
    if !player.is_null() {
        G_GhostAddScale(newscale);
        (*player)
            .viewheight = FixedMul(FixedDiv((*player).viewheight, oldscale), newscale);
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_Attract(
    mut source: *mut mobj_t,
    mut dest: *mut mobj_t,
    mut nightsgrab: boolean,
) {
    let mut dist: fixed_t = 0;
    let mut ndist: fixed_t = 0;
    let mut speedmul: fixed_t = 0;
    let mut vangle: angle_t = 0;
    let mut tx: fixed_t = (*dest).x;
    let mut ty: fixed_t = (*dest).y;
    let mut tz: fixed_t = (*dest).z + (*dest).height / 2 as libc::c_int;
    let mut xydist: fixed_t = P_AproxDistance(tx - (*source).x, ty - (*source).y);
    if dest.is_null() || (*dest).health <= 0 as libc::c_int || ((*dest).player).is_null()
        || ((*source).tracer).is_null()
    {
        return;
    }
    (*source).angle = R_PointToAngle2((*source).x, (*source).y, tx, ty);
    dist = P_AproxDistance(xydist, tz - (*source).z);
    if dist < 1 as libc::c_int {
        dist = 1 as libc::c_int;
    }
    if nightsgrab != 0 && (*source).movefactor != 0 {
        (*source).movefactor
            += ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int;
        if dist < (*source).movefactor {
            (*source).momz = 0 as libc::c_int;
            (*source).momy = (*source).momz;
            (*source).momx = (*source).momy;
            P_MoveOrigin(source, tx, ty, tz);
        } else {
            vangle = R_PointToAngle2((*source).z, 0 as libc::c_int, tz, xydist);
            (*source)
                .momx = FixedMul(
                finesine[(vangle >> 19 as libc::c_int) as usize]
                    >> 16 as libc::c_int - 16 as libc::c_int,
                FixedMul(
                    *finecosine.offset(((*source).angle >> 19 as libc::c_int) as isize)
                        >> 16 as libc::c_int - 16 as libc::c_int,
                    (*source).movefactor,
                ),
            );
            (*source)
                .momy = FixedMul(
                finesine[(vangle >> 19 as libc::c_int) as usize]
                    >> 16 as libc::c_int - 16 as libc::c_int,
                FixedMul(
                    finesine[((*source).angle >> 19 as libc::c_int) as usize]
                        >> 16 as libc::c_int - 16 as libc::c_int,
                    (*source).movefactor,
                ),
            );
            (*source)
                .momz = FixedMul(
                *finecosine.offset((vangle >> 19 as libc::c_int) as isize)
                    >> 16 as libc::c_int - 16 as libc::c_int,
                (*source).movefactor,
            );
        }
    } else {
        if nightsgrab != 0 {
            speedmul = P_AproxDistance((*dest).momx, (*dest).momy)
                + FixedMul(
                    8 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*source).scale,
                );
        } else {
            speedmul = P_AproxDistance((*dest).momx, (*dest).momy)
                + FixedMul((*(*source).info).speed, (*source).scale);
        }
        (*source).momx = FixedMul(FixedDiv(tx - (*source).x, dist), speedmul);
        (*source).momy = FixedMul(FixedDiv(ty - (*source).y, dist), speedmul);
        (*source).momz = FixedMul(FixedDiv(tz - (*source).z, dist), speedmul);
    }
    ndist = P_AproxDistance(
        P_AproxDistance(
            tx - ((*source).x + (*source).momx),
            ty - ((*source).y + (*source).momy),
        ),
        tz - ((*source).z + (*source).momz),
    );
    if ndist > dist {
        (*source).momz = 0 as libc::c_int;
        (*source).momy = (*source).momz;
        (*source).momx = (*source).momy;
        P_UnsetThingPosition(source);
        (*source).x = tx;
        (*source).y = ty;
        (*source).z = tz;
        P_SetThingPosition(source);
    }
}
unsafe extern "C" fn P_NightsItemChase(mut thing: *mut mobj_t) {
    if ((*thing).tracer).is_null() {
        P_SetTarget2(&mut (*thing).tracer, 0 as *mut mobj_t);
        (*thing).flags2 &= !(MF2_NIGHTSPULL as libc::c_int) as uint32_t;
        (*thing).movefactor = 0 as libc::c_int;
        return;
    }
    if ((*(*thing).tracer).player).is_null() {
        return;
    }
    P_Attract(thing, (*thing).tracer, true_0 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn P_MaceRotate(
    mut center: *mut mobj_t,
    mut baserot: int32_t,
    mut baseprevrot: int32_t,
) {
    let mut m: matrix_t = matrix_t { m: [0; 16] };
    let mut unit_lengthways: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut unit_sideways: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut pos_lengthways: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut pos_sideways: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut res: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut radius: fixed_t = 0;
    let mut dist: fixed_t = 0 as libc::c_int;
    let mut zstore: fixed_t = 0;
    let mut fa: angle_t = 0;
    let mut dosound: boolean = false_0 as libc::c_int;
    let mut mobj: *mut mobj_t = (*center).hnext;
    let mut hnext: *mut mobj_t = 0 as *mut mobj_t;
    let mut lastthreshold: int32_t = -(1 as libc::c_int);
    let mut lastfriction: fixed_t = -(2147483647 as libc::c_int) - 1 as libc::c_int;
    let mut rot: int32_t = 0;
    let mut prevrot: int32_t = 0;
    FV4_Load(
        &mut pos_sideways,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    );
    FV4_Load(
        &mut unit_sideways,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    );
    FV4_Load(
        &mut pos_lengthways,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    );
    while !mobj.is_null() {
        if P_MobjWasRemoved(mobj) != 0 || (*mobj).health == 0 {
            mobj = (*mobj).hnext;
        } else {
            (*mobj).momz = 0 as libc::c_int;
            (*mobj).momy = (*mobj).momz;
            (*mobj).momx = (*mobj).momy;
            if (*mobj).threshold != lastthreshold || (*mobj).friction != lastfriction {
                rot = baserot + (*mobj).threshold
                    & 8192 as libc::c_int - 1 as libc::c_int;
                prevrot = baseprevrot + (*mobj).threshold
                    & 8192 as libc::c_int - 1 as libc::c_int;
                FV4_Load(
                    &mut pos_lengthways,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                );
                dist = if (*(*mobj).info).speed != 0 {
                    (*(*mobj).info).speed
                } else {
                    mobjinfo[MT_SMALLMACECHAIN as libc::c_int as usize].speed
                };
                dist = if (*center).scale == (1 as libc::c_int) << 16 as libc::c_int {
                    dist
                } else {
                    FixedMul(dist, (*center).scale)
                };
                fa = FixedAngle(
                    (*center).movefactor * ((1 as libc::c_int) << 16 as libc::c_int),
                ) >> 19 as libc::c_int;
                radius = FixedMul(
                    dist,
                    *finecosine.offset(fa as isize)
                        >> 16 as libc::c_int - 16 as libc::c_int,
                );
                unit_lengthways
                    .y = -FixedMul(
                    dist,
                    finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                );
                unit_lengthways.a = (1 as libc::c_int) << 16 as libc::c_int;
                if (*center).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
                    let mut swingmag: fixed_t = FixedMul(
                        *finecosine.offset(rot as isize)
                            >> 16 as libc::c_int - 16 as libc::c_int,
                        (*center).lastlook << 16 as libc::c_int,
                    );
                    let mut prevswingmag: fixed_t = *finecosine.offset(prevrot as isize)
                        >> 16 as libc::c_int - 16 as libc::c_int;
                    if (prevswingmag > 0 as libc::c_int) as libc::c_int
                        != (swingmag > 0 as libc::c_int) as libc::c_int
                    {
                        dosound = true_0 as libc::c_int;
                    }
                    fa = (FixedAngle(swingmag) >> 19 as libc::c_int)
                        .wrapping_add((*mobj).friction as angle_t)
                        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
                    unit_lengthways
                        .x = FixedMul(
                        finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                        -radius,
                    );
                    unit_lengthways
                        .z = FixedMul(
                        *finecosine.offset(fa as isize)
                            >> 16 as libc::c_int - 16 as libc::c_int,
                        -radius,
                    );
                } else {
                    let mut prevfa: angle_t = (prevrot + (*mobj).friction
                        & 8192 as libc::c_int - 1 as libc::c_int) as angle_t;
                    fa = (rot + (*mobj).friction
                        & 8192 as libc::c_int - 1 as libc::c_int) as angle_t;
                    if !(prevfa
                        > ((8192 as libc::c_int - 1 as libc::c_int) / 2 as libc::c_int)
                            as angle_t)
                        && fa
                            > ((8192 as libc::c_int - 1 as libc::c_int)
                                / 2 as libc::c_int) as angle_t
                    {
                        dosound = true_0 as libc::c_int;
                    }
                    unit_lengthways
                        .x = FixedMul(
                        *finecosine.offset(fa as isize)
                            >> 16 as libc::c_int - 16 as libc::c_int,
                        radius,
                    );
                    unit_lengthways
                        .z = FixedMul(
                        finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                        radius,
                    );
                }
                FM_RotateX(
                    &mut m,
                    ((*center).threshold << 19 as libc::c_int) as angle_t,
                );
                FV4_Copy(
                    &mut unit_lengthways,
                    FM_MultMatrixVec4(&mut m, &mut unit_lengthways, &mut res),
                );
                FM_RotateZ(&mut m, (*center).angle);
                FV4_Copy(
                    &mut unit_lengthways,
                    FM_MultMatrixVec4(&mut m, &mut unit_lengthways, &mut res),
                );
                lastthreshold = (*mobj).threshold;
                lastfriction = (*mobj).friction;
            }
            if dosound != 0
                && (*mobj).flags2 & MF2_BOSSNOTRAP as libc::c_int as uint32_t != 0
            {
                S_StartSound(mobj as *const libc::c_void, (*(*mobj).info).activesound);
                dosound = false_0 as libc::c_int;
            }
            if pos_sideways.a != (*mobj).movefactor {
                if unit_sideways.a == 0 {
                    unit_sideways.y = dist;
                    unit_sideways.z = 0 as libc::c_int;
                    unit_sideways.x = unit_sideways.z;
                    unit_sideways.a = (1 as libc::c_int) << 16 as libc::c_int;
                    FM_RotateX(
                        &mut m,
                        ((*center).threshold << 19 as libc::c_int) as angle_t,
                    );
                    FV4_Copy(
                        &mut unit_sideways,
                        FM_MultMatrixVec4(&mut m, &mut unit_sideways, &mut res),
                    );
                    FM_RotateZ(&mut m, (*center).angle);
                    FV4_Copy(
                        &mut unit_sideways,
                        FM_MultMatrixVec4(&mut m, &mut unit_sideways, &mut res),
                    );
                }
                if pos_sideways.a > (*mobj).movefactor {
                    loop {
                        pos_sideways.x -= unit_sideways.x;
                        pos_sideways.y -= unit_sideways.y;
                        pos_sideways.z -= unit_sideways.z;
                        pos_sideways.a -= 1;
                        if !(pos_sideways.a != (*mobj).movefactor) {
                            break;
                        }
                    }
                } else {
                    loop {
                        pos_sideways.x += unit_sideways.x;
                        pos_sideways.y += unit_sideways.y;
                        pos_sideways.z += unit_sideways.z;
                        pos_sideways.a += 1;
                        if !(pos_sideways.a != (*mobj).movefactor) {
                            break;
                        }
                    }
                }
            }
            hnext = (*mobj).hnext;
            if pos_lengthways.a > (*mobj).movecount {
                loop {
                    pos_lengthways.x -= unit_lengthways.x;
                    pos_lengthways.y -= unit_lengthways.y;
                    pos_lengthways.z -= unit_lengthways.z;
                    pos_lengthways.a -= 1;
                    if !(pos_lengthways.a != (*mobj).movecount) {
                        break;
                    }
                }
            } else if pos_lengthways.a < (*mobj).movecount {
                loop {
                    pos_lengthways.x += unit_lengthways.x;
                    pos_lengthways.y += unit_lengthways.y;
                    pos_lengthways.z += unit_lengthways.z;
                    pos_lengthways.a += 1;
                    if !(pos_lengthways.a != (*mobj).movecount) {
                        break;
                    }
                }
            }
            P_UnsetThingPosition(mobj);
            (*mobj).x = (*center).x;
            (*mobj).y = (*center).y;
            (*mobj).z = (*center).z;
            if pos_lengthways.a != 0 {
                (*mobj).x += pos_lengthways.x;
                (*mobj).y += pos_lengthways.y;
                zstore = pos_lengthways.z + pos_sideways.z;
            } else {
                zstore = pos_sideways.z;
            }
            (*mobj).x += pos_sideways.x;
            (*mobj).y += pos_sideways.y;
            if (*mobj).type_0 as libc::c_uint
                == MT_SMALLMACECHAIN as libc::c_int as libc::c_uint
                || (*mobj).type_0 as libc::c_uint
                    == MT_BIGMACECHAIN as libc::c_int as libc::c_uint
                || (*mobj).type_0 as libc::c_uint
                    == MT_SMALLGRABCHAIN as libc::c_int as libc::c_uint
                || (*mobj).type_0 as libc::c_uint
                    == MT_BIGGRABCHAIN as libc::c_int as libc::c_uint
            {
                zstore
                    -= P_MobjFlip(mobj) as libc::c_int * (*mobj).height
                        / 4 as libc::c_int;
            } else {
                zstore
                    -= P_MobjFlip(mobj) as libc::c_int * (*mobj).height
                        / 2 as libc::c_int;
            }
            (*mobj).z += zstore;
            P_SetThingPosition(mobj);
            mobj = hnext;
        }
    }
}
unsafe extern "C" fn P_ShieldLook(
    mut thing: *mut mobj_t,
    mut shield: shieldtype_t,
) -> boolean {
    if ((*thing).target).is_null() || (*(*thing).target).health <= 0 as libc::c_int
        || ((*(*thing).target).player).is_null()
        || (*(*(*thing).target).player).powers[pw_shield as libc::c_int as usize]
            as libc::c_int & SH_NOSTACK as libc::c_int == SH_NONE as libc::c_int
        || (*(*(*thing).target).player).powers[pw_super as libc::c_int as usize]
            as libc::c_int != 0
        || (*(*(*thing).target).player)
            .powers[pw_invulnerability as libc::c_int as usize] as libc::c_int
            > 1 as libc::c_int
    {
        P_RemoveMobj(thing);
        return false_0 as libc::c_int;
    }
    if shield as libc::c_int & SH_FORCE as libc::c_int == 0 {
        if ((*(*(*thing).target).player).powers[pw_shield as libc::c_int as usize]
            as libc::c_int & SH_NOSTACK as libc::c_int) as shieldtype_t as libc::c_int
            != shield as libc::c_int
        {
            P_RemoveMobj(thing);
            return false_0 as libc::c_int;
        }
    } else if (*(*(*thing).target).player).powers[pw_shield as libc::c_int as usize]
        as libc::c_int & SH_FORCE as libc::c_int == 0
    {
        P_RemoveMobj(thing);
        return false_0 as libc::c_int;
    }
    if shield as libc::c_int & SH_FORCE as libc::c_int != 0
        && (*thing).movecount
            != (*(*(*thing).target).player).powers[pw_shield as libc::c_int as usize]
                as libc::c_int & SH_FORCEHP as libc::c_int
    {
        (*thing)
            .movecount = (*(*(*thing).target).player)
            .powers[pw_shield as libc::c_int as usize] as libc::c_int
            & SH_FORCEHP as libc::c_int;
        if (*thing).movecount < 1 as libc::c_int {
            if (*(*thing).info).painstate as u64 != 0 {
                P_SetMobjState(thing, (*(*thing).info).painstate);
            } else {
                (*thing).flags2 |= MF2_SHADOW as libc::c_int as uint32_t;
            }
        } else if (*(*thing).info).painstate as u64 != 0 {
            P_SetMobjState(thing, (*(*thing).info).spawnstate);
        } else {
            (*thing).flags2 &= !(MF2_SHADOW as libc::c_int) as uint32_t;
        }
    }
    (*thing).flags |= MF_NOCLIPHEIGHT as libc::c_int as uint32_t;
    (*thing)
        .eflags = ((*thing).eflags as libc::c_int & !(MFE_VERTICALFLIP as libc::c_int)
        | (*(*thing).target).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int)
        as uint16_t;
    P_SetScale(
        thing,
        FixedMul((*(*thing).target).scale, (*(*(*thing).target).player).shieldscale),
    );
    (*thing).destscale = (*thing).scale;
    P_UnsetThingPosition(thing);
    (*thing).x = (*(*thing).target).x;
    (*thing).y = (*(*thing).target).y;
    if (*thing).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        (*thing)
            .z = (*(*thing).target).z
            + ((*(*thing).target).height - (*thing).height
                + FixedDiv(
                    FixedMul(
                        (*(*(*thing).target).player).height,
                        (*(*(*(*thing).target).player).mo).scale,
                    ) - (*(*thing).target).height,
                    3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                ))
            - FixedMul(
                2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*(*thing).target).scale,
            );
    } else {
        (*thing)
            .z = (*(*thing).target).z
            - FixedDiv(
                FixedMul(
                    (*(*(*thing).target).player).height,
                    (*(*(*(*thing).target).player).mo).scale,
                ) - (*(*thing).target).height,
                3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
            )
            + FixedMul(
                2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*(*thing).target).scale,
            );
    }
    P_SetThingPosition(thing);
    P_CheckPosition(thing, (*thing).x, (*thing).y);
    if P_MobjWasRemoved(thing) != 0 {
        return false_0 as libc::c_int;
    }
    return true_0 as libc::c_int;
}
#[no_mangle]
pub static mut shields: [*mut mobj_t; 64] = [0 as *const mobj_t as *mut mobj_t; 64];
#[no_mangle]
pub static mut numshields: int32_t = 0 as libc::c_int;
#[no_mangle]
pub unsafe extern "C" fn P_RunShields() {
    let mut i: int32_t = 0;
    i = 0 as libc::c_int;
    while i < numshields {
        if P_MobjWasRemoved(shields[i as usize]) == 0 {
            P_ShieldLook(
                shields[i as usize],
                (*shields[i as usize]).threshold as shieldtype_t,
            );
        }
        P_SetTarget2(&mut *shields.as_mut_ptr().offset(i as isize), 0 as *mut mobj_t);
        i += 1;
        i;
    }
    numshields = 0 as libc::c_int;
}
unsafe extern "C" fn P_AddShield(mut thing: *mut mobj_t) -> boolean {
    let mut shield: shieldtype_t = (*thing).threshold as shieldtype_t;
    if ((*thing).target).is_null() || (*(*thing).target).health <= 0 as libc::c_int
        || ((*(*thing).target).player).is_null()
        || (*(*(*thing).target).player).powers[pw_shield as libc::c_int as usize]
            as libc::c_int & SH_NOSTACK as libc::c_int == SH_NONE as libc::c_int
        || (*(*(*thing).target).player).powers[pw_super as libc::c_int as usize]
            as libc::c_int != 0
        || (*(*(*thing).target).player)
            .powers[pw_invulnerability as libc::c_int as usize] as libc::c_int
            > 1 as libc::c_int
    {
        P_RemoveMobj(thing);
        return false_0 as libc::c_int;
    }
    if shield as libc::c_int & SH_FORCE as libc::c_int == 0 {
        if ((*(*(*thing).target).player).powers[pw_shield as libc::c_int as usize]
            as libc::c_int & SH_NOSTACK as libc::c_int) as shieldtype_t as libc::c_int
            != shield as libc::c_int
        {
            P_RemoveMobj(thing);
            return false_0 as libc::c_int;
        }
    } else if (*(*(*thing).target).player).powers[pw_shield as libc::c_int as usize]
        as libc::c_int & SH_FORCE as libc::c_int == 0
    {
        P_RemoveMobj(thing);
        return false_0 as libc::c_int;
    }
    if numshields >= 32 as libc::c_int * 2 as libc::c_int {
        return P_ShieldLook(thing, (*(*thing).info).speed as shieldtype_t);
    }
    let fresh7 = numshields;
    numshields = numshields + 1;
    P_SetTarget2(&mut *shields.as_mut_ptr().offset(fresh7 as isize), thing);
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_RunOverlays() {
    let mut mo: *mut mobj_t = 0 as *mut mobj_t;
    let mut next: *mut mobj_t = 0 as *mut mobj_t;
    let mut destx: fixed_t = 0;
    let mut desty: fixed_t = 0;
    let mut zoffs: fixed_t = 0;
    mo = overlaycap;
    while !mo.is_null() {
        next = (*mo).hnext;
        P_SetTarget2(&mut (*mo).hnext, 0 as *mut mobj_t);
        if !((*mo).target).is_null() {
            if P_MobjWasRemoved((*mo).target) != 0 {
                P_RemoveMobj(mo);
            } else {
                if splitscreen == 0 {
                    let mut viewingangle: angle_t = 0;
                    if players[displayplayer as usize].awayviewtics != 0
                        && !(players[displayplayer as usize].awayviewmobj).is_null()
                        && P_MobjWasRemoved(players[displayplayer as usize].awayviewmobj)
                            == 0
                    {
                        viewingangle = R_PointToAngle2(
                            (*(*mo).target).x,
                            (*(*mo).target).y,
                            (*players[displayplayer as usize].awayviewmobj).x,
                            (*players[displayplayer as usize].awayviewmobj).y,
                        );
                    } else if camera.chase == 0
                        && !(players[displayplayer as usize].mo).is_null()
                    {
                        viewingangle = R_PointToAngle2(
                            (*(*mo).target).x,
                            (*(*mo).target).y,
                            (*players[displayplayer as usize].mo).x,
                            (*players[displayplayer as usize].mo).y,
                        );
                    } else {
                        viewingangle = R_PointToAngle2(
                            (*(*mo).target).x,
                            (*(*mo).target).y,
                            camera.x,
                            camera.y,
                        );
                    }
                    if (*(*mo).state).frame & 0x10000000 as libc::c_int as uint32_t == 0
                        && (*(*mo).state).var1 != 0
                    {
                        viewingangle = (viewingangle as libc::c_uint)
                            .wrapping_add(0x80000000 as libc::c_uint) as angle_t
                            as angle_t;
                    }
                    destx = (*(*mo).target).x
                        + P_ReturnThrustX(
                            (*mo).target,
                            viewingangle,
                            FixedMul(
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 4 as libc::c_int,
                                (*mo).scale,
                            ),
                        );
                    desty = (*(*mo).target).y
                        + P_ReturnThrustY(
                            (*mo).target,
                            viewingangle,
                            FixedMul(
                                ((1 as libc::c_int) << 16 as libc::c_int)
                                    / 4 as libc::c_int,
                                (*mo).scale,
                            ),
                        );
                } else {
                    destx = (*(*mo).target).x;
                    desty = (*(*mo).target).y;
                }
                (*mo)
                    .eflags = ((*mo).eflags as libc::c_int
                    & !(MFE_VERTICALFLIP as libc::c_int)
                    | (*(*mo).target).eflags as libc::c_int
                        & MFE_VERTICALFLIP as libc::c_int) as uint16_t;
                (*mo).destscale = (*(*mo).target).scale;
                (*mo).scale = (*mo).destscale;
                (*mo)
                    .angle = (if !((*(*mo).target).player).is_null() {
                    (*(*(*mo).target).player).drawangle
                } else {
                    (*(*mo).target).angle
                })
                    .wrapping_add((*mo).movedir);
                if (*(*mo).state).frame & 0x10000000 as libc::c_int as uint32_t == 0 {
                    zoffs = FixedMul(
                        (*(*mo).state).var2 * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*mo).scale,
                    );
                } else {
                    zoffs = 0 as libc::c_int;
                }
                P_UnsetThingPosition(mo);
                (*mo).x = destx;
                (*mo).y = desty;
                (*mo).radius = (*(*mo).target).radius;
                (*mo).height = (*(*mo).target).height;
                if (*mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
                    (*mo)
                        .z = (*(*mo).target).z + (*(*mo).target).height - (*mo).height
                        - zoffs;
                } else {
                    (*mo).z = (*(*mo).target).z + zoffs;
                }
                if (*(*mo).state).var1 != 0 {
                    P_SetUnderlayPosition(mo);
                } else {
                    P_SetThingPosition(mo);
                }
                P_CheckPosition(mo, (*mo).x, (*mo).y);
            }
        }
        mo = next;
    }
    P_SetTarget2(&mut overlaycap, 0 as *mut mobj_t);
}
unsafe extern "C" fn P_AddOverlay(mut thing: *mut mobj_t) {
    if overlaycap.is_null() {
        P_SetTarget2(&mut overlaycap, thing);
    } else {
        let mut mo: *mut mobj_t = 0 as *mut mobj_t;
        mo = overlaycap;
        while !mo.is_null() && !((*mo).hnext).is_null() {
            mo = (*mo).hnext;
        }
        P_SetTarget2(&mut (*mo).hnext, thing);
    }
    P_SetTarget2(&mut (*thing).hnext, 0 as *mut mobj_t);
}
unsafe extern "C" fn P_RemoveOverlay(mut thing: *mut mobj_t) {
    let mut mo: *mut mobj_t = 0 as *mut mobj_t;
    if overlaycap == thing {
        P_SetTarget2(&mut overlaycap, (*thing).hnext);
        P_SetTarget2(&mut (*thing).hnext, 0 as *mut mobj_t);
        return;
    }
    mo = overlaycap;
    while !mo.is_null() {
        if (*mo).hnext != thing {
            mo = (*mo).hnext;
        } else {
            P_SetTarget2(&mut (*mo).hnext, (*thing).hnext);
            P_SetTarget2(&mut (*thing).hnext, 0 as *mut mobj_t);
            return;
        }
    }
}
unsafe extern "C" fn P_KoopaThinker(mut koopa: *mut mobj_t) {
    P_MobjCheckWater(koopa);
    if (*koopa).watertop
        > (*koopa).z + (*koopa).height
            + FixedMul(
                128 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*koopa).scale,
            ) && (*koopa).health > 0 as libc::c_int
    {
        if !((*koopa).spawnpoint).is_null() {
            EV_DoCeiling(
                (*(*koopa).spawnpoint).args[0 as libc::c_int as usize] as mtag_t,
                0 as *mut line_t,
                raiseToHighest,
            );
        }
        P_RemoveMobj(koopa);
        return;
    }
    if (*koopa).threshold > 0 as libc::c_int {
        (*koopa).threshold -= 1;
        (*koopa).threshold;
        (*koopa)
            .momx = FixedMul((1 as libc::c_int) << 16 as libc::c_int, (*koopa).scale);
        if (*koopa).threshold == 0 {
            (*koopa).threshold = -(35 as libc::c_int) * 2 as libc::c_int;
        }
    } else if (*koopa).threshold < 0 as libc::c_int {
        (*koopa).threshold += 1;
        (*koopa).threshold;
        (*koopa)
            .momx = FixedMul(-((1 as libc::c_int) << 16 as libc::c_int), (*koopa).scale);
        if (*koopa).threshold == 0 {
            (*koopa).threshold = 35 as libc::c_int * 2 as libc::c_int;
        }
    } else {
        (*koopa).threshold = 35 as libc::c_int * 2 as libc::c_int;
    }
    P_XYMovement(koopa);
    if P_RandomFixed() < ((1 as libc::c_int) << 16 as libc::c_int) / 32 as libc::c_int
        && (*koopa).z <= (*koopa).floorz
    {
        (*koopa)
            .momz = FixedMul(
            5 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
            (*koopa).scale,
        );
    }
    if (*koopa).z > (*koopa).floorz {
        (*koopa).momz
            += FixedMul(
                ((1 as libc::c_int) << 16 as libc::c_int) / 4 as libc::c_int,
                (*koopa).scale,
            );
    }
    if P_RandomFixed() < ((1 as libc::c_int) << 16 as libc::c_int) / 64 as libc::c_int {
        let mut flame: *mut mobj_t = 0 as *mut mobj_t;
        flame = P_SpawnMobj(
            (*koopa).x - (*koopa).radius
                + FixedMul(
                    5 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*koopa).scale,
                ),
            (*koopa).y,
            (*koopa).z
                + ((P_RandomByte() as libc::c_int)
                    << 16 as libc::c_int - 2 as libc::c_int),
            MT_KOOPAFLAME,
        );
        (*flame).momx = -FixedMul((*(*flame).info).speed, (*flame).scale);
        S_StartSound(flame as *const libc::c_void, sfx_koopfr);
    } else if P_RandomFixed()
        < 5 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
            / 256 as libc::c_int
    {
        let mut hammer: *mut mobj_t = 0 as *mut mobj_t;
        hammer = P_SpawnMobj(
            (*koopa).x - (*koopa).radius,
            (*koopa).y,
            (*koopa).z + (*koopa).height,
            MT_HAMMER,
        );
        (*hammer)
            .momx = FixedMul(
            -(5 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
            (*hammer).scale,
        );
        (*hammer)
            .momz = FixedMul(
            7 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
            (*hammer).scale,
        );
    }
}
unsafe extern "C" fn P_SpawnMinecartSegments(mut mobj: *mut mobj_t, mut mode: boolean) {
    let mut x: fixed_t = (*mobj).x;
    let mut y: fixed_t = (*mobj).y;
    let mut z: fixed_t = (*mobj).z;
    let mut prevseg: *mut mobj_t = mobj;
    let mut seg: *mut mobj_t = 0 as *mut mobj_t;
    let mut i: uint8_t = 0;
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 4 as libc::c_int {
        seg = P_SpawnMobj(x, y, z, MT_MINECARTSEG);
        P_SetMobjState(
            seg,
            (S_MINECARTSEG_FRONT as libc::c_int + i as libc::c_int) as statenum_t,
        );
        if i as libc::c_int >= 2 as libc::c_int {
            (*seg)
                .extravalue1 = if i as libc::c_int == 2 as libc::c_int {
                -(18 as libc::c_int)
            } else {
                18 as libc::c_int
            };
        } else {
            (*seg)
                .extravalue2 = if i as libc::c_int == 0 as libc::c_int {
                24 as libc::c_int
            } else {
                -(24 as libc::c_int)
            };
            (*seg).cusval = -(90 as libc::c_int);
        }
        if mode == 0 {
            (*seg).frame &= !(0x10000000 as libc::c_int) as uint32_t;
        }
        P_SetTarget2(&mut (*prevseg).tracer, seg);
        prevseg = seg;
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn P_UpdateMinecartSegments(mut mobj: *mut mobj_t) {
    let mut seg: *mut mobj_t = (*mobj).tracer;
    let mut x: fixed_t = (*mobj).x;
    let mut y: fixed_t = (*mobj).y;
    let mut z: fixed_t = (*mobj).z;
    let mut ang: angle_t = (*mobj).angle;
    let mut fa: angle_t = ang >> 19 as libc::c_int
        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
    let mut c: fixed_t = *finecosine.offset(fa as isize)
        >> 16 as libc::c_int - 16 as libc::c_int;
    let mut s: fixed_t = finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int;
    let mut dx: int32_t = 0;
    let mut dy: int32_t = 0;
    let mut sang: int32_t = 0;
    while !seg.is_null() {
        dx = (*seg).extravalue1;
        dy = (*seg).extravalue2;
        sang = (*seg).cusval;
        P_MoveOrigin(seg, x + s * dx + c * dy, y - c * dx + s * dy, z);
        (*seg)
            .angle = ang
            .wrapping_add(FixedAngle(((1 as libc::c_int) << 16 as libc::c_int) * sang));
        (*seg)
            .flags2 = (*seg).flags2 & !(MF2_DONTDRAW as libc::c_int) as uint32_t
            | (*mobj).flags2 & MF2_DONTDRAW as libc::c_int as uint32_t;
        seg = (*seg).tracer;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_HandleMinecartSegments(mut mobj: *mut mobj_t) {
    if ((*mobj).tracer).is_null() {
        P_SpawnMinecartSegments(
            mobj,
            ((*mobj).type_0 as libc::c_uint
                == MT_MINECART as libc::c_int as libc::c_uint) as libc::c_int,
        );
    }
    P_UpdateMinecartSegments(mobj);
}
unsafe extern "C" fn P_PyreFlyBurn(
    mut mobj: *mut mobj_t,
    mut hoffs: fixed_t,
    mut vrange: int16_t,
    mut mobjtype: mobjtype_t,
    mut momz: fixed_t,
) {
    let mut fa: angle_t = FixedAngle(
        P_RandomKey(360 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
    ) >> 19 as libc::c_int & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
    let mut xoffs: fixed_t = FixedMul(
        *finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int,
        (*mobj).radius + hoffs,
    );
    let mut yoffs: fixed_t = FixedMul(
        finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
        (*mobj).radius + hoffs,
    );
    let mut zoffs: fixed_t = P_RandomRange(-(vrange as libc::c_int), vrange as int32_t)
        * ((1 as libc::c_int) << 16 as libc::c_int);
    let mut particle: *mut mobj_t = P_SpawnMobjFromMobj(
        mobj,
        xoffs,
        yoffs,
        zoffs,
        mobjtype,
    );
    (*particle).momz = momz;
    (*particle).flags2 |= MF2_LINKDRAW as libc::c_int as uint32_t;
    P_SetTarget2(&mut (*particle).tracer, mobj);
}
unsafe extern "C" fn P_MobjScaleThink(mut mobj: *mut mobj_t) {
    let mut oldheight: fixed_t = (*mobj).height;
    let mut correctionType: uint8_t = 0 as libc::c_int as uint8_t;
    if (*mobj).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t != 0
        || (*mobj).z > (*mobj).floorz && (*mobj).z + (*mobj).height < (*mobj).ceilingz
    {
        correctionType = 1 as libc::c_int as uint8_t;
    } else if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        correctionType = 2 as libc::c_int as uint8_t;
    }
    if abs((*mobj).scale - (*mobj).destscale) < (*mobj).scalespeed {
        P_SetScale(mobj, (*mobj).destscale);
    } else if (*mobj).scale < (*mobj).destscale {
        P_SetScale(mobj, (*mobj).scale + (*mobj).scalespeed);
    } else if (*mobj).scale > (*mobj).destscale {
        P_SetScale(mobj, (*mobj).scale - (*mobj).scalespeed);
    }
    if correctionType as libc::c_int == 1 as libc::c_int {
        (*mobj).z -= ((*mobj).height - oldheight) / 2 as libc::c_int;
    } else if correctionType as libc::c_int == 2 as libc::c_int {
        (*mobj).z -= (*mobj).height - oldheight;
    }
    if (*mobj).scale == (*mobj).destscale {
        match (*mobj).type_0 as libc::c_uint {
            _ => {}
        }
    }
}
unsafe extern "C" fn P_MaceSceneryThink(mut mobj: *mut mobj_t) {
    let mut oldmovedir: angle_t = (*mobj).movedir;
    (*mobj)
        .movedir = ((*mobj).movedir).wrapping_add((*mobj).lastlook as angle_t)
        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
    if (*mobj).flags2 & MF2_BOSSNOTRAP as libc::c_int as uint32_t == 0 {
        let mut i: uint8_t = 0;
        i = 0 as libc::c_int as uint8_t;
        while (i as libc::c_int) < 32 as libc::c_int {
            if playeringame[i as usize] != 0 && !(players[i as usize].mo).is_null()
                && P_AproxDistance(
                    P_AproxDistance(
                        (*mobj).x - (*players[i as usize].mo).x,
                        (*mobj).y - (*players[i as usize].mo).y,
                    ),
                    (*mobj).z - (*players[i as usize].mo).z,
                ) < (4200 as libc::c_int) << 16 as libc::c_int
            {
                break;
            }
            i = i.wrapping_add(1);
            i;
        }
        if i as libc::c_int == 32 as libc::c_int {
            if (*mobj).flags2 & MF2_BEYONDTHEGRAVE as libc::c_int as uint32_t == 0 {
                let mut ref_0: *mut mobj_t = mobj;
                loop {
                    ref_0 = (*ref_0).hnext;
                    if ref_0.is_null() {
                        break;
                    }
                    (*ref_0)
                        .eflags = ((if (*ref_0).flags
                        & MF_NOTHINK as libc::c_int as uint32_t != 0
                    {
                        0 as libc::c_int
                    } else {
                        1 as libc::c_int
                    })
                        | (if (*ref_0).flags & MF_NOCLIPTHING as libc::c_int as uint32_t
                            != 0
                        {
                            0 as libc::c_int
                        } else {
                            2 as libc::c_int
                        })
                        | (if (*ref_0).flags2 & MF2_DONTDRAW as libc::c_int as uint32_t
                            != 0
                        {
                            0 as libc::c_int
                        } else {
                            4 as libc::c_int
                        })) as uint16_t;
                    (*ref_0).flags
                        |= (MF_NOTHINK as libc::c_int | MF_NOCLIPTHING as libc::c_int)
                            as uint32_t;
                    (*ref_0).flags2 |= MF2_DONTDRAW as libc::c_int as uint32_t;
                    (*ref_0).momz = 0 as libc::c_int;
                    (*ref_0).momy = (*ref_0).momz;
                    (*ref_0).momx = (*ref_0).momy;
                }
                (*mobj).flags2 |= MF2_BEYONDTHEGRAVE as libc::c_int as uint32_t;
            }
            return;
        } else if (*mobj).flags2 & MF2_BEYONDTHEGRAVE as libc::c_int as uint32_t != 0 {
            let mut ref_1: *mut mobj_t = mobj;
            loop {
                ref_1 = (*ref_1).hnext;
                if ref_1.is_null() {
                    break;
                }
                if (*ref_1).eflags as libc::c_int & 1 as libc::c_int != 0 {
                    (*ref_1).flags &= !(MF_NOTHINK as libc::c_int) as uint32_t;
                }
                if (*ref_1).eflags as libc::c_int & 2 as libc::c_int != 0 {
                    (*ref_1).flags &= !(MF_NOCLIPTHING as libc::c_int) as uint32_t;
                }
                if (*ref_1).eflags as libc::c_int & 4 as libc::c_int != 0 {
                    (*ref_1).flags2 &= !(MF2_DONTDRAW as libc::c_int) as uint32_t;
                }
                (*ref_1).eflags = 0 as libc::c_int as uint16_t;
            }
            (*mobj).flags2 &= !(MF2_BEYONDTHEGRAVE as libc::c_int) as uint32_t;
        }
    }
    P_MaceRotate(mobj, (*mobj).movedir as int32_t, oldmovedir as int32_t);
}
unsafe extern "C" fn P_DrownNumbersSceneryThink(mut mobj: *mut mobj_t) -> boolean {
    if ((*mobj).target).is_null() {
        P_RemoveMobj(mobj);
        return false_0 as libc::c_int;
    }
    if ((*(*mobj).target).player).is_null()
        || !((*(*(*mobj).target).player).powers[pw_underwater as libc::c_int as usize]
            as libc::c_int != 0
            || (*(*(*mobj).target).player).powers[pw_spacetime as libc::c_int as usize]
                as libc::c_int != 0)
    {
        P_RemoveMobj(mobj);
        return false_0 as libc::c_int;
    }
    (*mobj).x = (*(*mobj).target).x;
    (*mobj).y = (*(*mobj).target).y;
    (*mobj).destscale = (*(*mobj).target).destscale;
    P_SetScale(mobj, (*(*mobj).target).scale);
    if (*(*mobj).target).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        (*mobj)
            .z = (*(*mobj).target).z
            - FixedMul(
                16 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*(*mobj).target).scale,
            ) - (*mobj).height;
        if (*(*(*mobj).target).player).pflags as libc::c_uint
            & PF_FLIPCAM as libc::c_int as libc::c_uint != 0
        {
            (*mobj)
                .eflags = ((*mobj).eflags as libc::c_int
                | MFE_VERTICALFLIP as libc::c_int) as uint16_t;
        }
    } else {
        (*mobj)
            .z = (*(*mobj).target).z + (*(*mobj).target).height
            + FixedMul(
                8 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*(*mobj).target).scale,
            );
    }
    if (*mobj).threshold <= 35 as libc::c_int {
        (*mobj).flags2 |= MF2_DONTDRAW as libc::c_int as uint32_t;
    } else {
        (*mobj).flags2 &= !(MF2_DONTDRAW as libc::c_int) as uint32_t;
    }
    if (*mobj).threshold <= 30 as libc::c_int {
        (*mobj).threshold = 40 as libc::c_int;
    }
    (*mobj).threshold -= 1;
    (*mobj).threshold;
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_FlameJetSceneryThink(mut mobj: *mut mobj_t) {
    let mut flame: *mut mobj_t = 0 as *mut mobj_t;
    let mut strength: fixed_t = 0;
    if (*mobj).flags2 & MF2_FIRING as libc::c_int as uint32_t == 0 {
        return;
    }
    if leveltime & 3 as libc::c_int as tic_t != 0 as libc::c_int as tic_t {
        return;
    }
    if (*mobj).fuse <= -(16 as libc::c_int) {
        (*mobj).reactiontime = 1 as libc::c_int;
    } else if (*mobj).fuse >= 16 as libc::c_int {
        (*mobj).reactiontime = 0 as libc::c_int;
    }
    if (*mobj).reactiontime != 0 {
        (*mobj).fuse += 2 as libc::c_int;
    } else {
        (*mobj).fuse -= 2 as libc::c_int;
    }
    flame = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, MT_FLAMEJETFLAME);
    P_SetMobjState(flame, S_FLAMEJETFLAME4);
    (*flame).angle = (*mobj).angle;
    if (*mobj).flags2 & MF2_AMBUSH as libc::c_int as uint32_t != 0 {
        (*flame).momz = (*mobj).fuse << 16 as libc::c_int - 2 as libc::c_int;
    } else {
        (*flame)
            .angle = ((*flame).angle)
            .wrapping_add(FixedAngle((*mobj).fuse << 16 as libc::c_int));
    }
    strength = ((if (*mobj).movedir != 0 {
        (*mobj).movedir
    } else {
        80 as libc::c_int as angle_t
    }) << 16 as libc::c_int - 2 as libc::c_int) as fixed_t;
    P_InstaThrust(flame, (*flame).angle, strength);
    S_StartSound(flame as *const libc::c_void, sfx_fire);
}
unsafe extern "C" fn P_VerticalFlameJetSceneryThink(mut mobj: *mut mobj_t) {
    let mut flame: *mut mobj_t = 0 as *mut mobj_t;
    let mut strength: fixed_t = 0;
    if (*mobj).flags2 & MF2_FIRING as libc::c_int as uint32_t == 0 {
        return;
    }
    if leveltime & 3 as libc::c_int as tic_t != 0 as libc::c_int as tic_t {
        return;
    }
    if (*mobj).fuse <= -(16 as libc::c_int) {
        (*mobj).reactiontime = 1 as libc::c_int;
    } else if (*mobj).fuse >= 16 as libc::c_int {
        (*mobj).reactiontime = 0 as libc::c_int;
    }
    if (*mobj).reactiontime != 0 {
        (*mobj).fuse += 1;
        (*mobj).fuse;
    } else {
        (*mobj).fuse -= 1;
        (*mobj).fuse;
    }
    flame = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, MT_FLAMEJETFLAME);
    strength = ((if (*mobj).movedir != 0 {
        (*mobj).movedir
    } else {
        80 as libc::c_int as angle_t
    }) << 16 as libc::c_int - 2 as libc::c_int) as fixed_t;
    if (*mobj).flags2 & MF2_AMBUSH as libc::c_int as uint32_t != 0 {
        (*mobj).z = (*mobj).ceilingz - (*mobj).height;
        (*flame).momz = -strength;
    } else {
        (*flame).momz = strength;
        P_SetMobjState(flame, S_FLAMEJETFLAME7);
    }
    P_InstaThrust(
        flame,
        (*mobj).angle,
        FixedDiv(
            (*mobj).fuse * ((1 as libc::c_int) << 16 as libc::c_int),
            3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        ),
    );
    S_StartSound(flame as *const libc::c_void, sfx_fire);
}
unsafe extern "C" fn P_ParticleGenSceneryThink(mut mobj: *mut mobj_t) -> boolean {
    if (*mobj).lastlook == 0 {
        return false_0 as libc::c_int;
    }
    if (*mobj).threshold == 0 {
        return false_0 as libc::c_int;
    }
    (*mobj).fuse -= 1;
    if (*mobj).fuse <= 0 as libc::c_int {
        let mut i: int32_t = 0 as libc::c_int;
        let mut spawn: *mut mobj_t = 0 as *mut mobj_t;
        let mut bottomheight: fixed_t = 0;
        let mut topheight: fixed_t = 0;
        let mut type_0: int32_t = (*mobj).threshold;
        let mut line: int32_t = (*mobj).cvmem;
        (*mobj).fuse = (*mobj).reactiontime as tic_t as int32_t;
        if line != -(1 as libc::c_int) {
            bottomheight = (*(*lines.offset(line as isize)).frontsector).floorheight;
            topheight = (*(*lines.offset(line as isize)).frontsector).ceilingheight
                - mobjinfo[type_0 as mobjtype_t as usize].height;
        } else if (*mobj).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t != 0 {
            bottomheight = (*mobj).z - (*mobj).extravalue1;
            topheight = (*mobj).z - mobjinfo[type_0 as mobjtype_t as usize].height;
        } else {
            bottomheight = (*mobj).z;
            topheight = (*mobj).z + (*mobj).extravalue1
                - mobjinfo[type_0 as mobjtype_t as usize].height;
        }
        if (*mobj).waterbottom != bottomheight || (*mobj).watertop != topheight {
            if (*mobj).movefactor != 0 && topheight > bottomheight {
                (*mobj)
                    .health = (FixedDiv(
                    topheight - bottomheight,
                    abs((*mobj).movefactor),
                ) >> 16 as libc::c_int) as tic_t as int32_t;
            } else {
                (*mobj).health = 0 as libc::c_int;
            }
            if line != -(1 as libc::c_int) {
                (*mobj)
                    .z = if (*mobj).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t
                    != 0
                {
                    topheight
                } else {
                    bottomheight
                };
            }
        }
        if (*mobj).health == 0 {
            return false_0 as libc::c_int;
        }
        i = 0 as libc::c_int;
        while i < (*mobj).lastlook {
            spawn = P_SpawnMobj(
                (*mobj).x
                    + FixedMul(
                        FixedMul((*mobj).friction, (*mobj).scale),
                        *finecosine.offset(((*mobj).angle >> 19 as libc::c_int) as isize)
                            >> 16 as libc::c_int - 16 as libc::c_int,
                    ),
                (*mobj).y
                    + FixedMul(
                        FixedMul((*mobj).friction, (*mobj).scale),
                        finesine[((*mobj).angle >> 19 as libc::c_int) as usize]
                            >> 16 as libc::c_int - 16 as libc::c_int,
                    ),
                (*mobj).z,
                (*mobj).threshold as mobjtype_t,
            );
            P_SetScale(spawn, (*mobj).scale);
            (*spawn).momz = FixedMul((*mobj).movefactor, (*spawn).scale);
            (*spawn).destscale = (*spawn).scale / 100 as libc::c_int;
            (*spawn).scalespeed = (*spawn).scale / (*mobj).health;
            (*spawn).tics = (*mobj).health as tic_t as int32_t;
            (*spawn).flags2
                |= (*mobj).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t;
            (*spawn)
                .angle = ((*spawn).angle)
                .wrapping_add(
                    (P_RandomKey(36 as libc::c_int) * 0x71c71c7 as libc::c_int)
                        as angle_t,
                );
            (*mobj).angle = ((*mobj).angle).wrapping_add((*mobj).movedir);
            i += 1;
            i;
        }
        (*mobj).angle = ((*mobj).angle).wrapping_add((*mobj).movecount as angle_t);
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_RosySceneryThink(mut mobj: *mut mobj_t) {
    let mut i: uint8_t = 0;
    let mut pdist: fixed_t = 1700 as libc::c_int * (*mobj).scale;
    let mut work: fixed_t = 0;
    let mut actualwork: fixed_t = 0;
    let mut player: *mut player_t = 0 as *mut player_t;
    let mut stat: statenum_t = ((*mobj).state).offset_from(states.as_mut_ptr())
        as libc::c_long as statenum_t;
    let mut current_block_5: u64;
    i = 0 as libc::c_int as uint8_t;
    while (i as libc::c_int) < 32 as libc::c_int {
        if !(playeringame[i as usize] == 0) {
            if !(players[i as usize].mo).is_null() {
                if !(players[i as usize].bot as libc::c_int == BOT_2PAI as libc::c_int
                    || players[i as usize].bot as libc::c_int
                        == BOT_2PHUMAN as libc::c_int)
                {
                    if !((*players[i as usize].mo).health == 0) {
                        work = FixedHypot(
                            (*mobj).x - (*players[i as usize].mo).x,
                            (*mobj).y - (*players[i as usize].mo).y,
                        );
                        actualwork = work;
                        if !player.is_null() {
                            if players[i as usize].skin == 0 as libc::c_int
                                || players[i as usize].skin == 5 as libc::c_int
                            {
                                work = 2 as libc::c_int * work / 3 as libc::c_int;
                            }
                            if work >= pdist {
                                current_block_5 = 8258075665625361029;
                            } else {
                                current_block_5 = 12209867499936983673;
                            }
                        } else {
                            current_block_5 = 12209867499936983673;
                        }
                        match current_block_5 {
                            8258075665625361029 => {}
                            _ => {
                                pdist = actualwork;
                                player = &mut *players.as_mut_ptr().offset(i as isize)
                                    as *mut player_t;
                            }
                        }
                    }
                }
            }
        }
        i = i.wrapping_add(1);
        i;
    }
    if stat as libc::c_uint == S_ROSY_JUMP as libc::c_int as libc::c_uint
        || stat as libc::c_uint == S_ROSY_PAIN as libc::c_int as libc::c_uint
    {
        if P_IsObjectOnGround(mobj) != 0 {
            (*mobj).momy = 0 as libc::c_int;
            (*mobj).momx = (*mobj).momy;
            if !player.is_null()
                && (*mobj).cvmem < -(2 as libc::c_int) * 35 as libc::c_int
            {
                stat = S_ROSY_UNHAPPY;
            } else {
                stat = S_ROSY_WALK;
            }
            P_SetMobjState(mobj, stat);
        } else if P_MobjFlip(mobj) as libc::c_int * (*mobj).momz < 0 as libc::c_int {
            (*mobj)
                .frame = ((*(*mobj).state).frame)
                .wrapping_add((*(*mobj).state).var1 as uint32_t);
        }
    }
    if player.is_null() {
        if ((stat as libc::c_uint) < S_ROSY_IDLE1 as libc::c_int as libc::c_uint
            || stat as libc::c_uint > S_ROSY_IDLE4 as libc::c_int as libc::c_uint)
            && stat as libc::c_uint != S_ROSY_JUMP as libc::c_int as libc::c_uint
        {
            (*mobj).momy = 0 as libc::c_int;
            (*mobj).momx = (*mobj).momy;
            P_SetMobjState(mobj, S_ROSY_IDLE1);
        }
    } else {
        let mut dojump: boolean = false_0 as libc::c_int;
        let mut targonground: boolean = 0;
        let mut love: boolean = 0;
        let mut makeheart: boolean = false_0 as libc::c_int;
        if (*mobj).target != (*player).mo {
            P_SetTarget2(&mut (*mobj).target, (*player).mo);
        }
        targonground = (P_IsObjectOnGround((*mobj).target) != 0
            && ((*player).panim as libc::c_uint == PA_IDLE as libc::c_int as libc::c_uint
                || (*player).panim as libc::c_uint
                    == PA_WALK as libc::c_int as libc::c_uint
                || (*player).panim as libc::c_uint
                    == PA_RUN as libc::c_int as libc::c_uint)
            && (*(*player).mo).z == (*mobj).z) as libc::c_int;
        love = ((*player).skin == 0 as libc::c_int || (*player).skin == 5 as libc::c_int)
            as libc::c_int;
        match stat as libc::c_uint {
            1535 | 1536 | 1537 | 1538 => {
                dojump = true_0 as libc::c_int;
            }
            1540 => {
                let mut x: fixed_t = (*mobj).x;
                let mut y: fixed_t = (*mobj).y;
                let mut z: fixed_t = (*mobj).z;
                let mut angletoplayer: angle_t = R_PointToAngle2(
                    x,
                    y,
                    (*(*mobj).target).x,
                    (*(*mobj).target).y,
                );
                let mut allowed: boolean = P_TryMove(
                    mobj,
                    (*(*mobj).target).x,
                    (*(*mobj).target).y,
                    false_0 as libc::c_int,
                );
                P_UnsetThingPosition(mobj);
                (*mobj).x = x;
                (*mobj).y = y;
                (*mobj).z = z;
                P_SetThingPosition(mobj);
                if allowed != 0 {
                    let mut mom: fixed_t = 0;
                    let mut max: fixed_t = 0;
                    P_Thrust(
                        mobj,
                        angletoplayer,
                        3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                            >> 1 as libc::c_int,
                    );
                    mom = FixedHypot((*mobj).momx, (*mobj).momy);
                    max = pdist;
                    (*mobj).extravalue1 -= 1;
                    if (*mobj).extravalue1 <= 0 as libc::c_int {
                        (*mobj).frame = ((*mobj).frame).wrapping_add(1);
                        if (*mobj).frame
                            > ((*(*mobj).state).frame)
                                .wrapping_add((*(*mobj).state).var1 as uint32_t)
                        {
                            (*mobj).frame = (*(*mobj).state).frame;
                        }
                        if mom > 12 as libc::c_int * (*mobj).scale {
                            (*mobj).extravalue1 = 2 as libc::c_int;
                        } else if mom > 6 as libc::c_int * (*mobj).scale {
                            (*mobj).extravalue1 = 3 as libc::c_int;
                        } else {
                            (*mobj).extravalue1 = 4 as libc::c_int;
                        }
                    }
                    if max < (*mobj).radius + (*(*mobj).target).radius {
                        (*mobj).momx = (*(*(*mobj).target).player).cmomx;
                        (*mobj).momy = (*(*(*mobj).target).player).cmomy;
                        if (*mobj).cvmem > 35 as libc::c_int && (*player).exiting == 0
                            || targonground == 0
                        {
                            stat = S_ROSY_STND;
                            P_SetMobjState(mobj, stat);
                        } else {
                            (*(*mobj).target).momx = (*mobj).momx;
                            (*(*mobj).target).momy = (*mobj).momy;
                            stat = S_ROSY_HUG;
                            P_SetMobjState(mobj, stat);
                            S_StartSound(mobj as *const libc::c_void, sfx_cdpcm6);
                            (*mobj).angle = angletoplayer;
                        }
                    } else {
                        max /= 3 as libc::c_int;
                        if max > 30 as libc::c_int * (*mobj).scale {
                            max = 30 as libc::c_int * (*mobj).scale;
                        }
                        if mom > max && max > (*mobj).scale {
                            max = FixedDiv(max, mom);
                            (*mobj).momx = FixedMul((*mobj).momx, max);
                            (*mobj).momy = FixedMul((*mobj).momy, max);
                        }
                        if abs((*mobj).momx) > (*mobj).scale
                            || abs((*mobj).momy) > (*mobj).scale
                        {
                            (*mobj)
                                .angle = R_PointToAngle2(
                                0 as libc::c_int,
                                0 as libc::c_int,
                                (*mobj).momx,
                                (*mobj).momy,
                            );
                        }
                    }
                } else {
                    dojump = true_0 as libc::c_int;
                }
            }
            1541 => {
                if targonground != 0 {
                    (*player)
                        .pflags = ::core::mem::transmute::<
                        libc::c_uint,
                        pflags_t,
                    >(
                        (*player).pflags as libc::c_uint
                            | PF_STASIS as libc::c_int as libc::c_uint,
                    );
                    if (*mobj).cvmem < 5 as libc::c_int * 35 as libc::c_int {
                        (*mobj).cvmem += 1;
                        (*mobj).cvmem;
                    }
                    if love != 0 && leveltime & 7 as libc::c_int as tic_t == 0 {
                        makeheart = true_0 as libc::c_int;
                    }
                } else {
                    if (*mobj).cvmem
                        < (if love != 0 {
                            5 as libc::c_int * 35 as libc::c_int
                        } else {
                            0 as libc::c_int
                        })
                    {
                        stat = S_ROSY_PAIN;
                        P_SetMobjState(mobj, stat);
                        S_StartSound(mobj as *const libc::c_void, sfx_cdpcm7);
                    } else {
                        stat = S_ROSY_JUMP;
                        P_SetMobjState(mobj, stat);
                    }
                    var2 = 0 as libc::c_int;
                    var1 = var2;
                    A_DoNPCPain(mobj);
                    (*mobj).cvmem -= 35 as libc::c_int;
                }
            }
            1543 => {
                if pdist
                    > (*mobj).radius + (*(*mobj).target).radius
                        + 3 as libc::c_int * ((*mobj).scale + (*(*mobj).target).scale)
                {
                    stat = S_ROSY_WALK;
                    P_SetMobjState(mobj, stat);
                } else if !(targonground == 0) {
                    if love != 0 && leveltime & 15 as libc::c_int as tic_t == 0 {
                        makeheart = true_0 as libc::c_int;
                    }
                    if (*player).exiting != 0
                        || {
                            (*mobj).cvmem -= 1;
                            (*mobj).cvmem < 35 as libc::c_int
                        }
                    {
                        stat = S_ROSY_HUG;
                        P_SetMobjState(mobj, stat);
                        S_StartSound(mobj as *const libc::c_void, sfx_cdpcm6);
                        (*mobj)
                            .angle = R_PointToAngle2(
                            (*mobj).x,
                            (*mobj).y,
                            (*(*mobj).target).x,
                            (*(*mobj).target).y,
                        );
                        (*(*mobj).target).momx = (*mobj).momx;
                        (*(*mobj).target).momy = (*mobj).momy;
                    }
                }
            }
            1539 | 1542 | 1544 | _ => {}
        }
        if stat as libc::c_uint == S_ROSY_HUG as libc::c_int as libc::c_uint {
            if (*player).panim as libc::c_uint != PA_IDLE as libc::c_int as libc::c_uint
            {
                P_SetPlayerMobjState((*mobj).target, S_PLAY_STND);
            }
            (*player)
                .pflags = ::core::mem::transmute::<
                libc::c_uint,
                pflags_t,
            >(
                (*player).pflags as libc::c_uint
                    | PF_STASIS as libc::c_int as libc::c_uint,
            );
        }
        if dojump != 0 {
            P_SetMobjState(mobj, S_ROSY_JUMP);
            (*mobj).z += P_MobjFlip(mobj) as libc::c_int;
            (*mobj).momy = 0 as libc::c_int;
            (*mobj).momx = (*mobj).momy;
            P_SetObjectMomZ(
                mobj,
                (6 as libc::c_int) << 16 as libc::c_int,
                false_0 as libc::c_int,
            );
            S_StartSound(mobj as *const libc::c_void, sfx_cdfm02);
        }
        if makeheart != 0 {
            let mut cdlhrt: *mut mobj_t = P_SpawnMobjFromMobj(
                mobj,
                0 as libc::c_int,
                0 as libc::c_int,
                (*mobj).height,
                MT_CDLHRT,
            );
            (*cdlhrt).destscale = 5 as libc::c_int * (*mobj).scale >> 4 as libc::c_int;
            P_SetScale(cdlhrt, (*cdlhrt).destscale);
            (*cdlhrt).fuse = 5 as libc::c_int * 35 as libc::c_int >> 1 as libc::c_int;
            (*cdlhrt).momz = (*mobj).scale;
            P_SetTarget2(&mut (*cdlhrt).target, mobj);
            (*cdlhrt).extravalue1 = (*mobj).x;
            (*cdlhrt).extravalue2 = (*mobj).y;
        }
    };
}
unsafe extern "C" fn P_MobjSceneryThink(mut mobj: *mut mobj_t) {
    if LUA_HookMobj(mobj, mobjhook_MobjThinker as libc::c_int) != 0 {
        return;
    }
    if P_MobjWasRemoved(mobj) != 0 {
        return;
    }
    if (*mobj).flags2 & MF2_SHIELD as libc::c_int as uint32_t != 0
        && P_AddShield(mobj) == 0
    {
        return;
    }
    let mut current_block_207: u64;
    match (*mobj).type_0 as libc::c_uint {
        60 => {
            (*mobj).flags2 ^= MF2_DONTDRAW as libc::c_int as uint32_t;
            current_block_207 = 2525024825076287515;
        }
        272 | 273 | 274 | 275 | 277 | 278 | 276 => {
            P_MaceSceneryThink(mobj);
            current_block_207 = 2525024825076287515;
        }
        577 => {
            if (*mobj).fuse > 1 as libc::c_int {
                P_MoveHoop(mobj);
            } else if (*mobj).fuse == 1 as libc::c_int {
                (*mobj).movecount = 1 as libc::c_int;
            }
            if (*mobj).movecount != 0 {
                (*mobj).fuse += 1;
                (*mobj).fuse;
                if (*mobj).fuse > 32 as libc::c_int {
                    P_RemoveMobj(mobj);
                }
            } else {
                (*mobj).fuse -= 1;
                (*mobj).fuse;
            }
            return;
        }
        574 => {
            if (*mobj).tics != -(1 as libc::c_int) {
                (*mobj).tics -= 1;
                (*mobj).tics;
                if (*mobj).tics == 0 {
                    if P_SetMobjState(mobj, (*(*mobj).state).nextstate) == 0 {
                        return;
                    }
                }
            }
            P_UnsetThingPosition(mobj);
            (*mobj).x += (*mobj).momx;
            (*mobj).y += (*mobj).momy;
            (*mobj).z += (*mobj).momz;
            P_SetThingPosition(mobj);
            return;
        }
        575 => {
            (*mobj).tics -= 1;
            if (*mobj).tics <= 0 as libc::c_int {
                P_RemoveMobj(mobj);
            }
            return;
        }
        616 => {
            if ((*mobj).target).is_null() {
                P_RemoveMobj(mobj);
                return;
            } else {
                P_AddOverlay(mobj);
            }
            current_block_207 = 2525024825076287515;
        }
        462 | 461 | 460 => {
            if (*mobj).flags2 & MF2_SHIELD as libc::c_int as uint32_t == 0 {
                return;
            }
            current_block_207 = 2525024825076287515;
        }
        458 => {
            if (*mobj).flags2 & MF2_SHIELD as libc::c_int as uint32_t == 0 {
                return;
            }
            if (*(*(*mobj).target).player).homing as libc::c_int != 0
                && (*(*(*mobj).target).player).pflags as libc::c_uint
                    & PF_SHIELDABILITY as libc::c_int as libc::c_uint != 0
            {
                P_SetMobjState(mobj, (*(*mobj).info).painstate);
                (*mobj).tics += 1;
                (*mobj).tics;
            }
            current_block_207 = 2525024825076287515;
        }
        457 => {
            if (*mobj).flags2 & MF2_SHIELD as libc::c_int as uint32_t == 0 {
                return;
            }
            if !((*mobj).tracer).is_null()
                && (*(*(*mobj).target).player).pflags as libc::c_uint
                    & PF_SHIELDABILITY as libc::c_int as libc::c_uint != 0
                && ((((*(*mobj).tracer).state).offset_from(states.as_mut_ptr())
                    as libc::c_long as statenum_t as libc::c_uint)
                    < (*(*mobj).info).raisestate as libc::c_uint
                    || ((*(*(*mobj).tracer).state).nextstate as libc::c_uint)
                        < (*(*mobj).info).raisestate as libc::c_uint
                        && (*(*mobj).tracer).tics == 1 as libc::c_int)
            {
                P_SetMobjState(mobj, (*(*mobj).info).painstate);
                (*mobj).tics += 1;
                (*mobj).tics;
                P_SetMobjState((*mobj).tracer, (*(*mobj).info).raisestate);
                (*(*mobj).tracer).tics += 1;
                (*(*mobj).tracer).tics;
            }
            current_block_207 = 2525024825076287515;
        }
        459 => {
            if (*mobj).flags2 & MF2_SHIELD as libc::c_int as uint32_t == 0 {
                return;
            }
            if (*(*(*mobj).target).player).pflags as libc::c_uint
                & PF_SHIELDABILITY as libc::c_int as libc::c_uint != 0
            {
                let mut whoosh: *mut mobj_t = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    MT_GHOST,
                );
                P_SetMobjState(whoosh, (*(*mobj).info).raisestate);
                (*whoosh).destscale = (*whoosh).scale << 1 as libc::c_int;
                (*whoosh).scalespeed = FixedMul((*whoosh).scalespeed, (*whoosh).scale);
                (*whoosh).height = 38 as libc::c_int * (*whoosh).scale;
                (*whoosh).fuse = 10 as libc::c_int;
                (*whoosh).flags |= MF_NOCLIPHEIGHT as libc::c_int as uint32_t;
                (*whoosh).momz = (*(*mobj).target).momz;
                (*(*(*mobj).target).player)
                    .pflags = ::core::mem::transmute::<
                    libc::c_uint,
                    pflags_t,
                >(
                    (*(*(*mobj).target).player).pflags as libc::c_uint
                        & !(PF_SHIELDABILITY as libc::c_int) as libc::c_uint,
                );
            }
            current_block_207 = 5845872889173891897;
        }
        463 => {
            current_block_207 = 5845872889173891897;
        }
        464 => {
            if (*mobj).flags2 & MF2_SHIELD as libc::c_int as uint32_t == 0 {
                return;
            }
            if !((*mobj).tracer).is_null() {
                if (*(*(*mobj).target).player).pflags as libc::c_uint
                    & PF_SHIELDABILITY as libc::c_int as libc::c_uint != 0
                    && ((((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                        as statenum_t as libc::c_uint)
                        < (*(*mobj).info).painstate as libc::c_uint
                        || ((*(*mobj).state).nextstate as libc::c_uint)
                            < (*(*mobj).info).painstate as libc::c_uint
                            && (*mobj).tics == 1 as libc::c_int)
                {
                    P_SetMobjState(mobj, (*(*mobj).info).painstate);
                    (*mobj).tics += 1;
                    (*mobj).tics;
                    P_SetMobjState((*mobj).tracer, (*(*mobj).info).raisestate);
                    (*(*mobj).tracer).tics += 1;
                    (*(*mobj).tracer).tics;
                } else if (*(*mobj).target).eflags as libc::c_int
                    & MFE_JUSTHITFLOOR as libc::c_int != 0
                    && ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                        as statenum_t as libc::c_uint
                        == (*(*mobj).info).painstate as libc::c_uint
                {
                    P_SetMobjState(
                        mobj,
                        ((*(*mobj).info).painstate as libc::c_uint)
                            .wrapping_add(1 as libc::c_int as libc::c_uint) as statenum_t,
                    );
                    (*mobj).tics += 1;
                    (*mobj).tics;
                    P_SetMobjState(
                        (*mobj).tracer,
                        ((*(*mobj).info).raisestate as libc::c_uint)
                            .wrapping_add(1 as libc::c_int as libc::c_uint) as statenum_t,
                    );
                    (*(*mobj).tracer).tics += 1;
                    (*(*mobj).tracer).tics;
                }
            }
            current_block_207 = 2525024825076287515;
        }
        465 => {
            if (*mobj).flags2 & MF2_SHIELD as libc::c_int as uint32_t == 0 {
                return;
            }
            if !((*mobj).tracer).is_null()
                && (*(*(*mobj).target).player).pflags as libc::c_uint
                    & PF_SHIELDABILITY as libc::c_int as libc::c_uint != 0
            {
                P_SetMobjState(mobj, (*(*mobj).info).painstate);
                (*mobj).tics += 1;
                (*mobj).tics;
                P_SetMobjState((*mobj).tracer, (*(*mobj).info).raisestate);
                (*(*mobj).tracer).tics += 1;
                (*(*mobj).tracer).tics;
                (*(*(*mobj).target).player)
                    .pflags = ::core::mem::transmute::<
                    libc::c_uint,
                    pflags_t,
                >(
                    (*(*(*mobj).target).player).pflags as libc::c_uint
                        & !(PF_SHIELDABILITY as libc::c_int) as libc::c_uint,
                );
            }
            current_block_207 = 2525024825076287515;
        }
        255 => {
            P_SceneryCheckWater(mobj);
            if ((*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                && ((*mobj).z <= (*mobj).floorz || (*mobj).z <= (*mobj).watertop)
                || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                    && (*mobj).z + (*mobj).height >= (*mobj).ceilingz)
                && (*mobj).health > 0 as libc::c_int
            {
                (*mobj).health = 0 as libc::c_int;
                P_SetMobjState(mobj, (*(*mobj).info).deathstate);
                S_StartSound(
                    mobj as *const libc::c_void,
                    ((*(*mobj).info).deathsound as libc::c_uint)
                        .wrapping_add(P_RandomKey((*(*mobj).info).mass) as libc::c_uint)
                        as sfxenum_t,
                );
                return;
            }
            current_block_207 = 2525024825076287515;
        }
        145 => {
            P_SceneryCheckWater(mobj);
            current_block_207 = 2525024825076287515;
        }
        511 | 512 | 513 => {
            P_SceneryCheckWater(mobj);
            if P_MobjWasRemoved(mobj) != 0 {
                return;
            }
            if (*mobj).eflags as libc::c_int & MFE_UNDERWATER as libc::c_int == 0
                || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                    && (*mobj).z + (*mobj).height >= (*mobj).ceilingz
                || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                    && (*mobj).z <= (*mobj).floorz || P_CheckDeathPitCollide(mobj) != 0
                || {
                    (*mobj).fuse -= 1;
                    (*mobj).fuse <= 0 as libc::c_int
                }
            {
                P_RemoveMobj(mobj);
                return;
            }
            current_block_207 = 2525024825076287515;
        }
        522 => {
            if ((*mobj).target).is_null() {
                P_RemoveMobj(mobj);
                return;
            }
            (*mobj).flags2 &= !(MF2_DONTDRAW as libc::c_int) as uint32_t;
            (*mobj).x = (*(*mobj).target).x;
            (*mobj).y = (*(*mobj).target).y;
            (*mobj)
                .eflags = ((*mobj).eflags as libc::c_int
                | (*(*mobj).target).eflags as libc::c_int
                    & MFE_VERTICALFLIP as libc::c_int) as uint16_t;
            (*mobj).destscale = (*(*mobj).target).destscale;
            P_SetScale(mobj, (*(*mobj).target).scale);
            if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0 {
                (*mobj)
                    .z = (*(*mobj).target).z + (*(*mobj).target).height
                    + FixedMul(
                        (16 as libc::c_int
                            + abs(
                                (leveltime % 35 as libc::c_int as tic_t) as libc::c_int
                                    - 35 as libc::c_int / 2 as libc::c_int,
                            )) * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*(*mobj).target).scale,
                    );
            } else {
                (*mobj)
                    .z = (*(*mobj).target).z
                    - FixedMul(
                        (16 as libc::c_int
                            + abs(
                                (leveltime % 35 as libc::c_int as tic_t) as libc::c_int
                                    - 35 as libc::c_int / 2 as libc::c_int,
                            )) * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*(*mobj).target).scale,
                    ) - (*mobj).height;
            }
            (*mobj).old_z = (*mobj).z;
            current_block_207 = 2525024825076287515;
        }
        523 => {
            if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t == 0 {
                (*mobj).threshold = (*mobj).z;
                (*mobj).flags2 |= MF2_STRONGBOX as libc::c_int as uint32_t;
            }
            if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0 {
                (*mobj)
                    .z = (*mobj).threshold
                    + FixedMul(
                        (16 as libc::c_int
                            + abs(
                                (leveltime % 35 as libc::c_int as tic_t) as libc::c_int
                                    - 35 as libc::c_int / 2 as libc::c_int,
                            )) * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*mobj).scale,
                    );
            } else {
                (*mobj)
                    .z = (*mobj).threshold
                    - FixedMul(
                        (16 as libc::c_int
                            + abs(
                                (leveltime % 35 as libc::c_int as tic_t) as libc::c_int
                                    - 35 as libc::c_int / 2 as libc::c_int,
                            )) * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*mobj).scale,
                    );
            }
            (*mobj).old_z = (*mobj).z;
            current_block_207 = 2525024825076287515;
        }
        520 => {
            if P_DrownNumbersSceneryThink(mobj) == 0 {
                return;
            }
            current_block_207 = 2525024825076287515;
        }
        347 => {
            P_FlameJetSceneryThink(mobj);
            current_block_207 = 2525024825076287515;
        }
        348 => {
            P_VerticalFlameJetSceneryThink(mobj);
            current_block_207 = 2525024825076287515;
        }
        470 | 472 | 474 | 476 | 478 | 480 | 482 | 484 | 486 | 488 | 490 | 492 | 494 | 496
        | 498 | 500 | 502 | 504 => {
            if !((*mobj).tracer).is_null()
                && (*mobj).flags & MF_NOCLIPTHING as libc::c_int as uint32_t != 0
                && (*mobj).flags & MF_GRENADEBOUNCE as libc::c_int as uint32_t != 0
            {
                if (*(*mobj).tracer).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t
                    == 0 && (*(*mobj).tracer).z <= (*(*mobj).tracer).floorz
                {
                    (*(*mobj).tracer)
                        .momz = 7 as libc::c_int
                        * ((1 as libc::c_int) << 16 as libc::c_int);
                } else if (*(*mobj).tracer).flags2
                    & MF2_OBJECTFLIP as libc::c_int as uint32_t != 0
                    && (*(*mobj).tracer).z
                        >= (*(*mobj).tracer).ceilingz - (*(*mobj).tracer).height
                {
                    (*(*mobj).tracer)
                        .momz = -(7 as libc::c_int)
                        * ((1 as libc::c_int) << 16 as libc::c_int);
                }
            }
            current_block_207 = 2525024825076287515;
        }
        505 => {
            if P_MobjFlip(mobj) as libc::c_int * (*mobj).momz < (*(*mobj).info).speed {
                (*mobj).momz = P_MobjFlip(mobj) as libc::c_int * (*(*mobj).info).speed;
            }
            current_block_207 = 2525024825076287515;
        }
        627 | 628 | 629 | 630 | 631 | 632 | 633 | 634 | 635 | 636 | 637 | 638 | 639 | 640
        | 641 | 642 | 645 | 644 | 79 => {
            if ((*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
                && (*mobj).z
                    <= P_FloorzAtPos((*mobj).x, (*mobj).y, (*mobj).z, (*mobj).height)
                || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                    && (*mobj).z + (*mobj).height
                        >= P_CeilingzAtPos(
                            (*mobj).x,
                            (*mobj).y,
                            (*mobj).z,
                            (*mobj).height,
                        ))
                && (*mobj).state
                    != &mut *states
                        .as_mut_ptr()
                        .offset((*(*mobj).info).deathstate as isize) as *mut state_t
            {
                P_SetMobjState(mobj, (*(*mobj).info).deathstate);
                return;
            }
            current_block_207 = 2525024825076287515;
        }
        518 => {
            if P_ParticleGenSceneryThink(mobj) == 0 {
                return;
            }
            current_block_207 = 2525024825076287515;
        }
        85 => {
            if (*mobj).movedir != 0 {
                (*mobj).angle = ((*mobj).angle).wrapping_add((*mobj).movedir);
            }
            current_block_207 = 2525024825076287515;
        }
        394 => {
            P_RosySceneryThink(mobj);
            current_block_207 = 2525024825076287515;
        }
        395 => {
            if (*mobj).cvmem < 24 as libc::c_int {
                (*mobj).cvmem += 1;
                (*mobj).cvmem;
            }
            (*mobj)
                .movedir = ((*mobj).movedir)
                .wrapping_add(0x71c71c7 as libc::c_int as angle_t);
            P_UnsetThingPosition(mobj);
            (*mobj)
                .x = (*mobj).extravalue1
                + P_ReturnThrustX(mobj, (*mobj).movedir, (*mobj).cvmem * (*mobj).scale);
            (*mobj)
                .y = (*mobj).extravalue2
                + P_ReturnThrustY(mobj, (*mobj).movedir, (*mobj).cvmem * (*mobj).scale);
            P_SetThingPosition(mobj);
            if (*mobj).fuse == 0 {
                if LUA_HookMobj(mobj, mobjhook_MobjFuse as libc::c_int) == 0 {
                    P_RemoveMobj(mobj);
                }
                return;
            }
            if (*mobj).fuse < 0 as libc::c_int {
                return;
            }
            if (*mobj).fuse < 6 as libc::c_int {
                (*mobj)
                    .frame = (*mobj).frame & !(0xf0000 as libc::c_int) as uint32_t
                    | ((10 as libc::c_int - (*mobj).fuse * 2 as libc::c_int)
                        << 16 as libc::c_int) as uint32_t;
            }
            (*mobj).fuse -= 1;
            (*mobj).fuse;
            current_block_207 = 2525024825076287515;
        }
        526 => {
            if ((*mobj).target).is_null()
                || (*(*(*mobj).target).player).playerstate as libc::c_uint
                    == PST_DEAD as libc::c_int as libc::c_uint || cv_exitmove.value == 0
            {
                P_RemoveMobj(mobj);
                return;
            }
            P_UnsetThingPosition(mobj);
            let mut radius: fixed_t = FixedMul(
                10 as libc::c_int * (*(*mobj).info).speed,
                (*(*mobj).target).scale,
            );
            let mut fa: angle_t = 0;
            (*mobj)
                .angle = ((*mobj).angle).wrapping_add(FixedAngle((*(*mobj).info).speed));
            fa = (*mobj).angle >> 19 as libc::c_int;
            (*mobj)
                .x = (*(*mobj).target).x
                + FixedMul(
                    *finecosine.offset(fa as isize)
                        >> 16 as libc::c_int - 16 as libc::c_int,
                    radius,
                );
            (*mobj)
                .y = (*(*mobj).target).y
                + FixedMul(
                    finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                    radius,
                );
            (*mobj)
                .z = (*(*mobj).target).z + (*(*mobj).target).height / 2 as libc::c_int;
            P_SetThingPosition(mobj);
            P_SetScale(mobj, (*(*mobj).target).scale);
            current_block_207 = 2525024825076287515;
        }
        226 => {
            (*mobj)
                .angle = ((*mobj).angle)
                .wrapping_add(
                    FixedAngle(
                        3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    ),
                );
            current_block_207 = 2525024825076287515;
        }
        80 | 81 => {
            let mut strength: int32_t = 0;
            (*mobj).movedir = ((*mobj).movedir).wrapping_add(1);
            (*mobj).movedir;
            (*mobj).frame &= !(0xf0000 as libc::c_int) as uint32_t;
            strength = (if (*mobj).fuse < (*mobj).movedir as int32_t {
                (*mobj).fuse
            } else {
                (*mobj).movedir as int32_t
            }) * 3 as libc::c_int;
            if strength < 10 as libc::c_int {
                (*mobj).frame
                    |= (10 as libc::c_int - strength << 16 as libc::c_int) as uint32_t;
            }
            current_block_207 = 13442560403810260754;
        }
        _ => {
            current_block_207 = 13442560403810260754;
        }
    }
    match current_block_207 {
        5845872889173891897 => {
            if (*mobj).flags2 & MF2_SHIELD as libc::c_int as uint32_t == 0 {
                return;
            }
            if (((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                as statenum_t as libc::c_uint)
                < (*(*mobj).info).painstate as libc::c_uint
            {
                (*mobj).angle = (*(*mobj).target).angle;
            }
            if !((*mobj).tracer).is_null()
                && (*(*(*mobj).target).player).pflags as libc::c_uint
                    & PF_SHIELDABILITY as libc::c_int as libc::c_uint != 0
                && ((((*(*mobj).tracer).state).offset_from(states.as_mut_ptr())
                    as libc::c_long as statenum_t as libc::c_uint)
                    < (*(*mobj).info).raisestate as libc::c_uint
                    || ((*(*(*mobj).tracer).state).nextstate as libc::c_uint)
                        < (*(*mobj).info).raisestate as libc::c_uint
                        && (*(*mobj).tracer).tics == 1 as libc::c_int)
            {
                P_SetMobjState(mobj, (*(*mobj).info).painstate);
                (*mobj).tics += 1;
                (*mobj).tics;
                P_SetMobjState((*mobj).tracer, (*(*mobj).info).raisestate);
                (*(*mobj).tracer).tics += 1;
                (*(*mobj).tracer).tics;
            }
        }
        13442560403810260754 => {
            if (*mobj).fuse != 0 {
                (*mobj).fuse -= 1;
                (*mobj).fuse;
                if (*mobj).fuse == 0 {
                    if LUA_HookMobj(mobj, mobjhook_MobjFuse as libc::c_int) == 0 {
                        P_RemoveMobj(mobj);
                    }
                    return;
                }
            }
        }
        _ => {}
    }
    P_SceneryThinker(mobj);
}
unsafe extern "C" fn P_MobjPushableThink(mut mobj: *mut mobj_t) -> boolean {
    P_MobjCheckWater(mobj);
    P_PushableThinker(mobj);
    if (*mobj).flags & MF_FIRE as libc::c_int as uint32_t != 0
        && (*mobj).eflags as libc::c_int & MFE_TOUCHLAVA as libc::c_int == 0
        && (*mobj).eflags as libc::c_int
            & (MFE_UNDERWATER as libc::c_int | MFE_TOUCHWATER as libc::c_int) != 0
    {
        P_KillMobj(
            mobj,
            0 as *mut mobj_t,
            0 as *mut mobj_t,
            0 as libc::c_int as uint8_t,
        );
        return false_0 as libc::c_int;
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_MobjBossThink(mut mobj: *mut mobj_t) -> boolean {
    if LUA_HookMobj(mobj, mobjhook_BossThinker as libc::c_int) != 0 {
        if P_MobjWasRemoved(mobj) != 0 {
            return false_0 as libc::c_int;
        }
    } else if P_MobjWasRemoved(mobj) != 0 {
        return false_0 as libc::c_int
    } else {
        match (*mobj).type_0 as libc::c_uint {
            61 => {
                if (*mobj).health < (*(*mobj).info).damage + 1 as libc::c_int
                    && leveltime & 2 as libc::c_int as tic_t != 0
                {
                    let mut rad: fixed_t = (*mobj).radius >> 16 as libc::c_int;
                    let mut hei: fixed_t = (*mobj).height >> 16 as libc::c_int;
                    let mut particle: *mut mobj_t = P_SpawnMobjFromMobj(
                        mobj,
                        P_RandomRange(rad, -rad) << 16 as libc::c_int,
                        P_RandomRange(rad, -rad) << 16 as libc::c_int,
                        P_RandomRange(hei / 2 as libc::c_int, hei) << 16 as libc::c_int,
                        MT_SMOKE,
                    );
                    P_SetObjectMomZ(
                        particle,
                        (2 as libc::c_int) << 16 as libc::c_int,
                        false_0 as libc::c_int,
                    );
                    (*particle).momz += (*mobj).momz;
                }
                if (*mobj).flags2 & MF2_SKULLFLY as libc::c_int as uint32_t != 0 {
                    P_SpawnGhostMobj(mobj);
                }
                P_Boss1Thinker(mobj);
            }
            66 => {
                if (*mobj).health < (*(*mobj).info).damage + 1 as libc::c_int
                    && leveltime & 2 as libc::c_int as tic_t != 0
                {
                    let mut rad_0: fixed_t = (*mobj).radius >> 16 as libc::c_int;
                    let mut hei_0: fixed_t = (*mobj).height >> 16 as libc::c_int;
                    let mut particle_0: *mut mobj_t = P_SpawnMobjFromMobj(
                        mobj,
                        P_RandomRange(rad_0, -rad_0) << 16 as libc::c_int,
                        P_RandomRange(rad_0, -rad_0) << 16 as libc::c_int,
                        P_RandomRange(hei_0 / 2 as libc::c_int, hei_0)
                            << 16 as libc::c_int,
                        MT_SMOKE,
                    );
                    P_SetObjectMomZ(
                        particle_0,
                        (2 as libc::c_int) << 16 as libc::c_int,
                        false_0 as libc::c_int,
                    );
                    (*particle_0).momz += (*mobj).momz;
                }
                P_Boss2Thinker(mobj);
            }
            70 => {
                if (*mobj).health < (*(*mobj).info).damage + 1 as libc::c_int
                    && leveltime & 2 as libc::c_int as tic_t != 0
                {
                    let mut rad_1: fixed_t = (*mobj).radius >> 16 as libc::c_int;
                    let mut hei_1: fixed_t = (*mobj).height >> 16 as libc::c_int;
                    let mut particle_1: *mut mobj_t = P_SpawnMobjFromMobj(
                        mobj,
                        P_RandomRange(rad_1, -rad_1) << 16 as libc::c_int,
                        P_RandomRange(rad_1, -rad_1) << 16 as libc::c_int,
                        P_RandomRange(hei_1 / 2 as libc::c_int, hei_1)
                            << 16 as libc::c_int,
                        MT_SMOKE,
                    );
                    P_SetObjectMomZ(
                        particle_1,
                        (2 as libc::c_int) << 16 as libc::c_int,
                        false_0 as libc::c_int,
                    );
                    (*particle_1).momz += (*mobj).momz;
                }
                P_Boss3Thinker(mobj);
            }
            73 => {
                if (*mobj).health < (*(*mobj).info).damage + 1 as libc::c_int
                    && leveltime & 2 as libc::c_int as tic_t != 0
                {
                    let mut rad_2: fixed_t = (*mobj).radius >> 16 as libc::c_int;
                    let mut hei_2: fixed_t = (*mobj).height >> 16 as libc::c_int;
                    let mut particle_2: *mut mobj_t = P_SpawnMobjFromMobj(
                        mobj,
                        P_RandomRange(rad_2, -rad_2) << 16 as libc::c_int,
                        P_RandomRange(rad_2, -rad_2) << 16 as libc::c_int,
                        P_RandomRange(hei_2 / 2 as libc::c_int, hei_2)
                            << 16 as libc::c_int,
                        MT_SMOKE,
                    );
                    P_SetObjectMomZ(
                        particle_2,
                        (2 as libc::c_int) << 16 as libc::c_int,
                        false_0 as libc::c_int,
                    );
                    (*particle_2).momz += (*mobj).momz;
                }
                P_Boss4Thinker(mobj);
            }
            78 => {
                P_Boss5Thinker(mobj);
            }
            88 => {
                P_Boss7Thinker(mobj);
            }
            104 => {
                P_Boss9Thinker(mobj);
            }
            _ => {
                if (*mobj).flags2 & MF2_SKULLFLY as libc::c_int as uint32_t != 0 {
                    P_SpawnGhostMobj(mobj);
                }
                P_GenericBossThinker(mobj);
            }
        }
    }
    if (*mobj).flags2 & MF2_BOSSFLEE as libc::c_int as uint32_t != 0 {
        if (*mobj).extravalue1 != 0 {
            (*mobj).extravalue1 -= 1;
            if (*mobj).extravalue1 == 0 {
                if !((*mobj).target).is_null() {
                    (*mobj)
                        .momz = FixedMul(
                        FixedDiv(
                            (*(*mobj).target).z - (*mobj).z,
                            P_AproxDistance(
                                (*mobj).x - (*(*mobj).target).x,
                                (*mobj).y - (*(*mobj).target).y,
                            ),
                        ),
                        (*mobj).scale << 1 as libc::c_int,
                    );
                    (*mobj)
                        .angle = R_PointToAngle2(
                        (*mobj).x,
                        (*mobj).y,
                        (*(*mobj).target).x,
                        (*(*mobj).target).y,
                    );
                } else {
                    (*mobj).momz = 8 as libc::c_int * (*mobj).scale;
                }
            } else {
                (*mobj).angle = ((*mobj).angle).wrapping_add((*mobj).movedir);
            }
        } else if !((*mobj).target).is_null() {
            P_InstaThrust(
                mobj,
                (*mobj).angle,
                FixedMul(
                    12 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*mobj).scale,
                ),
            );
        }
    }
    if (*mobj).type_0 as libc::c_uint == MT_CYBRAKDEMON as libc::c_int as libc::c_uint
        && (*mobj).health == 0
    {
        if (*mobj).tics & 1 as libc::c_int == 0 {
            var1 = 2 as libc::c_int;
            var2 = 0 as libc::c_int;
            A_BossScream(mobj);
        }
        if P_CheckDeathPitCollide(mobj) != 0 {
            P_RemoveMobj(mobj);
            return false_0 as libc::c_int;
        }
        if (*mobj).momz != 0 && (*mobj).z + (*mobj).momz <= (*mobj).floorz {
            S_StartSound(mobj as *const libc::c_void, sfx_befall);
            if (*mobj).state
                != states.as_mut_ptr().offset(S_CYBRAKDEMON_DIE8 as libc::c_int as isize)
            {
                P_SetMobjState(mobj, S_CYBRAKDEMON_DIE8);
            }
        }
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_MobjDeadThink(mut mobj: *mut mobj_t) -> boolean {
    match (*mobj).type_0 as libc::c_uint {
        109 => {
            if ((*mobj).tics >> 2 as libc::c_int) + 1 as libc::c_int > 0 as libc::c_int
                && ((*mobj).tics >> 2 as libc::c_int) + 1 as libc::c_int
                    <= tr_trans60 as libc::c_int
            {
                (*mobj)
                    .frame = (NUMTRANSMAPS as libc::c_int
                    - (((*mobj).tics >> 2 as libc::c_int) + 1 as libc::c_int)
                    << 16 as libc::c_int) as uint32_t;
            } else {
                (*mobj)
                    .frame = ((tr_trans60 as libc::c_int) << 16 as libc::c_int)
                    as uint32_t;
            }
        }
        590 => {
            if (*mobj).z <= (*mobj).floorz {
                P_RemoveMobj(mobj);
                return false_0 as libc::c_int;
            }
        }
        71 => {
            if (*mobj).scale == (*mobj).destscale {
                if (*mobj).fuse == 0 {
                    S_StartSound(mobj as *const libc::c_void, sfx_s3k77);
                    (*mobj).flags2 |= MF2_DONTDRAW as libc::c_int as uint32_t;
                    (*mobj).fuse = 35 as libc::c_int;
                }
                return false_0 as libc::c_int;
            }
            if (*mobj).reactiontime == 0 {
                if P_RandomFixed()
                    < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
                {
                    (*mobj).movefactor = (1 as libc::c_int) << 16 as libc::c_int;
                } else {
                    (*mobj).movefactor = -((1 as libc::c_int) << 16 as libc::c_int);
                }
                if P_RandomFixed()
                    < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
                {
                    (*mobj).movedir = 0xe38e38e as libc::c_int as angle_t;
                } else {
                    (*mobj).movedir = -(0xe38e38e as libc::c_int) as angle_t;
                }
                (*mobj).reactiontime = 5 as libc::c_int;
            }
            (*mobj).momz += (*mobj).movefactor;
            (*mobj).angle = ((*mobj).angle).wrapping_add((*mobj).movedir);
            P_InstaThrust(mobj, (*mobj).angle, -(*(*mobj).info).speed);
            (*mobj).reactiontime -= 1;
            (*mobj).reactiontime;
        }
        33 => {
            (*mobj).flags2 ^= MF2_DONTDRAW as libc::c_int as uint32_t;
        }
        57 => {
            if (*mobj).fuse > 0 as libc::c_int {
                let mut i: int32_t = 0;
                let mut x: fixed_t = 0;
                let mut y: fixed_t = 0;
                let mut z: fixed_t = 0;
                let mut ns: fixed_t = 0;
                let mut mo2: *mut mobj_t = 0 as *mut mobj_t;
                let mut flicky: *mut mobj_t = 0 as *mut mobj_t;
                z = (*(*(*mobj).subsector).sector).floorheight
                    + ((1 as libc::c_int) << 16 as libc::c_int)
                    + (P_RandomKey(64 as libc::c_int) << 16 as libc::c_int);
                i = 0 as libc::c_int;
                while i < 3 as libc::c_int {
                    let fa: angle_t = (P_RandomKey(8192 as libc::c_int)
                        & 8192 as libc::c_int - 1 as libc::c_int) as angle_t;
                    ns = 64 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
                    x = (*mobj).x
                        + FixedMul(
                            finesine[fa as usize]
                                >> 16 as libc::c_int - 16 as libc::c_int,
                            ns,
                        );
                    y = (*mobj).y
                        + FixedMul(
                            *finecosine.offset(fa as isize)
                                >> 16 as libc::c_int - 16 as libc::c_int,
                            ns,
                        );
                    mo2 = P_SpawnMobj(x, y, z, MT_EXPLODE);
                    P_SetMobjStateNF(mo2, S_XPLD_EGGTRAP);
                    ns = 4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
                    (*mo2)
                        .momx = FixedMul(
                        finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                        ns,
                    );
                    (*mo2)
                        .momy = FixedMul(
                        *finecosine.offset(fa as isize)
                            >> 16 as libc::c_int - 16 as libc::c_int,
                        ns,
                    );
                    (*mo2).angle = fa << 19 as libc::c_int;
                    if i == 0 && (*mobj).fuse & 2 as libc::c_int == 0 {
                        S_StartSound(
                            mo2 as *const libc::c_void,
                            (*(*mobj).info).deathsound,
                        );
                    }
                    flicky = P_InternalFlickySpawn(
                        mo2,
                        MT_NULL,
                        8 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                        false_0 as libc::c_int,
                        -(1 as libc::c_int) as int8_t,
                    );
                    if flicky.is_null() {
                        break;
                    }
                    P_SetTarget2(&mut (*flicky).target, mo2);
                    (*flicky).momx = (*mo2).momx;
                    (*flicky).momy = (*mo2).momy;
                    i += 1;
                    i;
                }
                (*mobj).fuse -= 1;
                (*mobj).fuse;
            }
        }
        3 => {
            if (*mobj).fuse == 0 {
                (*mobj).momz = 0 as libc::c_int;
                if !((*mobj).player).is_null() {
                    (*mobj).flags2 |= MF2_DONTDRAW as libc::c_int as uint32_t;
                } else {
                    P_RemoveMobj(mobj);
                    return false_0 as libc::c_int;
                }
            } else {
                if !((*mobj).player).is_null() && (*mobj).fuse % 8 as libc::c_int == 0
                    && (*(*mobj).player).charflags
                        & SF_MACHINE as libc::c_int as uint32_t != 0
                {
                    let mut r: fixed_t = (*mobj).radius >> 16 as libc::c_int;
                    let mut explosion: *mut mobj_t = P_SpawnMobj(
                        (*mobj).x + (P_RandomRange(r, -r) << 16 as libc::c_int),
                        (*mobj).y + (P_RandomRange(r, -r) << 16 as libc::c_int),
                        (*mobj).z
                            + (P_RandomKey((*mobj).height >> 16 as libc::c_int)
                                << 16 as libc::c_int),
                        MT_SONIC3KBOSSEXPLODE,
                    );
                    S_StartSound(explosion as *const libc::c_void, sfx_s3kb4);
                }
                if (*mobj).movedir == (0x80 as libc::c_int + 1 as libc::c_int) as angle_t
                {
                    P_SetObjectMomZ(
                        mobj,
                        -((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int,
                        true_0 as libc::c_int,
                    );
                } else {
                    P_SetObjectMomZ(
                        mobj,
                        -(2 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int)
                            / 3 as libc::c_int,
                        true_0 as libc::c_int,
                    );
                }
            }
        }
        103 => {
            if (*mobj).fuse % 8 as libc::c_int == 0 {
                let mut r_0: fixed_t = (*mobj).radius >> 16 as libc::c_int;
                let mut explosion_0: *mut mobj_t = P_SpawnMobj(
                    (*mobj).x + (P_RandomRange(r_0, -r_0) << 16 as libc::c_int),
                    (*mobj).y + (P_RandomRange(r_0, -r_0) << 16 as libc::c_int),
                    (*mobj).z
                        + (P_RandomKey((*mobj).height >> 16 as libc::c_int)
                            << 16 as libc::c_int),
                    MT_SONIC3KBOSSEXPLODE,
                );
                S_StartSound(explosion_0 as *const libc::c_void, sfx_s3kb4);
            }
            P_SetObjectMomZ(
                mobj,
                -(2 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int)
                    / 3 as libc::c_int,
                true_0 as libc::c_int,
            );
        }
        _ => {}
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_TracerAngleThink(mut mobj: *mut mobj_t) {
    let mut looking: angle_t = 0;
    let mut ang: angle_t = 0;
    if ((*mobj).tracer).is_null() {
        return;
    }
    if (*mobj).extravalue2 == 0 {
        return;
    }
    if !((*mobj).player).is_null() {
        looking = (((*(*mobj).player).cmd.angleturn as libc::c_int) << 16 as libc::c_int)
            as angle_t;
    } else {
        looking = (*mobj).angle;
    }
    ang = looking
        .wrapping_sub(
            R_PointToAngle2(
                (*mobj).x,
                (*mobj).y,
                (*(*mobj).tracer).x,
                (*(*mobj).tracer).y,
            ),
        );
    if ang >= (*mobj).extravalue1 as angle_t
        && ang
            <= (0xffffffff as libc::c_uint).wrapping_sub((*mobj).extravalue1 as angle_t)
    {
        if (*mobj).cvmem != 0 {
            (*mobj).cvmem -= 1;
            (*mobj).cvmem;
        } else {
            let mut exectag: int32_t = (*mobj).extravalue2;
            if (*mobj).lastlook != 0 {
                (*mobj).cvmem = (*mobj).cusval;
            } else {
                (*mobj)
                    .eflags = ((*mobj).eflags as libc::c_int
                    & !(MFE_TRACERANGLE as libc::c_int)) as uint16_t;
                (*mobj).cusval = 0 as libc::c_int;
                (*mobj).cvmem = (*mobj).cusval;
                (*mobj).extravalue2 = (*mobj).cvmem;
                (*mobj).extravalue1 = (*mobj).extravalue2;
                (*mobj).lastlook = (*mobj).extravalue1;
            }
            P_LinedefExecute(exectag as int16_t, mobj, 0 as *mut sector_t);
        }
    } else {
        (*mobj).cvmem = (*mobj).cusval;
    };
}
unsafe extern "C" fn P_ArrowThink(mut mobj: *mut mobj_t) {
    if (*mobj).flags & MF_MISSILE as libc::c_int as uint32_t != 0 {
        let mut dist: fixed_t = P_AproxDistance((*mobj).momx, (*mobj).momy);
        let mut angle: angle_t = R_PointToAngle2(
            0 as libc::c_int,
            0 as libc::c_int,
            dist,
            (*mobj).momz,
        );
        if angle > 0xe38e38e as libc::c_int as angle_t
            && angle <= 0x80000000 as libc::c_uint
        {
            (*mobj).frame = 2 as libc::c_int as uint32_t;
        } else if angle < 0xf1c71c72 as libc::c_uint
            && angle > 0x80000000 as libc::c_uint
        {
            (*mobj).frame = 0 as libc::c_int as uint32_t;
        } else {
            (*mobj).frame = 1 as libc::c_int as uint32_t;
        }
        if (*mobj).extravalue1 == 0 && (*mobj).momz < 0 as libc::c_int {
            (*mobj).extravalue1 = 1 as libc::c_int;
            S_StartSound(mobj as *const libc::c_void, (*(*mobj).info).activesound);
        }
        if leveltime & 1 as libc::c_int as tic_t != 0 {
            let mut dust: *mut mobj_t = P_SpawnMobjFromMobj(
                mobj,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                MT_PARTICLE,
            );
            (*dust).tics = 18 as libc::c_int;
            (*dust).scalespeed = 4096 as libc::c_int;
            (*dust)
                .destscale = ((1 as libc::c_int) << 16 as libc::c_int)
                / 32 as libc::c_int;
        }
    } else {
        (*mobj).flags2 ^= MF2_DONTDRAW as libc::c_int as uint32_t;
    };
}
unsafe extern "C" fn P_BumbleboreThink(mut mobj: *mut mobj_t) {
    let mut st: statenum_t = ((*mobj).state).offset_from(states.as_mut_ptr())
        as libc::c_long as statenum_t;
    if st as libc::c_uint == S_BUMBLEBORE_FLY1 as libc::c_int as libc::c_uint
        || st as libc::c_uint == S_BUMBLEBORE_FLY2 as libc::c_int as libc::c_uint
    {
        if ((*mobj).target).is_null() {
            P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
        } else if P_MobjFlip(mobj) as libc::c_int
            * ((*mobj).z + ((*mobj).height >> 1 as libc::c_int)
                - ((*(*mobj).target).z + ((*(*mobj).target).height >> 1 as libc::c_int)))
            > 0 as libc::c_int
            && R_PointToDist2(
                (*mobj).x,
                (*mobj).y,
                (*(*mobj).target).x,
                (*(*mobj).target).y,
            ) <= 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
        {
            (*mobj).momx >>= 1 as libc::c_int;
            (*mobj).momy >>= 1 as libc::c_int;
            (*mobj).movefactor += 1;
            if (*mobj).movefactor == 4 as libc::c_int {
                S_StartSound(mobj as *const libc::c_void, (*(*mobj).info).seesound);
                (*mobj).momz = 0 as libc::c_int;
                (*mobj).momy = (*mobj).momz;
                (*mobj).momx = (*mobj).momy;
                (*mobj)
                    .flags = ((*mobj).flags | MF_PAIN as libc::c_int as uint32_t)
                    & !(MF_NOGRAVITY as libc::c_int) as uint32_t;
                P_SetMobjState(mobj, (*(*mobj).info).meleestate);
            }
        } else {
            (*mobj).movefactor = 0 as libc::c_int;
        }
    } else if st as libc::c_uint == S_BUMBLEBORE_RAISE as libc::c_int as libc::c_uint
        || st as libc::c_uint == S_BUMBLEBORE_FALL2 as libc::c_int as libc::c_uint
    {
        if P_IsObjectOnGround(mobj) != 0 {
            S_StopSound(mobj as *mut libc::c_void);
            S_StartSound(mobj as *const libc::c_void, (*(*mobj).info).attacksound);
            (*mobj)
                .flags = ((*mobj).flags | MF_NOGRAVITY as libc::c_int as uint32_t)
                & !(MF_PAIN as libc::c_int) as uint32_t;
            (*mobj).momz = 0 as libc::c_int;
            (*mobj).momy = (*mobj).momz;
            (*mobj).momx = (*mobj).momy;
            P_SetMobjState(mobj, (*(*mobj).info).painstate);
        } else {
            (*mobj)
                .angle = ((*mobj).angle)
                .wrapping_add(0x10000000 as libc::c_int as angle_t);
            (*mobj)
                .frame = ((*(*mobj).state).frame)
                .wrapping_add(
                    (((*mobj).tics & 2 as libc::c_int) >> 1 as libc::c_int) as uint32_t,
                );
        }
    } else if st as libc::c_uint == S_BUMBLEBORE_STUCK2 as libc::c_int as libc::c_uint
        && (*mobj).tics < 35 as libc::c_int
    {
        (*mobj)
            .frame = ((*(*mobj).state).frame)
            .wrapping_add(
                (((*mobj).tics & 2 as libc::c_int) >> 1 as libc::c_int) as uint32_t,
            );
    }
}
unsafe extern "C" fn P_HangsterThink(mut mobj: *mut mobj_t) -> boolean {
    let mut st: statenum_t = ((*mobj).state).offset_from(states.as_mut_ptr())
        as libc::c_long as statenum_t;
    if st as libc::c_uint == S_HANGSTER_SWOOP1 as libc::c_int as libc::c_uint
        || st as libc::c_uint == S_HANGSTER_SWOOP2 as libc::c_int as libc::c_uint
    {
        P_SpawnGhostMobj(mobj);
        if (*mobj).z - (*mobj).floorz
            <= 80 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
            || !((*mobj).target).is_null()
                && (*mobj).z - (*(*mobj).target).z
                    <= 80 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
        {
            st = S_HANGSTER_ARC1;
            P_SetMobjState(mobj, st);
        }
    }
    if st as libc::c_uint == S_HANGSTER_ARC1 as libc::c_int as libc::c_uint {
        A_FaceTarget(mobj);
        P_Thrust(
            mobj,
            (*mobj).angle,
            1 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
    } else if st as libc::c_uint == S_HANGSTER_ARC2 as libc::c_int as libc::c_uint {
        P_Thrust(
            mobj,
            (*mobj).angle,
            2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
    } else if st as libc::c_uint == S_HANGSTER_ARC3 as libc::c_int as libc::c_uint {
        P_Thrust(
            mobj,
            (*mobj).angle,
            4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
    } else if st as libc::c_uint == S_HANGSTER_FLY1 as libc::c_int as libc::c_uint
        && (*mobj).momx == 0 && (*mobj).momy == 0
    {
        (*mobj).extravalue1 = 0 as libc::c_int;
        P_SetMobjState(mobj, S_HANGSTER_ARCUP1);
    } else if (st as libc::c_uint == S_HANGSTER_RETURN1 as libc::c_int as libc::c_uint
        || st as libc::c_uint == S_HANGSTER_RETURN2 as libc::c_int as libc::c_uint)
        && (*mobj).momz == 0 as libc::c_int
        && (*mobj).ceilingz == (*mobj).z + (*mobj).height
    {
        st = S_HANGSTER_RETURN3;
        P_SetMobjState(mobj, st);
        (*mobj).momy = 0 as libc::c_int;
        (*mobj).momx = (*mobj).momy;
    }
    if st as libc::c_uint == S_HANGSTER_RETURN3 as libc::c_int as libc::c_uint
        && (*mobj).momz == 0 as libc::c_int
        && (*mobj).ceilingz == (*mobj).z + (*mobj).height
        && (*(*(*mobj).subsector).sector).ceilingpic == skyflatnum
        && (*(*(*mobj).subsector).sector).ceilingheight == (*mobj).ceilingz
    {
        P_RemoveMobj(mobj);
        return false_0 as libc::c_int;
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_JetFume1Think(mut mobj: *mut mobj_t) -> boolean {
    let mut jetx: fixed_t = 0;
    let mut jety: fixed_t = 0;
    if ((*mobj).target).is_null()
        || (*(*mobj).target).flags & MF_BOSS as libc::c_int as uint32_t == 0
            && (*(*mobj).target).health <= 0 as libc::c_int
    {
        P_RemoveMobj(mobj);
        return false_0 as libc::c_int;
    }
    jetx = (*(*mobj).target).x
        + P_ReturnThrustX(
            (*mobj).target,
            (*(*mobj).target).angle,
            FixedMul(
                -(64 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
                (*(*mobj).target).scale,
            ),
        );
    jety = (*(*mobj).target).y
        + P_ReturnThrustY(
            (*mobj).target,
            (*(*mobj).target).angle,
            FixedMul(
                -(64 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
                (*(*mobj).target).scale,
            ),
        );
    if (*mobj).fuse == 56 as libc::c_int {
        P_UnsetThingPosition(mobj);
        (*mobj).x = jetx;
        (*mobj).y = jety;
        if (*(*mobj).target).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
        {
            (*mobj)
                .z = (*(*mobj).target).z + (*(*mobj).target).height - (*mobj).height
                - FixedMul(
                    38 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*(*mobj).target).scale,
                );
        } else {
            (*mobj)
                .z = (*(*mobj).target).z
                + FixedMul(
                    38 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*(*mobj).target).scale,
                );
        }
        (*mobj).floorz = (*mobj).z;
        (*mobj).ceilingz = (*mobj).z + (*mobj).height;
        P_SetThingPosition(mobj);
    } else if (*mobj).fuse == 57 as libc::c_int {
        P_UnsetThingPosition(mobj);
        (*mobj)
            .x = jetx
            + P_ReturnThrustX(
                (*mobj).target,
                ((*(*mobj).target).angle)
                    .wrapping_sub(0x40000000 as libc::c_int as angle_t),
                FixedMul(
                    24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*(*mobj).target).scale,
                ),
            );
        (*mobj)
            .y = jety
            + P_ReturnThrustY(
                (*mobj).target,
                ((*(*mobj).target).angle)
                    .wrapping_sub(0x40000000 as libc::c_int as angle_t),
                FixedMul(
                    24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*(*mobj).target).scale,
                ),
            );
        if (*(*mobj).target).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
        {
            (*mobj)
                .z = (*(*mobj).target).z + (*(*mobj).target).height - (*mobj).height
                - FixedMul(
                    12 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*(*mobj).target).scale,
                );
        } else {
            (*mobj)
                .z = (*(*mobj).target).z
                + FixedMul(
                    12 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*(*mobj).target).scale,
                );
        }
        (*mobj).floorz = (*mobj).z;
        (*mobj).ceilingz = (*mobj).z + (*mobj).height;
        P_SetThingPosition(mobj);
    } else if (*mobj).fuse == 58 as libc::c_int {
        P_UnsetThingPosition(mobj);
        (*mobj)
            .x = jetx
            + P_ReturnThrustX(
                (*mobj).target,
                ((*(*mobj).target).angle)
                    .wrapping_add(0x40000000 as libc::c_int as angle_t),
                FixedMul(
                    24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*(*mobj).target).scale,
                ),
            );
        (*mobj)
            .y = jety
            + P_ReturnThrustY(
                (*mobj).target,
                ((*(*mobj).target).angle)
                    .wrapping_add(0x40000000 as libc::c_int as angle_t),
                FixedMul(
                    24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*(*mobj).target).scale,
                ),
            );
        if (*(*mobj).target).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
        {
            (*mobj)
                .z = (*(*mobj).target).z + (*(*mobj).target).height - (*mobj).height
                - FixedMul(
                    12 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*(*mobj).target).scale,
                );
        } else {
            (*mobj)
                .z = (*(*mobj).target).z
                + FixedMul(
                    12 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*(*mobj).target).scale,
                );
        }
        (*mobj).floorz = (*mobj).z;
        (*mobj).ceilingz = (*mobj).z + (*mobj).height;
        P_SetThingPosition(mobj);
    } else if (*mobj).fuse == 59 as libc::c_int {
        let mut dashmod: boolean = ((*(*mobj).target).flags
            & MF_PAIN as libc::c_int as uint32_t != 0
            && (*(*mobj).target).health <= (*(*(*mobj).target).info).damage)
            as libc::c_int;
        jetx = (*(*mobj).target).x
            + P_ReturnThrustX(
                (*mobj).target,
                (*(*mobj).target).angle,
                -(*(*mobj).target).radius,
            );
        jety = (*(*mobj).target).y
            + P_ReturnThrustY(
                (*mobj).target,
                (*(*mobj).target).angle,
                -(*(*mobj).target).radius,
            );
        P_UnsetThingPosition(mobj);
        (*mobj).x = jetx;
        (*mobj).y = jety;
        (*mobj).destscale = (*(*mobj).target).scale;
        if !(dashmod != 0
            && (*(*mobj).target).state
                == states
                    .as_mut_ptr()
                    .offset(S_METALSONIC_BOUNCE as libc::c_int as isize))
        {
            (*mobj)
                .destscale = ((*mobj).destscale
                + FixedDiv(
                    R_PointToDist2(
                        0 as libc::c_int,
                        0 as libc::c_int,
                        (*(*mobj).target).momx,
                        (*(*mobj).target).momy,
                    ),
                    36 as libc::c_int * (*(*mobj).target).scale,
                )) / 3 as libc::c_int;
        }
        if (*(*mobj).target).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
        {
            (*mobj)
                .z = (*(*mobj).target).z + (*(*mobj).target).height / 2 as libc::c_int
                + (*mobj).height / 2 as libc::c_int;
        } else {
            (*mobj)
                .z = (*(*mobj).target).z + (*(*mobj).target).height / 2 as libc::c_int
                - (*mobj).height / 2 as libc::c_int;
        }
        (*mobj).floorz = (*mobj).z;
        (*mobj).ceilingz = (*mobj).z + (*mobj).height;
        P_SetThingPosition(mobj);
        if dashmod != 0 {
            (*mobj).color = SKINCOLOR_SUNSET as libc::c_int as uint16_t;
            if (*(*mobj).target).movecount == 3 as libc::c_int
                && (*(*mobj).target).reactiontime == 0
                && ((*(*mobj).target).movedir == 0 as libc::c_int as angle_t
                    || (*(*mobj).target).movedir == 2 as libc::c_int as angle_t)
            {
                P_SpawnGhostMobj(mobj);
            }
        } else {
            (*mobj).color = SKINCOLOR_ICY as libc::c_int as uint16_t;
        }
    }
    (*mobj).fuse += 1;
    (*mobj).fuse;
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_EggRobo1Think(mut mobj: *mut mobj_t) -> boolean {
    if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t == 0 {
        (*mobj).cusval = (*mobj).x;
        (*mobj).cvmem = (*mobj).y;
        (*mobj).movedir = (*mobj).angle;
        (*mobj)
            .threshold = P_MobjFlip(mobj) as libc::c_int * 10 as libc::c_int
            * (*mobj).scale;
        if (*mobj).threshold < 0 as libc::c_int {
            (*mobj).threshold += (*mobj).ceilingz - (*mobj).height;
        } else {
            (*mobj).threshold += (*mobj).floorz;
        }
        var1 = 4 as libc::c_int;
        A_BossJetFume(mobj);
        (*mobj).flags2 |= MF2_STRONGBOX as libc::c_int as uint32_t;
    }
    if (*mobj).state
        == &mut *states.as_mut_ptr().offset((*(*mobj).info).deathstate as isize)
            as *mut state_t
    {
        if (*mobj).movecount != 0 {
            (*mobj).movecount -= 1;
            if (*mobj).movecount == 0 {
                S_StartSound(mobj as *const libc::c_void, (*(*mobj).info).deathsound);
            }
        } else {
            (*mobj).momz += P_MobjFlip(mobj) as libc::c_int * (*mobj).scale;
            if (*mobj).momz > 0 as libc::c_int {
                if (*mobj).z + (*mobj).momz
                    > (*mobj).ceilingz + ((1000 as libc::c_int) << 16 as libc::c_int)
                {
                    P_RemoveMobj(mobj);
                    return false_0 as libc::c_int;
                }
            } else if (*mobj).z + (*mobj).height + (*mobj).momz
                < (*mobj).floorz - ((1000 as libc::c_int) << 16 as libc::c_int)
            {
                P_RemoveMobj(mobj);
                return false_0 as libc::c_int;
            }
        }
    } else {
        let mut basex: fixed_t = (*mobj).cusval;
        let mut basey: fixed_t = (*mobj).cvmem;
        if !((*mobj).spawnpoint).is_null()
            && (*(*mobj).spawnpoint).args[0 as libc::c_int as usize]
                != TMED_NONE as libc::c_int
        {
            let mut sideang: angle_t = ((*mobj).movedir)
                .wrapping_add(
                    (if (*(*mobj).spawnpoint).args[0 as libc::c_int as usize]
                        == TMED_LEFT as libc::c_int
                    {
                        0x40000000 as libc::c_int
                    } else {
                        -(0x40000000 as libc::c_int)
                    }) as angle_t,
                );
            let mut oscillate: fixed_t = FixedMul(
                finesine[(leveltime * 0xb60b61 as libc::c_int as tic_t
                    >> 19 as libc::c_int + 2 as libc::c_int
                    & (8192 as libc::c_int - 1 as libc::c_int) as tic_t) as usize]
                    >> 16 as libc::c_int - 16 as libc::c_int,
                250 as libc::c_int * (*mobj).scale,
            );
            basex += P_ReturnThrustX(mobj, sideang, oscillate);
            basey += P_ReturnThrustY(mobj, sideang, oscillate);
        }
        (*mobj)
            .z = (*mobj).threshold
            + FixedMul(
                finesine[(leveltime.wrapping_add((*mobj).movecount as tic_t)
                    * 0x16c16c1 as libc::c_int as tic_t
                    >> 19 as libc::c_int - 2 as libc::c_int
                    & (8192 as libc::c_int - 1 as libc::c_int) as tic_t) as usize]
                    >> 16 as libc::c_int - 16 as libc::c_int,
                8 as libc::c_int * (*mobj).scale,
            );
        if (*mobj).state
            != &mut *states.as_mut_ptr().offset((*(*mobj).info).meleestate as isize)
                as *mut state_t
        {
            let mut didmove: boolean = false_0 as libc::c_int;
            if (*mobj).state
                == &mut *states.as_mut_ptr().offset((*(*mobj).info).spawnstate as isize)
                    as *mut state_t
            {
                let mut i: uint8_t = 0;
                let mut dist: fixed_t = 2147483647 as libc::c_int;
                i = 0 as libc::c_int as uint8_t;
                while (i as libc::c_int) < 32 as libc::c_int {
                    let mut compdist: fixed_t = 0;
                    if !(playeringame[i as usize] == 0) {
                        if !(players[i as usize].spectator != 0) {
                            if !(players[i as usize].mo).is_null() {
                                if !((*players[i as usize].mo).health == 0) {
                                    if !(P_PlayerInPain(
                                        &mut *players.as_mut_ptr().offset(i as isize),
                                    ) != 0)
                                    {
                                        if !((*players[i as usize].mo).z
                                            > (*mobj).z + (*mobj).height
                                                + 8 as libc::c_int * (*mobj).scale)
                                        {
                                            if !((*players[i as usize].mo).z
                                                + (*players[i as usize].mo).height
                                                < (*mobj).z - 8 as libc::c_int * (*mobj).scale)
                                            {
                                                compdist = P_AproxDistance(
                                                    (*players[i as usize].mo).x + (*players[i as usize].mo).momx
                                                        - basex,
                                                    (*players[i as usize].mo).y + (*players[i as usize].mo).momy
                                                        - basey,
                                                );
                                                if !(compdist >= dist) {
                                                    dist = compdist;
                                                    P_SetTarget2(&mut (*mobj).target, players[i as usize].mo);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    i = i.wrapping_add(1);
                    i;
                }
                if dist < 96 as libc::c_int * (*mobj).scale << 1 as libc::c_int {
                    didmove = true_0 as libc::c_int;
                    (*mobj)
                        .frame = (3 as libc::c_int as tic_t)
                        .wrapping_add(
                            (leveltime & 2 as libc::c_int as tic_t) >> 1 as libc::c_int,
                        );
                    (*mobj)
                        .angle = R_PointToAngle2(
                        (*mobj).x,
                        (*mobj).y,
                        (*(*mobj).target).x,
                        (*(*mobj).target).y,
                    );
                    if P_AproxDistance((*mobj).x - basex, (*mobj).y - basey)
                        < (*mobj).scale
                    {
                        S_StartSound(
                            mobj as *const libc::c_void,
                            (*(*mobj).info).seesound,
                        );
                    }
                    P_MoveOrigin(
                        mobj,
                        15 as libc::c_int * ((*mobj).x >> 4 as libc::c_int)
                            + (basex >> 4 as libc::c_int)
                            + P_ReturnThrustX(
                                mobj,
                                (*mobj).angle,
                                96 as libc::c_int * (*mobj).scale >> 4 as libc::c_int,
                            ),
                        15 as libc::c_int * ((*mobj).y >> 4 as libc::c_int)
                            + (basey >> 4 as libc::c_int)
                            + P_ReturnThrustY(
                                mobj,
                                (*mobj).angle,
                                96 as libc::c_int * (*mobj).scale >> 4 as libc::c_int,
                            ),
                        (*mobj).z,
                    );
                } else {
                    let mut diff: angle_t = ((*mobj).movedir)
                        .wrapping_sub((*mobj).angle);
                    if diff > 0x80000000 as libc::c_uint {
                        diff = InvAngle(InvAngle(diff) / 8 as libc::c_int as angle_t);
                    } else {
                        diff = diff / 8 as libc::c_int as angle_t;
                    }
                    (*mobj).angle = ((*mobj).angle).wrapping_add(diff);
                    dist = *finecosine
                        .offset(
                            (leveltime.wrapping_add((*mobj).movecount as tic_t)
                                * 0x16c16c1 as libc::c_int as tic_t
                                >> 19 as libc::c_int - 2 as libc::c_int
                                & (8192 as libc::c_int - 1 as libc::c_int) as tic_t)
                                as isize,
                        ) >> 16 as libc::c_int - 16 as libc::c_int;
                    if abs(dist)
                        < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
                    {
                        (*mobj).frame = 0 as libc::c_int as uint32_t;
                    } else {
                        (*mobj)
                            .frame = (if dist > 0 as libc::c_int {
                            1 as libc::c_int
                        } else {
                            2 as libc::c_int
                        }) as uint32_t;
                    }
                }
            }
            if didmove == 0 {
                if P_AproxDistance((*mobj).x - basex, (*mobj).y - basey) < (*mobj).scale
                {
                    P_MoveOrigin(mobj, basex, basey, (*mobj).z);
                } else {
                    P_MoveOrigin(
                        mobj,
                        15 as libc::c_int * ((*mobj).x >> 4 as libc::c_int)
                            + (basex >> 4 as libc::c_int),
                        15 as libc::c_int * ((*mobj).y >> 4 as libc::c_int)
                            + (basey >> 4 as libc::c_int),
                        (*mobj).z,
                    );
                }
            }
        }
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_NiGHTSDroneThink(mut mobj: *mut mobj_t) {
    let mut goalpost: *mut mobj_t = 0 as *mut mobj_t;
    let mut sparkle: *mut mobj_t = 0 as *mut mobj_t;
    let mut droneman: *mut mobj_t = 0 as *mut mobj_t;
    let mut flip: boolean = ((*mobj).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t)
        as boolean;
    let mut topaligned: boolean = ((*mobj).flags & MF_SLIDEME as libc::c_int as uint32_t
        != 0 && (*mobj).flags & MF_GRENADEBOUNCE as libc::c_int as uint32_t == 0)
        as libc::c_int;
    let mut middlealigned: boolean = ((*mobj).flags
        & MF_GRENADEBOUNCE as libc::c_int as uint32_t != 0
        && (*mobj).flags & MF_SLIDEME as libc::c_int as uint32_t == 0) as libc::c_int;
    let mut bottomoffsetted: boolean = ((*mobj).flags
        & MF_SLIDEME as libc::c_int as uint32_t == 0
        && (*mobj).flags & MF_GRENADEBOUNCE as libc::c_int as uint32_t == 0)
        as libc::c_int;
    let mut flipchanged: boolean = false_0 as libc::c_int;
    let mut dronemanoffset: fixed_t = 0;
    let mut goaloffset: fixed_t = 0;
    let mut sparkleoffset: fixed_t = 0;
    let mut droneboxmandiff: fixed_t = 0;
    let mut dronemangoaldiff: fixed_t = 0;
    if !((*mobj).target).is_null()
        && (*(*mobj).target).type_0 as libc::c_uint
            == MT_NIGHTSDRONE_GOAL as libc::c_int as libc::c_uint
    {
        goalpost = (*mobj).target;
        if !((*goalpost).target).is_null()
            && (*(*goalpost).target).type_0 as libc::c_uint
                == MT_NIGHTSDRONE_SPARKLING as libc::c_int as libc::c_uint
        {
            sparkle = (*goalpost).target;
        }
        if !((*goalpost).tracer).is_null()
            && (*(*goalpost).tracer).type_0 as libc::c_uint
                == MT_NIGHTSDRONE_MAN as libc::c_int as libc::c_uint
        {
            droneman = (*goalpost).tracer;
        }
    }
    if goalpost.is_null() || sparkle.is_null() || droneman.is_null() {
        return;
    }
    droneboxmandiff = if (*mobj).height - (*droneman).height > 0 as libc::c_int {
        (*mobj).height - (*droneman).height
    } else {
        0 as libc::c_int
    };
    dronemangoaldiff = if (*droneman).height - (*goalpost).height > 0 as libc::c_int {
        (*droneman).height - (*goalpost).height
    } else {
        0 as libc::c_int
    };
    if (*goalpost).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t == 0
        && (*mobj).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t != 0
    {
        (*goalpost)
            .eflags = ((*goalpost).eflags as libc::c_int
            | MFE_VERTICALFLIP as libc::c_int) as uint16_t;
        (*goalpost).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
        (*sparkle)
            .eflags = ((*sparkle).eflags as libc::c_int
            | MFE_VERTICALFLIP as libc::c_int) as uint16_t;
        (*sparkle).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
        (*droneman)
            .eflags = ((*droneman).eflags as libc::c_int
            | MFE_VERTICALFLIP as libc::c_int) as uint16_t;
        (*droneman).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
        flipchanged = true_0 as libc::c_int;
    } else if (*goalpost).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t != 0
        && (*mobj).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t == 0
    {
        (*goalpost)
            .eflags = ((*goalpost).eflags as libc::c_int
            & !(MFE_VERTICALFLIP as libc::c_int)) as uint16_t;
        (*goalpost).flags2 &= !(MF2_OBJECTFLIP as libc::c_int) as uint32_t;
        (*sparkle)
            .eflags = ((*sparkle).eflags as libc::c_int
            & !(MFE_VERTICALFLIP as libc::c_int)) as uint16_t;
        (*sparkle).flags2 &= !(MF2_OBJECTFLIP as libc::c_int) as uint32_t;
        (*droneman)
            .eflags = ((*droneman).eflags as libc::c_int
            & !(MFE_VERTICALFLIP as libc::c_int)) as uint16_t;
        (*droneman).flags2 &= !(MF2_OBJECTFLIP as libc::c_int) as uint32_t;
        flipchanged = true_0 as libc::c_int;
    }
    if (*goalpost).destscale != (*mobj).destscale || (*goalpost).movefactor != (*mobj).z
        || (*goalpost).friction != (*mobj).height || flipchanged != 0
        || (*goalpost).threshold
            != ((*mobj).flags
                & (MF_SLIDEME as libc::c_int | MF_GRENADEBOUNCE as libc::c_int)
                    as uint32_t) as int32_t
    {
        (*droneman).destscale = (*mobj).destscale;
        (*sparkle).destscale = (*droneman).destscale;
        (*goalpost).destscale = (*sparkle).destscale;
        if flip == 0 {
            if topaligned != 0 {
                dronemanoffset = droneboxmandiff;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            } else if middlealigned != 0 {
                dronemanoffset = droneboxmandiff / 2 as libc::c_int;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            } else if bottomoffsetted != 0 {
                dronemanoffset = 24 as libc::c_int
                    * ((1 as libc::c_int) << 16 as libc::c_int);
                goaloffset = dronemangoaldiff + dronemanoffset;
            } else {
                dronemanoffset = 0 as libc::c_int;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            }
            sparkleoffset = goaloffset
                - FixedMul(
                    15 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*mobj).scale,
                );
        } else {
            if topaligned != 0 {
                dronemanoffset = 0 as libc::c_int;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            } else if middlealigned != 0 {
                dronemanoffset = droneboxmandiff / 2 as libc::c_int;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            } else if bottomoffsetted != 0 {
                dronemanoffset = droneboxmandiff
                    - FixedMul(
                        24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*mobj).scale,
                    );
                goaloffset = dronemangoaldiff + dronemanoffset;
            } else {
                dronemanoffset = droneboxmandiff;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            }
            sparkleoffset = goaloffset
                + FixedMul(
                    15 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*mobj).scale,
                );
        }
        P_MoveOrigin(goalpost, (*mobj).x, (*mobj).y, (*mobj).z + goaloffset);
        P_MoveOrigin(sparkle, (*mobj).x, (*mobj).y, (*mobj).z + sparkleoffset);
        if (*goalpost).movefactor != (*mobj).z || (*goalpost).friction != (*mobj).height
        {
            P_MoveOrigin(droneman, (*mobj).x, (*mobj).y, (*mobj).z + dronemanoffset);
            (*goalpost).movefactor = (*mobj).z;
            (*goalpost).friction = (*mobj).height;
        }
        (*goalpost)
            .threshold = ((*mobj).flags
            & (MF_SLIDEME as libc::c_int | MF_GRENADEBOUNCE as libc::c_int) as uint32_t)
            as int32_t;
    } else {
        if (*goalpost).x != (*mobj).x || (*goalpost).y != (*mobj).y {
            P_MoveOrigin(goalpost, (*mobj).x, (*mobj).y, (*goalpost).z);
            P_MoveOrigin(sparkle, (*mobj).x, (*mobj).y, (*sparkle).z);
        }
        if (*droneman).x != (*mobj).x || (*droneman).y != (*mobj).y {
            P_MoveOrigin(
                droneman,
                (*mobj).x,
                (*mobj).y,
                if (*droneman).z >= (*mobj).floorz && (*droneman).z <= (*mobj).ceilingz {
                    (*droneman).z
                } else {
                    (*mobj).z
                },
            );
        }
    }
    if (*sparkle).state
        >= &mut *states
            .as_mut_ptr()
            .offset(S_NIGHTSDRONE_SPARKLING1 as libc::c_int as isize) as *mut state_t
        && (*sparkle).state
            <= &mut *states
                .as_mut_ptr()
                .offset(S_NIGHTSDRONE_SPARKLING16 as libc::c_int as isize)
                as *mut state_t
    {
        let mut i: int32_t = 0;
        let mut bonustime: boolean = false_0 as libc::c_int;
        i = 0 as libc::c_int;
        while i < 32 as libc::c_int {
            if playeringame[i as usize] != 0 && players[i as usize].bonustime != 0
                && players[i as usize].powers[pw_carry as libc::c_int as usize]
                    as libc::c_int == CR_NIGHTSMODE as libc::c_int
            {
                bonustime = true_0 as libc::c_int;
                break;
            } else {
                i += 1;
                i;
            }
        }
        if bonustime == 0 {
            CONS_Debug(
                0x10 as libc::c_int,
                b"Removing goal post\n\0" as *const u8 as *const libc::c_char,
            );
            if !goalpost.is_null()
                && (*goalpost).state
                    != &mut *states
                        .as_mut_ptr()
                        .offset(S_INVISIBLE as libc::c_int as isize) as *mut state_t
            {
                P_SetMobjState(goalpost, S_INVISIBLE);
            }
            if !sparkle.is_null()
                && (*sparkle).state
                    != &mut *states
                        .as_mut_ptr()
                        .offset(S_INVISIBLE as libc::c_int as isize) as *mut state_t
            {
                P_SetMobjState(sparkle, S_INVISIBLE);
            }
        }
    } else {
        let mut i_0: int32_t = 0;
        let mut bonustime_0: boolean = false_0 as libc::c_int;
        let mut zcomp: fixed_t = 0;
        if flip == 0 {
            if topaligned != 0 {
                zcomp = droneboxmandiff + (*mobj).z;
            } else if middlealigned != 0 {
                zcomp = droneboxmandiff / 2 as libc::c_int + (*mobj).z;
            } else if bottomoffsetted != 0 {
                zcomp = (*mobj).z
                    + FixedMul(
                        24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*mobj).scale,
                    );
            } else {
                zcomp = (*mobj).z;
            }
        } else if topaligned != 0 {
            zcomp = (*mobj).z;
        } else if middlealigned != 0 {
            zcomp = droneboxmandiff / 2 as libc::c_int + (*mobj).z;
        } else if bottomoffsetted != 0 {
            zcomp = (*mobj).z + droneboxmandiff
                - FixedMul(
                    24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*mobj).scale,
                );
        } else {
            zcomp = (*mobj).z + droneboxmandiff;
        }
        (*droneman)
            .angle = ((*droneman).angle)
            .wrapping_add(0x71c71c7 as libc::c_int as angle_t);
        if flip == 0 && (*droneman).z <= zcomp {
            (*droneman)
                .momz = FixedMul(
                5 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*droneman).scale,
            );
        } else if flip != 0 && (*droneman).z >= zcomp {
            (*droneman)
                .momz = FixedMul(
                -(5 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
                (*droneman).scale,
            );
        }
        i_0 = 0 as libc::c_int;
        while i_0 < 32 as libc::c_int {
            if playeringame[i_0 as usize] != 0 && players[i_0 as usize].bonustime != 0
                && players[i_0 as usize].powers[pw_carry as libc::c_int as usize]
                    as libc::c_int == CR_NIGHTSMODE as libc::c_int
            {
                bonustime_0 = true_0 as libc::c_int;
                break;
            } else {
                i_0 += 1;
                i_0;
            }
        }
        if bonustime_0 != 0 {
            CONS_Debug(
                0x10 as libc::c_int,
                b"Adding goal post\n\0" as *const u8 as *const libc::c_char,
            );
            if (*droneman).flags2 & MF2_DONTDRAW as libc::c_int as uint32_t == 0 {
                (*droneman).flags2 |= MF2_DONTDRAW as libc::c_int as uint32_t;
            }
            if (*goalpost).state
                == &mut *states.as_mut_ptr().offset(S_INVISIBLE as libc::c_int as isize)
                    as *mut state_t
            {
                P_SetMobjState(
                    goalpost,
                    mobjinfo[(*goalpost).type_0 as usize].meleestate,
                );
            }
            if (*sparkle).state
                == &mut *states.as_mut_ptr().offset(S_INVISIBLE as libc::c_int as isize)
                    as *mut state_t
            {
                P_SetMobjState(sparkle, mobjinfo[(*sparkle).type_0 as usize].meleestate);
            }
        } else if G_IsSpecialStage(gamemap as int32_t) == 0 {
            i_0 = 0 as libc::c_int;
            while i_0 < 32 as libc::c_int {
                if playeringame[i_0 as usize] != 0
                    && players[i_0 as usize].powers[pw_carry as libc::c_int as usize]
                        as libc::c_int != CR_NIGHTSMODE as libc::c_int
                {
                    bonustime_0 = true_0 as libc::c_int;
                    break;
                } else {
                    i_0 += 1;
                    i_0;
                }
            }
            if bonustime_0 != 0 {
                if (*goalpost).state
                    != &mut *states
                        .as_mut_ptr()
                        .offset(S_INVISIBLE as libc::c_int as isize) as *mut state_t
                {
                    P_SetMobjState(goalpost, S_INVISIBLE);
                }
                if (*sparkle).state
                    != &mut *states
                        .as_mut_ptr()
                        .offset(S_INVISIBLE as libc::c_int as isize) as *mut state_t
                {
                    P_SetMobjState(sparkle, S_INVISIBLE);
                }
                if (*droneman).state
                    != &mut *states
                        .as_mut_ptr()
                        .offset(
                            (*mobjinfo.as_mut_ptr().offset((*droneman).type_0 as isize))
                                .meleestate as isize,
                        ) as *mut state_t
                {
                    P_SetMobjState(
                        droneman,
                        mobjinfo[(*droneman).type_0 as usize].meleestate,
                    );
                }
                if (*droneman).flags2 & MF2_DONTDRAW as libc::c_int as uint32_t != 0 {
                    (*droneman).flags2 &= !(MF2_DONTDRAW as libc::c_int) as uint32_t;
                }
            } else if (*droneman).flags2 & MF2_DONTDRAW as libc::c_int as uint32_t == 0 {
                (*droneman).flags2 |= MF2_DONTDRAW as libc::c_int as uint32_t;
            }
        }
    };
}
unsafe extern "C" fn P_TurretThink(mut mobj: *mut mobj_t) -> boolean {
    P_MobjCheckWater(mobj);
    P_CheckPosition(mobj, (*mobj).x, (*mobj).y);
    if P_MobjWasRemoved(mobj) != 0 {
        return false_0 as libc::c_int;
    }
    (*mobj).floorz = tmfloorz;
    (*mobj).ceilingz = tmceilingz;
    (*mobj).floorrover = tmfloorrover;
    (*mobj).ceilingrover = tmceilingrover;
    if (*mobj).eflags as libc::c_int & MFE_UNDERWATER as libc::c_int != 0
        && (*mobj).health > 0 as libc::c_int
    {
        P_SetMobjState(mobj, (*(*mobj).info).deathstate);
        (*mobj).health = 0 as libc::c_int;
        (*mobj).flags2 &= !(MF2_FIRING as libc::c_int) as uint32_t;
    } else if (*mobj).health > 0 as libc::c_int
        && (*mobj).z + (*mobj).height > (*mobj).ceilingz
    {
        let mut i: int32_t = 0;
        let mut j: int32_t = 0;
        let mut ns: fixed_t = 0;
        let mut x: fixed_t = 0;
        let mut y: fixed_t = 0;
        let mut z: fixed_t = 0;
        let mut mo2: *mut mobj_t = 0 as *mut mobj_t;
        z = (*(*(*mobj).subsector).sector).floorheight
            + FixedMul(
                64 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*mobj).scale,
            );
        j = 0 as libc::c_int;
        while j < 2 as libc::c_int {
            i = 0 as libc::c_int;
            while i < 32 as libc::c_int {
                let fa: angle_t = (i * 8192 as libc::c_int / 16 as libc::c_int
                    & 8192 as libc::c_int - 1 as libc::c_int) as angle_t;
                ns = FixedMul(
                    64 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*mobj).scale,
                );
                x = (*mobj).x
                    + FixedMul(
                        finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                        ns,
                    );
                y = (*mobj).y
                    + FixedMul(
                        *finecosine.offset(fa as isize)
                            >> 16 as libc::c_int - 16 as libc::c_int,
                        ns,
                    );
                mo2 = P_SpawnMobj(x, y, z, MT_EXPLODE);
                ns = FixedMul(
                    16 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*mobj).scale,
                );
                (*mo2)
                    .momx = FixedMul(
                    finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                    ns,
                );
                (*mo2)
                    .momy = FixedMul(
                    *finecosine.offset(fa as isize)
                        >> 16 as libc::c_int - 16 as libc::c_int,
                    ns,
                );
                i += 1;
                i;
            }
            z
                -= FixedMul(
                    32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*mobj).scale,
                );
            j += 1;
            j;
        }
        P_SetMobjState(mobj, (*(*mobj).info).deathstate);
        (*mobj).health = 0 as libc::c_int;
        (*mobj).flags2 &= !(MF2_FIRING as libc::c_int) as uint32_t;
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_SaloonDoorThink(mut mobj: *mut mobj_t) {
    let mut x: fixed_t = (*(*mobj).tracer).x;
    let mut y: fixed_t = (*(*mobj).tracer).y;
    let mut z: fixed_t = (*(*mobj).tracer).z;
    let mut oang: angle_t = FixedAngle((*mobj).extravalue1);
    let mut fa: angle_t = oang >> 19 as libc::c_int
        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
    let mut c0: fixed_t = -(96 as libc::c_int)
        * (*finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int);
    let mut s0: fixed_t = -(96 as libc::c_int)
        * (finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int);
    let mut fma: angle_t = 0;
    let mut c: fixed_t = 0;
    let mut s: fixed_t = 0;
    let mut angdiff: angle_t = 0;
    let mut da: fixed_t = AngleFixed(((*mobj).angle).wrapping_sub(oang));
    if da > 180 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int) {
        da -= 360 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
    }
    (*mobj)
        .extravalue2 = 8 as libc::c_int * ((*mobj).extravalue2 - da / 32 as libc::c_int)
        / 9 as libc::c_int;
    (*mobj).angle = ((*mobj).angle).wrapping_add(FixedAngle((*mobj).extravalue2));
    angdiff = ((*mobj).angle).wrapping_sub(FixedAngle((*mobj).extravalue1));
    if angdiff > (0x40000000 as libc::c_int - 0x16c16c1 as libc::c_int) as angle_t
        && angdiff < 0x80000000 as libc::c_uint
    {
        (*mobj)
            .angle = (FixedAngle((*mobj).extravalue1))
            .wrapping_add(
                (0x40000000 as libc::c_int - 0x16c16c1 as libc::c_int) as angle_t,
            );
        (*mobj).extravalue2 /= 2 as libc::c_int;
    } else if angdiff
        < (0xc0000000 as libc::c_uint)
            .wrapping_add(0x16c16c1 as libc::c_int as libc::c_uint)
        && angdiff >= 0x80000000 as libc::c_uint
    {
        (*mobj)
            .angle = (FixedAngle((*mobj).extravalue1))
            .wrapping_add(
                (0xc0000000 as libc::c_uint)
                    .wrapping_add(0x16c16c1 as libc::c_int as libc::c_uint),
            );
        (*mobj).extravalue2 /= 2 as libc::c_int;
    }
    fma = (*mobj).angle >> 19 as libc::c_int
        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
    c = 48 as libc::c_int
        * (*finecosine.offset(fma as isize) >> 16 as libc::c_int - 16 as libc::c_int);
    s = 48 as libc::c_int
        * (finesine[fma as usize] >> 16 as libc::c_int - 16 as libc::c_int);
    P_MoveOrigin(mobj, x + c0 + c, y + s0 + s, z);
}
unsafe extern "C" fn P_PyreFlyThink(mut mobj: *mut mobj_t) {
    let mut hdist: fixed_t = 0;
    (*mobj).extravalue1 = ((*mobj).extravalue1 + 3 as libc::c_int) % 360 as libc::c_int;
    (*mobj).z
        += finesine[((*mobj).extravalue1 * 0xb60b61 as libc::c_int >> 19 as libc::c_int
            & 8192 as libc::c_int - 1 as libc::c_int) as usize]
            >> 16 as libc::c_int - 16 as libc::c_int;
    if (*mobj).flags2 & MF2_BOSSNOTRAP as libc::c_int as uint32_t == 0 {
        P_LookForPlayers(
            mobj,
            true_0 as libc::c_int,
            false_0 as libc::c_int,
            1500 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
    }
    if ((*mobj).target).is_null() {
        return;
    }
    if (*mobj).extravalue2 == 1 as libc::c_int {
        P_PyreFlyBurn(
            mobj,
            0 as libc::c_int,
            20 as libc::c_int as int16_t,
            MT_SMOKE,
            4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
    } else if (*mobj).extravalue2 == 2 as libc::c_int {
        let mut fireradius: int32_t = if 100 as libc::c_int - (*mobj).fuse
            < 52 as libc::c_int
        {
            100 as libc::c_int - (*mobj).fuse
        } else {
            52 as libc::c_int
        };
        P_PyreFlyBurn(
            mobj,
            P_RandomRange(0 as libc::c_int, fireradius) << 16 as libc::c_int,
            20 as libc::c_int as int16_t,
            MT_FLAMEPARTICLE,
            4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
        P_PyreFlyBurn(
            mobj,
            fireradius * ((1 as libc::c_int) << 16 as libc::c_int),
            40 as libc::c_int as int16_t,
            MT_PYREFLY_FIRE,
            0 as libc::c_int,
        );
    }
    hdist = R_PointToDist2(
        (*mobj).x,
        (*mobj).y,
        (*(*mobj).target).x,
        (*(*mobj).target).y,
    );
    if hdist > 1500 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int) {
        (*mobj).flags2 &= !(MF2_BOSSNOTRAP as libc::c_int) as uint32_t;
        P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
        return;
    }
    if (*mobj).flags2 & MF2_BOSSNOTRAP as libc::c_int as uint32_t == 0
        && hdist <= 450 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
    {
        (*mobj).flags2 |= MF2_BOSSNOTRAP as libc::c_int as uint32_t;
    }
    if (*mobj).flags2 & MF2_BOSSNOTRAP as libc::c_int as uint32_t == 0 {
        return;
    }
    if hdist < 1000 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int) {
        let mut destz: fixed_t = if (if (*(*mobj).target).z
            > (*(*mobj).target).floorz
                + 70 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
        {
            (*(*mobj).target).z
        } else {
            (*(*mobj).target).floorz
                + 70 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
        })
            < (*(*mobj).target).ceilingz
                - 80 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                - (*mobj).height
        {
            if (*(*mobj).target).z
                > (*(*mobj).target).floorz
                    + 70 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
            {
                (*(*mobj).target).z
            } else {
                (*(*mobj).target).floorz
                    + 70 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
            }
        } else {
            (*(*mobj).target).ceilingz
                - 80 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                - (*mobj).height
        };
        let mut dist: fixed_t = P_AproxDistance(hdist, destz - (*mobj).z);
        P_InstaThrust(
            mobj,
            R_PointToAngle2(
                (*mobj).x,
                (*mobj).y,
                (*(*mobj).target).x,
                (*(*mobj).target).y,
            ),
            2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
        (*mobj)
            .momz = FixedMul(
            FixedDiv(destz - (*mobj).z, dist),
            2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
    } else {
        (*mobj).momx = 0 as libc::c_int;
        (*mobj).momy = 0 as libc::c_int;
        (*mobj).momz = 0 as libc::c_int;
    };
}
unsafe extern "C" fn P_PterabyteThink(mut mobj: *mut mobj_t) {
    if (*mobj).extravalue1 & 4 as libc::c_int != 0 {
        if (*mobj).movefactor != 0 {
            (*mobj).movefactor -= 1;
            (*mobj).movefactor;
        } else {
            P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
            (*mobj).extravalue1 &= 3 as libc::c_int;
        }
    }
    if (*mobj).extravalue1 & 3 as libc::c_int == 0 as libc::c_int {
        let mut vdist: fixed_t = 0;
        let mut hdist: fixed_t = 0;
        let mut time: fixed_t = 0;
        let mut hspeed: fixed_t = 3 as libc::c_int * (*(*mobj).info).speed;
        let mut fa: angle_t = 0;
        var1 = 1 as libc::c_int;
        var2 = 0 as libc::c_int;
        A_CapeChase(mobj);
        if !((*mobj).target).is_null() {
            return;
        }
        P_LookForPlayers(
            mobj,
            true_0 as libc::c_int,
            false_0 as libc::c_int,
            256 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
        );
        if ((*mobj).target).is_null() {
            return;
        }
        if (*(*(*mobj).target).player).powers[pw_flashing as libc::c_int as usize] != 0 {
            P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
            return;
        }
        vdist = (*mobj).z - (*(*mobj).target).z - (*(*mobj).target).height;
        if P_MobjFlip(mobj) as libc::c_int * vdist <= 0 as libc::c_int {
            P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
            return;
        }
        hdist = R_PointToDist2(
            (*mobj).x,
            (*mobj).y,
            (*(*mobj).target).x,
            (*(*mobj).target).y,
        );
        if hdist > 450 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int) {
            P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
            return;
        }
        P_SetMobjState(mobj, S_PTERABYTE_SWOOPDOWN);
        (*mobj).extravalue1 += 1;
        (*mobj).extravalue1;
        S_StartSound(mobj as *const libc::c_void, (*(*mobj).info).attacksound);
        time = FixedDiv(hdist, hspeed);
        (*mobj)
            .angle = R_PointToAngle2(
            (*mobj).x,
            (*mobj).y,
            (*(*mobj).target).x,
            (*(*mobj).target).y,
        );
        fa = (*mobj).angle >> 19 as libc::c_int
            & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
        (*mobj)
            .momx = FixedMul(
            *finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int,
            hspeed,
        );
        (*mobj)
            .momy = FixedMul(
            finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
            hspeed,
        );
        (*mobj).momz = -(2 as libc::c_int) * FixedDiv(vdist, time);
        (*mobj).extravalue2 = -FixedDiv((*mobj).momz, time);
        (*mobj).movecount = time >> 16 as libc::c_int;
        (*mobj).reactiontime = (*mobj).movecount;
    } else if (*mobj).extravalue1 & 3 as libc::c_int == 1 as libc::c_int {
        (*mobj).reactiontime -= 1;
        (*mobj).reactiontime;
        (*mobj).momz += (*mobj).extravalue2;
        if (*mobj).reactiontime != 0 {
            return;
        }
        if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
            == S_PTERABYTE_SWOOPDOWN as libc::c_int as libc::c_long
        {
            P_SetMobjState(mobj, S_PTERABYTE_SWOOPUP);
            (*mobj).reactiontime = (*mobj).movecount;
        } else if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
            == S_PTERABYTE_SWOOPUP as libc::c_int as libc::c_long
        {
            P_SetMobjState(mobj, S_PTERABYTE_FLY1);
            (*mobj).extravalue1 += 1;
            (*mobj).extravalue1;
            if !((*mobj).target).is_null() && (*(*mobj).target).tracer != mobj {
                P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
            }
            (*mobj).momz = 0 as libc::c_int;
            (*mobj).momy = (*mobj).momz;
            (*mobj).momx = (*mobj).momy;
        }
    } else {
        var1 = 2 as libc::c_int * (*(*mobj).info).speed;
        var2 = 1 as libc::c_int;
        A_HomingChase(mobj);
        if P_AproxDistance(
            (*mobj).x - (*(*mobj).tracer).x,
            (*mobj).y - (*(*mobj).tracer).y,
        ) <= (*(*mobj).info).speed
        {
            (*mobj).extravalue1 -= 2 as libc::c_int;
            (*mobj).momz = 0 as libc::c_int;
            (*mobj).momy = (*mobj).momz;
            (*mobj).momx = (*mobj).momy;
        }
    };
}
unsafe extern "C" fn P_DragonbomberThink(mut mobj: *mut mobj_t) {
    (*mobj).movecount = ((*mobj).movecount + 9 as libc::c_int) % 360 as libc::c_int;
    P_SetObjectMomZ(
        mobj,
        4 as libc::c_int
            * (finesine[((*mobj).movecount * 0xb60b61 as libc::c_int >> 19 as libc::c_int
                & 8192 as libc::c_int - 1 as libc::c_int) as usize]
                >> 16 as libc::c_int - 16 as libc::c_int),
        false_0 as libc::c_int,
    );
    if (*mobj).threshold > 0 as libc::c_int {
        (*mobj).threshold -= 1;
        (*mobj).threshold;
        if (*mobj).threshold == 0 as libc::c_int {
            let mut segment: *mut mobj_t = mobj;
            while !((*segment).tracer).is_null()
                && P_MobjWasRemoved((*segment).tracer) == 0
                && (*(*segment).tracer).state
                    == &mut *states
                        .as_mut_ptr()
                        .offset((*(*(*segment).tracer).info).spawnstate as isize)
                        as *mut state_t
            {
                segment = (*segment).tracer;
            }
            if segment != mobj {
                let mut mine: *mut mobj_t = P_SpawnMobjFromMobj(
                    segment,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    (*(*segment).info).painchance as mobjtype_t,
                );
                (*mine).angle = (*segment).angle;
                P_InstaThrust(
                    mine,
                    (*mobj).angle,
                    P_AproxDistance((*mobj).momx, (*mobj).momy) >> 1 as libc::c_int,
                );
                P_SetObjectMomZ(
                    mine,
                    -(2 as libc::c_int) * ((1 as libc::c_int) << 16 as libc::c_int),
                    true_0 as libc::c_int,
                );
                S_StartSound(mine as *const libc::c_void, (*(*mine).info).seesound);
                P_SetMobjState(segment, (*(*segment).info).raisestate);
                (*mobj).threshold = (*(*mobj).info).painchance;
            }
        }
    }
    if !((*mobj).target).is_null() {
        let mut dist: fixed_t = P_AproxDistance(
            (*mobj).x - (*(*mobj).target).x,
            (*mobj).y - (*(*mobj).target).y,
        );
        if dist > 2000 as libc::c_int * (*mobj).scale {
            P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
        } else {
            let mut vspeed: fixed_t = FixedMul(
                (*(*mobj).info).speed >> 3 as libc::c_int,
                (*mobj).scale,
            );
            let mut z: fixed_t = (*(*mobj).target).z
                + ((*mobj).height >> 1 as libc::c_int)
                + (if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                    != 0
                {
                    -(128 as libc::c_int) * (*mobj).scale
                } else {
                    128 as libc::c_int * (*mobj).scale + (*(*mobj).target).height
                });
            let mut diff: angle_t = (R_PointToAngle2(
                (*mobj).x,
                (*mobj).y,
                (*(*mobj).target).x,
                (*(*mobj).target).y,
            ))
                .wrapping_sub((*mobj).angle);
            if diff > 0x80000000 as libc::c_uint {
                (*mobj)
                    .angle = ((*mobj).angle)
                    .wrapping_sub(0x16c16c1 as libc::c_int as angle_t);
            } else {
                (*mobj)
                    .angle = ((*mobj).angle)
                    .wrapping_add(0x16c16c1 as libc::c_int as angle_t);
            }
            if (*mobj).threshold == 0 && dist < 512 as libc::c_int * (*mobj).scale {
                (*mobj).threshold = (*(*mobj).info).painchance;
            }
            (*mobj).momz
                += if (if z - (*mobj).z < vspeed { z - (*mobj).z } else { vspeed })
                    > -vspeed
                {
                    if z - (*mobj).z < vspeed { z - (*mobj).z } else { vspeed }
                } else {
                    -vspeed
                };
        }
    } else if ((*mobj).tracer).is_null()
        || (*(*mobj).tracer).state
            != &mut *states
                .as_mut_ptr()
                .offset((*(*(*mobj).tracer).info).spawnstate as isize) as *mut state_t
        || P_LookForPlayers(
            mobj,
            true_0 as libc::c_int,
            false_0 as libc::c_int,
            2000 as libc::c_int * (*mobj).scale,
        ) == 0
    {
        if ((*mobj).spawnpoint).is_null() {
            (*mobj)
                .angle = ((*mobj).angle)
                .wrapping_add(0x16c16c1 as libc::c_int as angle_t);
        } else {
            let mut flip: boolean = (*(*mobj).spawnpoint).options as libc::c_int
                & 2 as libc::c_int;
            let mut vspeed_0: fixed_t = FixedMul(
                (*(*mobj).info).speed >> 3 as libc::c_int,
                (*mobj).scale,
            );
            let mut x: fixed_t = ((*(*mobj).spawnpoint).x as libc::c_int)
                << 16 as libc::c_int;
            let mut y: fixed_t = ((*(*mobj).spawnpoint).y as libc::c_int)
                << 16 as libc::c_int;
            let mut z_0: fixed_t = (if flip != 0 {
                Some(
                    P_GetSectorCeilingZAt
                        as unsafe extern "C" fn(
                            *const sector_t,
                            fixed_t,
                            fixed_t,
                        ) -> fixed_t,
                )
            } else {
                Some(
                    P_GetSectorFloorZAt
                        as unsafe extern "C" fn(
                            *const sector_t,
                            fixed_t,
                            fixed_t,
                        ) -> fixed_t,
                )
            })
                .expect(
                    "non-null function pointer",
                )((*R_PointInSubsector(x, y)).sector, x, y)
                + (if flip != 0 { -(1 as libc::c_int) } else { 1 as libc::c_int })
                    * (((*(*mobj).spawnpoint).z as libc::c_int) << 16 as libc::c_int);
            let mut diff_0: angle_t = (R_PointToAngle2((*mobj).x, (*mobj).y, x, y))
                .wrapping_sub((*mobj).angle);
            if diff_0 > 0x80000000 as libc::c_uint {
                (*mobj)
                    .angle = ((*mobj).angle)
                    .wrapping_sub(0x16c16c1 as libc::c_int as angle_t);
            } else {
                (*mobj)
                    .angle = ((*mobj).angle)
                    .wrapping_add(0x16c16c1 as libc::c_int as angle_t);
            }
            (*mobj).momz
                += if (if z_0 - (*mobj).z < vspeed_0 {
                    z_0 - (*mobj).z
                } else {
                    vspeed_0
                }) > -vspeed_0
                {
                    if z_0 - (*mobj).z < vspeed_0 { z_0 - (*mobj).z } else { vspeed_0 }
                } else {
                    -vspeed_0
                };
        }
    }
    P_InstaThrust(mobj, (*mobj).angle, FixedMul((*(*mobj).info).speed, (*mobj).scale));
}
static mut pushmobj: *mut mobj_t = 0 as *const mobj_t as *mut mobj_t;
#[inline]
unsafe extern "C" fn PIT_PushThing(mut thing: *mut mobj_t) -> boolean {
    if (*thing).eflags as libc::c_int & MFE_PUSHED as libc::c_int != 0 {
        return false_0 as libc::c_int;
    }
    if !((*thing).player).is_null()
        && (*(*thing).player).powers[pw_carry as libc::c_int as usize] as libc::c_int
            == CR_ROPEHANG as libc::c_int
    {
        return false_0 as libc::c_int;
    }
    if pushmobj.is_null() {
        return false_0 as libc::c_int;
    }
    if ((*pushmobj).spawnpoint).is_null() {
        return false_0 as libc::c_int;
    }
    if !((*thing).player).is_null()
        && (*thing).flags
            & (MF_NOGRAVITY as libc::c_int | MF_NOCLIP as libc::c_int) as uint32_t == 0
    {
        let mut dist: int32_t = 0;
        let mut speed: int32_t = 0;
        let mut sx: int32_t = (*pushmobj).x;
        let mut sy: int32_t = (*pushmobj).y;
        let mut sz: int32_t = (*pushmobj).z;
        let mut radius: fixed_t = (*(*pushmobj).spawnpoint)
            .args[0 as libc::c_int as usize] << 16 as libc::c_int;
        if (*(*pushmobj).spawnpoint).args[2 as libc::c_int as usize]
            & TMPP_NOZFADE as libc::c_int != 0
        {
            dist = P_AproxDistance((*thing).x - sx, (*thing).y - sy);
        } else {
            if (*thing).z < sz - radius || (*thing).z > sz + radius {
                return false_0 as libc::c_int;
            }
            dist = P_AproxDistance(
                P_AproxDistance((*thing).x - sx, (*thing).y - sy),
                (*thing).z - sz,
            );
        }
        speed = abs((*(*pushmobj).spawnpoint).args[1 as libc::c_int as usize])
            - (dist >> 16 as libc::c_int >> 1 as libc::c_int)
            << 16 as libc::c_int - 7 as libc::c_int - 1 as libc::c_int;
        if speed > 0 as libc::c_int && P_CheckSight(thing, pushmobj) != 0 {
            let mut tmpmomx: fixed_t = 0;
            let mut tmpmomy: fixed_t = 0;
            let mut tmpmomz: fixed_t = 0;
            if (*(*pushmobj).spawnpoint).args[2 as libc::c_int as usize]
                & TMPP_PUSHZ as libc::c_int != 0
            {
                tmpmomx = FixedMul(FixedDiv(sx - (*thing).x, dist), speed);
                tmpmomy = FixedMul(FixedDiv(sy - (*thing).y, dist), speed);
                tmpmomz = FixedMul(FixedDiv(sz - (*thing).z, dist), speed);
            } else {
                let mut pushangle: angle_t = R_PointToAngle2(
                    (*thing).x,
                    (*thing).y,
                    sx,
                    sy,
                ) >> 19 as libc::c_int;
                tmpmomx = FixedMul(
                    speed,
                    *finecosine.offset(pushangle as isize)
                        >> 16 as libc::c_int - 16 as libc::c_int,
                );
                tmpmomy = FixedMul(
                    speed,
                    finesine[pushangle as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                );
                tmpmomz = 0 as libc::c_int;
            }
            if (*(*pushmobj).spawnpoint).args[1 as libc::c_int as usize]
                > 0 as libc::c_int
            {
                tmpmomx *= -(1 as libc::c_int);
                tmpmomy *= -(1 as libc::c_int);
                tmpmomz *= -(1 as libc::c_int);
            }
            (*thing).momx += tmpmomx;
            (*thing).momy += tmpmomy;
            (*thing).momz += tmpmomz;
            if !((*thing).player).is_null() {
                (*(*thing).player).cmomx += tmpmomx;
                (*(*thing).player).cmomy += tmpmomy;
                (*(*thing).player)
                    .cmomx = FixedMul((*(*thing).player).cmomx, 0xe800 as libc::c_int);
                (*(*thing).player)
                    .cmomy = FixedMul((*(*thing).player).cmomy, 0xe800 as libc::c_int);
            }
        }
    }
    if (*(*pushmobj).spawnpoint).args[2 as libc::c_int as usize]
        & TMPP_NONEXCLUSIVE as libc::c_int == 0
    {
        (*thing)
            .eflags = ((*thing).eflags as libc::c_int | MFE_PUSHED as libc::c_int)
            as uint16_t;
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_PointPushThink(mut mobj: *mut mobj_t) {
    let mut xl: int32_t = 0;
    let mut xh: int32_t = 0;
    let mut yl: int32_t = 0;
    let mut yh: int32_t = 0;
    let mut bx: int32_t = 0;
    let mut by: int32_t = 0;
    let mut radius: fixed_t = 0;
    if ((*mobj).spawnpoint).is_null() {
        return;
    }
    radius = (*(*mobj).spawnpoint).args[0 as libc::c_int as usize] << 16 as libc::c_int;
    pushmobj = mobj;
    xl = (((*mobj).x - radius - bmaporgx
        - 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)) as libc::c_uint
        >> 16 as libc::c_int + 7 as libc::c_int) as int32_t;
    xh = (((*mobj).x + radius - bmaporgx
        + 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)) as libc::c_uint
        >> 16 as libc::c_int + 7 as libc::c_int) as int32_t;
    yl = (((*mobj).y - radius - bmaporgy
        - 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)) as libc::c_uint
        >> 16 as libc::c_int + 7 as libc::c_int) as int32_t;
    yh = (((*mobj).y + radius - bmaporgy
        + 32 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)) as libc::c_uint
        >> 16 as libc::c_int + 7 as libc::c_int) as int32_t;
    bx = xl;
    while bx <= xh {
        by = yl;
        while by <= yh {
            P_BlockThingsIterator(
                bx,
                by,
                Some(PIT_PushThing as unsafe extern "C" fn(*mut mobj_t) -> boolean),
            );
            by += 1;
            by;
        }
        bx += 1;
        bx;
    }
}
unsafe extern "C" fn P_MobjRegularThink(mut mobj: *mut mobj_t) -> boolean {
    if (*mobj).flags & MF_ENEMY as libc::c_int as uint32_t != 0
        && ((*(*mobj).state).nextstate as libc::c_uint
            == (*(*mobj).info).spawnstate as libc::c_uint
            && (*mobj).tics == 1 as libc::c_int)
    {
        (*mobj).flags2 &= !(MF2_FRET as libc::c_int) as uint32_t;
    }
    if (*mobj).eflags as libc::c_int & MFE_TRACERANGLE as libc::c_int != 0 {
        P_TracerAngleThink(mobj);
    }
    let mut current_block_275: u64;
    match (*mobj).type_0 as libc::c_uint {
        151 => {
            if ((*mobj).target).is_null() {
                P_RemoveMobj(mobj);
                return false_0 as libc::c_int;
            }
            (*mobj)
                .frame = (*mobj).frame & !(0xff as libc::c_int) as uint32_t
                | (*(*mobj).target).frame & 0xff as libc::c_int as uint32_t;
            current_block_275 = 13095187161273680990;
        }
        626 => {
            if (*mobj).momx == 0 && (*mobj).momy == 0 && (*mobj).momz == 0
                && (if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                    != 0
                {
                    ((*mobj).z + (*mobj).height >= (*mobj).ceilingz) as libc::c_int
                } else {
                    ((*mobj).z <= (*mobj).floorz) as libc::c_int
                }) != 0
            {
                P_RemoveMobj(mobj);
                return false_0 as libc::c_int;
            }
            P_MobjCheckWater(mobj);
            current_block_275 = 13095187161273680990;
        }
        221 => {
            P_ArrowThink(mobj);
            current_block_275 = 13095187161273680990;
        }
        126 => {
            if (*mobj).threshold != 0 {
                (*mobj).threshold -= 1;
                (*mobj).threshold;
                if (*mobj).threshold == 0 && ((*mobj).target).is_null()
                    && (*mobj).reactiontime != 0
                {
                    let mut emerald: *mut mobj_t = P_SpawnMobj(
                        (*mobj).x,
                        (*mobj).y,
                        (*mobj).z,
                        (*mobj).reactiontime as mobjtype_t,
                    );
                    (*emerald).threshold = 42 as libc::c_int;
                    P_SetTarget2(&mut (*mobj).target, emerald);
                    P_SetTarget2(&mut (*emerald).target, mobj);
                }
            }
            current_block_275 = 13095187161273680990;
        }
        601 => {
            (*mobj)
                .eflags = ((*mobj).eflags as libc::c_int | MFE_UNDERWATER as libc::c_int)
                as uint16_t;
            if !((*mobj).tracer).is_null() && !((*(*mobj).tracer).player).is_null()
                && (*(*mobj).tracer).health > 0 as libc::c_int
                && P_AproxDistance(
                    P_AproxDistance(
                        (*(*mobj).tracer).x - (*mobj).x,
                        (*(*mobj).tracer).y - (*mobj).y,
                    ),
                    (*(*mobj).tracer).z - (*mobj).z,
                ) <= (*mobj).radius * 16 as libc::c_int
            {
                var1 = (*(*mobj).info).speed;
                var2 = 1 as libc::c_int;
                A_HomingChase(mobj);
                if (*mobj).z < (*mobj).floorz {
                    (*mobj).z = (*mobj).floorz;
                }
                if leveltime % (*(*mobj).info).painchance as tic_t
                    == 0 as libc::c_int as tic_t
                {
                    S_StartSound(
                        mobj as *const libc::c_void,
                        (*(*mobj).info).activesound,
                    );
                }
                if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                    as statenum_t as libc::c_uint
                    != (*(*mobj).info).seestate as libc::c_uint
                {
                    P_SetMobjState(mobj, (*(*mobj).info).seestate);
                }
            } else {
                P_LookForPlayers(
                    mobj,
                    true_0 as libc::c_int,
                    true_0 as libc::c_int,
                    (*mobj).radius * 16 as libc::c_int,
                );
                (*mobj).momx >>= 1 as libc::c_int;
                (*mobj).momy >>= 1 as libc::c_int;
                (*mobj).momz >>= 1 as libc::c_int;
                if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                    as statenum_t as libc::c_uint
                    != (*(*mobj).info).spawnstate as libc::c_uint
                {
                    P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
                }
            }
            current_block_275 = 13095187161273680990;
        }
        600 => {
            P_BumbleboreThink(mobj);
            current_block_275 = 13095187161273680990;
        }
        153 => {
            (*mobj).extravalue1 += 3 as libc::c_int;
            (*mobj).extravalue1 %= 360 as libc::c_int;
            P_UnsetThingPosition(mobj);
            (*mobj).z
                += finesine[((*mobj).extravalue1
                    * (8192 as libc::c_int - 1 as libc::c_int + 1 as libc::c_int)
                    / 360 as libc::c_int) as usize]
                    >> 16 as libc::c_int - 16 as libc::c_int;
            P_SetThingPosition(mobj);
            current_block_275 = 13095187161273680990;
        }
        269 => {
            if (*mobj).flags2 & MF2_BOSSNOTRAP as libc::c_int as uint32_t != 0 {
                if ((*mobj).target).is_null() || P_MobjWasRemoved((*mobj).target) != 0 {
                    if !((*mobj).tracer).is_null()
                        && P_MobjWasRemoved((*mobj).tracer) == 0
                    {
                        P_RemoveMobj((*mobj).tracer);
                    }
                    P_RemoveMobj(mobj);
                    return false_0 as libc::c_int;
                }
                (*mobj).z = (*(*mobj).target).z + (*(*mobj).target).momz;
                if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0 {
                    (*mobj).z += (*(*mobj).target).height;
                }
            }
            if !((*mobj).tracer).is_null() && P_MobjWasRemoved((*mobj).tracer) == 0 {
                (*(*mobj).tracer)
                    .z = (*mobj).z
                    + P_MobjFlip(mobj) as libc::c_int * 20 as libc::c_int
                        * (*mobj).scale;
                if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
                    (*(*mobj).tracer).z += (*mobj).height;
                }
            }
            current_block_275 = 13095187161273680990;
        }
        301 | 302 => {
            let mut base: fixed_t = (leveltime << 16 as libc::c_int + 1 as libc::c_int)
                as fixed_t;
            let mut seg: *mut mobj_t = (*mobj).tracer;
            let mut prev: *mut mobj_t = mobj;
            (*mobj)
                .movedir = ((*mobj).angle)
                .wrapping_add(
                    (((finesine[(FixedAngle(base << 1 as libc::c_int)
                        >> 19 as libc::c_int
                        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t) as usize]
                        >> 16 as libc::c_int - 16 as libc::c_int)
                        + (finesine[(FixedAngle(base << 4 as libc::c_int)
                            >> 19 as libc::c_int
                            & (8192 as libc::c_int - 1 as libc::c_int) as angle_t)
                            as usize] >> 16 as libc::c_int - 16 as libc::c_int)
                        >> 1 as libc::c_int)
                        + (finesine[(FixedAngle(base * 9 as libc::c_int)
                            >> 19 as libc::c_int
                            & (8192 as libc::c_int - 1 as libc::c_int) as angle_t)
                            as usize] >> 16 as libc::c_int - 16 as libc::c_int)
                        + (*finecosine
                            .offset(
                                (FixedAngle(base * 9 as libc::c_int) >> 19 as libc::c_int
                                    & (8192 as libc::c_int - 1 as libc::c_int) as angle_t)
                                    as isize,
                            ) >> 16 as libc::c_int - 16 as libc::c_int)
                        << 12 as libc::c_int) as angle_t,
                );
            while !seg.is_null() {
                (*seg).movedir = (*seg).angle;
                (*seg).angle = (*prev).movedir;
                P_UnsetThingPosition(seg);
                (*seg)
                    .x = (*prev).x
                    + P_ReturnThrustX(prev, (*prev).angle, (*prev).radius);
                (*seg)
                    .y = (*prev).y
                    + P_ReturnThrustY(prev, (*prev).angle, (*prev).radius);
                (*seg)
                    .z = (*prev).z + (*prev).height - ((*seg).scale >> 1 as libc::c_int);
                P_SetThingPosition(seg);
                prev = seg;
                seg = (*seg).tracer;
            }
            current_block_275 = 13095187161273680990;
        }
        18 => {
            if !((*mobj).target).is_null()
                && ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                    >= S_SPINCUSHION_AIM1 as libc::c_int as libc::c_long
                && ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                    <= S_SPINCUSHION_AIM5 as libc::c_int as libc::c_long
            {
                (*mobj)
                    .angle = R_PointToAngle2(
                    (*mobj).x,
                    (*mobj).y,
                    (*(*mobj).target).x,
                    (*(*mobj).target).y,
                );
            }
            current_block_275 = 13095187161273680990;
        }
        20 => {
            if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                == S_CRUSHCLAW_STAY as libc::c_int as libc::c_long
                && !((*mobj).target).is_null()
            {
                let mut chain: *mut mobj_t = (*(*mobj).target).target;
                let mut sign: int8_t = (if (*mobj).tics & 1 as libc::c_int != 0 {
                    (*mobj).tics
                } else {
                    -((*mobj).tics as int8_t as libc::c_int)
                }) as int8_t;
                while !chain.is_null() {
                    (*chain)
                        .z = (*chain).movefactor + sign as libc::c_int * (*mobj).scale;
                    sign = -(sign as libc::c_int) as int8_t;
                    chain = (*chain).target;
                }
            }
            current_block_275 = 13095187161273680990;
        }
        602 => {
            (*mobj).momy = 0 as libc::c_int;
            (*mobj).momx = (*mobj).momy;
            if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                == S_SMASHSPIKE_FALL as libc::c_int as libc::c_long
                && P_IsObjectOnGround(mobj) != 0
            {
                P_SetMobjState(mobj, S_SMASHSPIKE_STOMP1);
                S_StartSound(mobj as *const libc::c_void, sfx_spsmsh);
            } else if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                == S_SMASHSPIKE_RISE2 as libc::c_int as libc::c_long
                && P_MobjFlip(mobj) as libc::c_int * ((*mobj).z - (*mobj).movecount)
                    >= 0 as libc::c_int
            {
                (*mobj).momz = 0 as libc::c_int;
                P_SetMobjState(mobj, S_SMASHSPIKE_FLOAT);
            }
            current_block_275 = 13095187161273680990;
        }
        609 => {
            if P_HangsterThink(mobj) == 0 {
                return false_0 as libc::c_int;
            }
            current_block_275 = 13095187161273680990;
        }
        529 => {
            (*mobj).momx = FixedMul((*mobj).momx, (*mobj).extravalue2);
            (*mobj).momy = FixedMul((*mobj).momy, (*mobj).extravalue2);
            current_block_275 = 13095187161273680990;
        }
        590 => {
            if (*mobj).reactiontime == 0 {
                let mut shortest: fixed_t = 1024 as libc::c_int
                    * ((1 as libc::c_int) << 16 as libc::c_int);
                let mut i: int32_t = 0;
                P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
                i = 0 as libc::c_int;
                while i < 32 as libc::c_int {
                    if playeringame[i as usize] != 0
                        && !(players[i as usize].mo).is_null()
                        && players[i as usize].mare as libc::c_int == (*mobj).threshold
                        && players[i as usize].spheres as libc::c_int > 0 as libc::c_int
                    {
                        let mut dist: fixed_t = P_AproxDistance(
                            (*players[i as usize].mo).x - (*mobj).x,
                            (*players[i as usize].mo).y - (*mobj).y,
                        );
                        if dist < shortest {
                            P_SetTarget2(&mut (*mobj).target, players[i as usize].mo);
                            shortest = dist;
                        }
                    }
                    i += 1;
                    i;
                }
            }
            current_block_275 = 13095187161273680990;
        }
        67 => {
            if ((*mobj).target).is_null() || (*(*mobj).target).health == 0
                || (*(*mobj).target).state
                    == &mut *states
                        .as_mut_ptr()
                        .offset((*(*(*mobj).target).info).spawnstate as isize)
                        as *mut state_t
                || (*(*mobj).target).state
                    == &mut *states
                        .as_mut_ptr()
                        .offset((*(*(*mobj).target).info).raisestate as isize)
                        as *mut state_t
            {
                P_RemoveMobj(mobj);
                return false_0 as libc::c_int;
            }
            P_MoveOrigin(
                mobj,
                (*(*mobj).target).x,
                (*(*mobj).target).y,
                (*(*mobj).target).z - (*mobj).height,
            );
            current_block_275 = 13095187161273680990;
        }
        560 => {
            if (*mobj).z <= (*mobj).floorz {
                P_RemoveMobj(mobj);
                return false_0 as libc::c_int;
            }
            current_block_275 = 13095187161273680990;
        }
        561 => {
            P_KoopaThinker(mobj);
            current_block_275 = 13095187161273680990;
        }
        555 => {
            if P_AproxDistance((*mobj).momx, (*mobj).momy)
                <= 16 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
            {
                P_KillMobj(
                    mobj,
                    0 as *mut mobj_t,
                    0 as *mut mobj_t,
                    0 as libc::c_int as uint8_t,
                );
                return false_0 as libc::c_int;
            }
            current_block_275 = 13095187161273680990;
        }
        530 => {
            if ((*mobj).z < (*mobj).floorz
                || (*mobj).z + (*mobj).height > (*mobj).ceilingz)
                && (*mobj).flags & MF_MISSILE as libc::c_int as uint32_t != 0
            {
                P_ExplodeMissile(mobj);
                return false_0 as libc::c_int;
            }
            current_block_275 = 13095187161273680990;
        }
        56 => return false_0 as libc::c_int,
        580 => {
            (*mobj)
                .color = linkColor[(*mobj).extravalue2
                as usize][(leveltime.wrapping_add((*mobj).extravalue1 as tic_t)
                % 12 as libc::c_int as tic_t) as usize] as uint16_t;
            current_block_275 = 13095187161273680990;
        }
        62 => {
            if P_JetFume1Think(mobj) == 0 {
                return false_0 as libc::c_int;
            }
            current_block_275 = 13095187161273680990;
        }
        75 => {
            if ((*mobj).target).is_null()
                || (*(*mobj).target).flags & MF_BOSS as libc::c_int as uint32_t == 0
                    && (*(*mobj).target).health <= 0 as libc::c_int
            {
                P_RemoveMobj(mobj);
                return false_0 as libc::c_int;
            }
            P_UnsetThingPosition(mobj);
            (*mobj).x = (*(*mobj).target).x;
            (*mobj).y = (*(*mobj).target).y;
            (*mobj)
                .z = (*(*mobj).target).z - 50 as libc::c_int * (*(*mobj).target).scale;
            (*mobj).floorz = (*mobj).z;
            (*mobj).ceilingz = (*mobj).z + (*mobj).height;
            P_SetThingPosition(mobj);
            current_block_275 = 13095187161273680990;
        }
        76 => {
            if P_EggRobo1Think(mobj) == 0 {
                return false_0 as libc::c_int;
            }
            current_block_275 = 13095187161273680990;
        }
        77 => {
            if ((*mobj).target).is_null() || P_MobjWasRemoved((*mobj).target) != 0
                || (*(*mobj).target).health <= 0 as libc::c_int
            {
                P_RemoveMobj(mobj);
                return false_0 as libc::c_int;
            }
            (*mobj).flags2 ^= MF2_DONTDRAW as libc::c_int as uint32_t;
            P_UnsetThingPosition(mobj);
            (*mobj)
                .x = (*(*mobj).target).x
                + P_ReturnThrustX(
                    mobj,
                    ((*(*mobj).target).angle)
                        .wrapping_add(0x40000000 as libc::c_int as angle_t),
                    (*mobj).movefactor * (*(*mobj).target).scale,
                )
                - P_ReturnThrustX(
                    mobj,
                    (*(*mobj).target).angle,
                    19 as libc::c_int * (*(*mobj).target).scale,
                );
            (*mobj)
                .y = (*(*mobj).target).y
                + P_ReturnThrustY(
                    mobj,
                    ((*(*mobj).target).angle)
                        .wrapping_add(0x40000000 as libc::c_int as angle_t),
                    (*mobj).movefactor * (*(*mobj).target).scale,
                )
                - P_ReturnThrustY(
                    mobj,
                    (*(*mobj).target).angle,
                    19 as libc::c_int * (*(*mobj).target).scale,
                );
            (*mobj).z = (*(*mobj).target).z;
            if (*(*mobj).target).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                != 0
            {
                (*mobj).z += (*(*mobj).target).height - (*mobj).height;
            }
            (*mobj).floorz = (*mobj).z;
            (*mobj).ceilingz = (*mobj).z + (*mobj).height;
            P_SetThingPosition(mobj);
            current_block_275 = 13095187161273680990;
        }
        570 => {
            P_NiGHTSDroneThink(mobj);
            current_block_275 = 13095187161273680990;
        }
        3 => {
            if !((*mobj).player).is_null() {
                P_PlayerMobjThinker(mobj);
            }
            return false_0 as libc::c_int;
        }
        15 => {
            P_MobjCheckWater(mobj);
            if (*mobj).z <= (*mobj).watertop {
                (*mobj).flags |= MF_NOGRAVITY as libc::c_int as uint32_t;
                if (*mobj).z < (*mobj).watertop {
                    if (*mobj).watertop - (*mobj).z
                        <= FixedMul(
                            (*(*mobj).info).speed
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                            (*mobj).scale,
                        )
                    {
                        (*mobj).z = (*mobj).watertop;
                    } else {
                        (*mobj)
                            .momz = FixedMul(
                            (*(*mobj).info).speed
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                            (*mobj).scale,
                        );
                    }
                }
            } else {
                (*mobj).flags &= !(MF_NOGRAVITY as libc::c_int) as uint32_t;
                if (*mobj).z > (*mobj).watertop
                    && (*mobj).z - (*mobj).watertop
                        < FixedMul(
                            24 as libc::c_int
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                            (*mobj).scale,
                        )
                {
                    (*mobj).z = (*mobj).watertop;
                }
            }
            current_block_275 = 13095187161273680990;
        }
        107 | 112 | 113 => {
            P_KillRingsInLava(mobj);
            if P_MobjWasRemoved(mobj) != 0 {
                return false_0 as libc::c_int;
            }
            current_block_275 = 6075675982325936352;
        }
        550 | 109 | 111 | 581 | 583 => {
            current_block_275 = 6075675982325936352;
        }
        108 => {
            P_KillRingsInLava(mobj);
            if P_MobjWasRemoved(mobj) != 0 {
                return false_0 as libc::c_int;
            }
            current_block_275 = 8176634618824715234;
        }
        551 | 110 | 582 => {
            current_block_275 = 8176634618824715234;
        }
        117 => {
            if P_EmblemWasCollected((*mobj).health - 1 as libc::c_int) != 0
                || P_CanPickupEmblem(
                    &mut *players.as_mut_ptr().offset(consoleplayer as isize),
                    (*mobj).health - 1 as libc::c_int,
                ) == 0
            {
                (*mobj).frame
                    |= ((tr_trans50 as libc::c_int) << 16 as libc::c_int) as uint32_t;
            } else {
                (*mobj).frame &= !(0xf0000 as libc::c_int) as uint32_t;
            }
            if (*mobj).flags2 & MF2_NIGHTSPULL as libc::c_int as uint32_t != 0 {
                P_NightsItemChase(mobj);
            }
            current_block_275 = 13095187161273680990;
        }
        557 => {
            if (*mobj).threshold != 0 && (*mobj).threshold != 35 as libc::c_int {
                (*mobj).threshold -= 1;
                (*mobj).threshold;
            }
            if (*mobj).threshold >= 35 as libc::c_int {
                (*mobj)
                    .angle = ((*mobj).angle as libc::c_uint)
                    .wrapping_add(
                        if (*mobj).movedir == 1 as libc::c_int as angle_t {
                            0x10000000 as libc::c_int as libc::c_uint
                        } else {
                            0xf0000000 as libc::c_uint
                        },
                    ) as angle_t as angle_t;
                P_InstaThrust(
                    mobj,
                    R_PointToAngle2(
                        0 as libc::c_int,
                        0 as libc::c_int,
                        (*mobj).momx,
                        (*mobj).momy,
                    ),
                    (*(*mobj).info).speed * (*mobj).scale,
                );
            }
            current_block_275 = 13095187161273680990;
        }
        16 => {
            if P_TurretThink(mobj) == 0 {
                return false_0 as libc::c_int;
            }
            current_block_275 = 13095187161273680990;
        }
        116 | 115 => {
            if !(P_MobjTouchingSectorSpecialFlag(mobj, SSF_RETURNFLAG)).is_null() {
                (*mobj).fuse = 1 as libc::c_int;
            }
            current_block_275 = 13095187161273680990;
        }
        515 => {
            (*mobj)
                .momx = FixedMul(
                (*mobj).momx,
                3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                    / 4 as libc::c_int,
            );
            (*mobj)
                .momy = FixedMul(
                (*mobj).momy,
                3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                    / 4 as libc::c_int,
            );
            if (*mobj).state
                >= &mut *states
                    .as_mut_ptr()
                    .offset(S_SPINDUST_BUBBLE1 as libc::c_int as isize) as *mut state_t
                && (*mobj).state
                    <= &mut *states
                        .as_mut_ptr()
                        .offset(S_SPINDUST_BUBBLE4 as libc::c_int as isize)
                        as *mut state_t
            {
                P_MobjCheckWater(mobj);
                if (*mobj).watertop
                    != (*(*(*mobj).subsector).sector).floorheight
                        - 1000 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                    && (*mobj).z + (*mobj).height
                        >= (*mobj).watertop
                            - 5 as libc::c_int
                                * ((1 as libc::c_int) << 16 as libc::c_int)
                {
                    (*mobj).flags2 |= MF2_DONTDRAW as libc::c_int as uint32_t;
                }
            }
            current_block_275 = 13095187161273680990;
        }
        344 => {
            if leveltime % 5 as libc::c_int as tic_t == 0 as libc::c_int as tic_t {
                let mut traindust: *mut mobj_t = P_SpawnMobj(
                    (*mobj).x,
                    (*mobj).y,
                    (*mobj).z,
                    MT_PARTICLE,
                );
                (*traindust).flags = MF_SCENERY as libc::c_int as uint32_t;
                P_SetMobjState(traindust, S_TRAINDUST);
                (*traindust)
                    .frame = (P_RandomRange(0 as libc::c_int, 8 as libc::c_int)
                    | (tr_trans90 as libc::c_int) << 16 as libc::c_int) as uint32_t;
                (*traindust).angle = (*mobj).angle;
                (*traindust).tics = 35 as libc::c_int * 4 as libc::c_int;
                (*traindust)
                    .destscale = ((1 as libc::c_int) << 16 as libc::c_int)
                    * 64 as libc::c_int;
                (*traindust)
                    .scalespeed = ((1 as libc::c_int) << 16 as libc::c_int)
                    / 24 as libc::c_int;
                P_SetScale(
                    traindust,
                    ((1 as libc::c_int) << 16 as libc::c_int) * 6 as libc::c_int,
                );
            }
            current_block_275 = 13095187161273680990;
        }
        345 => {
            if leveltime % 5 as libc::c_int as tic_t == 0 as libc::c_int as tic_t {
                let mut steam: *mut mobj_t = P_SpawnMobj(
                    (*mobj).x
                        + ((1 as libc::c_int) << 16 as libc::c_int)
                            * (P_RandomByte() as int32_t - 128 as libc::c_int)
                            / 2 as libc::c_int,
                    (*mobj).y
                        + ((1 as libc::c_int) << 16 as libc::c_int)
                            * (P_RandomByte() as int32_t - 128 as libc::c_int)
                            / 2 as libc::c_int,
                    (*mobj).z,
                    MT_PARTICLE,
                );
                P_SetMobjState(steam, S_TRAINSTEAM);
                (*steam)
                    .frame = (P_RandomRange(0 as libc::c_int, 1 as libc::c_int)
                    | (tr_trans90 as libc::c_int) << 16 as libc::c_int) as uint32_t;
                (*steam).tics = 35 as libc::c_int * 8 as libc::c_int;
                (*steam)
                    .destscale = ((1 as libc::c_int) << 16 as libc::c_int)
                    * 64 as libc::c_int;
                (*steam)
                    .scalespeed = ((1 as libc::c_int) << 16 as libc::c_int)
                    / 8 as libc::c_int;
                P_SetScale(
                    steam,
                    ((1 as libc::c_int) << 16 as libc::c_int) * 16 as libc::c_int,
                );
                (*steam)
                    .momx = (P_RandomByte() as int32_t - 128 as libc::c_int)
                    * 32 as libc::c_int;
                (*steam)
                    .momy = -(64 as libc::c_int)
                    * ((1 as libc::c_int) << 16 as libc::c_int);
                (*steam)
                    .momz = 2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            }
            current_block_275 = 13095187161273680990;
        }
        44 => {
            let mut momz: fixed_t = 0;
            if (*mobj).flags2 & MF2_AMBUSH as libc::c_int as uint32_t != 0 {
                (*mobj)
                    .momx = FixedMul(
                    (*mobj).momx,
                    50 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                        / 51 as libc::c_int,
                );
                (*mobj)
                    .momy = FixedMul(
                    (*mobj).momy,
                    50 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                        / 51 as libc::c_int,
                );
            } else {
                if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
                    if (*mobj).z + (*mobj).height + (*mobj).momz <= (*mobj).ceilingz {
                        current_block_275 = 13095187161273680990;
                    } else {
                        current_block_275 = 6497888915984600225;
                    }
                } else if (*mobj).z + (*mobj).momz >= (*mobj).floorz {
                    current_block_275 = 13095187161273680990;
                } else {
                    current_block_275 = 6497888915984600225;
                }
                match current_block_275 {
                    13095187161273680990 => {}
                    _ => {
                        momz = abs((*mobj).momz);
                        if R_PointToDist2(
                            0 as libc::c_int,
                            0 as libc::c_int,
                            (*mobj).momx,
                            (*mobj).momy,
                        ) < momz
                        {
                            P_InstaThrust(
                                mobj,
                                R_PointToAngle2(
                                    0 as libc::c_int,
                                    0 as libc::c_int,
                                    (*mobj).momx,
                                    (*mobj).momy,
                                ),
                                momz,
                            );
                        }
                        (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
                    }
                }
            }
            current_block_275 = 13095187161273680990;
        }
        340 => {
            if ((*mobj).tracer).is_null() {
                P_RemoveMobj(mobj);
                return false_0 as libc::c_int;
            }
            P_SaloonDoorThink(mobj);
            current_block_275 = 13095187161273680990;
        }
        335 => {
            P_HandleMinecartSegments(mobj);
            if (*mobj).fuse == 0 || (*mobj).fuse > 35 as libc::c_int {
                current_block_275 = 13095187161273680990;
            } else {
                if (*mobj).fuse == 2 as libc::c_int {
                    (*mobj).fuse = 0 as libc::c_int;
                } else {
                    (*mobj).flags2 ^= MF2_DONTDRAW as libc::c_int as uint32_t;
                }
                current_block_275 = 13095187161273680990;
            }
        }
        355 => {
            if P_IsObjectOnGround(mobj) != 0 {
                P_RemoveMobj(mobj);
            }
            current_block_275 = 13095187161273680990;
        }
        45 => {
            P_PyreFlyThink(mobj);
            current_block_275 = 13095187161273680990;
        }
        49 => {
            P_PterabyteThink(mobj);
            current_block_275 = 13095187161273680990;
        }
        50 => {
            P_DragonbomberThink(mobj);
            current_block_275 = 13095187161273680990;
        }
        37 => {
            if P_IsObjectOnGround(mobj) != 0 {
                (*mobj).spriteroll = 0 as libc::c_int as angle_t;
            } else {
                (*mobj)
                    .spriteroll = R_PointToAngle2(
                    0 as libc::c_int,
                    0 as libc::c_int,
                    P_MobjFlip(mobj) as libc::c_int * (*mobj).momz,
                    ((*mobj).scale << 1 as libc::c_int)
                        - (if abs((*mobj).momz) < (*mobj).scale << 1 as libc::c_int {
                            abs((*mobj).momz)
                        } else {
                            (*mobj).scale << 1 as libc::c_int
                        }),
                );
            }
            current_block_275 = 13095187161273680990;
        }
        614 => {
            P_PointPushThink(mobj);
            current_block_275 = 13095187161273680990;
        }
        148 => {
            if (*mobj).flags & MF_NOGRAVITY as libc::c_int as uint32_t != 0 {
                if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
                    (*mobj).z = (*mobj).ceilingz - (*mobj).height;
                } else {
                    (*mobj).z = (*mobj).floorz;
                }
            } else if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int
                == 0 && (*mobj).z <= (*mobj).floorz
                || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
                    && (*mobj).z + (*mobj).height >= (*mobj).ceilingz
            {
                (*mobj).flags |= MF_NOGRAVITY as libc::c_int as uint32_t;
                (*mobj).momx = 8 as libc::c_int;
                (*mobj).momz = 0 as libc::c_int;
                (*mobj).momy = (*mobj).momz;
                (*mobj)
                    .z = if (*mobj).eflags as libc::c_int
                    & MFE_VERTICALFLIP as libc::c_int != 0
                {
                    (*mobj).ceilingz - (*mobj).height
                } else {
                    (*mobj).floorz
                };
            }
            current_block_275 = 16110516266283226930;
        }
        _ => {
            current_block_275 = 16110516266283226930;
        }
    }
    match current_block_275 {
        16110516266283226930 => {
            P_MobjCheckWater(mobj);
            if (*mobj).flags & MF_FIRE as libc::c_int as uint32_t != 0
                && (*mobj).eflags as libc::c_int & MFE_TOUCHLAVA as libc::c_int == 0
                && (*mobj).eflags as libc::c_int
                    & (MFE_UNDERWATER as libc::c_int | MFE_TOUCHWATER as libc::c_int)
                    != 0
            {
                P_KillMobj(
                    mobj,
                    0 as *mut mobj_t,
                    0 as *mut mobj_t,
                    0 as libc::c_int as uint8_t,
                );
                return false_0 as libc::c_int;
            }
        }
        6075675982325936352 => {
            P_RingThinker(mobj);
            if (*mobj).flags2 & MF2_NIGHTSPULL as libc::c_int as uint32_t != 0 {
                P_NightsItemChase(mobj);
            } else if (*mobj).type_0 as libc::c_uint
                != MT_BOMBSPHERE as libc::c_int as libc::c_uint
            {
                A_AttractChase(mobj);
            }
            return false_0 as libc::c_int;
        }
        8176634618824715234 => {
            if (*mobj).flags2 & MF2_NIGHTSPULL as libc::c_int as uint32_t != 0 {
                P_NightsItemChase(mobj);
            } else {
                A_AttractChase(mobj);
            }
        }
        _ => {}
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_FiringThink(mut mobj: *mut mobj_t) {
    if ((*mobj).target).is_null() {
        return;
    }
    if (*mobj).health <= 0 as libc::c_int {
        return;
    }
    if (*(*mobj).state).action.acp1
        == ::core::mem::transmute::<
            Option::<unsafe extern "C" fn() -> ()>,
            actionf_p1,
        >(
            Some(
                ::core::mem::transmute::<
                    unsafe extern "C" fn() -> (),
                    unsafe extern "C" fn() -> (),
                >(A_Boss1Laser),
            ),
        )
    {
        if (*(*mobj).state).tics > 1 as libc::c_int {
            var1 = (*(*mobj).state).var1;
            var2 = (*(*mobj).state).var2 & 65535 as libc::c_int;
            ((*(*mobj).state).action.acp1)
                .expect("non-null function pointer")(mobj as *mut libc::c_void);
        }
    } else if leveltime & 1 as libc::c_int as tic_t != 0 {
        let mut missile: *mut mobj_t = 0 as *mut mobj_t;
        if !((*(*mobj).target).player).is_null()
            && (*(*(*mobj).target).player).powers[pw_carry as libc::c_int as usize]
                as libc::c_int == CR_NIGHTSMODE as libc::c_int
        {
            let mut oldval: fixed_t = mobjinfo[(*mobj).extravalue1 as usize].speed;
            (*mobj)
                .angle = R_PointToAngle2(
                (*mobj).x,
                (*mobj).y,
                (*(*mobj).target).x + (*(*mobj).target).momx,
                (*(*mobj).target).y + (*(*mobj).target).momy,
            );
            mobjinfo[(*mobj).extravalue1 as usize]
                .speed = FixedMul(
                60 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*mobj).scale,
            );
            missile = P_SpawnMissile(
                mobj,
                (*mobj).target,
                (*mobj).extravalue1 as mobjtype_t,
            );
            mobjinfo[(*mobj).extravalue1 as usize].speed = oldval;
        } else {
            (*mobj)
                .angle = R_PointToAngle2(
                (*mobj).x,
                (*mobj).y,
                (*(*mobj).target).x,
                (*(*mobj).target).y,
            );
            missile = P_SpawnMissile(
                mobj,
                (*mobj).target,
                (*mobj).extravalue1 as mobjtype_t,
            );
        }
        if !missile.is_null() {
            if (*mobj).flags2 & MF2_SUPERFIRE as libc::c_int as uint32_t != 0 {
                (*missile).flags2 |= MF2_SUPERFIRE as libc::c_int as uint32_t;
            }
            if (*(*mobj).info).attacksound as u64 != 0 {
                S_StartSound(
                    missile as *const libc::c_void,
                    (*(*mobj).info).attacksound,
                );
            }
        }
    } else {
        (*mobj)
            .angle = R_PointToAngle2(
            (*mobj).x,
            (*mobj).y,
            (*(*mobj).target).x,
            (*(*mobj).target).y,
        );
    };
}
unsafe extern "C" fn P_MonitorFuseThink(mut mobj: *mut mobj_t) {
    let mut newmobj: *mut mobj_t = 0 as *mut mobj_t;
    if (*(*mobj).info).speed != 0 as libc::c_int
        && (*mobj).flags2
            & (MF2_AMBUSH as libc::c_int | MF2_STRONGBOX as libc::c_int) as uint32_t != 0
    {
        let mut spawnchance: [mobjtype_t; 64] = [MT_NULL; 64];
        let mut numchoices: int32_t = 0 as libc::c_int;
        let mut i: int32_t = 0 as libc::c_int;
        i = if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
            0 as libc::c_int
        } else {
            10 as libc::c_int
        };
        while i != 0 {
            let fresh8 = numchoices;
            numchoices = numchoices + 1;
            spawnchance[fresh8 as usize] = MT_SNEAKERS_BOX;
            i -= 1;
            i;
        }
        i = if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
            2 as libc::c_int
        } else {
            0 as libc::c_int
        };
        while i != 0 {
            let fresh9 = numchoices;
            numchoices = numchoices + 1;
            spawnchance[fresh9 as usize] = MT_INVULN_BOX;
            i -= 1;
            i;
        }
        i = if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
            3 as libc::c_int
        } else {
            8 as libc::c_int
        };
        while i != 0 {
            let fresh10 = numchoices;
            numchoices = numchoices + 1;
            spawnchance[fresh10 as usize] = MT_WHIRLWIND_BOX;
            i -= 1;
            i;
        }
        i = if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
            3 as libc::c_int
        } else {
            8 as libc::c_int
        };
        while i != 0 {
            let fresh11 = numchoices;
            numchoices = numchoices + 1;
            spawnchance[fresh11 as usize] = MT_ELEMENTAL_BOX;
            i -= 1;
            i;
        }
        i = if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
            2 as libc::c_int
        } else {
            0 as libc::c_int
        };
        while i != 0 {
            let fresh12 = numchoices;
            numchoices = numchoices + 1;
            spawnchance[fresh12 as usize] = MT_ATTRACT_BOX;
            i -= 1;
            i;
        }
        i = if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
            3 as libc::c_int
        } else {
            3 as libc::c_int
        };
        while i != 0 {
            let fresh13 = numchoices;
            numchoices = numchoices + 1;
            spawnchance[fresh13 as usize] = MT_FORCE_BOX;
            i -= 1;
            i;
        }
        i = if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
            2 as libc::c_int
        } else {
            0 as libc::c_int
        };
        while i != 0 {
            let fresh14 = numchoices;
            numchoices = numchoices + 1;
            spawnchance[fresh14 as usize] = MT_ARMAGEDDON_BOX;
            i -= 1;
            i;
        }
        i = if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
            0 as libc::c_int
        } else {
            1 as libc::c_int
        };
        while i != 0 {
            let fresh15 = numchoices;
            numchoices = numchoices + 1;
            spawnchance[fresh15 as usize] = MT_MIXUP_BOX;
            i -= 1;
            i;
        }
        i = if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
            0 as libc::c_int
        } else {
            1 as libc::c_int
        };
        while i != 0 {
            let fresh16 = numchoices;
            numchoices = numchoices + 1;
            spawnchance[fresh16 as usize] = MT_RECYCLER_BOX;
            i -= 1;
            i;
        }
        i = if (*mobj).flags2 & MF2_STRONGBOX as libc::c_int as uint32_t != 0 {
            1 as libc::c_int
        } else {
            1 as libc::c_int
        };
        while i != 0 {
            let fresh17 = numchoices;
            numchoices = numchoices + 1;
            spawnchance[fresh17 as usize] = MT_1UP_BOX;
            i -= 1;
            i;
        }
        i = P_RandomKey(numchoices);
        newmobj = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, spawnchance[i as usize]);
    } else {
        newmobj = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, (*mobj).type_0);
    }
    (*newmobj).flags2 = (*mobj).flags2;
    P_RemoveMobj(mobj);
}
unsafe extern "C" fn P_FlagFuseThink(mut mobj: *mut mobj_t) {
    let mut ss: *mut subsector_t = 0 as *mut subsector_t;
    let mut x: fixed_t = 0;
    let mut y: fixed_t = 0;
    let mut z: fixed_t = 0;
    let mut flagmo: *mut mobj_t = 0 as *mut mobj_t;
    if ((*mobj).spawnpoint).is_null() {
        return;
    }
    x = ((*(*mobj).spawnpoint).x as libc::c_int) << 16 as libc::c_int;
    y = ((*(*mobj).spawnpoint).y as libc::c_int) << 16 as libc::c_int;
    z = ((*(*mobj).spawnpoint).z as libc::c_int) << 16 as libc::c_int;
    ss = R_PointInSubsector(x, y);
    if (*(*mobj).spawnpoint).options as libc::c_int & 2 as libc::c_int != 0 {
        z = (*(*ss).sector).ceilingheight - mobjinfo[(*mobj).type_0 as usize].height - z;
    } else {
        z = (*(*ss).sector).floorheight + z;
    }
    flagmo = P_SpawnMobj(x, y, z, (*mobj).type_0);
    (*flagmo).spawnpoint = (*mobj).spawnpoint;
    if (*(*mobj).spawnpoint).options as libc::c_int & 2 as libc::c_int != 0 {
        (*flagmo)
            .eflags = ((*flagmo).eflags as libc::c_int | MFE_VERTICALFLIP as libc::c_int)
            as uint16_t;
        (*flagmo).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
    }
    if (*mobj).type_0 as libc::c_uint == MT_REDFLAG as libc::c_int as libc::c_uint {
        if (*mobj).flags2 & MF2_JUSTATTACKED as libc::c_int as uint32_t == 0 {
            CONS_Printf(
                b"The \x85Red flag\x80 has returned to base.\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if players[consoleplayer as usize].ctfteam == 1 as libc::c_int
            || splitscreen != 0
        {
            S_StartSound(0 as *const libc::c_void, sfx_hoop1);
        } else if players[consoleplayer as usize].ctfteam == 2 as libc::c_int {
            S_StartSound(0 as *const libc::c_void, sfx_hoop3);
        }
        redflag = flagmo;
    } else {
        if (*mobj).flags2 & MF2_JUSTATTACKED as libc::c_int as uint32_t == 0 {
            CONS_Printf(
                b"The \x84Blue flag\x80 has returned to base.\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if players[consoleplayer as usize].ctfteam == 2 as libc::c_int
            || splitscreen != 0
        {
            S_StartSound(0 as *const libc::c_void, sfx_hoop1);
        } else if players[consoleplayer as usize].ctfteam == 1 as libc::c_int {
            S_StartSound(0 as *const libc::c_void, sfx_hoop3);
        }
        blueflag = flagmo;
    };
}
unsafe extern "C" fn P_FuseThink(mut mobj: *mut mobj_t) -> boolean {
    if (*mobj).type_0 as libc::c_uint == MT_SNAPPER_HEAD as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_SNAPPER_LEG as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_MINECARTSEG as libc::c_int as libc::c_uint
    {
        (*mobj).flags2 ^= MF2_DONTDRAW as libc::c_int as uint32_t;
    }
    (*mobj).fuse -= 1;
    (*mobj).fuse;
    if (*mobj).fuse != 0 {
        return true_0 as libc::c_int;
    }
    if !(LUA_HookMobj(mobj, mobjhook_MobjFuse as libc::c_int) != 0
        || P_MobjWasRemoved(mobj) != 0)
    {
        if (*(*mobj).info).flags & MF_MONITOR as libc::c_int as uint32_t != 0 {
            P_MonitorFuseThink(mobj);
            return false_0 as libc::c_int;
        } else {
            match (*mobj).type_0 as libc::c_uint {
                549 | 99 => {
                    P_SetMobjState(mobj, (*(*mobj).info).deathstate);
                }
                529 => {
                    P_KillMobj(
                        mobj,
                        0 as *mut mobj_t,
                        0 as *mut mobj_t,
                        0 as libc::c_int as uint8_t,
                    );
                }
                116 | 115 => {
                    P_FlagFuseThink(mobj);
                    P_RemoveMobj(mobj);
                    return false_0 as libc::c_int;
                }
                78 => {
                    if (*mobj).flags2 & MF2_SLIDEPUSH as libc::c_int as uint32_t != 0 {
                        var1 = 0 as libc::c_int;
                        var2 = 0 as libc::c_int;
                        A_BossDeath(mobj);
                        return false_0 as libc::c_int;
                    }
                    P_SetMobjState(mobj, (*(*mobj).state).nextstate);
                    if P_MobjWasRemoved(mobj) != 0 {
                        return false_0 as libc::c_int;
                    }
                }
                149 | 150 => {
                    P_SetMobjState(mobj, (*(*mobj).state).nextstate);
                    if P_MobjWasRemoved(mobj) != 0 {
                        return false_0 as libc::c_int;
                    }
                    (*mobj)
                        .fuse = if !((*mobj).spawnpoint).is_null() {
                        (*(*mobj).spawnpoint).args[0 as libc::c_int as usize]
                    } else {
                        (*(*mobj).info).speed
                    };
                }
                580 => {
                    P_RemoveMobj(mobj);
                    return false_0 as libc::c_int;
                }
                353 => {
                    if ((*mobj).state).offset_from(states.as_mut_ptr()) as libc::c_long
                        == S_LAVAFALL_DORMANT as libc::c_int as libc::c_long
                    {
                        (*mobj).fuse = 30 as libc::c_int;
                        P_SetMobjState(mobj, S_LAVAFALL_TELL);
                        S_StartSound(
                            mobj as *const libc::c_void,
                            (*(*mobj).info).seesound,
                        );
                    } else if ((*mobj).state).offset_from(states.as_mut_ptr())
                        as libc::c_long == S_LAVAFALL_TELL as libc::c_int as libc::c_long
                    {
                        (*mobj).fuse = 40 as libc::c_int;
                        P_SetMobjState(mobj, S_LAVAFALL_SHOOT);
                        S_StopSound(mobj as *mut libc::c_void);
                        S_StartSound(
                            mobj as *const libc::c_void,
                            (*(*mobj).info).attacksound,
                        );
                    } else {
                        (*mobj).fuse = 30 as libc::c_int;
                        P_SetMobjState(mobj, S_LAVAFALL_DORMANT);
                        S_StopSound(mobj as *mut libc::c_void);
                    }
                    return false_0 as libc::c_int;
                }
                45 => {
                    if !((*mobj).health <= 0 as libc::c_int) {
                        (*mobj)
                            .extravalue2 = ((*mobj).extravalue2 + 1 as libc::c_int)
                            % 3 as libc::c_int;
                        if (*mobj).extravalue2 == 0 as libc::c_int {
                            P_SetMobjState(mobj, (*(*mobj).info).spawnstate);
                            (*mobj).fuse = 100 as libc::c_int;
                            S_StopSound(mobj as *mut libc::c_void);
                            S_StartSound(mobj as *const libc::c_void, sfx_s3k8c);
                        } else if (*mobj).extravalue2 == 1 as libc::c_int {
                            (*mobj).fuse = 50 as libc::c_int;
                            S_StartSound(mobj as *const libc::c_void, sfx_s3ka3);
                        } else {
                            P_SetMobjState(mobj, (*(*mobj).info).meleestate);
                            (*mobj).fuse = 100 as libc::c_int;
                            S_StopSound(mobj as *mut libc::c_void);
                            S_StartSound(mobj as *const libc::c_void, sfx_s3kc2l);
                        }
                        return false_0 as libc::c_int;
                    }
                }
                104 | 3 => {}
                _ => {
                    P_SetMobjState(mobj, (*(*mobj).info).xdeathstate);
                }
            }
        }
    }
    return (P_MobjWasRemoved(mobj) == 0) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_MobjThinker(mut mobj: *mut mobj_t) {
    if (*mobj).flags & MF_NOTHINK as libc::c_int as uint32_t != 0 {
        return;
    }
    if (*mobj).flags & MF_BOSS as libc::c_int as uint32_t != 0
        && !((*mobj).spawnpoint).is_null()
        && bossdisabled as libc::c_int
            & (1 as libc::c_int) << (*(*mobj).spawnpoint).args[0 as libc::c_int as usize]
            != 0
    {
        return;
    }
    if !((*mobj).target).is_null() && P_MobjWasRemoved((*mobj).target) != 0 {
        P_SetTarget2(&mut (*mobj).target, 0 as *mut mobj_t);
    }
    if !((*mobj).tracer).is_null() && P_MobjWasRemoved((*mobj).tracer) != 0 {
        P_SetTarget2(&mut (*mobj).tracer, 0 as *mut mobj_t);
    }
    if !((*mobj).hnext).is_null() && P_MobjWasRemoved((*mobj).hnext) != 0 {
        P_SetTarget2(&mut (*mobj).hnext, 0 as *mut mobj_t);
    }
    if !((*mobj).hprev).is_null() && P_MobjWasRemoved((*mobj).hprev) != 0 {
        P_SetTarget2(&mut (*mobj).hprev, 0 as *mut mobj_t);
    }
    (*mobj)
        .eflags = ((*mobj).eflags as libc::c_int
        & !(MFE_PUSHED as libc::c_int | MFE_SPRUNG as libc::c_int)) as uint16_t;
    tmhitthing = 0 as *mut mobj_t;
    tmfloorthing = tmhitthing;
    P_CheckMobjTrigger(mobj, false_0 as libc::c_int);
    if (*mobj).scale != (*mobj).destscale {
        P_MobjScaleThink(mobj);
    }
    if ((*mobj).type_0 as libc::c_uint == MT_GHOST as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint == MT_THOK as libc::c_int as libc::c_uint)
        && (*mobj).fuse > 0 as libc::c_int
    {
        if (*mobj).flags2 & MF2_BOSSNOTRAP as libc::c_int as uint32_t != 0 {
            if ((((*mobj).frame & 0xf0000 as libc::c_int as uint32_t)
                >> 16 as libc::c_int) as libc::c_int)
                < NUMTRANSMAPS as libc::c_int - 1 as libc::c_int
                    - 2 as libc::c_int * (*mobj).fuse / 3 as libc::c_int
            {
                (*mobj)
                    .frame = (*mobj).frame & !(0xf0000 as libc::c_int) as uint32_t
                    | ((NUMTRANSMAPS as libc::c_int - 1 as libc::c_int
                        - 2 as libc::c_int * (*mobj).fuse / 3 as libc::c_int)
                        << 16 as libc::c_int) as uint32_t;
            }
        } else if ((((*mobj).frame & 0xf0000 as libc::c_int as uint32_t)
            >> 16 as libc::c_int) as libc::c_int)
            < NUMTRANSMAPS as libc::c_int - 1 as libc::c_int
                - (*mobj).fuse / 2 as libc::c_int
        {
            (*mobj)
                .frame = (*mobj).frame & !(0xf0000 as libc::c_int) as uint32_t
                | ((NUMTRANSMAPS as libc::c_int - 1 as libc::c_int
                    - (*mobj).fuse / 2 as libc::c_int) << 16 as libc::c_int) as uint32_t;
        }
    }
    if (*mobj).flags & MF_SCENERY as libc::c_int as uint32_t != 0 {
        P_MobjSceneryThink(mobj);
        return;
    }
    if ((*mobj).player).is_null() {
        if LUA_HookMobj(mobj, mobjhook_MobjThinker as libc::c_int) != 0
            || P_MobjWasRemoved(mobj) != 0
        {
            return;
        }
    } else if (*(*mobj).player).spectator == 0 {
        LUA_HookMobj(mobj, mobjhook_MobjThinker as libc::c_int);
        if P_MobjWasRemoved(mobj) != 0 {
            return;
        }
    }
    if (*mobj).flags & MF_PUSHABLE as libc::c_int as uint32_t != 0
        || (*(*mobj).info).flags & MF_PUSHABLE as libc::c_int as uint32_t != 0
            && (*mobj).fuse != 0
    {
        if P_MobjPushableThink(mobj) == 0 {
            return;
        }
    } else if (*mobj).flags & MF_BOSS as libc::c_int as uint32_t != 0 {
        if P_MobjBossThink(mobj) == 0 {
            return;
        }
    } else if (*mobj).health <= 0 as libc::c_int {
        if P_MobjDeadThink(mobj) == 0 {
            return;
        }
    } else if P_MobjRegularThink(mobj) == 0 {
        return
    }
    if P_MobjWasRemoved(mobj) != 0 {
        return;
    }
    if (*mobj).flags2 & MF2_FIRING as libc::c_int as uint32_t != 0 {
        P_FiringThink(mobj);
    }
    if (*mobj).flags & MF_AMBIENT as libc::c_int as uint32_t != 0 {
        if leveltime % (*mobj).health as tic_t != 0 {
            return;
        }
        if (*mobj).threshold != 0 {
            S_StartSound(mobj as *const libc::c_void, (*mobj).threshold as sfxenum_t);
        }
        return;
    }
    if (*mobj).fuse != 0 && P_FuseThink(mobj) == 0 {
        return;
    }
    if (*mobj).momx != 0 || (*mobj).momy != 0
        || (*mobj).flags2 & MF2_SKULLFLY as libc::c_int as uint32_t != 0
    {
        P_XYMovement(mobj);
        if P_MobjWasRemoved(mobj) != 0 {
            return;
        }
    }
    if (*mobj).eflags as libc::c_int & MFE_ONGROUND as libc::c_int == 0
        || (*mobj).momz != 0
        || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
            && (*mobj).z + (*mobj).height != (*mobj).ceilingz
        || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
            && (*mobj).z != (*mobj).floorz || P_IsObjectInGoop(mobj) != 0
    {
        if P_ZMovement(mobj) == 0 {
            return;
        }
        P_CheckPosition(mobj, (*mobj).x, (*mobj).y);
        if P_MobjWasRemoved(mobj) != 0 {
            return;
        }
    } else {
        (*mobj).pmomz = 0 as libc::c_int;
        (*mobj)
            .eflags = ((*mobj).eflags as libc::c_int
            & !(MFE_JUSTHITFLOOR as libc::c_int)) as uint16_t;
    }
    if (*mobj).type_0 as libc::c_uint == MT_FLINGRING as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint == MT_FLINGCOIN as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_FLINGBLUESPHERE as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_FLINGNIGHTSCHIP as libc::c_int as libc::c_uint
        || P_WeaponOrPanel((*mobj).type_0) != 0
        || (*mobj).type_0 as libc::c_uint
            == MT_FLINGEMERALD as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_BIGTUMBLEWEED as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_LITTLETUMBLEWEED as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_CANNONBALLDECOR as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_FALLINGROCK as libc::c_int as libc::c_uint
    {
        P_TryMove(mobj, (*mobj).x, (*mobj).y, true_0 as libc::c_int);
        P_ButteredSlope(mobj);
    }
    if (*mobj).flags & (MF_ENEMY as libc::c_int | MF_BOSS as libc::c_int) as uint32_t
        != 0 && (*mobj).health != 0 && P_CheckDeathPitCollide(mobj) != 0
    {
        P_KillMobj(
            mobj,
            0 as *mut mobj_t,
            0 as *mut mobj_t,
            (0x80 as libc::c_int + 3 as libc::c_int) as uint8_t,
        );
        return;
    }
    if (*mobj).ceilingz - (*mobj).floorz < (*mobj).height {
        if ((*mobj).flags
            & (MF_ENEMY as libc::c_int | MF_BOSS as libc::c_int) as uint32_t != 0
            && (*mobj).flags & MF_SHOOTABLE as libc::c_int as uint32_t != 0
            || (*mobj).type_0 as libc::c_uint
                == MT_EGGSHIELD as libc::c_int as libc::c_uint)
            && (*mobj).flags & MF_NOCLIPHEIGHT as libc::c_int as uint32_t == 0
            && (*mobj).health > 0 as libc::c_int
        {
            P_KillMobj(
                mobj,
                0 as *mut mobj_t,
                0 as *mut mobj_t,
                (0x80 as libc::c_int + 4 as libc::c_int) as uint8_t,
            );
            return;
        }
    }
    if !((*mobj).player).is_null() {
        P_CyclePlayerMobjState(mobj);
    } else {
        P_CycleMobjState(mobj);
    }
    if P_MobjWasRemoved(mobj) != 0 {
        return;
    }
    match (*mobj).type_0 as libc::c_uint {
        538 | 539 | 540 | 541 | 542 | 543 => {
            if (*mobj).health == 0 as libc::c_int {
                let mut value: int32_t = (*(*mobj).info).damage / 10 as libc::c_int;
                value = (*mobj).fuse / value;
                value = 10 as libc::c_int - value;
                value -= 1;
                value;
                if value <= 0 as libc::c_int {
                    value = 1 as libc::c_int;
                }
                (*mobj).frame &= !(0xf0000 as libc::c_int) as uint32_t;
                (*mobj).frame |= (value << 16 as libc::c_int) as uint32_t;
            }
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_RailThinker(mut mobj: *mut mobj_t) -> boolean {
    let mut x: fixed_t = 0;
    let mut y: fixed_t = 0;
    let mut z: fixed_t = 0;
    x = (*mobj).x;
    y = (*mobj).y;
    z = (*mobj).z;
    if (*mobj).momx != 0 || (*mobj).momy != 0 {
        P_XYMovement(mobj);
        if P_MobjWasRemoved(mobj) != 0 {
            return true_0 as libc::c_int;
        }
    }
    if (*mobj).momz != 0 {
        if P_ZMovement(mobj) == 0 {
            return true_0 as libc::c_int;
        }
    }
    return (P_MobjWasRemoved(mobj) != 0
        || x == (*mobj).x && y == (*mobj).y && z == (*mobj).z) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_PushableThinker(mut mobj: *mut mobj_t) {
    P_CheckMobjTrigger(mobj, true_0 as libc::c_int);
    if (*mobj).flags & MF_PUSHABLE as libc::c_int as uint32_t != 0
        && !((*mobj).momx != 0 || (*mobj).momy != 0)
    {
        P_TryMove(mobj, (*mobj).x, (*mobj).y, true_0 as libc::c_int);
    }
    if (*mobj).type_0 as libc::c_uint == MT_MINECART as libc::c_int as libc::c_uint
        && (*mobj).health != 0
    {
        if ((*mobj).target).is_null() || P_MobjWasRemoved((*mobj).target) != 0
            || (*(*mobj).target).health == 0 || ((*(*mobj).target).player).is_null()
            || (*(*(*mobj).target).player).powers[pw_carry as libc::c_int as usize]
                as libc::c_int != CR_MINECART as libc::c_int
        {
            P_KillMobj(
                mobj,
                0 as *mut mobj_t,
                0 as *mut mobj_t,
                0 as libc::c_int as uint8_t,
            );
            return;
        }
    }
    if (*mobj).fuse == 1 as libc::c_int {
        let mut spawnmo: *mut mobj_t = 0 as *mut mobj_t;
        let mut x: fixed_t = 0;
        let mut y: fixed_t = 0;
        let mut z: fixed_t = 0;
        let mut ss: *mut subsector_t = 0 as *mut subsector_t;
        match (*mobj).type_0 as libc::c_uint {
            383 | 251 => {
                x = ((*(*mobj).spawnpoint).x as libc::c_int) << 16 as libc::c_int;
                y = ((*(*mobj).spawnpoint).y as libc::c_int) << 16 as libc::c_int;
                ss = R_PointInSubsector(x, y);
                if (*(*mobj).spawnpoint).z as libc::c_int != 0 as libc::c_int {
                    z = ((*(*mobj).spawnpoint).z as libc::c_int) << 16 as libc::c_int;
                } else {
                    z = (*(*ss).sector).floorheight;
                }
                spawnmo = P_SpawnMobj(x, y, z, (*mobj).type_0);
                (*spawnmo).spawnpoint = (*mobj).spawnpoint;
                P_UnsetThingPosition(spawnmo);
                (*spawnmo).flags = (*mobj).flags;
                P_SetThingPosition(spawnmo);
                (*spawnmo).flags2 = (*mobj).flags2;
                (*spawnmo).flags |= MF_PUSHABLE as libc::c_int as uint32_t;
                P_RemoveMobj(mobj);
            }
            _ => {}
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_SceneryThinker(mut mobj: *mut mobj_t) {
    if (*mobj).flags & MF_BOXICON as libc::c_int as uint32_t != 0 {
        if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0 {
            if (*mobj).z
                < (*mobj).floorz + FixedMul((*(*mobj).info).damage, (*mobj).scale)
            {
                (*mobj).momz = FixedMul((*(*mobj).info).speed, (*mobj).scale);
            } else {
                (*mobj).momz = 0 as libc::c_int;
            }
        } else if (*mobj).z + FixedMul((*(*mobj).info).height, (*mobj).scale)
            > (*mobj).ceilingz - FixedMul((*(*mobj).info).damage, (*mobj).scale)
        {
            (*mobj).momz = -FixedMul((*(*mobj).info).speed, (*mobj).scale);
        } else {
            (*mobj).momz = 0 as libc::c_int;
        }
    }
    if (*mobj).momx != 0 || (*mobj).momy != 0 {
        P_SceneryXYMovement(mobj);
        if P_MobjWasRemoved(mobj) != 0 {
            return;
        }
    }
    if (*mobj).eflags as libc::c_int & MFE_ONGROUND as libc::c_int == 0
        || (*mobj).momz != 0
        || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0
            && (*mobj).z + (*mobj).height != (*mobj).ceilingz
        || (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int == 0
            && (*mobj).z != (*mobj).floorz || P_IsObjectInGoop(mobj) != 0
    {
        if P_SceneryZMovement(mobj) == 0 {
            return;
        }
        P_CheckPosition(mobj, (*mobj).x, (*mobj).y);
        if P_MobjWasRemoved(mobj) != 0 {
            return;
        }
        (*mobj).floorz = tmfloorz;
        (*mobj).ceilingz = tmceilingz;
        (*mobj).floorrover = tmfloorrover;
        (*mobj).ceilingrover = tmceilingrover;
    } else {
        (*mobj).pmomz = 0 as libc::c_int;
        (*mobj)
            .eflags = ((*mobj).eflags as libc::c_int
            & !(MFE_JUSTHITFLOOR as libc::c_int)) as uint16_t;
    }
    P_CycleMobjState(mobj);
}
unsafe extern "C" fn P_DefaultMobjShadowScale(mut thing: *mut mobj_t) -> fixed_t {
    match (*thing).type_0 as libc::c_uint {
        3 | 103 | 357 | 74 | 281 | 282 | 283 | 284 | 285 | 286 => {
            return (1 as libc::c_int) << 16 as libc::c_int;
        }
        107 | 108 | 550 | 551 | 109 | 110 | 111 | 112 | 113 | 115 | 116 | 531 | 534 | 533
        | 532 | 535 | 536 | 537 | 538 | 539 | 540 | 541 | 542 | 543 | 530 | 544 | 545
        | 546 | 547 | 548 | 549 | 117 | 114 | 118 | 119 | 120 | 121 | 122 | 123 | 124
        | 125 | 127 => {
            return 2 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                / 3 as libc::c_int;
        }
        469 | 471 | 473 | 475 | 477 | 479 | 481 | 483 | 485 | 487 | 489 | 491 | 493 | 495
        | 497 | 499 | 501 | 503 => return (1 as libc::c_int) << 16 as libc::c_int,
        _ => {
            if (*thing).flags
                & (MF_ENEMY as libc::c_int | MF_BOSS as libc::c_int) as uint32_t != 0
            {
                return (1 as libc::c_int) << 16 as libc::c_int
            } else {
                return 0 as libc::c_int
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnMobj(
    mut x: fixed_t,
    mut y: fixed_t,
    mut z: fixed_t,
    mut type_0: mobjtype_t,
) -> *mut mobj_t {
    let mut info: *const mobjinfo_t = &mut *mobjinfo.as_mut_ptr().offset(type_0 as isize)
        as *mut mobjinfo_t;
    let mut sc: int8_t = -(1 as libc::c_int) as int8_t;
    let mut st: *mut state_t = 0 as *mut state_t;
    let mut mobj: *mut mobj_t = 0 as *mut mobj_t;
    if type_0 as libc::c_uint == MT_NULL as libc::c_int as libc::c_uint {
        CONS_Debug(
            0x80 as libc::c_int,
            b"Tried to spawn MT_NULL, using MT_RAY\n\0" as *const u8
                as *const libc::c_char,
        );
        type_0 = MT_RAY;
    }
    mobj = Z_CallocAlign(
        ::core::mem::size_of::<mobj_t>() as libc::c_ulong,
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut mobj_t;
    (*mobj)
        .thinker
        .function
        .acp1 = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mobj_t) -> ()>,
        actionf_p1,
    >(Some(P_MobjThinker as unsafe extern "C" fn(*mut mobj_t) -> ()));
    (*mobj).type_0 = type_0;
    (*mobj).info = info;
    (*mobj).x = x;
    (*mobj).y = y;
    (*mobj).radius = (*info).radius;
    (*mobj).height = (*info).height;
    (*mobj).flags = (*info).flags;
    (*mobj)
        .health = if (*info).spawnhealth != 0 {
        (*info).spawnhealth
    } else {
        1 as libc::c_int
    };
    (*mobj).reactiontime = (*info).reactiontime;
    (*mobj).dispoffset = (*info).dispoffset;
    (*mobj).lastlook = -(1 as libc::c_int);
    st = &mut *states.as_mut_ptr().offset((*info).spawnstate as isize) as *mut state_t;
    (*mobj).state = st;
    (*mobj).tics = (*st).tics;
    (*mobj).sprite = (*st).sprite;
    (*mobj).frame = (*st).frame;
    P_SetupStateAnimation(mobj, st);
    (*mobj).friction = (0xe8 as libc::c_int) << 16 as libc::c_int - 8 as libc::c_int;
    (*mobj).movefactor = (1 as libc::c_int) << 16 as libc::c_int;
    (*mobj).scale = (1 as libc::c_int) << 16 as libc::c_int;
    (*mobj).destscale = (*mobj).scale;
    (*mobj).scalespeed = ((1 as libc::c_int) << 16 as libc::c_int) / 12 as libc::c_int;
    if maptol & TOL_ERZ3 as libc::c_int as uint32_t != 0
        && !((*mobj).type_0 as libc::c_uint
            == MT_BLACKEGGMAN as libc::c_int as libc::c_uint)
    {
        (*mobj).destscale = ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int;
    }
    (*mobj).blendmode = AST_TRANSLUCENT as libc::c_int;
    (*mobj).spriteyscale = (*mobj).scale;
    (*mobj).spritexscale = (*mobj).spriteyscale;
    (*mobj).spriteyoffset = 0 as libc::c_int;
    (*mobj).spritexoffset = (*mobj).spriteyoffset;
    (*mobj).floorspriteslope = 0 as *mut pslope_s;
    P_SetThingPosition(mobj);
    (*mobj).floorz = P_GetSectorFloorZAt((*(*mobj).subsector).sector, x, y);
    (*mobj).ceilingz = P_GetSectorCeilingZAt((*(*mobj).subsector).sector, x, y);
    (*mobj).floorrover = 0 as *mut ffloor_s;
    (*mobj).ceilingrover = 0 as *mut ffloor_s;
    (*mobj).watertop = 2147483647 as libc::c_int;
    if z == -(2147483647 as libc::c_int) - 1 as libc::c_int {
        (*mobj).z = (*mobj).floorz;
        if (*mobj).type_0 as libc::c_uint == MT_UNIDUS as libc::c_int as libc::c_uint {
            (*mobj).z += FixedMul((*(*mobj).info).mass, (*mobj).scale);
        }
        if (*mobj).z == (*mobj).floorz {
            (*mobj)
                .eflags = ((*mobj).eflags as libc::c_int | MFE_ONGROUND as libc::c_int)
                as uint16_t;
        }
    } else if z == 2147483647 as libc::c_int {
        (*mobj).z = (*mobj).ceilingz - (*mobj).height;
        if (*mobj).type_0 as libc::c_uint == MT_UNIDUS as libc::c_int as libc::c_uint {
            (*mobj).z -= FixedMul((*(*mobj).info).mass, (*mobj).scale);
        }
        if (*mobj).z + (*mobj).height == (*mobj).ceilingz {
            (*mobj)
                .eflags = ((*mobj).eflags as libc::c_int | MFE_ONGROUND as libc::c_int)
                as uint16_t;
        }
    } else {
        (*mobj).z = z;
    }
    (*mobj).shadowscale = P_DefaultMobjShadowScale(mobj);
    if LUA_HookMobj(mobj, mobjhook_MobjSpawn as libc::c_int) != 0 {
        if P_MobjWasRemoved(mobj) != 0 {
            return 0 as *mut mobj_t;
        }
    } else if P_MobjWasRemoved(mobj) != 0 {
        return 0 as *mut mobj_t
    } else {
        let mut current_block_166: u64;
        match (*mobj).type_0 as libc::c_uint {
            611 => {
                if titlemapinaction != 0 {
                    (*mobj).flags &= !(MF_NOTHINK as libc::c_int) as uint32_t;
                }
                current_block_166 = 10265166559088591044;
            }
            523 => {
                (*mobj).destscale = 3 as libc::c_int * (*mobj).scale;
                P_SetScale(mobj, (*mobj).destscale);
                current_block_166 = 10265166559088591044;
            }
            99 => {
                (*mobj).fuse = (*(*mobj).info).painchance;
                current_block_166 = 10265166559088591044;
            }
            88 => {
                let mut spawn: *mut mobj_t = P_SpawnMobj(
                    (*mobj).x,
                    (*mobj).z,
                    (*mobj).z + (*mobj).height
                        - 16 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    MT_BLACKEGGMAN_HELPER,
                );
                (*spawn).destscale = (*mobj).scale;
                P_SetScale(spawn, (*mobj).scale);
                P_SetTarget2(&mut (*spawn).target, mobj);
                current_block_166 = 10265166559088591044;
            }
            71 | 33 => {
                (*mobj).flags2 |= MF2_INVERTAIMABLE as libc::c_int as uint32_t;
                current_block_166 = 10265166559088591044;
            }
            14 => {
                (*mobj).movedir = 0 as libc::c_int as angle_t;
                current_block_166 = 10265166559088591044;
            }
            32 => {
                let mut spawn_0: *mut mobj_t = P_SpawnMobj(x, y, z, MT_EGGSHIELD);
                (*spawn_0).destscale = (*mobj).scale;
                P_SetScale(spawn_0, (*mobj).scale);
                P_SetTarget2(&mut (*mobj).tracer, spawn_0);
                P_SetTarget2(&mut (*spawn_0).target, mobj);
                current_block_166 = 10265166559088591044;
            }
            41 => {
                let mut i: int32_t = 0;
                let mut ball: *mut mobj_t = 0 as *mut mobj_t;
                i = 0 as libc::c_int;
                while i < (*(*mobj).info).damage {
                    ball = P_SpawnMobj(
                        x,
                        y,
                        z,
                        (*(*mobj).info).painchance as mobjtype_t,
                    );
                    (*ball).destscale = (*mobj).scale;
                    P_SetScale(ball, (*mobj).scale);
                    P_SetTarget2(&mut (*ball).target, mobj);
                    (*ball)
                        .movedir = FixedAngle(
                        FixedMul(
                            FixedDiv(
                                i << 16 as libc::c_int,
                                (*(*mobj).info).damage << 16 as libc::c_int,
                            ),
                            (360 as libc::c_int) << 16 as libc::c_int,
                        ),
                    );
                    (*ball)
                        .threshold = (*ball).radius + (*mobj).radius
                        + FixedMul((*(*ball).info).painchance, (*ball).scale);
                    var1 = (*(*ball).state).var1;
                    var2 = (*(*ball).state).var2;
                    ((*(*ball).state).action.acp1)
                        .expect("non-null function pointer")(ball as *mut libc::c_void);
                    i += 1;
                    i;
                }
                current_block_166 = 10265166559088591044;
            }
            27 => {
                let mut q: int32_t = 0;
                let mut ball_0: *mut mobj_t = 0 as *mut mobj_t;
                let mut lastball: *mut mobj_t = mobj;
                q = 0 as libc::c_int;
                while q < (*(*mobj).info).painchance {
                    ball_0 = P_SpawnMobj(x, y, z, (*(*mobj).info).mass as mobjtype_t);
                    (*ball_0).destscale = (*mobj).scale;
                    P_SetScale(ball_0, (*mobj).scale);
                    P_SetTarget2(&mut (*lastball).tracer, ball_0);
                    P_SetTarget2(&mut (*ball_0).target, mobj);
                    lastball = ball_0;
                    q += 1;
                    q;
                }
                current_block_166 = 10265166559088591044;
            }
            19 => {
                let mut bigmeatyclaw: *mut mobj_t = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    MT_CRUSHCLAW,
                );
                (*bigmeatyclaw)
                    .angle = ((*mobj).angle)
                    .wrapping_add(
                        (if (*mobj).flags2 & MF2_AMBUSH as libc::c_int as uint32_t != 0 {
                            0x40000000 as libc::c_int as libc::c_uint
                        } else {
                            0xc0000000 as libc::c_uint
                        }),
                    );
                P_SetTarget2(&mut (*mobj).tracer, bigmeatyclaw);
                P_SetTarget2(&mut (*bigmeatyclaw).tracer, mobj);
                (*mobj).reactiontime >>= 1 as libc::c_int;
                current_block_166 = 10265166559088591044;
            }
            22 => {
                let mut bigmeatyclaw_0: *mut mobj_t = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    MT_BANPSPRING,
                );
                (*bigmeatyclaw_0)
                    .angle = ((*mobj).angle)
                    .wrapping_add(
                        (if (*mobj).flags2 & MF2_AMBUSH as libc::c_int as uint32_t != 0 {
                            0x40000000 as libc::c_int as libc::c_uint
                        } else {
                            0xc0000000 as libc::c_uint
                        }),
                    );
                P_SetTarget2(&mut (*mobj).tracer, bigmeatyclaw_0);
                P_SetTarget2(&mut (*bigmeatyclaw_0).tracer, mobj);
                (*mobj).reactiontime >>= 1 as libc::c_int;
                current_block_166 = 10265166559088591044;
            }
            153 => {
                (*mobj)
                    .extravalue1 = FixedHypot((*mobj).x, (*mobj).y) >> 16 as libc::c_int;
                current_block_166 = 10265166559088591044;
            }
            301 | 302 => {
                let mut prev: *mut mobj_t = mobj;
                let mut cur: *mut mobj_t = 0 as *mut mobj_t;
                let mut i_0: uint8_t = 0;
                i_0 = 0 as libc::c_int as uint8_t;
                while i_0 as libc::c_int <= 16 as libc::c_int {
                    cur = P_SpawnMobjFromMobj(
                        mobj,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        (if (*mobj).type_0 as libc::c_uint
                            == MT_WAVINGFLAG1 as libc::c_int as libc::c_uint
                        {
                            MT_WAVINGFLAGSEG1 as libc::c_int
                        } else {
                            MT_WAVINGFLAGSEG2 as libc::c_int
                        }) as mobjtype_t,
                    );
                    P_SetTarget2(&mut (*prev).tracer, cur);
                    (*cur).extravalue1 = i_0 as int32_t;
                    prev = cur;
                    i_0 = i_0.wrapping_add(1);
                    i_0;
                }
                current_block_166 = 10265166559088591044;
            }
            66 => {
                (*mobj).watertop = (*(*mobj).info).speed;
                current_block_166 = 10265166559088591044;
            }
            70 => {
                (*mobj)
                    .movefactor = -(512 as libc::c_int)
                    * ((1 as libc::c_int) << 16 as libc::c_int);
                (*mobj).flags2 |= MF2_CLASSICPUSH as libc::c_int as uint32_t;
                current_block_166 = 10265166559088591044;
            }
            73 => {
                (*mobj).flags2 |= MF2_INVERTAIMABLE as libc::c_int as uint32_t;
                current_block_166 = 10265166559088591044;
            }
            483 => {
                (*mobj)
                    .color = (if P_RandomFixed()
                    < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
                {
                    SKINCOLOR_RED as libc::c_int
                } else {
                    SKINCOLOR_AQUA as libc::c_int
                }) as uint16_t;
                current_block_166 = 10265166559088591044;
            }
            131 => {
                (*mobj).color = SKINCOLOR_RED as libc::c_int as uint16_t;
                current_block_166 = 10265166559088591044;
            }
            76 => {
                (*mobj).movecount = P_RandomKey(13 as libc::c_int);
                (*mobj)
                    .color = (SKINCOLOR_RUBY as libc::c_int
                    + P_RandomKey(
                        numskincolors as libc::c_int - SKINCOLOR_RUBY as libc::c_int,
                    )) as uint16_t;
                current_block_166 = 10265166559088591044;
            }
            599 => {
                (*mobj).extravalue1 = 5 as libc::c_int;
                current_block_166 = 10265166559088591044;
            }
            602 => {
                (*mobj).movecount = (*mobj).z;
                current_block_166 = 10265166559088591044;
            }
            606 => {
                let mut fire: *mut mobj_t = 0 as *mut mobj_t;
                fire = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    MT_SPINBOBERT_FIRE1,
                );
                P_SetTarget2(&mut (*fire).target, mobj);
                P_SetTarget2(&mut (*mobj).hnext, fire);
                fire = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    MT_SPINBOBERT_FIRE2,
                );
                P_SetTarget2(&mut (*fire).target, mobj);
                P_SetTarget2(&mut (*mobj).hprev, fire);
                current_block_166 = 10265166559088591044;
            }
            530 => {
                (*mobj).color = skincolor_redring;
                current_block_166 = 10265166559088591044;
            }
            511 | 512 | 513 => {
                (*mobj).fuse += 30 as libc::c_int * 35 as libc::c_int;
                current_block_166 = 10265166559088591044;
            }
            570 => {
                nummaprings = -(1 as libc::c_int);
                current_block_166 = 10265166559088591044;
            }
            590 => {
                (*mobj).reactiontime = 0 as libc::c_int;
                (*mobj).extravalue2 = -(1 as libc::c_int);
                (*mobj).lastlook = (*mobj).extravalue2;
                (*mobj).movecount = (*mobj).lastlook;
                (*mobj).cusval = (*mobj).movecount;
                (*mobj).cvmem = (*mobj).cusval;
                (*mobj).extravalue1 = (*mobj).cvmem;
                current_block_166 = 10265166559088591044;
            }
            112 => {
                (*mobj).color = skincolor_redteam;
                current_block_166 = 10265166559088591044;
            }
            113 => {
                (*mobj).color = skincolor_blueteam;
                current_block_166 = 10265166559088591044;
            }
            107 | 550 | 583 => {
                if nummaprings >= 0 as libc::c_int {
                    nummaprings += 1;
                    nummaprings;
                }
                current_block_166 = 10265166559088591044;
            }
            103 => {
                (*mobj)
                    .skin = &mut *skins.as_mut_ptr().offset(5 as libc::c_int as isize)
                    as *mut skin_t as *mut libc::c_void;
                current_block_166 = 7088517283453344531;
            }
            104 => {
                current_block_166 = 7088517283453344531;
            }
            78 => {
                sc = 4 as libc::c_int as int8_t;
                current_block_166 = 10265166559088591044;
            }
            394 => {
                sc = 3 as libc::c_int as int8_t;
                current_block_166 = 10265166559088591044;
            }
            528 => {
                (*mobj).flags2 |= MF2_SUPERFIRE as libc::c_int as uint32_t;
                current_block_166 = 10265166559088591044;
            }
            83 => {
                (*mobj).flags2 |= MF2_EXPLOSION as libc::c_int as uint32_t;
                current_block_166 = 10265166559088591044;
            }
            327 => {
                let mut overlay: *mut mobj_t = P_SpawnMobj(
                    (*mobj).x,
                    (*mobj).y,
                    (*mobj).z,
                    MT_OVERLAY,
                );
                P_SetTarget2(&mut (*overlay).target, mobj);
                P_SetMobjState(overlay, S_OILLAMPFLARE);
                current_block_166 = 10265166559088591044;
            }
            328 => {
                (*mobj).momx = 1 as libc::c_int;
                (*mobj).flags2 |= MF2_INVERTAIMABLE as libc::c_int as uint32_t;
                current_block_166 = 10265166559088591044;
            }
            336 => {
                P_SetTarget2(
                    &mut (*mobj).tracer,
                    P_SpawnMobjFromMobj(
                        mobj,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        MT_MINECARTENDSOLID,
                    ),
                );
                (*(*mobj).tracer)
                    .angle = ((*mobj).angle)
                    .wrapping_add(0x40000000 as libc::c_int as angle_t);
                current_block_166 = 10265166559088591044;
            }
            361 => {
                let mut fire_0: *mut mobj_t = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    46 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    MT_FLAME,
                );
                P_SetTarget2(&mut (*mobj).target, fire_0);
                current_block_166 = 10265166559088591044;
            }
            45 => {
                (*mobj)
                    .extravalue1 = FixedHypot((*mobj).x, (*mobj).y)
                    / ((1 as libc::c_int) << 16 as libc::c_int) % 360 as libc::c_int;
                (*mobj).extravalue2 = 0 as libc::c_int;
                (*mobj).fuse = 100 as libc::c_int;
                current_block_166 = 10265166559088591044;
            }
            146 => {
                P_SetTarget2(
                    &mut (*mobj).tracer,
                    P_SpawnMobjFromMobj(
                        mobj,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        MT_OVERLAY,
                    ),
                );
                P_SetTarget2(&mut (*(*mobj).tracer).target, mobj);
                P_SetMobjState((*mobj).tracer, S_SIGNBOARD);
                (*(*mobj).tracer).movedir = 0x40000000 as libc::c_int as angle_t;
                current_block_166 = 10265166559088591044;
            }
            _ => {
                current_block_166 = 10265166559088591044;
            }
        }
        match current_block_166 {
            7088517283453344531 => {
                (*mobj).color = skins[5 as libc::c_int as usize].prefcolor;
                sc = 5 as libc::c_int as int8_t;
            }
            _ => {}
        }
    }
    if sc as libc::c_int != -(1 as libc::c_int)
        && (*mobj).flags2 & MF2_SLIDEPUSH as libc::c_int as uint32_t == 0
    {
        let mut i_1: uint8_t = 0;
        i_1 = 0 as libc::c_int as uint8_t;
        while (i_1 as libc::c_int) < 32 as libc::c_int {
            if !(playeringame[i_1 as usize] == 0 || players[i_1 as usize].spectator != 0)
            {
                if players[i_1 as usize].skin == sc as libc::c_int {
                    (*mobj).color = SKINCOLOR_SILVER as libc::c_int as uint16_t;
                    (*mobj).colorized = true_0 as libc::c_int;
                    (*mobj).flags2 |= MF2_SLIDEPUSH as libc::c_int as uint32_t;
                    break;
                }
            }
            i_1 = i_1.wrapping_add(1);
            i_1;
        }
    }
    if (*mobj).flags & MF_NOTHINK as libc::c_int as uint32_t == 0 {
        P_AddThinker(THINK_MOBJ, &mut (*mobj).thinker);
    }
    if !((*mobj).skin).is_null() {
        (*mobj)
            .sprite2 = P_GetSkinSprite2(
            (*mobj).skin as *mut skin_t,
            ((*mobj).frame & 0xff as libc::c_int as uint32_t) as uint8_t,
            0 as *mut player_t,
        );
        (*mobj).frame &= !(0xff as libc::c_int) as uint32_t;
    }
    if ((*st).action.acp1).is_some()
        && (*mobj).flags & MF_RUNSPAWNFUNC as libc::c_int as uint32_t != 0
    {
        if levelloading != 0 {
            P_AddCachedAction(mobj, (*(*mobj).info).spawnstate as int32_t);
        } else {
            var1 = (*st).var1;
            var2 = (*st).var2;
            astate = st;
            ((*st).action.acp1)
                .expect("non-null function pointer")(mobj as *mut libc::c_void);
            if P_MobjWasRemoved(mobj) != 0 {
                return 0 as *mut mobj_t;
            }
        }
    }
    if CheckForReverseGravity != 0
        && (*mobj).flags & MF_NOBLOCKMAP as libc::c_int as uint32_t == 0
    {
        P_CheckGravity(mobj, false_0 as libc::c_int);
    }
    R_AddMobjInterpolator(mobj);
    return mobj;
}
unsafe extern "C" fn P_SpawnPrecipMobj(
    mut x: fixed_t,
    mut y: fixed_t,
    mut z: fixed_t,
    mut type_0: mobjtype_t,
) -> *mut precipmobj_t {
    let mut st: *mut state_t = 0 as *mut state_t;
    let mut mobj: *mut precipmobj_t = Z_CallocAlign(
        ::core::mem::size_of::<precipmobj_t>() as libc::c_ulong,
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut precipmobj_t;
    let mut starting_floorz: fixed_t = 0;
    (*mobj).x = x;
    (*mobj).y = y;
    (*mobj).flags = mobjinfo[type_0 as usize].flags as int32_t;
    st = &mut *states
        .as_mut_ptr()
        .offset((*mobjinfo.as_mut_ptr().offset(type_0 as isize)).spawnstate as isize)
        as *mut state_t;
    (*mobj).state = st;
    (*mobj).tics = (*st).tics;
    (*mobj).sprite = (*st).sprite;
    (*mobj).frame = (*st).frame;
    P_SetupStateAnimation(mobj as *mut mobj_t, st);
    P_SetPrecipitationThingPosition(mobj);
    starting_floorz = P_GetSectorFloorZAt((*(*mobj).subsector).sector, x, y);
    (*mobj).floorz = starting_floorz;
    (*mobj).ceilingz = P_GetSectorCeilingZAt((*(*mobj).subsector).sector, x, y);
    (*mobj).floorrover = 0 as *mut ffloor_s;
    (*mobj).ceilingrover = 0 as *mut ffloor_s;
    (*mobj).z = z;
    (*mobj).momz = mobjinfo[type_0 as usize].speed;
    (*mobj)
        .thinker
        .function
        .acp1 = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut precipmobj_t) -> ()>,
        actionf_p1,
    >(Some(P_NullPrecipThinker as unsafe extern "C" fn(*mut precipmobj_t) -> ()));
    P_AddThinker(THINK_PRECIP, &mut (*mobj).thinker);
    CalculatePrecipFloor(mobj);
    if (*mobj).floorz != starting_floorz {
        (*mobj).precipflags |= PCF_FOF as libc::c_int;
    } else if (*(*(*mobj).subsector).sector).damagetype as libc::c_int
        == SD_DEATHPITNOTILT as libc::c_int
        || (*(*(*mobj).subsector).sector).damagetype as libc::c_int
            == SD_DEATHPITTILT as libc::c_int
        || (*(*(*mobj).subsector).sector).floorpic == skyflatnum
    {
        (*mobj).precipflags |= PCF_PIT as libc::c_int;
    }
    R_ResetPrecipitationMobjInterpolationState(mobj);
    return mobj;
}
#[inline]
unsafe extern "C" fn P_SpawnRainMobj(
    mut x: fixed_t,
    mut y: fixed_t,
    mut z: fixed_t,
    mut type_0: mobjtype_t,
) -> *mut precipmobj_t {
    let mut mo: *mut precipmobj_t = P_SpawnPrecipMobj(x, y, z, type_0);
    (*mo).precipflags |= PCF_RAIN as libc::c_int;
    return mo;
}
#[inline]
unsafe extern "C" fn P_SpawnSnowMobj(
    mut x: fixed_t,
    mut y: fixed_t,
    mut z: fixed_t,
    mut type_0: mobjtype_t,
) -> *mut precipmobj_t {
    let mut mo: *mut precipmobj_t = P_SpawnPrecipMobj(x, y, z, type_0);
    return mo;
}
#[no_mangle]
pub unsafe extern "C" fn P_CreateFloorSpriteSlope(
    mut mobj: *mut mobj_t,
) -> *mut libc::c_void {
    if !((*mobj).floorspriteslope).is_null() {
        Z_Free((*mobj).floorspriteslope as *mut libc::c_void);
    }
    (*mobj)
        .floorspriteslope = Z_CallocAlign(
        ::core::mem::size_of::<pslope_t>() as libc::c_ulong,
        PU_LEVEL as libc::c_int,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
    ) as *mut pslope_s;
    (*(*mobj).floorspriteslope).normal.z = (1 as libc::c_int) << 16 as libc::c_int;
    return (*mobj).floorspriteslope as *mut libc::c_void;
}
#[no_mangle]
pub unsafe extern "C" fn P_RemoveFloorSpriteSlope(mut mobj: *mut mobj_t) {
    if !((*mobj).floorspriteslope).is_null() {
        Z_Free((*mobj).floorspriteslope as *mut libc::c_void);
    }
    (*mobj).floorspriteslope = 0 as *mut pslope_s;
}
#[no_mangle]
pub static mut itemrespawnque: [*mut mapthing_t; 1024] = [0 as *const mapthing_t
    as *mut mapthing_t; 1024];
#[no_mangle]
pub static mut itemrespawntime: [tic_t; 1024] = [0; 1024];
#[no_mangle]
pub static mut iquehead: size_t = 0;
#[no_mangle]
pub static mut iquetail: size_t = 0;
#[no_mangle]
pub unsafe extern "C" fn P_RemoveMobj(mut mobj: *mut mobj_t) {
    if P_MobjWasRemoved(mobj) != 0 {
        return;
    }
    (*mobj)
        .thinker
        .function
        .acp1 = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut thinker_t) -> ()>,
        actionf_p1,
    >(Some(P_RemoveThinkerDelayed as unsafe extern "C" fn(*mut thinker_t) -> ()));
    LUA_HookMobj(mobj, mobjhook_MobjRemoved as libc::c_int);
    (*mobj)
        .thinker
        .function
        .acp1 = ::core::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut mobj_t) -> ()>,
        actionf_p1,
    >(Some(P_MobjThinker as unsafe extern "C" fn(*mut mobj_t) -> ()));
    if !((*mobj).spawnpoint).is_null()
        && ((*mobj).type_0 as libc::c_uint == MT_RING as libc::c_int as libc::c_uint
            || (*mobj).type_0 as libc::c_uint == MT_COIN as libc::c_int as libc::c_uint
            || (*mobj).type_0 as libc::c_uint
                == MT_NIGHTSSTAR as libc::c_int as libc::c_uint
            || (*mobj).type_0 as libc::c_uint
                == MT_REDTEAMRING as libc::c_int as libc::c_uint
            || (*mobj).type_0 as libc::c_uint
                == MT_BLUETEAMRING as libc::c_int as libc::c_uint
            || P_WeaponOrPanel((*mobj).type_0) != 0)
        && (*mobj).flags2 & MF2_DONTRESPAWN as libc::c_int as uint32_t == 0
    {
        itemrespawnque[iquehead as usize] = (*mobj).spawnpoint;
        itemrespawntime[iquehead as usize] = leveltime;
        iquehead = iquehead.wrapping_add(1 as libc::c_int as size_t)
            & (1024 as libc::c_int - 1 as libc::c_int) as size_t;
        if iquehead == iquetail {
            iquetail = iquetail.wrapping_add(1 as libc::c_int as size_t)
                & (1024 as libc::c_int - 1 as libc::c_int) as size_t;
        }
    }
    if (*mobj).type_0 as libc::c_uint == MT_OVERLAY as libc::c_int as libc::c_uint {
        P_RemoveOverlay(mobj);
    }
    if !((*mobj).player).is_null() && !((*(*mobj).player).followmobj).is_null() {
        P_RemoveMobj((*(*mobj).player).followmobj);
        P_SetTarget2(&mut (*(*mobj).player).followmobj, 0 as *mut mobj_t);
    }
    (*mobj).health = 0 as libc::c_int;
    P_UnsetThingPosition(mobj);
    if !sector_list.is_null() {
        P_DelSeclist(sector_list);
        sector_list = 0 as *mut msecnode_t;
    }
    (*mobj).flags
        |= (MF_NOSECTOR as libc::c_int | MF_NOBLOCKMAP as libc::c_int) as uint32_t;
    (*mobj).subsector = 0 as *mut subsector_s;
    (*mobj).state = 0 as *mut state_t;
    (*mobj).player = 0 as *mut player_s;
    P_RemoveFloorSpriteSlope(mobj);
    S_StopSound(mobj as *mut libc::c_void);
    P_SetTarget2(
        &mut (*mobj).target,
        P_SetTarget2(&mut (*mobj).tracer, 0 as *mut mobj_t),
    );
    if !((*mobj).hnext).is_null() && P_MobjWasRemoved((*mobj).hnext) == 0 {
        P_SetTarget2(&mut (*(*mobj).hnext).hprev, (*mobj).hprev);
    }
    if !((*mobj).hprev).is_null() && P_MobjWasRemoved((*mobj).hprev) == 0 {
        P_SetTarget2(&mut (*(*mobj).hprev).hnext, (*mobj).hnext);
    }
    P_SetTarget2(&mut (*mobj).hnext, P_SetTarget2(&mut (*mobj).hprev, 0 as *mut mobj_t));
    R_RemoveMobjInterpolator(mobj);
    if ((*mobj).thinker.next).is_null() {
        let mut prevreferences: int32_t = 0;
        if (*mobj).thinker.references == 0 {
            Z_Free(mobj as *mut libc::c_void);
            return;
        }
        prevreferences = (*mobj).thinker.references;
        P_AddThinker(THINK_MOBJ, mobj as *mut thinker_t);
        (*mobj).thinker.references = prevreferences;
    }
    P_RemoveThinker(mobj as *mut thinker_t);
}
#[no_mangle]
pub unsafe extern "C" fn P_MobjWasRemoved(mut mobj: *mut mobj_t) -> boolean {
    if !mobj.is_null()
        && (*mobj).thinker.function.acp1
            == ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut mobj_t) -> ()>,
                actionf_p1,
            >(Some(P_MobjThinker as unsafe extern "C" fn(*mut mobj_t) -> ()))
    {
        return false_0 as libc::c_int;
    }
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_RemovePrecipMobj(mut mobj: *mut precipmobj_t) {
    P_UnsetPrecipThingPosition(mobj);
    if !precipsector_list.is_null() {
        P_DelPrecipSeclist(precipsector_list);
        precipsector_list = 0 as *mut mprecipsecnode_t;
    }
    P_RemoveThinker(mobj as *mut thinker_t);
}
#[no_mangle]
pub unsafe extern "C" fn P_RemoveSavegameMobj(mut mobj: *mut mobj_t) {
    if (*(mobj as *mut thinker_t)).function.acp1
        == ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut precipmobj_t) -> ()>,
            actionf_p1,
        >(Some(P_NullPrecipThinker as unsafe extern "C" fn(*mut precipmobj_t) -> ()))
    {
        P_UnsetPrecipThingPosition(mobj as *mut precipmobj_t);
        if !precipsector_list.is_null() {
            P_DelPrecipSeclist(precipsector_list);
            precipsector_list = 0 as *mut mprecipsecnode_t;
        }
    } else {
        P_UnsetThingPosition(mobj);
        if !sector_list.is_null() {
            P_DelSeclist(sector_list);
            sector_list = 0 as *mut msecnode_t;
        }
    }
    S_StopSound(mobj as *mut libc::c_void);
    R_RemoveMobjInterpolator(mobj);
    let mut thinker: *mut thinker_t = mobj as *mut thinker_t;
    let mut next: *mut thinker_t = (*thinker).next;
    (*next).prev = (*thinker).prev;
    (*(*next).prev).next = next;
    Z_Free(thinker as *mut libc::c_void);
}
static mut respawnitemtime_cons_t: [CV_PossibleValue_t; 3] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 1 as libc::c_int,
            strvalue: b"MIN\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 300 as libc::c_int,
            strvalue: b"MAX\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut cv_itemrespawntime: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"respawnitemtime\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"30\0" as *const u8 as *const libc::c_char,
            flags: CV_SAVE as libc::c_int | CV_NETVAR as libc::c_int
                | CV_CHEAT as libc::c_int | CV_ALLOWLUA as libc::c_int,
            PossibleValue: respawnitemtime_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_2 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_3 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub static mut cv_itemrespawn: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"respawnitem\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"On\0" as *const u8 as *const libc::c_char,
            flags: CV_SAVE as libc::c_int | CV_NETVAR as libc::c_int
                | CV_ALLOWLUA as libc::c_int,
            PossibleValue: CV_OnOff.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_2 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_3 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
static mut flagtime_cons_t: [CV_PossibleValue_t; 3] = [
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: b"MIN\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 300 as libc::c_int,
            strvalue: b"MAX\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = CV_PossibleValue_s {
            value: 0 as libc::c_int,
            strvalue: 0 as *const libc::c_char,
        };
        init
    },
];
#[no_mangle]
pub static mut cv_flagtime: consvar_t = unsafe {
    {
        let mut init = consvar_s {
            name: b"flagtime\0" as *const u8 as *const libc::c_char,
            defaultvalue: b"30\0" as *const u8 as *const libc::c_char,
            flags: CV_SAVE as libc::c_int | CV_NETVAR as libc::c_int
                | CV_CHEAT as libc::c_int | CV_ALLOWLUA as libc::c_int,
            PossibleValue: flagtime_cons_t.as_ptr() as *mut _,
            func: None,
            value: 0 as libc::c_int,
            string: 0 as *const libc::c_char,
            zstring: 0 as *const libc::c_char as *mut libc::c_char,
            revert: {
                let mut init = C2RustUnnamed_2 {
                    allocated: 0 as libc::c_int as libc::c_char,
                    v: C2RustUnnamed_3 {
                        string: 0 as *const libc::c_char as *mut libc::c_char,
                    },
                };
                init
            },
            netid: 0 as libc::c_uint as uint16_t,
            changed: 0 as libc::c_int as libc::c_char,
            next: 0 as *const consvar_s as *mut consvar_s,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn P_SpawnPrecipitation() {
    let mut i: int32_t = 0;
    let mut mrand: int32_t = 0;
    let mut basex: fixed_t = 0;
    let mut basey: fixed_t = 0;
    let mut x: fixed_t = 0;
    let mut y: fixed_t = 0;
    let mut height: fixed_t = 0;
    let mut precipsector: *mut subsector_t = 0 as *mut subsector_t;
    let mut rainmo: *mut precipmobj_t = 0 as *mut precipmobj_t;
    if dedicated != 0 || cv_drawdist_precip.value == 0 || curWeather == 0 as libc::c_int
        || curWeather == 5 as libc::c_int
    {
        return;
    }
    let mut current_block_18: u64;
    i = 0 as libc::c_int;
    while i < bmapwidth * bmapheight {
        basex = bmaporgx
            + i % bmapwidth
                * (128 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int));
        basey = bmaporgy
            + i / bmapwidth
                * (128 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int));
        x = basex
            + (M_RandomKey((128 as libc::c_int) << 3 as libc::c_int) << 16 as libc::c_int
                >> 3 as libc::c_int);
        y = basey
            + (M_RandomKey((128 as libc::c_int) << 3 as libc::c_int) << 16 as libc::c_int
                >> 3 as libc::c_int);
        precipsector = R_PointInSubsectorOrNull(x, y);
        if !precipsector.is_null() {
            if (*(*precipsector).sector).floorheight
                <= (*(*precipsector).sector).ceilingheight
                    - ((32 as libc::c_int) << 16 as libc::c_int)
            {
                height = (*(*precipsector).sector).ceilingheight;
                if curWeather == 2 as libc::c_int {
                    if (maptol & TOL_NIGHTS as libc::c_int as uint32_t == 0
                        && (*(*precipsector).sector).ceilingpic != skyflatnum)
                        as libc::c_int
                        == ((*(*precipsector).sector).flags as libc::c_uint
                            & MSF_INVERTPRECIP as libc::c_int as libc::c_uint == 0)
                            as libc::c_int
                    {
                        current_block_18 = 10680521327981672866;
                    } else {
                        rainmo = P_SpawnSnowMobj(x, y, height, MT_SNOWFLAKE);
                        mrand = M_RandomByte() as int32_t;
                        if mrand < 64 as libc::c_int {
                            P_SetPrecipMobjState(rainmo, S_SNOW3);
                        } else if mrand < 144 as libc::c_int {
                            P_SetPrecipMobjState(rainmo, S_SNOW2);
                        }
                        current_block_18 = 5601891728916014340;
                    }
                } else if ((*(*precipsector).sector).ceilingpic != skyflatnum)
                    as libc::c_int
                    == ((*(*precipsector).sector).flags as libc::c_uint
                        & MSF_INVERTPRECIP as libc::c_int as libc::c_uint == 0)
                        as libc::c_int
                {
                    current_block_18 = 10680521327981672866;
                } else {
                    rainmo = P_SpawnRainMobj(x, y, height, MT_RAIN);
                    if curWeather == 4 as libc::c_int {
                        (*rainmo).precipflags |= PCF_INVISIBLE as libc::c_int;
                    }
                    current_block_18 = 5601891728916014340;
                }
                match current_block_18 {
                    10680521327981672866 => {}
                    _ => {
                        (*rainmo)
                            .z = M_RandomRange(
                            (*rainmo).floorz >> 16 as libc::c_int,
                            (*rainmo).ceilingz >> 16 as libc::c_int,
                        ) << 16 as libc::c_int;
                    }
                }
            }
        }
        i += 1;
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_PrecipitationEffects() {
    let mut thunderchance: int16_t = 32767 as libc::c_int as int16_t;
    let mut volume: int32_t = 0;
    let mut i: size_t = 0;
    let mut sounds_rain: boolean = true_0 as libc::c_int;
    let mut sounds_thunder: boolean = true_0 as libc::c_int;
    let mut effects_lightning: boolean = true_0 as libc::c_int;
    let mut lightningStrike: boolean = false_0 as libc::c_int;
    if !(leveltime & 1 as libc::c_int as tic_t != 0) {
        if globalweather as libc::c_int == 1 as libc::c_int
            || globalweather as libc::c_int == 5 as libc::c_int
        {
            thunderchance = P_RandomKey(8192 as libc::c_int) as int16_t;
        } else {
            thunderchance = M_RandomKey(8192 as libc::c_int) as int16_t;
        }
    }
    if (thunderchance as libc::c_int) < 70 as libc::c_int {
        lightningStrike = true_0 as libc::c_int;
    }
    let mut current_block_10: u64;
    match curWeather {
        3 => {
            sounds_thunder = false_0 as libc::c_int;
            current_block_10 = 13285685433705150545;
        }
        6 => {
            current_block_10 = 13285685433705150545;
        }
        5 => {
            sounds_rain = false_0 as libc::c_int;
            current_block_10 = 3512920355445576850;
        }
        1 => {
            current_block_10 = 3512920355445576850;
        }
        _ => return,
    }
    match current_block_10 {
        13285685433705150545 => {
            effects_lightning = false_0 as libc::c_int;
        }
        _ => {}
    }
    if effects_lightning != 0 && lightningStrike != 0 {
        let mut ss: *mut sector_t = sectors;
        i = 0 as libc::c_int as size_t;
        while i < numsectors {
            if (*ss).ceilingpic == skyflatnum {
                P_SpawnLightningFlash(ss);
            }
            i = i.wrapping_add(1);
            i;
            ss = ss.offset(1);
            ss;
        }
    }
    if playeringame[displayplayer as usize] == 0
        || (players[displayplayer as usize].mo).is_null()
    {
        return;
    }
    if sound_disabled != 0 {
        return;
    }
    if (*(*(*players[displayplayer as usize].mo).subsector).sector).ceilingpic
        == skyflatnum
    {
        volume = 255 as libc::c_int;
    } else {
        let mut x: fixed_t = 0;
        let mut y: fixed_t = 0;
        let mut yl: fixed_t = 0;
        let mut yh: fixed_t = 0;
        let mut xl: fixed_t = 0;
        let mut xh: fixed_t = 0;
        let mut closedist: fixed_t = 0;
        let mut newdist: fixed_t = 0;
        yl = (*players[displayplayer as usize].mo).y
            - 1024 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
        yh = (*players[displayplayer as usize].mo).y
            + 1024 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
        xl = (*players[displayplayer as usize].mo).x
            - 1024 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
        xh = (*players[displayplayer as usize].mo).x
            + 1024 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
        closedist = 2048 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
        y = yl;
        while y <= yh {
            x = xl;
            while x <= xh {
                if (*(*R_PointInSubsector(x, y)).sector).ceilingpic == skyflatnum {
                    newdist = S_CalculateSoundDistance(
                        (*players[displayplayer as usize].mo).x,
                        (*players[displayplayer as usize].mo).y,
                        0 as libc::c_int,
                        x,
                        y,
                        0 as libc::c_int,
                    );
                    if newdist < closedist {
                        closedist = newdist;
                    }
                }
                x += ((1 as libc::c_int) << 16 as libc::c_int) * 64 as libc::c_int;
            }
            y += ((1 as libc::c_int) << 16 as libc::c_int) * 64 as libc::c_int;
        }
        volume = 255 as libc::c_int
            - (closedist >> 16 as libc::c_int + 2 as libc::c_int);
    }
    if volume < 0 as libc::c_int {
        volume = 0 as libc::c_int;
    } else if volume > 255 as libc::c_int {
        volume = 255 as libc::c_int;
    }
    if sounds_rain != 0
        && (leveltime == 0
            || leveltime % 80 as libc::c_int as tic_t == 1 as libc::c_int as tic_t)
    {
        S_StartSoundAtVolume(
            players[displayplayer as usize].mo as *const libc::c_void,
            sfx_rainin,
            volume,
        );
    }
    if sounds_thunder == 0 {
        return;
    }
    if effects_lightning != 0 && lightningStrike != 0 && volume != 0 {
        S_StartSoundAtVolume(
            players[displayplayer as usize].mo as *const libc::c_void,
            (sfx_litng1 as libc::c_int + M_RandomKey(4 as libc::c_int)) as sfxenum_t,
            volume,
        );
    } else if (thunderchance as libc::c_int) < 20 as libc::c_int {
        if volume < 80 as libc::c_int {
            volume = 80 as libc::c_int;
        }
        S_StartSoundAtVolume(
            players[displayplayer as usize].mo as *const libc::c_void,
            (sfx_athun1 as libc::c_int + M_RandomKey(2 as libc::c_int)) as sfxenum_t,
            volume,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_GetMobjtype(mut mthingtype: uint16_t) -> mobjtype_t {
    let mut i: mobjtype_t = MT_NULL;
    i = MT_NULL;
    while (i as libc::c_uint) < NUMMOBJTYPES as libc::c_int as libc::c_uint {
        if mthingtype as libc::c_int == mobjinfo[i as usize].doomednum {
            return i;
        }
        i += 1;
        i;
    }
    return MT_UNKNOWN;
}
#[no_mangle]
pub unsafe extern "C" fn P_RespawnSpecials() {
    let mut mthing: *mut mapthing_t = 0 as *mut mapthing_t;
    if !(netgame != 0 || multiplayer != 0)
        || maptol & TOL_NIGHTS as libc::c_int as uint32_t != 0
        || cv_itemrespawn.value == 0
    {
        return;
    }
    if G_IsSpecialStage(gamemap as int32_t) != 0 {
        return;
    }
    if iquehead == iquetail {
        return;
    }
    if leveltime.wrapping_sub(itemrespawntime[iquetail as usize])
        < cv_itemrespawntime.value as tic_t * 35 as libc::c_int as tic_t
    {
        return;
    }
    mthing = itemrespawnque[iquetail as usize];
    if !mthing.is_null() {
        P_SpawnMapThing(mthing);
    }
    iquetail = iquetail.wrapping_add(1 as libc::c_int as size_t)
        & (1024 as libc::c_int - 1 as libc::c_int) as size_t;
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnPlayer(mut playernum: int32_t) {
    let mut p: *mut player_t = &mut *players.as_mut_ptr().offset(playernum as isize)
        as *mut player_t;
    let mut mobj: *mut mobj_t = 0 as *mut mobj_t;
    if (*p).playerstate as libc::c_uint == PST_REBORN as libc::c_int as libc::c_uint {
        G_PlayerReborn(playernum, false_0 as libc::c_int);
    }
    if G_GametypeHasSpectators() == 0 {
        (*p)
            .outofcoop = ((multiplayer != 0 || netgame != 0) && G_CoopGametype() != 0
            && (leveltime > 0 as libc::c_int as tic_t
                && (G_IsSpecialStage(gamemap as int32_t) != 0
                    || cv_coopstarposts.value == 2 as libc::c_int
                        && ((*p).jointime < 1 as libc::c_int as tic_t
                            || (*p).outofcoop != 0))
                || P_GetLives(p) == 0 && (*p).lives as libc::c_int <= 0 as libc::c_int))
            as libc::c_int;
        (*p).spectator = (*p).outofcoop;
    } else {
        (*p).outofcoop = false_0 as libc::c_int;
        if netgame != 0 && (*p).jointime < 1 as libc::c_int as tic_t {
            (*p)
                .spectator = if gametyperules
                & GTR_NOSPECTATORSPAWN as libc::c_int as uint32_t != 0
            {
                false_0 as libc::c_int
            } else {
                true_0 as libc::c_int
            };
        } else if multiplayer != 0 && netgame == 0 {
            if G_GametypeHasTeams() != 0 && (*p).ctfteam == 0 as libc::c_int {
                let mut NetPacket: changeteam_union = changeteam_union {
                    packet: changeteam_packet_t {
                        playernum_newteam_verification_autobalance_scrambled: [0; 2],
                    },
                };
                let mut usvalue: uint16_t = 0;
                NetPacket.value.b = 0 as libc::c_int as uint16_t;
                NetPacket.value.l = NetPacket.value.b;
                (*p).spectator = true_0 as libc::c_int;
                if playernum & 1 as libc::c_int != 0 {
                    (*p).skincolor = skincolor_redteam;
                } else {
                    (*p).skincolor = skincolor_blueteam;
                }
                (NetPacket.packet).set_playernum(playernum as uint32_t);
                (NetPacket.packet).set_verification(true_0 as libc::c_int as uint32_t);
                (NetPacket.packet)
                    .set_newteam(
                        ((playernum & 1 as libc::c_int == 0) as libc::c_int
                            + 1 as libc::c_int) as uint32_t,
                    );
                usvalue = (NetPacket.value.l as libc::c_int
                    | NetPacket.value.b as libc::c_int) as int16_t as uint16_t;
                SendNetXCmd(
                    XD_TEAMCHANGE,
                    &mut usvalue as *mut uint16_t as *const libc::c_void,
                    ::core::mem::size_of::<uint16_t>() as libc::c_ulong,
                );
            } else {
                (*p).spectator = false_0 as libc::c_int;
            }
        }
    }
    if G_GametypeHasTeams() != 0 {
        if (*p).spectator == 0 && (*p).ctfteam == 0 {
            (*p).spectator = true_0 as libc::c_int;
        }
        if (*p).ctfteam == 1 as libc::c_int {
            (*p).skincolor = skincolor_redteam;
        } else if (*p).ctfteam == 2 as libc::c_int {
            (*p).skincolor = skincolor_blueteam;
        }
    }
    if (netgame != 0 || multiplayer != 0)
        && (gametyperules & GTR_SPAWNINVUL as libc::c_int as uint32_t != 0
            || leveltime != 0) && (*p).spectator == 0
        && maptol & TOL_NIGHTS as libc::c_int as uint32_t == 0
    {
        (*p)
            .powers[pw_flashing as libc::c_int
            as usize] = (flashingtics as libc::c_int - 1 as libc::c_int) as uint16_t;
    }
    mobj = P_SpawnMobj(0 as libc::c_int, 0 as libc::c_int, 0 as libc::c_int, MT_PLAYER);
    (*mobj).player = p;
    (*(*mobj).player).mo = mobj;
    (*mobj).angle = 0 as libc::c_int as angle_t;
    (*mobj).color = (*p).skincolor;
    (*mobj)
        .skin = &mut *skins.as_mut_ptr().offset((*p).skin as isize) as *mut skin_t
        as *mut libc::c_void;
    P_SetupStateAnimation(mobj, (*mobj).state);
    (*mobj).health = 1 as libc::c_int;
    (*p).playerstate = PST_LIVE;
    (*p).bonustime = false_0 as libc::c_int;
    (*p).realtime = leveltime;
    (*p).followitem = skins[(*p).skin as usize].followitem as mobjtype_t;
    if (*p).dashmode != 0 {
        (*p).dashmode = 0 as libc::c_int as tic_t;
        (*p).normalspeed = skins[(*p).skin as usize].normalspeed;
        (*p).jumpfactor = skins[(*p).skin as usize].jumpfactor;
    }
    (*p).lastsidehit = -(1 as libc::c_int) as int16_t;
    (*p).lastlinehit = -(1 as libc::c_int) as int16_t;
    (*p).awayviewmobj = 0 as *mut mobj_t;
    (*p).awayviewtics = 0 as libc::c_int;
    P_SetScale(mobj, (*mobj).destscale);
    P_FlashPal(p, 0 as libc::c_int as uint16_t, 0 as libc::c_int as uint16_t);
    (*mobj).radius = FixedMul(skins[(*p).skin as usize].radius, (*mobj).scale);
    (*mobj).height = FixedMul((*p).height, (*(*p).mo).scale);
    if leveltime == 0 && (*p).spectator == 0
        && (maptol & TOL_NIGHTS as libc::c_int as uint32_t
            == TOL_NIGHTS as libc::c_int as uint32_t) as libc::c_int
            != G_IsSpecialStage(gamemap as int32_t)
    {
        if maptol & TOL_NIGHTS as libc::c_int as uint32_t != 0 {
            if p == players.as_mut_ptr() {
                let mut idya: *mut mobj_t = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    (*mobj).height,
                    MT_GOTEMERALD,
                );
                (*idya).health = 0 as libc::c_int;
                P_SetTarget2(&mut (*idya).target, mobj);
                P_SetMobjState(
                    idya,
                    mobjinfo[MT_GOTEMERALD as libc::c_int as usize].missilestate,
                );
                P_SetTarget2(&mut (*mobj).tracer, idya);
            }
        } else if sstimer != 0 {
            (*p).nightstime = sstimer as tic_t;
        }
    }
    P_DoPityCheck(p);
}
#[no_mangle]
pub unsafe extern "C" fn P_AfterPlayerSpawn(mut playernum: int32_t) {
    let mut p: *mut player_t = &mut *players.as_mut_ptr().offset(playernum as isize)
        as *mut player_t;
    let mut mobj: *mut mobj_t = (*p).mo;
    P_SetPlayerAngle(p, (*mobj).angle);
    (*p).viewheight = 41 as libc::c_int * (*p).height / 48 as libc::c_int;
    if (*(*p).mo).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        (*p).viewz = (*(*p).mo).z + (*(*p).mo).height - (*p).viewheight;
    } else {
        (*p).viewz = (*(*p).mo).z + (*p).viewheight;
    }
    if playernum == consoleplayer {
        ST_Start();
        HU_Start();
    }
    (*p).drawangle = (*mobj).angle;
    if camera.chase != 0 {
        if displayplayer == playernum {
            P_ResetCamera(p, &mut camera);
        }
    }
    if camera2.chase != 0 && splitscreen != 0 {
        if secondarydisplayplayer == playernum {
            P_ResetCamera(p, &mut camera2);
        }
    }
    if CheckForReverseGravity != 0 {
        P_CheckGravity(mobj, false_0 as libc::c_int);
    }
    if (*p).pflags as libc::c_uint & PF_FINISHED as libc::c_int as libc::c_uint != 0 {
        P_GiveFinishFlags(p);
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_MovePlayerToSpawn(
    mut playernum: int32_t,
    mut mthing: *mut mapthing_t,
) {
    let mut x: fixed_t = 0 as libc::c_int;
    let mut y: fixed_t = 0 as libc::c_int;
    let mut angle: angle_t = 0 as libc::c_int as angle_t;
    let mut z: fixed_t = 0;
    let mut sector: *mut sector_t = 0 as *mut sector_t;
    let mut floor: fixed_t = 0;
    let mut ceiling: fixed_t = 0;
    let mut ceilingspawn: fixed_t = 0;
    let mut p: *mut player_t = &mut *players.as_mut_ptr().offset(playernum as isize)
        as *mut player_t;
    let mut mobj: *mut mobj_t = (*p).mo;
    if !mthing.is_null() {
        x = ((*mthing).x as libc::c_int) << 16 as libc::c_int;
        y = ((*mthing).y as libc::c_int) << 16 as libc::c_int;
        angle = FixedAngle(((*mthing).angle as libc::c_int) << 16 as libc::c_int);
    }
    sector = (*R_PointInSubsector(x, y)).sector;
    floor = P_GetSectorFloorZAt(sector, x, y);
    ceiling = P_GetSectorCeilingZAt(sector, x, y);
    ceilingspawn = ceiling - mobjinfo[MT_PLAYER as libc::c_int as usize].height;
    if !mthing.is_null() {
        let mut offset: fixed_t = ((*mthing).z as libc::c_int) << 16 as libc::c_int;
        if ((*mthing).args[0 as libc::c_int as usize] != 0) as libc::c_int
            ^ ((*mthing).options as libc::c_int & 2 as libc::c_int != 0) as libc::c_int
            != 0
        {
            z = ceilingspawn - offset;
        } else {
            z = floor + offset;
        }
        if (*mthing).options as libc::c_int & 2 as libc::c_int != 0 {
            (*mobj)
                .eflags = ((*mobj).eflags as libc::c_int
                | MFE_VERTICALFLIP as libc::c_int) as uint16_t;
            (*mobj).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
        }
        if (*mthing).args[0 as libc::c_int as usize] != 0 {
            P_SetPlayerMobjState(mobj, S_PLAY_FALL);
        } else if metalrecording != 0 {
            P_SetPlayerMobjState(mobj, S_PLAY_WAIT);
        }
    } else {
        z = floor;
    }
    if z < floor {
        z = floor;
    } else if z > ceilingspawn {
        z = ceilingspawn;
    }
    (*mobj).floorz = floor;
    (*mobj).ceilingz = ceiling;
    P_UnsetThingPosition(mobj);
    (*mobj).x = x;
    (*mobj).y = y;
    P_SetThingPosition(mobj);
    (*mobj).z = z;
    if (*mobj).flags2 & MF2_OBJECTFLIP as libc::c_int as uint32_t != 0 {
        if (*mobj).z + (*mobj).height == (*mobj).ceilingz {
            (*mobj)
                .eflags = ((*mobj).eflags as libc::c_int | MFE_ONGROUND as libc::c_int)
                as uint16_t;
        }
    } else if (*mobj).z == (*mobj).floorz {
        (*mobj)
            .eflags = ((*mobj).eflags as libc::c_int | MFE_ONGROUND as libc::c_int)
            as uint16_t;
    }
    (*mobj).angle = angle;
    P_AfterPlayerSpawn(playernum);
}
#[no_mangle]
pub unsafe extern "C" fn P_MovePlayerToStarpost(mut playernum: int32_t) {
    let mut z: fixed_t = 0;
    let mut sector: *mut sector_t = 0 as *mut sector_t;
    let mut floor: fixed_t = 0;
    let mut ceiling: fixed_t = 0;
    let mut p: *mut player_t = &mut *players.as_mut_ptr().offset(playernum as isize)
        as *mut player_t;
    let mut mobj: *mut mobj_t = (*p).mo;
    P_UnsetThingPosition(mobj);
    (*mobj).x = ((*p).starpostx as libc::c_int) << 16 as libc::c_int;
    (*mobj).y = ((*p).starposty as libc::c_int) << 16 as libc::c_int;
    P_SetThingPosition(mobj);
    sector = (*R_PointInSubsector((*mobj).x, (*mobj).y)).sector;
    floor = P_GetSectorFloorZAt(sector, (*mobj).x, (*mobj).y);
    ceiling = P_GetSectorCeilingZAt(sector, (*mobj).x, (*mobj).y);
    z = ((*p).starpostz as libc::c_int) << 16 as libc::c_int;
    (*mobj).destscale = abs((*p).starpostscale);
    P_SetScale(mobj, (*mobj).destscale);
    if (*p).starpostscale < 0 as libc::c_int {
        (*mobj).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
        if z >= ceiling {
            (*mobj)
                .eflags = ((*mobj).eflags as libc::c_int | MFE_ONGROUND as libc::c_int)
                as uint16_t;
            z = ceiling;
        }
        z -= (*mobj).height;
    } else if z <= floor {
        (*mobj)
            .eflags = ((*mobj).eflags as libc::c_int | MFE_ONGROUND as libc::c_int)
            as uint16_t;
        z = floor;
    }
    (*mobj).floorz = floor;
    (*mobj).ceilingz = ceiling;
    (*mobj).z = z;
    (*mobj).angle = (*p).starpostangle;
    P_AfterPlayerSpawn(playernum);
    if !(netgame != 0 || multiplayer != 0) {
        leveltime = (*p).starposttime;
    }
}
#[no_mangle]
pub static mut huntemeralds: [*mut mapthing_t; 64] = [0 as *const mapthing_t
    as *mut mapthing_t; 64];
#[no_mangle]
pub static mut numhuntemeralds: int32_t = 0;
#[no_mangle]
pub unsafe extern "C" fn P_GetMobjSpawnHeight(
    mobjtype: mobjtype_t,
    x: fixed_t,
    y: fixed_t,
    dz: fixed_t,
    offset: fixed_t,
    flip: boolean,
    scale: fixed_t,
    absolutez: boolean,
) -> fixed_t {
    let mut ss: *const subsector_t = R_PointInSubsector(x, y);
    if mobjtype as libc::c_uint == MT_AXIS as libc::c_int as libc::c_uint
        || mobjtype as libc::c_uint == MT_AXISTRANSFER as libc::c_int as libc::c_uint
        || mobjtype as libc::c_uint == MT_AXISTRANSFERLINE as libc::c_int as libc::c_uint
    {
        return -(2147483647 as libc::c_int) - 1 as libc::c_int;
    }
    if flip != 0 {
        return (if absolutez != 0 {
            dz
        } else {
            P_GetSectorCeilingZAt((*ss).sector, x, y) - dz
        }) - FixedMul(scale, offset + mobjinfo[mobjtype as usize].height)
    } else {
        return (if absolutez != 0 {
            dz
        } else {
            P_GetSectorFloorZAt((*ss).sector, x, y) + dz
        }) + FixedMul(scale, offset)
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_GetMapThingSpawnHeight(
    mobjtype: mobjtype_t,
    mut mthing: *const mapthing_t,
    x: fixed_t,
    y: fixed_t,
) -> fixed_t {
    let mut dz: fixed_t = ((*mthing).z as libc::c_int) << 16 as libc::c_int;
    let mut offset: fixed_t = 0 as libc::c_int;
    let mut flip: boolean = (mobjinfo[mobjtype as usize].flags
        & MF_SPAWNCEILING as libc::c_int as uint32_t != 0) as libc::c_int
        ^ ((*mthing).options as libc::c_int & 2 as libc::c_int != 0) as libc::c_int;
    let mut absolutez: boolean = ((*mthing).options as libc::c_int & 16 as libc::c_int
        != 0) as libc::c_int;
    match mobjtype as libc::c_uint {
        13 | 14 | 11 | 12 | 66 => {
            if dz == 0 {
                dz = 33 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            }
        }
        61 => {
            if dz == 0 {
                dz = 128 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            }
        }
        9 | 10 => {
            if dz == 0 {
                dz = 288 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int);
            }
        }
        138 | 139 | 140 => {
            offset
                += if (*mthing).args[0 as libc::c_int as usize] != 0 {
                    0 as libc::c_int
                } else {
                    16 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                };
        }
        147 | 125 | 126 | 114 | 107 | 112 | 113 | 550 | 109 | 111 | 581 | 583 => {
            offset
                += if (*mthing).args[0 as libc::c_int as usize] != 0 {
                    0 as libc::c_int
                } else {
                    24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                };
        }
        117 => {
            offset
                += if (*mthing).args[1 as libc::c_int as usize] != 0 {
                    0 as libc::c_int
                } else {
                    24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                };
        }
        _ => {
            if P_WeaponOrPanel(mobjtype) != 0 {
                offset
                    += if (*mthing).args[0 as libc::c_int as usize] != 0 {
                        0 as libc::c_int
                    } else {
                        24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                    };
            }
        }
    }
    if dz + offset == 0 && absolutez == 0 {
        if flip != 0 {
            return 2147483647 as libc::c_int
        } else {
            return -(2147483647 as libc::c_int) - 1 as libc::c_int
        }
    }
    return P_GetMobjSpawnHeight(
        mobjtype,
        x,
        y,
        dz,
        offset,
        flip,
        (*mthing).scale,
        absolutez,
    );
}
unsafe extern "C" fn P_SpawnNonMobjMapThing(mut mthing: *mut mapthing_t) -> boolean {
    if (*mthing).type_0 as libc::c_int <= 32 as libc::c_int {
        if metalrecording == 0 {
            playerstarts[((*mthing).type_0 as libc::c_int - 1 as libc::c_int)
                as usize] = mthing;
        }
        return true_0 as libc::c_int;
    } else if (*mthing).type_0 as libc::c_int == 33 as libc::c_int {
        if numdmstarts < 64 as libc::c_int {
            deathmatchstarts[numdmstarts as usize] = mthing;
            (*mthing).type_0 = 0 as libc::c_int as uint16_t;
            numdmstarts += 1;
            numdmstarts;
        }
        return true_0 as libc::c_int;
    } else if (*mthing).type_0 as libc::c_int == 34 as libc::c_int {
        if numredctfstarts < 32 as libc::c_int {
            redctfstarts[numredctfstarts as usize] = mthing;
            (*mthing).type_0 = 0 as libc::c_int as uint16_t;
            numredctfstarts += 1;
            numredctfstarts;
        }
        return true_0 as libc::c_int;
    } else if (*mthing).type_0 as libc::c_int == 35 as libc::c_int {
        if numbluectfstarts < 32 as libc::c_int {
            bluectfstarts[numbluectfstarts as usize] = mthing;
            (*mthing).type_0 = 0 as libc::c_int as uint16_t;
            numbluectfstarts += 1;
            numbluectfstarts;
        }
        return true_0 as libc::c_int;
    } else if metalrecording != 0
        && (*mthing).type_0 as libc::c_int
            == mobjinfo[MT_METALSONIC_RACE as libc::c_int as usize].doomednum
    {
        playerstarts[0 as libc::c_int as usize] = mthing;
        return true_0 as libc::c_int;
    } else if (*mthing).type_0 as libc::c_int == 750 as libc::c_int
        || (*mthing).type_0 as libc::c_int >= 600 as libc::c_int
            && (*mthing).type_0 as libc::c_int <= 611 as libc::c_int
        || (*mthing).type_0 as libc::c_int == 1713 as libc::c_int
    {
        return true_0 as libc::c_int
    } else if (*mthing).type_0 as libc::c_int
        == mobjinfo[MT_EMERHUNT as libc::c_int as usize].doomednum
    {
        if gametyperules & GTR_EMERALDHUNT as libc::c_int as uint32_t != 0
            && numhuntemeralds < 64 as libc::c_int
        {
            let fresh18 = numhuntemeralds;
            numhuntemeralds = numhuntemeralds + 1;
            huntemeralds[fresh18 as usize] = mthing;
        }
        return true_0 as libc::c_int;
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn P_AllowMobjSpawn(
    mut mthing: *mut mapthing_t,
    mut i: mobjtype_t,
) -> boolean {
    match i as libc::c_uint {
        118 | 119 | 120 | 121 | 122 | 123 | 124 => {
            if G_CoopGametype() == 0 {
                return false_0 as libc::c_int;
            }
            if metalrecording != 0 {
                return false_0 as libc::c_int;
            }
            if emeralds as libc::c_int & mobjinfo[i as usize].speed != 0 {
                return false_0 as libc::c_int;
            }
        }
        126 => {
            if cv_powerstones.value == 0 {
                return false_0 as libc::c_int;
            }
            if gametyperules & GTR_POWERSTONES as libc::c_int as uint32_t == 0 {
                return false_0 as libc::c_int;
            }
            runemeraldmanager = true_0 as libc::c_int;
        }
        394 => {
            if !(G_CoopGametype() != 0 || (*mthing).args[0 as libc::c_int as usize] != 0)
            {
                return false_0 as libc::c_int;
            }
            if !(netgame != 0 || multiplayer != 0)
                && players[consoleplayer as usize].skin == 3 as libc::c_int
            {
                return false_0 as libc::c_int;
            }
        }
        114 => {
            if gametyperules & GTR_EMERALDTOKENS as libc::c_int as uint32_t == 0 {
                return false_0 as libc::c_int;
            }
            if tokenbits == 30 as libc::c_int {
                return false_0 as libc::c_int;
            }
            let fresh19 = tokenbits;
            tokenbits = tokenbits + 1;
            if tokenlist & ((1 as libc::c_int) << fresh19) as uint32_t != 0 {
                return false_0 as libc::c_int;
            }
        }
        117 => {
            if G_CoopGametype() == 0 {
                return false_0 as libc::c_int;
            }
        }
        _ => {}
    }
    if metalrecording != 0 {
        if mobjinfo[i as usize].flags
            & (MF_ENEMY as libc::c_int | MF_BOSS as libc::c_int) as uint32_t != 0
            || i as libc::c_uint == MT_TOKEN as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_STARPOST as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_RING as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_BLUETEAMRING as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_REDTEAMRING as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_COIN as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_BLUESPHERE as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_BOMBSPHERE as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_NIGHTSCHIP as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_NIGHTSSTAR as libc::c_int as libc::c_uint
        {
            return false_0 as libc::c_int;
        }
    }
    if (mobjinfo[i as usize].flags & MF_ENEMY as libc::c_int as uint32_t != 0
        || mobjinfo[i as usize].flags & MF_BOSS as libc::c_int as uint32_t != 0)
        && gametyperules & GTR_SPAWNENEMIES as libc::c_int as uint32_t == 0
    {
        return false_0 as libc::c_int;
    }
    if gametyperules & GTR_ALLOWEXIT as libc::c_int as uint32_t == 0
        && i as libc::c_uint == MT_SIGN as libc::c_int as libc::c_uint
    {
        return false_0 as libc::c_int;
    }
    if G_PlatformGametype() == 0
        && i as libc::c_uint == MT_STARPOST as libc::c_int as libc::c_uint
    {
        return false_0 as libc::c_int;
    }
    if G_RingSlingerGametype() == 0 || cv_specialrings.value == 0 {
        if P_WeaponOrPanel(i) != 0 {
            return false_0 as libc::c_int;
        }
    }
    if gametyperules & GTR_TEAMFLAGS as libc::c_int as uint32_t == 0 {
        if i as libc::c_uint == MT_BLUEFLAG as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_REDFLAG as libc::c_int as libc::c_uint
        {
            return false_0 as libc::c_int;
        }
    } else if i as libc::c_uint == MT_BLUEFLAG as libc::c_int as libc::c_uint
        && !blueflag.is_null()
        || i as libc::c_uint == MT_REDFLAG as libc::c_int as libc::c_uint
            && !redflag.is_null()
    {
        CONS_Alert(
            CONS_ERROR,
            b"Only one flag per team allowed in CTF!\n\0" as *const u8
                as *const libc::c_char,
        );
        return false_0 as libc::c_int;
    }
    if modeattacking != 0 {
        if i as libc::c_uint == MT_STARPOST as libc::c_int as libc::c_uint {
            return false_0 as libc::c_int;
        }
    }
    if ultimatemode != 0 {
        if i as libc::c_uint == MT_RING as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_REDTEAMRING as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_BLUETEAMRING as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_COIN as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_NIGHTSSTAR as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_NIGHTSCHIP as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_PITY_BOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_ELEMENTAL_BOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_ATTRACT_BOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_FORCE_BOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_ARMAGEDDON_BOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_WHIRLWIND_BOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_FLAMEAURA_BOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_BUBBLEWRAP_BOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_THUNDERCOIN_BOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_RING_BOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_STARPOST as libc::c_int as libc::c_uint
        {
            return false_0 as libc::c_int;
        }
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_GetMobjtypeSubstitute(
    mut mthing: *mut mapthing_t,
    mut i: mobjtype_t,
) -> mobjtype_t {
    if mobjinfo[i as usize].flags
        & (MF_MONITOR as libc::c_int | MF_GRENADEBOUNCE as libc::c_int) as uint32_t
        == MF_MONITOR as libc::c_int as uint32_t
    {
        if gametyperules & GTR_RACE as libc::c_int as uint32_t != 0 {
            match cv_competitionboxes.value {
                1 => return MT_MYSTERY_BOX,
                2 => return MT_MIXUP_BOX,
                3 => return MT_NULL,
                _ => return i,
            }
        } else if G_CoopGametype() == 0 {
            match cv_matchboxes.value {
                1 => return MT_MYSTERY_BOX,
                2 => {
                    if i as libc::c_uint == MT_MYSTERY_BOX as libc::c_int as libc::c_uint
                    {
                        return MT_NULL;
                    }
                    (*mthing).args[1 as libc::c_int as usize] = TMMR_SAME as libc::c_int;
                    return i;
                }
                3 => return MT_NULL,
                _ => return i,
            }
        }
    }
    if maptol & TOL_NIGHTS as libc::c_int as uint32_t != 0
        && G_IsSpecialStage(gamemap as int32_t) == 0
    {
        if i as libc::c_uint == MT_RING as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_REDTEAMRING as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_BLUETEAMRING as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_COIN as libc::c_int as libc::c_uint
        {
            return MT_NIGHTSSTAR;
        }
        if i as libc::c_uint == MT_BLUESPHERE as libc::c_int as libc::c_uint {
            return MT_NIGHTSCHIP;
        }
    }
    if gametyperules & GTR_TEAMS as libc::c_int as uint32_t == 0 {
        if i as libc::c_uint == MT_BLUETEAMRING as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_REDTEAMRING as libc::c_int as libc::c_uint
        {
            return MT_RING;
        }
        if i as libc::c_uint == MT_RING_BLUEBOX as libc::c_int as libc::c_uint
            || i as libc::c_uint == MT_RING_REDBOX as libc::c_int as libc::c_uint
        {
            return MT_RING_BOX;
        }
    }
    if modeattacking as libc::c_int != 0
        && i as libc::c_uint == MT_1UP_BOX as libc::c_int as libc::c_uint
    {
        if (*mthing).args[2 as libc::c_int as usize] != 0 {
            return MT_SCORE10K_BOX
        } else {
            return MT_SCORE1K_BOX
        }
    }
    return i;
}
unsafe extern "C" fn P_SetupEmblem(
    mut mthing: *mut mapthing_t,
    mut mobj: *mut mobj_t,
) -> boolean {
    let mut j: int32_t = 0;
    let mut emblem: *mut emblem_t = M_GetLevelEmblems(gamemap as int32_t);
    let mut emcolor: skincolornum_t = SKINCOLOR_NONE;
    while !emblem.is_null() {
        if ((*emblem).type_0 as libc::c_int == 0 as libc::c_int
            || (*emblem).type_0 as libc::c_int == 1 as libc::c_int)
            && (*emblem).tag as libc::c_int
                == Tag_FGet(&mut (*mthing).tags) as libc::c_int
        {
            break;
        }
        emblem = M_GetLevelEmblems(-(1 as libc::c_int));
    }
    if emblem.is_null() {
        CONS_Debug(
            0x80 as libc::c_int,
            b"No map emblem for map %d with tag %d found!\n\0" as *const u8
                as *const libc::c_char,
            gamemap as libc::c_int,
            Tag_FGet(&mut (*mthing).tags) as libc::c_int,
        );
        return false_0 as libc::c_int;
    }
    j = emblem.offset_from(emblemlocations.as_mut_ptr()) as libc::c_long as int32_t;
    P_SetMobjState(
        mobj,
        ((*(*mobj).info).spawnstate as libc::c_uint)
            .wrapping_add(
                (emblemlocations[j as usize].sprite as libc::c_int - 'A' as i32)
                    as libc::c_uint,
            ) as statenum_t,
    );
    (*mobj).health = j + 1 as libc::c_int;
    emcolor = M_GetEmblemColor(&mut *emblemlocations.as_mut_ptr().offset(j as isize));
    (*mobj).color = emcolor as uint16_t;
    (*mobj).frame &= !(0xf0000 as libc::c_int) as uint32_t;
    if emblemlocations[j as usize].type_0 as libc::c_int == 0 as libc::c_int {
        (*mobj).reactiontime = emblemlocations[j as usize].var;
        if emblemlocations[j as usize].var & 2 as libc::c_int != 0 {
            (*mobj).flags |= MF_NIGHTSITEM as libc::c_int as uint32_t;
            (*mobj).flags &= !(MF_SPECIAL as libc::c_int) as uint32_t;
            (*mobj).flags2 |= MF2_DONTDRAW as libc::c_int as uint32_t;
        }
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_SetupMace(
    mut mthing: *mut mapthing_t,
    mut mobj: *mut mobj_t,
    mut doangle: *mut boolean,
) -> boolean {
    let mut mlength: fixed_t = 0;
    let mut mmaxlength: fixed_t = 0;
    let mut mlengthset: fixed_t = 0;
    let mut mspeed: fixed_t = 0;
    let mut mphase: fixed_t = 0;
    let mut myaw: fixed_t = 0;
    let mut mpitch: fixed_t = 0;
    let mut mminlength: fixed_t = 0;
    let mut mnumspokes: fixed_t = 0;
    let mut mpinch: fixed_t = 0;
    let mut mroll: fixed_t = 0;
    let mut mnumnospokes: fixed_t = 0;
    let mut mwidth: fixed_t = 0;
    let mut mwidthset: fixed_t = 0;
    let mut mmin: fixed_t = 0;
    let mut msound: fixed_t = 0;
    let mut radiusfactor: fixed_t = 0;
    let mut widthfactor: fixed_t = 0;
    let mut mspokeangle: angle_t = 0;
    let mut chainlink: mobjtype_t = MT_NULL;
    let mut macetype: mobjtype_t = MT_NULL;
    let mut firsttype: mobjtype_t = MT_NULL;
    let mut linktype: mobjtype_t = MT_NULL;
    let mut mdosound: boolean = 0;
    let mut mdocenter: boolean = 0;
    let mut mchainlike: boolean = false_0 as libc::c_int;
    let mut spawnee: *mut mobj_t = 0 as *mut mobj_t;
    let mut hprev: *mut mobj_t = mobj;
    let mut mflagsapply: mobjflag_t = 0 as mobjflag_t;
    let mut mflags2apply: mobjflag2_t = 0 as mobjflag2_t;
    let mut meflagsapply: mobjeflag_t = 0 as mobjeflag_t;
    let mthingi: size_t = mthing.offset_from(mapthings) as libc::c_long as size_t;
    mlength = abs((*mthing).args[0 as libc::c_int as usize]);
    mnumspokes = (*mthing).args[1 as libc::c_int as usize] + 1 as libc::c_int;
    mspokeangle = FixedAngle(
        360 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int) / mnumspokes,
    ) >> 19 as libc::c_int;
    mwidth = if 0 as libc::c_int > (*mthing).args[2 as libc::c_int as usize] {
        0 as libc::c_int
    } else {
        (*mthing).args[2 as libc::c_int as usize]
    };
    mspeed = abs((*mthing).args[3 as libc::c_int as usize] << 4 as libc::c_int);
    mphase = (*mthing).args[4 as libc::c_int as usize] % 360 as libc::c_int;
    mpinch = (*mthing).args[5 as libc::c_int as usize] % 360 as libc::c_int;
    mnumnospokes = (*mthing).args[6 as libc::c_int as usize];
    mminlength = if 0 as libc::c_int
        > (if (mlength - 1 as libc::c_int) < (*mthing).args[7 as libc::c_int as usize] {
            mlength - 1 as libc::c_int
        } else {
            (*mthing).args[7 as libc::c_int as usize]
        })
    {
        0 as libc::c_int
    } else if (mlength - 1 as libc::c_int) < (*mthing).args[7 as libc::c_int as usize] {
        mlength - 1 as libc::c_int
    } else {
        (*mthing).args[7 as libc::c_int as usize]
    };
    mpitch = (*mthing).pitch as libc::c_int % 360 as libc::c_int;
    myaw = (*mthing).angle as libc::c_int % 360 as libc::c_int;
    mroll = (*mthing).roll as libc::c_int % 360 as libc::c_int;
    CONS_Debug(
        0x80 as libc::c_int,
        b"Mace/Chain (mapthing #%s):\nLength is %d (minus %d)\nSpeed is %d\nPhase is %d\nYaw is %d\nPitch is %d\nNo. of spokes is %d (%d antispokes)\nPinch is %d\nRoll is %d\nWidth is %d\n\0"
            as *const u8 as *const libc::c_char,
        sizeu1(mthingi),
        mlength,
        mminlength,
        mspeed,
        mphase,
        myaw,
        mpitch,
        mnumspokes,
        mnumnospokes,
        mpinch,
        mroll,
        mwidth,
    );
    if mnumnospokes > 0 as libc::c_int && mnumnospokes < mnumspokes {
        mnumnospokes = mnumspokes / mnumnospokes;
    } else {
        mnumnospokes = if (*mobj).type_0 as libc::c_uint
            == MT_CHAINMACEPOINT as libc::c_int as libc::c_uint
        {
            mnumspokes
        } else {
            0 as libc::c_int
        };
    }
    (*mobj).lastlook = mspeed;
    (*mobj).movecount = (*mobj).lastlook;
    (*mobj).angle = FixedAngle(myaw << 16 as libc::c_int);
    *doangle = false_0 as libc::c_int;
    (*mobj)
        .threshold = (FixedAngle(mpitch << 16 as libc::c_int) >> 19 as libc::c_int)
        as int32_t;
    (*mobj).movefactor = mpinch;
    (*mobj).movedir = 0 as libc::c_int as angle_t;
    match (*mobj).type_0 as libc::c_uint {
        274 => {
            macetype = (if (*mthing).args[8 as libc::c_int as usize]
                & TMM_DOUBLESIZE as libc::c_int != 0
            {
                MT_REDSPRINGBALL as libc::c_int
            } else {
                MT_YELLOWSPRINGBALL as libc::c_int
            }) as mobjtype_t;
            chainlink = MT_SMALLMACECHAIN;
        }
        277 => {
            macetype = (if (*mthing).args[8 as libc::c_int as usize]
                & TMM_DOUBLESIZE as libc::c_int != 0
            {
                MT_BIGFIREBAR as libc::c_int
            } else {
                MT_SMALLFIREBAR as libc::c_int
            }) as mobjtype_t;
            chainlink = MT_NULL;
        }
        278 => {
            macetype = (if !((*mthing).stringargs[0 as libc::c_int as usize]).is_null() {
                get_number((*mthing).stringargs[0 as libc::c_int as usize])
            } else {
                MT_NULL as libc::c_int
            }) as mobjtype_t;
            chainlink = (if !((*mthing).stringargs[1 as libc::c_int as usize]).is_null()
            {
                get_number((*mthing).stringargs[1 as libc::c_int as usize])
            } else {
                MT_NULL as libc::c_int
            }) as mobjtype_t;
        }
        275 => {
            if (*mthing).args[8 as libc::c_int as usize] & TMM_DOUBLESIZE as libc::c_int
                != 0
            {
                macetype = MT_BIGGRABCHAIN;
                chainlink = MT_BIGMACECHAIN;
            } else {
                macetype = MT_SMALLGRABCHAIN;
                chainlink = MT_SMALLMACECHAIN;
            }
            mchainlike = true_0 as libc::c_int;
        }
        _ => {
            if (*mthing).args[8 as libc::c_int as usize] & TMM_DOUBLESIZE as libc::c_int
                != 0
            {
                macetype = MT_BIGMACE;
                chainlink = MT_BIGMACECHAIN;
            } else {
                macetype = MT_SMALLMACE;
                chainlink = MT_SMALLMACECHAIN;
            }
        }
    }
    if macetype as u64 == 0 && chainlink as u64 == 0 {
        return true_0 as libc::c_int;
    }
    if (*mobj).type_0 as libc::c_uint == MT_CHAINPOINT as libc::c_int as libc::c_uint {
        if mlength == 0 {
            return true_0 as libc::c_int;
        }
    } else {
        mlength += 1;
        mlength;
    }
    firsttype = macetype;
    if (*mthing).args[8 as libc::c_int as usize] & TMM_ALLOWYAWCONTROL as libc::c_int
        != 0
    {
        (*mobj).flags |= MF_SLIDEME as libc::c_int as uint32_t;
    }
    if (*mthing).args[8 as libc::c_int as usize] & TMM_SWING as libc::c_int != 0 {
        (*mobj).flags2 |= MF2_STRONGBOX as libc::c_int as uint32_t;
        mmin = if mnumnospokes > 1 as libc::c_int {
            1 as libc::c_int
        } else {
            0 as libc::c_int
        };
    } else {
        mmin = mnumspokes;
    }
    if (*mthing).args[8 as libc::c_int as usize] & TMM_ALWAYSTHINK as libc::c_int != 0 {
        (*mobj).flags2 |= MF2_BOSSNOTRAP as libc::c_int as uint32_t;
    }
    if (*mobj).type_0 as libc::c_uint != MT_CHAINPOINT as libc::c_int as libc::c_uint
        && ((*mthing).args[8 as libc::c_int as usize] & TMM_MACELINKS as libc::c_int
            == TMM_MACELINKS as libc::c_int) as libc::c_int
            != ((*mobj).type_0 as libc::c_uint
                == MT_FIREBARPOINT as libc::c_int as libc::c_uint) as libc::c_int
    {
        linktype = macetype;
        radiusfactor = 2 as libc::c_int;
    } else {
        linktype = chainlink;
        radiusfactor = if linktype as libc::c_uint
            == MT_NULL as libc::c_int as libc::c_uint
        {
            2 as libc::c_int
        } else {
            1 as libc::c_int
        };
    }
    if mchainlike == 0 {
        mchainlike = (firsttype as libc::c_uint == chainlink as libc::c_uint)
            as libc::c_int;
    }
    widthfactor = if mchainlike != 0 { 1 as libc::c_int } else { 2 as libc::c_int };
    mflagsapply = (if (*mthing).args[8 as libc::c_int as usize] & TMM_CLIP as libc::c_int
        != 0
    {
        0 as libc::c_int
    } else {
        MF_NOCLIP as libc::c_int | MF_NOCLIPHEIGHT as libc::c_int
    }) as mobjflag_t;
    mflags2apply = (if (*mthing).options as libc::c_int & 2 as libc::c_int != 0 {
        MF2_OBJECTFLIP as libc::c_int
    } else {
        0 as libc::c_int
    }) as mobjflag2_t;
    meflagsapply = (if (*mthing).options as libc::c_int & 2 as libc::c_int != 0 {
        MFE_VERTICALFLIP as libc::c_int
    } else {
        0 as libc::c_int
    }) as mobjeflag_t;
    msound = if mchainlike != 0 { 0 as libc::c_int } else { mwidth & 1 as libc::c_int };
    mphase = (FixedAngle(mphase << 16 as libc::c_int) >> 19 as libc::c_int) as fixed_t;
    mroll = (FixedAngle(mroll << 16 as libc::c_int) >> 19 as libc::c_int) as fixed_t;
    mdosound = (mspeed != 0
        && (*mthing).args[8 as libc::c_int as usize] & TMM_SILENT as libc::c_int == 0)
        as libc::c_int;
    mdocenter = (macetype as libc::c_uint != 0
        && (*mthing).args[8 as libc::c_int as usize] & TMM_CENTERLINK as libc::c_int
            != 0) as libc::c_int;
    loop {
        let fresh20 = mnumspokes;
        mnumspokes = mnumspokes - 1;
        if !(fresh20 > 0 as libc::c_int) {
            break;
        }
        if (*mthing).args[8 as libc::c_int as usize] & TMM_SWING as libc::c_int != 0 {
            mroll = ((mroll as angle_t).wrapping_sub(mspokeangle)
                & (8192 as libc::c_int - 1 as libc::c_int) as angle_t) as fixed_t;
        } else {
            mphase = ((mphase as angle_t).wrapping_sub(mspokeangle)
                & (8192 as libc::c_int - 1 as libc::c_int) as angle_t) as fixed_t;
        }
        if mnumnospokes != 0 && mnumspokes % mnumnospokes == 0 {
            if (*mobj).type_0 as libc::c_uint
                != MT_CHAINMACEPOINT as libc::c_int as libc::c_uint
            {
                continue;
            }
            linktype = chainlink;
            firsttype = (if (*mthing).args[8 as libc::c_int as usize]
                & TMM_DOUBLESIZE as libc::c_int != 0
            {
                MT_BIGGRABCHAIN as libc::c_int
            } else {
                MT_SMALLGRABCHAIN as libc::c_int
            }) as mobjtype_t;
            mmaxlength = 1 as libc::c_int + (mlength - 1 as libc::c_int) * radiusfactor;
            widthfactor = 1 as libc::c_int;
            radiusfactor = widthfactor;
        } else {
            if (*mobj).type_0 as libc::c_uint
                == MT_CHAINMACEPOINT as libc::c_int as libc::c_uint
            {
                if (*mthing).args[8 as libc::c_int as usize]
                    & TMM_MACELINKS as libc::c_int != 0
                {
                    linktype = macetype;
                    radiusfactor = 2 as libc::c_int;
                } else {
                    linktype = chainlink;
                    radiusfactor = if linktype as libc::c_uint
                        == MT_NULL as libc::c_int as libc::c_uint
                    {
                        2 as libc::c_int
                    } else {
                        1 as libc::c_int
                    };
                }
                firsttype = macetype;
                widthfactor = 2 as libc::c_int;
            }
            mmaxlength = mlength;
        }
        mwidthset = mwidth;
        mlengthset = mminlength;
        if mdocenter != 0 {
            spawnee = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, linktype);
            P_SetTarget2(&mut (*spawnee).tracer, mobj);
            (*spawnee).threshold = mphase;
            (*spawnee).friction = mroll;
            (*spawnee).movefactor = mwidthset;
            (*spawnee).movecount = 0 as libc::c_int;
            (*spawnee).angle = myaw as angle_t;
            (*spawnee).flags
                |= MF_NOGRAVITY as libc::c_int as libc::c_uint
                    | mflagsapply as libc::c_uint;
            (*spawnee).flags2
                |= mflags2apply as libc::c_uint | 0 as libc::c_int as libc::c_uint;
            (*spawnee)
                .eflags = ((*spawnee).eflags as libc::c_uint
                | meflagsapply as libc::c_uint) as uint16_t;
            P_SetTarget2(&mut (*hprev).hnext, spawnee);
            P_SetTarget2(&mut (*spawnee).hprev, hprev);
            hprev = spawnee;
        }
        if linktype as u64 != 0 {
            loop {
                mlengthset += 1;
                if !(mlengthset < mmaxlength) {
                    break;
                }
                spawnee = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, linktype);
                P_SetTarget2(&mut (*spawnee).tracer, mobj);
                (*spawnee).threshold = mphase;
                (*spawnee).friction = mroll;
                (*spawnee).movefactor = mwidthset;
                (*spawnee).movecount = radiusfactor * mlengthset;
                (*spawnee).angle = myaw as angle_t;
                (*spawnee).flags
                    |= MF_NOGRAVITY as libc::c_int as libc::c_uint
                        | mflagsapply as libc::c_uint;
                (*spawnee).flags2
                    |= mflags2apply as libc::c_uint | 0 as libc::c_int as libc::c_uint;
                (*spawnee)
                    .eflags = ((*spawnee).eflags as libc::c_uint
                    | meflagsapply as libc::c_uint) as uint16_t;
                P_SetTarget2(&mut (*hprev).hnext, spawnee);
                P_SetTarget2(&mut (*spawnee).hprev, hprev);
                hprev = spawnee;
            }
        } else {
            mlengthset = mmaxlength;
        }
        if firsttype as u64 != 0 {
            spawnee = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, firsttype);
            P_SetTarget2(&mut (*spawnee).tracer, mobj);
            (*spawnee).threshold = mphase;
            (*spawnee).friction = mroll;
            (*spawnee).movefactor = mwidthset;
            (*spawnee).movecount = radiusfactor * mlengthset;
            (*spawnee).angle = myaw as angle_t;
            (*spawnee).flags
                |= MF_NOGRAVITY as libc::c_int as libc::c_uint
                    | mflagsapply as libc::c_uint;
            (*spawnee).flags2
                |= mflags2apply as libc::c_uint
                    | MF2_AMBUSH as libc::c_int as libc::c_uint;
            (*spawnee)
                .eflags = ((*spawnee).eflags as libc::c_uint
                | meflagsapply as libc::c_uint) as uint16_t;
            P_SetTarget2(&mut (*hprev).hnext, spawnee);
            P_SetTarget2(&mut (*spawnee).hprev, hprev);
            hprev = spawnee;
        }
        if mwidth == 0 {
            if mdosound != 0 && mnumspokes <= mmin {
                (*spawnee).flags2 |= MF2_BOSSNOTRAP as libc::c_int as uint32_t;
            }
        } else {
            if firsttype as u64 == 0 {
                mwidthset = -mwidth;
            } else if mwidth > 0 as libc::c_int {
                loop {
                    mwidthset -= widthfactor;
                    if !(mwidthset > -mwidth) {
                        break;
                    }
                    spawnee = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, firsttype);
                    P_SetTarget2(&mut (*spawnee).tracer, mobj);
                    (*spawnee).threshold = mphase;
                    (*spawnee).friction = mroll;
                    (*spawnee).movefactor = mwidthset;
                    (*spawnee).movecount = radiusfactor * mlengthset;
                    (*spawnee).angle = myaw as angle_t;
                    (*spawnee).flags
                        |= MF_NOGRAVITY as libc::c_int as libc::c_uint
                            | mflagsapply as libc::c_uint;
                    (*spawnee).flags2
                        |= mflags2apply as libc::c_uint
                            | MF2_AMBUSH as libc::c_int as libc::c_uint;
                    (*spawnee)
                        .eflags = ((*spawnee).eflags as libc::c_uint
                        | meflagsapply as libc::c_uint) as uint16_t;
                    P_SetTarget2(&mut (*hprev).hnext, spawnee);
                    P_SetTarget2(&mut (*spawnee).hprev, hprev);
                    hprev = spawnee;
                    if mdosound != 0 && mwidthset == msound && mnumspokes <= mmin {
                        (*spawnee).flags2 |= MF2_BOSSNOTRAP as libc::c_int as uint32_t;
                    }
                }
            } else {
                loop {
                    mwidthset += widthfactor;
                    if !(mwidthset < -mwidth) {
                        break;
                    }
                    spawnee = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, firsttype);
                    P_SetTarget2(&mut (*spawnee).tracer, mobj);
                    (*spawnee).threshold = mphase;
                    (*spawnee).friction = mroll;
                    (*spawnee).movefactor = mwidthset;
                    (*spawnee).movecount = radiusfactor * mlengthset;
                    (*spawnee).angle = myaw as angle_t;
                    (*spawnee).flags
                        |= MF_NOGRAVITY as libc::c_int as libc::c_uint
                            | mflagsapply as libc::c_uint;
                    (*spawnee).flags2
                        |= mflags2apply as libc::c_uint
                            | MF2_AMBUSH as libc::c_int as libc::c_uint;
                    (*spawnee)
                        .eflags = ((*spawnee).eflags as libc::c_uint
                        | meflagsapply as libc::c_uint) as uint16_t;
                    P_SetTarget2(&mut (*hprev).hnext, spawnee);
                    P_SetTarget2(&mut (*spawnee).hprev, hprev);
                    hprev = spawnee;
                    if mdosound != 0 && mwidthset == msound && mnumspokes <= mmin {
                        (*spawnee).flags2 |= MF2_BOSSNOTRAP as libc::c_int as uint32_t;
                    }
                }
            }
            mwidth = -mwidth;
            if firsttype as u64 != 0 {
                spawnee = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, firsttype);
                P_SetTarget2(&mut (*spawnee).tracer, mobj);
                (*spawnee).threshold = mphase;
                (*spawnee).friction = mroll;
                (*spawnee).movefactor = mwidthset;
                let fresh21 = mlengthset;
                mlengthset = mlengthset - 1;
                (*spawnee).movecount = radiusfactor * fresh21;
                (*spawnee).angle = myaw as angle_t;
                (*spawnee).flags
                    |= MF_NOGRAVITY as libc::c_int as libc::c_uint
                        | mflagsapply as libc::c_uint;
                (*spawnee).flags2
                    |= mflags2apply as libc::c_uint
                        | MF2_AMBUSH as libc::c_int as libc::c_uint;
                (*spawnee)
                    .eflags = ((*spawnee).eflags as libc::c_uint
                    | meflagsapply as libc::c_uint) as uint16_t;
                P_SetTarget2(&mut (*hprev).hnext, spawnee);
                P_SetTarget2(&mut (*spawnee).hprev, hprev);
                hprev = spawnee;
            }
            if linktype as u64 != 0 {
                while mlengthset > mminlength {
                    spawnee = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, linktype);
                    P_SetTarget2(&mut (*spawnee).tracer, mobj);
                    (*spawnee).threshold = mphase;
                    (*spawnee).friction = mroll;
                    (*spawnee).movefactor = mwidthset;
                    let fresh22 = mlengthset;
                    mlengthset = mlengthset - 1;
                    (*spawnee).movecount = radiusfactor * fresh22;
                    (*spawnee).angle = myaw as angle_t;
                    (*spawnee).flags
                        |= MF_NOGRAVITY as libc::c_int as libc::c_uint
                            | mflagsapply as libc::c_uint;
                    (*spawnee).flags2
                        |= mflags2apply as libc::c_uint
                            | 0 as libc::c_int as libc::c_uint;
                    (*spawnee)
                        .eflags = ((*spawnee).eflags as libc::c_uint
                        | meflagsapply as libc::c_uint) as uint16_t;
                    P_SetTarget2(&mut (*hprev).hnext, spawnee);
                    P_SetTarget2(&mut (*spawnee).hprev, hprev);
                    hprev = spawnee;
                }
            }
            if mdocenter != 0 {
                spawnee = P_SpawnMobj((*mobj).x, (*mobj).y, (*mobj).z, linktype);
                P_SetTarget2(&mut (*spawnee).tracer, mobj);
                (*spawnee).threshold = mphase;
                (*spawnee).friction = mroll;
                (*spawnee).movefactor = mwidthset;
                (*spawnee).movecount = 0 as libc::c_int;
                (*spawnee).angle = myaw as angle_t;
                (*spawnee).flags
                    |= MF_NOGRAVITY as libc::c_int as libc::c_uint
                        | mflagsapply as libc::c_uint;
                (*spawnee).flags2
                    |= mflags2apply as libc::c_uint | 0 as libc::c_int as libc::c_uint;
                (*spawnee)
                    .eflags = ((*spawnee).eflags as libc::c_uint
                    | meflagsapply as libc::c_uint) as uint16_t;
                P_SetTarget2(&mut (*hprev).hnext, spawnee);
                P_SetTarget2(&mut (*spawnee).hprev, hprev);
                hprev = spawnee;
            }
        }
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_SetupParticleGen(
    mut mthing: *mut mapthing_t,
    mut mobj: *mut mobj_t,
) -> boolean {
    let mut radius: fixed_t = 0;
    let mut speed: fixed_t = 0;
    let mut zdist: fixed_t = 0;
    let mut type_0: int32_t = 0;
    let mut numdivisions: int32_t = 0;
    let mut anglespeed: int32_t = 0;
    let mut ticcount: int32_t = 0;
    let mut angledivision: angle_t = 0;
    let mut line: int32_t = 0;
    let mthingi: size_t = mthing.offset_from(mapthings) as libc::c_long as size_t;
    line = if (*mthing).args[6 as libc::c_int as usize] != 0 {
        Tag_FindLineSpecial(
            15 as libc::c_int as int16_t,
            (*mthing).args[6 as libc::c_int as usize] as mtag_t,
        )
    } else {
        -(1 as libc::c_int)
    };
    type_0 = if !((*mthing).stringargs[0 as libc::c_int as usize]).is_null() {
        get_number((*mthing).stringargs[0 as libc::c_int as usize])
    } else {
        MT_PARTICLE as libc::c_int
    };
    ticcount = (*mthing).args[4 as libc::c_int as usize];
    if ticcount < 1 as libc::c_int {
        ticcount = 3 as libc::c_int;
    }
    numdivisions = (*mthing).args[0 as libc::c_int as usize];
    if numdivisions != 0 {
        radius = (*mthing).args[1 as libc::c_int as usize] << 16 as libc::c_int;
        anglespeed = (*mthing).args[3 as libc::c_int as usize] % 360 as libc::c_int;
        angledivision = (360 as libc::c_int / numdivisions) as angle_t;
    } else {
        numdivisions = 1 as libc::c_int;
        radius = 0 as libc::c_int;
        anglespeed = 0 as libc::c_int;
        angledivision = 0 as libc::c_int as angle_t;
    }
    speed = abs((*mthing).args[2 as libc::c_int as usize]) << 16 as libc::c_int;
    if (*mthing).options as libc::c_int & 2 as libc::c_int != 0 {
        speed *= -(1 as libc::c_int);
    }
    zdist = abs((*mthing).args[5 as libc::c_int as usize]) << 16 as libc::c_int;
    CONS_Debug(
        0x80 as libc::c_int,
        b"Particle Generator (mapthing #%s):\nRadius is %d\nSpeed is %d\nAnglespeed is %d\nNumdivisions is %d\nAngledivision is %d\nType is %d\nTic separation is %d\n\0"
            as *const u8 as *const libc::c_char,
        sizeu1(mthingi),
        radius,
        speed,
        anglespeed,
        numdivisions,
        angledivision,
        type_0,
        ticcount,
    );
    if line == -(1 as libc::c_int) {
        CONS_Debug(
            0x80 as libc::c_int,
            b"Spawn Z is %d\nZ dist is %d\n\0" as *const u8 as *const libc::c_char,
            (*mobj).z,
            zdist,
        );
    } else {
        CONS_Debug(
            0x80 as libc::c_int,
            b"Heights are taken from control sector\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    (*mobj).angle = 0 as libc::c_int as angle_t;
    (*mobj).movefactor = speed;
    (*mobj).lastlook = numdivisions;
    (*mobj).movedir = angledivision * 0xb60b61 as libc::c_int as angle_t;
    (*mobj).movecount = anglespeed * 0xb60b61 as libc::c_int;
    (*mobj).friction = radius;
    (*mobj).threshold = type_0;
    (*mobj).reactiontime = ticcount;
    (*mobj).extravalue1 = zdist;
    (*mobj).cvmem = line;
    (*mobj).waterbottom = 0 as libc::c_int;
    (*mobj).watertop = (*mobj).waterbottom;
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_SetupNiGHTSDrone(
    mut mthing: *mut mapthing_t,
    mut mobj: *mut mobj_t,
) -> boolean {
    let mut flip: boolean = (*mthing).options as libc::c_int & 2 as libc::c_int;
    let mut timelimit: int16_t = (*mthing).args[0 as libc::c_int as usize] as int16_t;
    let mut hitboxheight: fixed_t = (*mthing).args[1 as libc::c_int as usize]
        << 16 as libc::c_int;
    let mut hitboxradius: fixed_t = (*mthing).args[2 as libc::c_int as usize]
        << 16 as libc::c_int;
    let mut dronemanalignment: int32_t = (*mthing).args[3 as libc::c_int as usize];
    let mut oldheight: fixed_t = (*mobj).height;
    let mut dronemanoffset: fixed_t = 0;
    let mut goaloffset: fixed_t = 0;
    let mut sparkleoffset: fixed_t = 0;
    let mut droneboxmandiff: fixed_t = 0;
    let mut dronemangoaldiff: fixed_t = 0;
    if timelimit as libc::c_int > 0 as libc::c_int {
        (*mobj).health = timelimit as int32_t;
    }
    if hitboxradius > 0 as libc::c_int {
        (*mobj).radius = hitboxradius;
    }
    if hitboxheight > 0 as libc::c_int {
        (*mobj).height = hitboxheight;
    } else {
        (*mobj).height = mobjinfo[MT_NIGHTSDRONE as libc::c_int as usize].height;
    }
    if (*mthing).args[4 as libc::c_int as usize] != 0 {
        (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
    }
    droneboxmandiff = if (*mobj).height
        - mobjinfo[MT_NIGHTSDRONE_MAN as libc::c_int as usize].height > 0 as libc::c_int
    {
        (*mobj).height - mobjinfo[MT_NIGHTSDRONE_MAN as libc::c_int as usize].height
    } else {
        0 as libc::c_int
    };
    dronemangoaldiff = if mobjinfo[MT_NIGHTSDRONE_MAN as libc::c_int as usize].height
        - mobjinfo[MT_NIGHTSDRONE_GOAL as libc::c_int as usize].height > 0 as libc::c_int
    {
        mobjinfo[MT_NIGHTSDRONE_MAN as libc::c_int as usize].height
            - mobjinfo[MT_NIGHTSDRONE_GOAL as libc::c_int as usize].height
    } else {
        0 as libc::c_int
    };
    if flip != 0 && (*mobj).height != oldheight {
        P_SetOrigin(
            mobj,
            (*mobj).x,
            (*mobj).y,
            (*mobj).z - ((*mobj).height - oldheight),
        );
    }
    if flip == 0 {
        match dronemanalignment {
            2 => {
                dronemanoffset = 0 as libc::c_int;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            }
            4 => {
                dronemanoffset = droneboxmandiff / 2 as libc::c_int;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            }
            8 => {
                dronemanoffset = droneboxmandiff;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            }
            1 | _ => {
                dronemanoffset = FixedMul(
                    24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*mobj).scale,
                );
                goaloffset = dronemangoaldiff + dronemanoffset;
            }
        }
        sparkleoffset = goaloffset
            - FixedMul(
                15 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*mobj).scale,
            );
    } else {
        (*mobj)
            .eflags = ((*mobj).eflags as libc::c_int | MFE_VERTICALFLIP as libc::c_int)
            as uint16_t;
        (*mobj).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
        match dronemanalignment {
            2 => {
                dronemanoffset = droneboxmandiff;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            }
            4 => {
                dronemanoffset = droneboxmandiff / 2 as libc::c_int;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            }
            8 => {
                dronemanoffset = 0 as libc::c_int;
                goaloffset = dronemangoaldiff / 2 as libc::c_int + dronemanoffset;
            }
            1 | _ => {
                dronemanoffset = droneboxmandiff
                    - FixedMul(
                        24 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                        (*mobj).scale,
                    );
                goaloffset = dronemangoaldiff + dronemanoffset;
            }
        }
        sparkleoffset = goaloffset
            + FixedMul(
                15 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*mobj).scale,
            );
    }
    let mut goalpost: *mut mobj_t = P_SpawnMobjFromMobj(
        mobj,
        0 as libc::c_int,
        0 as libc::c_int,
        goaloffset,
        MT_NIGHTSDRONE_GOAL,
    );
    let mut sparkle: *mut mobj_t = P_SpawnMobjFromMobj(
        mobj,
        0 as libc::c_int,
        0 as libc::c_int,
        sparkleoffset,
        MT_NIGHTSDRONE_SPARKLING,
    );
    let mut droneman: *mut mobj_t = P_SpawnMobjFromMobj(
        mobj,
        0 as libc::c_int,
        0 as libc::c_int,
        dronemanoffset,
        MT_NIGHTSDRONE_MAN,
    );
    P_SetTarget2(&mut (*mobj).target, goalpost);
    P_SetTarget2(&mut (*goalpost).target, sparkle);
    P_SetTarget2(&mut (*goalpost).tracer, droneman);
    if flip != 0 {
        P_MoveOrigin(goalpost, (*goalpost).x, (*goalpost).y, (*mobj).z + goaloffset);
        P_MoveOrigin(sparkle, (*sparkle).x, (*sparkle).y, (*mobj).z + sparkleoffset);
        P_MoveOrigin(droneman, (*droneman).x, (*droneman).y, (*mobj).z + dronemanoffset);
    }
    (*mobj).flags
        &= !(MF_SLIDEME as libc::c_int | MF_GRENADEBOUNCE as libc::c_int) as uint32_t;
    match dronemanalignment {
        2 => {}
        4 => {
            (*mobj).flags |= MF_GRENADEBOUNCE as libc::c_int as uint32_t;
        }
        8 => {
            (*mobj).flags |= MF_SLIDEME as libc::c_int as uint32_t;
        }
        1 | _ => {
            (*mobj).flags
                |= (MF_SLIDEME as libc::c_int | MF_GRENADEBOUNCE as libc::c_int)
                    as uint32_t;
        }
    }
    (*goalpost).movefactor = (*mobj).z;
    (*goalpost).friction = (*mobj).height;
    (*goalpost)
        .threshold = ((*mobj).flags
        & (MF_SLIDEME as libc::c_int | MF_GRENADEBOUNCE as libc::c_int) as uint32_t)
        as int32_t;
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_SetupBooster(
    mut mthing: *mut mapthing_t,
    mut mobj: *mut mobj_t,
    mut strong: boolean,
) -> boolean {
    let mut angle: angle_t = FixedAngle(
        ((*mthing).angle as libc::c_int) << 16 as libc::c_int,
    );
    let mut x1: fixed_t = *finecosine
        .offset(
            (angle >> 19 as libc::c_int
                & (8192 as libc::c_int - 1 as libc::c_int) as angle_t) as isize,
        ) >> 16 as libc::c_int - 16 as libc::c_int;
    let mut y1: fixed_t = finesine[(angle >> 19 as libc::c_int
        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t) as usize]
        >> 16 as libc::c_int - 16 as libc::c_int;
    let mut x2: fixed_t = *finecosine
        .offset(
            (angle.wrapping_add(0x40000000 as libc::c_int as angle_t)
                >> 19 as libc::c_int
                & (8192 as libc::c_int - 1 as libc::c_int) as angle_t) as isize,
        ) >> 16 as libc::c_int - 16 as libc::c_int;
    let mut y2: fixed_t = finesine[(angle
        .wrapping_add(0x40000000 as libc::c_int as angle_t) >> 19 as libc::c_int
        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t) as usize]
        >> 16 as libc::c_int - 16 as libc::c_int;
    let mut facestate: statenum_t = (if strong != 0 {
        S_REDBOOSTERSEG_FACE as libc::c_int
    } else {
        S_YELLOWBOOSTERSEG_FACE as libc::c_int
    }) as statenum_t;
    let mut leftstate: statenum_t = (if strong != 0 {
        S_REDBOOSTERSEG_LEFT as libc::c_int
    } else {
        S_YELLOWBOOSTERSEG_LEFT as libc::c_int
    }) as statenum_t;
    let mut rightstate: statenum_t = (if strong != 0 {
        S_REDBOOSTERSEG_RIGHT as libc::c_int
    } else {
        S_YELLOWBOOSTERSEG_RIGHT as libc::c_int
    }) as statenum_t;
    let mut rollerstate: statenum_t = (if strong != 0 {
        S_REDBOOSTERROLLER as libc::c_int
    } else {
        S_YELLOWBOOSTERROLLER as libc::c_int
    }) as statenum_t;
    let mut seg: *mut mobj_t = P_SpawnMobjFromMobj(
        mobj,
        26 as libc::c_int * x1,
        26 as libc::c_int * y1,
        0 as libc::c_int,
        MT_BOOSTERSEG,
    );
    (*seg).angle = angle.wrapping_sub(0x40000000 as libc::c_int as angle_t);
    P_SetMobjState(seg, facestate);
    seg = P_SpawnMobjFromMobj(
        mobj,
        -(26 as libc::c_int) * x1,
        -(26 as libc::c_int) * y1,
        0 as libc::c_int,
        MT_BOOSTERSEG,
    );
    (*seg).angle = angle.wrapping_add(0x40000000 as libc::c_int as angle_t);
    P_SetMobjState(seg, facestate);
    seg = P_SpawnMobjFromMobj(
        mobj,
        21 as libc::c_int * x2,
        21 as libc::c_int * y2,
        0 as libc::c_int,
        MT_BOOSTERSEG,
    );
    (*seg).angle = angle;
    P_SetMobjState(seg, leftstate);
    seg = P_SpawnMobjFromMobj(
        mobj,
        -(21 as libc::c_int) * x2,
        -(21 as libc::c_int) * y2,
        0 as libc::c_int,
        MT_BOOSTERSEG,
    );
    (*seg).angle = angle;
    P_SetMobjState(seg, rightstate);
    seg = P_SpawnMobjFromMobj(
        mobj,
        13 as libc::c_int * (x1 + x2),
        13 as libc::c_int * (y1 + y2),
        0 as libc::c_int,
        MT_BOOSTERROLLER,
    );
    (*seg).angle = angle;
    P_SetMobjState(seg, rollerstate);
    seg = P_SpawnMobjFromMobj(
        mobj,
        13 as libc::c_int * (x1 - x2),
        13 as libc::c_int * (y1 - y2),
        0 as libc::c_int,
        MT_BOOSTERROLLER,
    );
    (*seg).angle = angle;
    P_SetMobjState(seg, rollerstate);
    seg = P_SpawnMobjFromMobj(
        mobj,
        -(13 as libc::c_int) * (x1 + x2),
        -(13 as libc::c_int) * (y1 + y2),
        0 as libc::c_int,
        MT_BOOSTERROLLER,
    );
    (*seg).angle = angle;
    P_SetMobjState(seg, rollerstate);
    seg = P_SpawnMobjFromMobj(
        mobj,
        -(13 as libc::c_int) * (x1 - x2),
        -(13 as libc::c_int) * (y1 - y2),
        0 as libc::c_int,
        MT_BOOSTERROLLER,
    );
    (*seg).angle = angle;
    P_SetMobjState(seg, rollerstate);
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_MakeSoftwareCorona(
    mut mo: *mut mobj_t,
    mut height: int32_t,
) -> *mut mobj_t {
    let mut corona: *mut mobj_t = P_SpawnMobjFromMobj(
        mo,
        0 as libc::c_int,
        0 as libc::c_int,
        height << 16 as libc::c_int,
        MT_PARTICLE,
    );
    (*corona).sprite = SPR_FLAM;
    (*corona)
        .frame = (0x100000 as libc::c_int
        | (tr_trans90 as libc::c_int) << 16 as libc::c_int | 12 as libc::c_int)
        as uint32_t;
    (*corona).tics = -(1 as libc::c_int);
    return corona;
}
unsafe extern "C" fn P_MapAlreadyHasStarPost(mut mobj: *mut mobj_t) -> boolean {
    let mut th: *mut thinker_t = 0 as *mut thinker_t;
    let mut mo2: *mut mobj_t = 0 as *mut mobj_t;
    th = (*thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)).next;
    while th
        != &mut *thlist.as_mut_ptr().offset(THINK_MOBJ as libc::c_int as isize)
            as *mut thinker_t
    {
        if !((*th).function.acp1
            == ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut thinker_t) -> ()>,
                actionf_p1,
            >(
                Some(
                    P_RemoveThinkerDelayed as unsafe extern "C" fn(*mut thinker_t) -> (),
                ),
            ))
        {
            mo2 = th as *mut mobj_t;
            if !(mo2 == mobj) {
                if (*mo2).type_0 as libc::c_uint
                    == MT_STARPOST as libc::c_int as libc::c_uint
                    && (*mo2).health == (*mobj).health
                {
                    return true_0 as libc::c_int;
                }
            }
        }
        th = (*th).next;
    }
    return false_0 as libc::c_int;
}
unsafe extern "C" fn P_SetupSpawnedMapThing(
    mut mthing: *mut mapthing_t,
    mut mobj: *mut mobj_t,
    mut doangle: *mut boolean,
) -> boolean {
    let mut override_0: boolean = LUA_HookMapThingSpawn(mobj, mthing);
    if P_MobjWasRemoved(mobj) != 0 {
        return false_0 as libc::c_int;
    }
    if override_0 != 0 {
        return true_0 as libc::c_int;
    }
    let mut current_block_239: u64;
    match (*mobj).type_0 as libc::c_uint {
        117 => {
            if P_SetupEmblem(mthing, mobj) == 0 {
                return false_0 as libc::c_int;
            }
            current_block_239 = 18078460720374183796;
        }
        620 => {
            let mut tag: mtag_t = Tag_FGet(&mut (*mthing).tags);
            if (tag as libc::c_int) < 0 as libc::c_int
                || tag as libc::c_int > 15 as libc::c_int
            {
                CONS_Debug(
                    0x80 as libc::c_int,
                    b"P_SetupSpawnedMapThing: Skybox ID %d of mapthing %s is not between 0 and 15!\n\0"
                        as *const u8 as *const libc::c_char,
                    tag as libc::c_int,
                    sizeu1(mthing.offset_from(mapthings) as libc::c_long as size_t),
                );
            } else if (*mthing).args[0 as libc::c_int as usize] != 0 {
                skyboxcenterpnts[tag as usize] = mobj;
            } else {
                skyboxviewpnts[tag as usize] = mobj;
            }
            current_block_239 = 18078460720374183796;
        }
        271 => {
            if (*mthing).args[1 as libc::c_int as usize] != 0 {
                (*mobj).color = SKINCOLOR_GOLD as libc::c_int as uint16_t;
                (*mobj).colorized = true_0 as libc::c_int;
            }
            current_block_239 = 18078460720374183796;
        }
        66 => {
            if (*mthing).args[5 as libc::c_int as usize] == 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        70 => {
            (*mobj).cusval = (*mthing).args[0 as libc::c_int as usize];
            current_block_239 = 18078460720374183796;
        }
        145 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        128 => {
            if (*mthing).args[1 as libc::c_int as usize] & TMF_INVISIBLE as libc::c_int
                != 0
            {
                P_UnsetThingPosition(mobj);
                if !sector_list.is_null() {
                    P_DelSeclist(sector_list);
                    sector_list = 0 as *mut msecnode_t;
                }
                (*mobj).flags |= MF_NOSECTOR as libc::c_int as uint32_t;
                P_SetThingPosition(mobj);
            }
            if (*mthing).args[1 as libc::c_int as usize]
                & TMF_NODISTANCECHECK as libc::c_int != 0
            {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).health = (*mthing).args[0 as libc::c_int as usize];
            } else {
                (*mobj)
                    .health = FixedMul(
                    (*(*(*mobj).subsector).sector).ceilingheight
                        - (*(*(*mobj).subsector).sector).floorheight,
                    3 as libc::c_int
                        * (((1 as libc::c_int) << 16 as libc::c_int) / 4 as libc::c_int),
                ) >> 16 as libc::c_int;
            }
            current_block_239 = 18078460720374183796;
        }
        78 => {
            if (*mthing).args[5 as libc::c_int as usize] & TMF_GRAYSCALE as libc::c_int
                != 0
            {
                (*mobj).color = SKINCOLOR_SILVER as libc::c_int as uint16_t;
                (*mobj).colorized = true_0 as libc::c_int;
                (*mobj).flags2 |= MF2_SLIDEPUSH as libc::c_int as uint32_t;
            }
            if (*mthing).args[5 as libc::c_int as usize] & TMF_SKIPINTRO as libc::c_int
                != 0
            {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        104 => {
            if (*mthing).args[5 as libc::c_int as usize] != 0 {
                (*mobj).color = SKINCOLOR_SILVER as libc::c_int as uint16_t;
                (*mobj).colorized = true_0 as libc::c_int;
                (*mobj).flags2 |= MF2_SLIDEPUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        103 | 394 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).color = SKINCOLOR_SILVER as libc::c_int as uint16_t;
                (*mobj).colorized = true_0 as libc::c_int;
                (*mobj).flags2 |= MF2_SLIDEPUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        131 => {
            if !((*mthing).stringargs[0 as libc::c_int as usize]).is_null() {
                (*mobj)
                    .color = get_number((*mthing).stringargs[0 as libc::c_int as usize])
                    as uint16_t;
            }
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        269 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                let mut corona: *mut mobj_t = P_MakeSoftwareCorona(
                    mobj,
                    20 as libc::c_int,
                );
                (*corona).destscale = (*mobj).scale * 3 as libc::c_int;
                P_SetScale(corona, (*corona).destscale);
                P_SetTarget2(&mut (*mobj).tracer, corona);
            }
            current_block_239 = 18078460720374183796;
        }
        299 => {
            if (*mthing).args[0 as libc::c_int as usize] & TMFH_NOFLAME as libc::c_int
                == 0
            {
                let mut flame: *mut mobj_t = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    (*mobj).height,
                    MT_FLAME,
                );
                P_SetTarget2(&mut (*flame).target, mobj);
                (*flame).flags2 |= MF2_BOSSNOTRAP as libc::c_int as uint32_t;
                if (*mthing).args[0 as libc::c_int as usize] & TMFH_CORONA as libc::c_int
                    != 0
                {
                    let mut corona_0: *mut mobj_t = P_MakeSoftwareCorona(
                        flame,
                        20 as libc::c_int,
                    );
                    (*corona_0).destscale = (*flame).scale * 3 as libc::c_int;
                    P_SetScale(corona_0, (*corona_0).destscale);
                    P_SetTarget2(&mut (*flame).tracer, corona_0);
                }
            }
            current_block_239 = 18078460720374183796;
        }
        297 | 298 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                P_MakeSoftwareCorona(
                    mobj,
                    if (*mobj).type_0 as libc::c_uint
                        == MT_CANDLE as libc::c_int as libc::c_uint
                    {
                        42 as libc::c_int
                    } else {
                        176 as libc::c_int
                    },
                );
            }
            current_block_239 = 18078460720374183796;
        }
        396 | 397 | 398 => {
            if (*mthing).args[0 as libc::c_int as usize] == 0 {
                let mut overlay: *mut mobj_t = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    MT_OVERLAY,
                );
                P_SetTarget2(&mut (*overlay).target, mobj);
                P_SetMobjState(overlay, (*(*mobj).info).raisestate);
            }
            current_block_239 = 18078460720374183796;
        }
        254 => {
            (*mobj)
                .tics = 3 as libc::c_int * 35 as libc::c_int
                + (*mthing).args[0 as libc::c_int as usize];
            current_block_239 = 18078460720374183796;
        }
        347 | 348 => {
            (*mobj).movecount = (*mthing).args[0 as libc::c_int as usize];
            (*mobj).threshold = (*mthing).args[1 as libc::c_int as usize];
            (*mobj).movedir = (*mthing).args[2 as libc::c_int as usize] as angle_t;
            if (*mthing).args[3 as libc::c_int as usize] != 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        272 | 273 | 274 | 275 | 277 | 278 => {
            if P_SetupMace(mthing, mobj, doangle) == 0 {
                return false_0 as libc::c_int;
            }
            current_block_239 = 18078460720374183796;
        }
        518 => {
            if P_SetupParticleGen(mthing, mobj) == 0 {
                return false_0 as libc::c_int;
            }
            current_block_239 = 18078460720374183796;
        }
        17 => {
            (*mobj)
                .threshold = if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mthing).args[0 as libc::c_int as usize]
            } else {
                35 as libc::c_int * 2 as libc::c_int - 1 as libc::c_int
            };
            current_block_239 = 18078460720374183796;
        }
        576 => {
            (*mobj)
                .threshold = ((*mthing).pitch as libc::c_int / 30 as libc::c_int
                + 3 as libc::c_int) % 12 as libc::c_int;
            P_SetMobjState(
                mobj,
                ((*(*mobj).info).spawnstate as libc::c_uint)
                    .wrapping_add((*mobj).threshold as libc::c_uint) as statenum_t,
            );
            current_block_239 = 18078460720374183796;
        }
        590 => {
            (*mobj)
                .threshold = if (*mthing).args[0 as libc::c_int as usize]
                < 7 as libc::c_int
            {
                (*mthing).args[0 as libc::c_int as usize]
            } else {
                7 as libc::c_int
            };
            (*mobj).health = (*mthing).args[1 as libc::c_int as usize];
            if (*mobj).health <= 0 as libc::c_int {
                (*mobj).health = 20 as libc::c_int;
            }
            current_block_239 = 18078460720374183796;
        }
        613 => {
            let mut sequence: uint8_t = (*mthing).args[0 as libc::c_int as usize]
                as uint8_t;
            let mut id: uint8_t = (*mthing).args[1 as libc::c_int as usize] as uint8_t;
            (*mobj).health = id as int32_t;
            (*mobj).threshold = sequence as int32_t;
            P_AddWaypoint(sequence, id, mobj);
            current_block_239 = 18078460720374183796;
        }
        591 => {
            (*mobj).health = (*mthing).args[0 as libc::c_int as usize];
            current_block_239 = 18078460720374183796;
        }
        570 => {
            if P_SetupNiGHTSDrone(mthing, mobj) == 0 {
                return false_0 as libc::c_int;
            }
            current_block_239 = 18078460720374183796;
        }
        599 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).extravalue1 = (*mthing).args[0 as libc::c_int as usize];
            }
            current_block_239 = 18078460720374183796;
        }
        364 | 365 | 366 | 367 => {
            (*mobj).tics += (*mthing).args[1 as libc::c_int as usize];
            current_block_239 = 18078460720374183796;
        }
        265 | 266 | 262 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                P_SetScale(mobj, 2 as libc::c_int * (*mobj).scale);
                (*mobj).destscale = (*mobj).scale;
            }
            current_block_239 = 18078460720374183796;
        }
        248 => {
            let mut mobjangle: angle_t = FixedAngle(
                ((*mthing).angle as libc::c_int % 113 as libc::c_int)
                    << 16 as libc::c_int,
            );
            (*P_SpawnMobjFromMobj(
                mobj,
                (1 as libc::c_int) << 16 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                MT_THZTREEBRANCH,
            ))
                .angle = mobjangle.wrapping_add(0x10000000 as libc::c_int as angle_t);
            (*P_SpawnMobjFromMobj(
                mobj,
                0 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                0 as libc::c_int,
                MT_THZTREEBRANCH,
            ))
                .angle = mobjangle.wrapping_add(0x70000000 as libc::c_int as angle_t);
            (*P_SpawnMobjFromMobj(
                mobj,
                -((1 as libc::c_int) << 16 as libc::c_int),
                0 as libc::c_int,
                0 as libc::c_int,
                MT_THZTREEBRANCH,
            ))
                .angle = mobjangle.wrapping_add(0xc0000000 as libc::c_uint);
            current_block_239 = 18078460720374183796;
        }
        224 => {
            let mut i: int32_t = 0;
            let mut segment: *mut mobj_t = 0 as *mut mobj_t;
            i = 0 as libc::c_int;
            while i < 6 as libc::c_int {
                segment = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    MT_TUTORIALLEAF,
                );
                (*segment)
                    .angle = ((*mobj).angle)
                    .wrapping_add(
                        FixedAngle(
                            i * 60 as libc::c_int
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                        ),
                    );
                P_SetMobjState(
                    segment,
                    (S_TUTORIALLEAF1 as libc::c_int
                        + (*mthing).args[0 as libc::c_int as usize]) as statenum_t,
                );
                i += 1;
                i;
            }
            i = 0 as libc::c_int;
            while i < 3 as libc::c_int {
                segment = P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    112 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    MT_TUTORIALFLOWER,
                );
                (*segment)
                    .angle = ((*mobj).angle)
                    .wrapping_add(
                        FixedAngle(
                            i * 120 as libc::c_int
                                * ((1 as libc::c_int) << 16 as libc::c_int),
                        ),
                    );
                P_SetMobjState(
                    segment,
                    (S_TUTORIALFLOWER1 as libc::c_int
                        + (*mthing).args[0 as libc::c_int as usize]) as statenum_t,
                );
                i += 1;
                i;
            }
            P_SetMobjState(
                P_SpawnMobjFromMobj(
                    mobj,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    112 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    MT_TUTORIALFLOWERF,
                ),
                (S_TUTORIALFLOWERF1 as libc::c_int
                    + (*mthing).args[0 as libc::c_int as usize]) as statenum_t,
            );
            current_block_239 = 18078460720374183796;
        }
        290 | 291 => {
            let mut mobjangle_0: angle_t = FixedAngle(
                ((*mthing).angle as libc::c_int) << 16 as libc::c_int,
            );
            (*P_SpawnMobjFromMobj(
                mobj,
                P_ReturnThrustX(
                    mobj,
                    mobjangle_0,
                    (4 as libc::c_int) << 16 as libc::c_int,
                ),
                P_ReturnThrustY(
                    mobj,
                    mobjangle_0,
                    (4 as libc::c_int) << 16 as libc::c_int,
                ),
                0 as libc::c_int,
                (if (*mobj).type_0 as libc::c_uint
                    == MT_CEZPOLE1 as libc::c_int as libc::c_uint
                {
                    MT_CEZBANNER1 as libc::c_int
                } else {
                    MT_CEZBANNER2 as libc::c_int
                }) as mobjtype_t,
            ))
                .angle = mobjangle_0.wrapping_add(0x40000000 as libc::c_int as angle_t);
            current_block_239 = 18078460720374183796;
        }
        399 => {
            let mut mobjangle_1: angle_t = FixedAngle(
                ((*mthing).angle as libc::c_int) << 16 as libc::c_int,
            ) & (0x40000000 as libc::c_int - 1 as libc::c_int) as angle_t;
            let mut leaf: *mut mobj_t = 0 as *mut mobj_t;
            leaf = P_SpawnMobjFromMobj(
                mobj,
                (1 as libc::c_int) << 16 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                MT_HHZTREE_PART,
            );
            (*leaf).angle = mobjangle_1;
            P_SetMobjState(leaf, (*(*leaf).info).seestate);
            mobjangle_1 = mobjangle_1.wrapping_add(0x40000000 as libc::c_int as angle_t);
            leaf = P_SpawnMobjFromMobj(
                mobj,
                0 as libc::c_int,
                (1 as libc::c_int) << 16 as libc::c_int,
                0 as libc::c_int,
                MT_HHZTREE_PART,
            );
            (*leaf).angle = mobjangle_1;
            P_SetMobjState(leaf, (*(*leaf).info).seestate);
            mobjangle_1 = mobjangle_1.wrapping_add(0x40000000 as libc::c_int as angle_t);
            leaf = P_SpawnMobjFromMobj(
                mobj,
                -((1 as libc::c_int) << 16 as libc::c_int),
                0 as libc::c_int,
                0 as libc::c_int,
                MT_HHZTREE_PART,
            );
            (*leaf).angle = mobjangle_1;
            P_SetMobjState(leaf, (*(*leaf).info).seestate);
            mobjangle_1 = mobjangle_1.wrapping_add(0x40000000 as libc::c_int as angle_t);
            leaf = P_SpawnMobjFromMobj(
                mobj,
                0 as libc::c_int,
                -((1 as libc::c_int) << 16 as libc::c_int),
                0 as libc::c_int,
                MT_HHZTREE_PART,
            );
            (*leaf).angle = mobjangle_1;
            P_SetMobjState(leaf, (*(*leaf).info).seestate);
            mobjangle_1 = mobjangle_1.wrapping_add(0x40000000 as libc::c_int as angle_t);
            current_block_239 = 18078460720374183796;
        }
        602 => {
            if (*mthing).args[0 as libc::c_int as usize] > 0 as libc::c_int {
                (*mobj).tics += (*mthing).args[0 as libc::c_int as usize];
            }
            current_block_239 = 18078460720374183796;
        }
        353 => {
            (*mobj).fuse = 30 as libc::c_int + (*mthing).args[0 as libc::c_int as usize];
            if (*mthing).args[1 as libc::c_int as usize] != 0 {
                P_SetScale(mobj, 2 as libc::c_int * (*mobj).scale);
                (*mobj).destscale = (*mobj).scale;
            }
            current_block_239 = 18078460720374183796;
        }
        45 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                P_SetMobjState(mobj, (*(*mobj).info).meleestate);
                (*mobj).extravalue2 = 2 as libc::c_int;
                S_StartSound(mobj as *const libc::c_void, sfx_s3kc2l);
            }
            current_block_239 = 18078460720374183796;
        }
        359 => {
            let mut angle: angle_t = FixedAngle(
                ((*mthing).angle as libc::c_int) << 16 as libc::c_int,
            );
            let mut j: uint8_t = 0;
            j = 0 as libc::c_int as uint8_t;
            while (j as libc::c_int) < 8 as libc::c_int {
                let mut fa: angle_t = angle >> 19 as libc::c_int
                    & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
                let mut xoffs: fixed_t = *finecosine.offset(fa as isize)
                    >> 16 as libc::c_int - 16 as libc::c_int;
                let mut yoffs: fixed_t = finesine[fa as usize]
                    >> 16 as libc::c_int - 16 as libc::c_int;
                let mut leaf_0: *mut mobj_t = P_SpawnMobjFromMobj(
                    mobj,
                    xoffs,
                    yoffs,
                    0 as libc::c_int,
                    MT_BIGFERNLEAF,
                );
                (*leaf_0).angle = angle;
                angle = angle.wrapping_add(0x20000000 as libc::c_int as angle_t);
                j = j.wrapping_add(1);
                j;
            }
            current_block_239 = 18078460720374183796;
        }
        144 | 143 => {
            if P_SetupBooster(
                mthing,
                mobj,
                ((*mobj).type_0 as libc::c_uint
                    == MT_REDBOOSTER as libc::c_int as libc::c_uint) as libc::c_int,
            ) == 0
            {
                return false_0 as libc::c_int;
            }
            current_block_239 = 18078460720374183796;
        }
        567 => {
            if (*mthing).args[3 as libc::c_int as usize] != 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            (*mobj)
                .radius = abs((*mthing).args[2 as libc::c_int as usize])
                << 16 as libc::c_int;
            current_block_239 = 15918027203073406300;
        }
        568 | 569 => {
            current_block_239 = 15918027203073406300;
        }
        114 => {
            (*mobj).health = (1 as libc::c_int) << tokenbits - 1 as libc::c_int;
            current_block_239 = 18078460720374183796;
        }
        92 => {
            if (*mthing).args[6 as libc::c_int as usize] & TMB_BARRIER as libc::c_int
                != 0
            {
                let mut elecmobj: *mut mobj_t = 0 as *mut mobj_t;
                elecmobj = P_SpawnMobj(
                    (*mobj).x,
                    (*mobj).y,
                    (*mobj).z,
                    MT_CYBRAKDEMON_ELECTRIC_BARRIER,
                );
                P_SetTarget2(&mut (*elecmobj).target, mobj);
                (*elecmobj)
                    .angle = FixedAngle(
                    ((*mthing).angle as libc::c_int) << 16 as libc::c_int,
                );
                (*elecmobj).destscale = (*mobj).scale * 2 as libc::c_int;
                P_SetScale(elecmobj, (*elecmobj).destscale);
            }
            current_block_239 = 18078460720374183796;
        }
        152 => {
            (*mobj)
                .health = (*mthing).args[0 as libc::c_int as usize] + 1 as libc::c_int;
            if P_MapAlreadyHasStarPost(mobj) == 0 {
                numstarposts += 1;
                numstarposts;
            }
            current_block_239 = 18078460720374183796;
        }
        149 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).flags &= !(MF_SCENERY as libc::c_int) as uint32_t;
                (*mobj).fuse = (*mthing).args[1 as libc::c_int as usize];
            }
            if (*mthing).args[2 as libc::c_int as usize] & TMSF_RETRACTED as libc::c_int
                != 0
            {
                P_SetMobjState(mobj, (*(*mobj).info).meleestate);
            }
            if (*mthing).args[2 as libc::c_int as usize] & TMSF_INTANGIBLE as libc::c_int
                == 0 && metalrecording == 0
            {
                P_UnsetThingPosition(mobj);
                (*mobj).flags
                    &= !(MF_NOBLOCKMAP as libc::c_int | MF_NOGRAVITY as libc::c_int
                        | MF_NOCLIPHEIGHT as libc::c_int) as uint32_t;
                (*mobj).flags |= MF_SOLID as libc::c_int as uint32_t;
                P_SetThingPosition(mobj);
            }
            current_block_239 = 18078460720374183796;
        }
        150 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).flags &= !(MF_SCENERY as libc::c_int) as uint32_t;
                (*mobj).fuse = (*mthing).args[1 as libc::c_int as usize];
            }
            if (*mthing).args[2 as libc::c_int as usize] & TMSF_RETRACTED as libc::c_int
                != 0
            {
                P_SetMobjState(mobj, (*(*mobj).info).meleestate);
            }
            if (*mthing).args[2 as libc::c_int as usize] & TMSF_INTANGIBLE as libc::c_int
                == 0 && metalrecording == 0
            {
                P_UnsetThingPosition(mobj);
                (*mobj).flags
                    &= !(MF_NOBLOCKMAP as libc::c_int | MF_NOCLIPHEIGHT as libc::c_int)
                        as uint32_t;
                (*mobj).flags |= MF_SOLID as libc::c_int as uint32_t;
                P_SetThingPosition(mobj);
            }
            let mobjangle_2: angle_t = FixedAngle(
                ((*mthing).angle as libc::c_int) << 16 as libc::c_int,
            );
            let baseradius: fixed_t = (*mobj).radius - (*mobj).scale;
            let mut base: *mut mobj_t = P_SpawnMobj(
                (*mobj).x - P_ReturnThrustX(mobj, mobjangle_2, baseradius),
                (*mobj).y - P_ReturnThrustY(mobj, mobjangle_2, baseradius),
                (*mobj).z,
                MT_WALLSPIKEBASE,
            );
            (*base)
                .angle = mobjangle_2.wrapping_add(0x40000000 as libc::c_int as angle_t);
            (*base).destscale = (*mobj).destscale;
            P_SetScale(base, (*mobj).scale);
            P_SetTarget2(&mut (*base).target, mobj);
            P_SetTarget2(&mut (*mobj).tracer, base);
            current_block_239 = 18078460720374183796;
        }
        157 => {
            if nummaprings >= 0 as libc::c_int {
                nummaprings += 10 as libc::c_int;
            }
            current_block_239 = 18078460720374183796;
        }
        309 | 310 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                let mut offset: fixed_t = FixedMul(
                    16 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*mobj).scale,
                );
                (*mobj).momx
                    += if P_RandomFixed()
                        < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
                    {
                        offset
                    } else {
                        -offset
                    };
                (*mobj).momy
                    += if P_RandomFixed()
                        < ((1 as libc::c_int) << 16 as libc::c_int) / 2 as libc::c_int
                    {
                        offset
                    } else {
                        -offset
                    };
                (*mobj).momz += offset;
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        115 => {
            redflag = mobj;
            rflagpoint = (*mobj).spawnpoint;
            current_block_239 = 18078460720374183796;
        }
        116 => {
            blueflag = mobj;
            bflagpoint = (*mobj).spawnpoint;
            current_block_239 = 18078460720374183796;
        }
        583 => {
            if maptol & TOL_XMAS as libc::c_int as uint32_t != 0 {
                P_SetMobjState(mobj, (*(*mobj).info).seestate);
            }
            current_block_239 = 18078460720374183796;
        }
        135 | 136 | 137 => {
            (*mobj)
                .angle = FixedAngle(
                ((*mthing).angle as libc::c_int) << 16 as libc::c_int,
            );
            if (*mthing).args[0 as libc::c_int as usize] & TMDS_NOGRAVITY as libc::c_int
                != 0
            {
                (*mobj).flags |= MF_NOGRAVITY as libc::c_int as uint32_t;
            }
            if (*mthing).args[0 as libc::c_int as usize]
                & TMDS_ROTATEEXTRA as libc::c_int != 0
            {
                (*mobj)
                    .angle = ((*mobj).angle)
                    .wrapping_add(0x10000000 as libc::c_int as angle_t);
            }
            *doangle = false_0 as libc::c_int;
            current_block_239 = 18078460720374183796;
        }
        527 => {
            if !((*mthing).stringargs[0 as libc::c_int as usize]).is_null() {
                (*mobj)
                    .threshold = get_number(
                    (*mthing).stringargs[0 as libc::c_int as usize],
                );
            }
            (*mobj)
                .health = if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mthing).args[0 as libc::c_int as usize]
            } else {
                35 as libc::c_int
            };
            current_block_239 = 18078460720374183796;
        }
        9 | 10 | 11 | 12 | 29 | 19 | 22 | 600 | 603 | 593 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        32 => {
            if (*mthing).args[1 as libc::c_int as usize] != 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        129 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        341 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        346 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        356 => {
            if (*mthing).args[0 as libc::c_int as usize] != 0 {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            current_block_239 = 18078460720374183796;
        }
        _ => {
            current_block_239 = 18078460720374183796;
        }
    }
    match current_block_239 {
        15918027203073406300 => {
            (*mobj)
                .threshold = if (*mthing).args[0 as libc::c_int as usize]
                < 7 as libc::c_int
            {
                (*mthing).args[0 as libc::c_int as usize]
            } else {
                7 as libc::c_int
            };
            (*mobj).health = (*mthing).args[1 as libc::c_int as usize];
            (*mobj).flags2 |= MF2_AXIS as libc::c_int as uint32_t;
        }
        _ => {}
    }
    if (*mobj).flags & MF_BOSS as libc::c_int as uint32_t != 0 {
        if (*mthing).args[1 as libc::c_int as usize] != 0 {
            (*mobj).flags2 |= MF2_BOSSNOTRAP as libc::c_int as uint32_t;
        }
    }
    if (*mobj).flags & MF_NIGHTSITEM as libc::c_int as uint32_t != 0 {
        if (*mthing).args[0 as libc::c_int as usize] & TMNI_BONUSONLY as libc::c_int != 0
        {
            (*mobj).flags2 |= MF2_STRONGBOX as libc::c_int as uint32_t;
        }
        if (*mthing).args[0 as libc::c_int as usize] & TMNI_REVEAL as libc::c_int != 0 {
            (*mobj).flags |= MF_SPECIAL as libc::c_int as uint32_t;
            (*mobj).flags &= !(MF_NIGHTSITEM as libc::c_int) as uint32_t;
        }
    }
    if (*mobj).flags & MF_PUSHABLE as libc::c_int as uint32_t != 0 {
        match (*mthing).args[0 as libc::c_int as usize] {
            1 => {
                (*mobj).flags2 |= MF2_SLIDEPUSH as libc::c_int as uint32_t;
                (*mobj).flags |= MF_BOUNCE as libc::c_int as uint32_t;
            }
            2 => {
                (*mobj).flags &= !(MF_PUSHABLE as libc::c_int) as uint32_t;
            }
            3 => {
                (*mobj).flags2 |= MF2_CLASSICPUSH as libc::c_int as uint32_t;
            }
            0 | _ => {}
        }
    }
    if (*mobj).flags & MF_SPRING as libc::c_int as uint32_t != 0
        && (*(*mobj).info).painchance == 3 as libc::c_int
    {
        if (*mthing).args[0 as libc::c_int as usize] != 0 {
            (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
        }
    }
    if (*mobj).flags & MF_MONITOR as libc::c_int as uint32_t != 0
        && (*(*mobj).info).speed != 0 as libc::c_int
    {
        match (*mthing).args[1 as libc::c_int as usize] {
            1 => {
                (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
            }
            2 => {
                (*mobj).flags2 |= MF2_STRONGBOX as libc::c_int as uint32_t;
            }
            0 | _ => {}
        }
    }
    if (*mobj).flags & MF_AMBIENT as libc::c_int as uint32_t != 0
        && (*mobj).type_0 as libc::c_uint != MT_AMBIENT as libc::c_int as libc::c_uint
    {
        (*mobj).threshold = (*(*mobj).info).seesound as int32_t;
        (*mobj).health = (*(*mobj).info).spawnhealth;
    }
    return true_0 as libc::c_int;
}
unsafe extern "C" fn P_SetAmbush(mut mthing: *mut mapthing_t, mut mobj: *mut mobj_t) {
    if (*mobj).type_0 as libc::c_uint == MT_NIGHTSBUMPER as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint == MT_AXIS as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_AXISTRANSFER as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_AXISTRANSFERLINE as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint
            == MT_NIGHTSBUMPER as libc::c_int as libc::c_uint
        || (*mobj).type_0 as libc::c_uint == MT_STARPOST as libc::c_int as libc::c_uint
    {
        return;
    }
    if (*mthing).options as libc::c_int & 4 as libc::c_int != 0
        && (*mobj).flags & MF_PUSHABLE as libc::c_int as uint32_t != 0
    {
        return;
    }
    (*mobj).flags2 |= MF2_AMBUSH as libc::c_int as uint32_t;
}
unsafe extern "C" fn P_SpawnMobjFromMapThing(
    mut mthing: *mut mapthing_t,
    mut x: fixed_t,
    mut y: fixed_t,
    mut z: fixed_t,
    mut i: mobjtype_t,
) -> *mut mobj_t {
    let mut mobj: *mut mobj_t = 0 as *mut mobj_t;
    let mut doangle: boolean = true_0 as libc::c_int;
    mobj = P_SpawnMobj(x, y, z, i);
    (*mobj).spawnpoint = mthing;
    P_SetScale(mobj, FixedMul((*mobj).scale, (*mthing).scale));
    (*mobj).destscale = FixedMul((*mobj).destscale, (*mthing).scale);
    (*mobj).spritexscale = (*mthing).spritexscale;
    (*mobj).spriteyscale = (*mthing).spriteyscale;
    if P_SetupSpawnedMapThing(mthing, mobj, &mut doangle) == 0 {
        return mobj;
    }
    if doangle != 0 {
        (*mobj)
            .angle = FixedAngle(((*mthing).angle as libc::c_int) << 16 as libc::c_int);
    }
    (*mobj).pitch = FixedAngle(((*mthing).pitch as libc::c_int) << 16 as libc::c_int);
    (*mobj).roll = FixedAngle(((*mthing).roll as libc::c_int) << 16 as libc::c_int);
    (*mthing).mobj = mobj;
    if udmf == 0 && (*mthing).options as libc::c_int & 8 as libc::c_int != 0 {
        P_SetAmbush(mthing, mobj);
    }
    if (*mthing).options as libc::c_int & 2 as libc::c_int != 0 {
        (*mobj)
            .eflags = ((*mobj).eflags as libc::c_int | MFE_VERTICALFLIP as libc::c_int)
            as uint16_t;
        (*mobj).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
    }
    if (*mobj).flags & MF_NIGHTSITEM as libc::c_int as uint32_t != 0 {
        (*mobj).flags2 |= MF2_DONTDRAW as libc::c_int as uint32_t;
    }
    return mobj;
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnMapThing(mut mthing: *mut mapthing_t) -> *mut mobj_t {
    let mut i: mobjtype_t = MT_NULL;
    let mut mobj: *mut mobj_t = 0 as *mut mobj_t;
    let mut x: fixed_t = 0;
    let mut y: fixed_t = 0;
    let mut z: fixed_t = 0;
    if (*mthing).type_0 == 0 {
        return mobj;
    }
    if (*mthing).type_0 as libc::c_int == 3328 as libc::c_int {
        return mobj;
    }
    if objectplacing == 0 && P_SpawnNonMobjMapThing(mthing) != 0 {
        return mobj;
    }
    i = P_GetMobjtype((*mthing).type_0);
    if i as libc::c_uint == MT_UNKNOWN as libc::c_int as libc::c_uint {
        CONS_Alert(
            CONS_WARNING,
            b"Unknown thing type %d placed at (%d, %d)\n\0" as *const u8
                as *const libc::c_char,
            (*mthing).type_0 as libc::c_int,
            (*mthing).x as libc::c_int,
            (*mthing).y as libc::c_int,
        );
    }
    if objectplacing == 0 {
        if P_AllowMobjSpawn(mthing, i) == 0 {
            return mobj;
        }
        i = P_GetMobjtypeSubstitute(mthing, i);
        if i as libc::c_uint == MT_NULL as libc::c_int as libc::c_uint {
            return mobj;
        }
    }
    x = ((*mthing).x as libc::c_int) << 16 as libc::c_int;
    y = ((*mthing).y as libc::c_int) << 16 as libc::c_int;
    z = P_GetMapThingSpawnHeight(i, mthing, x, y);
    return P_SpawnMobjFromMapThing(mthing, x, y, z, i);
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnHoop(mut mthing: *mut mapthing_t) {
    if metalrecording != 0 {
        return;
    }
    let mut mobj: *mut mobj_t = 0 as *mut mobj_t;
    let mut nextmobj: *mut mobj_t = 0 as *mut mobj_t;
    let mut hoopcenter: *mut mobj_t = 0 as *mut mobj_t;
    let mut pitchmatrix: matrix_t = matrix_t { m: [0; 16] };
    let mut yawmatrix: matrix_t = matrix_t { m: [0; 16] };
    let mut radius: fixed_t = (*mthing).args[0 as libc::c_int as usize]
        << 16 as libc::c_int;
    let mut sizefactor: fixed_t = 4 as libc::c_int
        * ((1 as libc::c_int) << 16 as libc::c_int);
    let mut hoopsize: fixed_t = radius / sizefactor;
    let mut i: int32_t = 0;
    let mut fa: angle_t = 0;
    let mut v: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut res: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut x: fixed_t = ((*mthing).x as libc::c_int) << 16 as libc::c_int;
    let mut y: fixed_t = ((*mthing).y as libc::c_int) << 16 as libc::c_int;
    let mut z: fixed_t = P_GetMobjSpawnHeight(
        MT_HOOP,
        x,
        y,
        ((*mthing).z as libc::c_int) << 16 as libc::c_int,
        0 as libc::c_int,
        false_0 as libc::c_int,
        (*mthing).scale,
        (*mthing).options as libc::c_int & 16 as libc::c_int,
    );
    hoopcenter = P_SpawnMobj(x, y, z, MT_HOOPCENTER);
    (*hoopcenter).spawnpoint = mthing;
    (*hoopcenter).z -= (*hoopcenter).height / 2 as libc::c_int;
    P_UnsetThingPosition(hoopcenter);
    (*hoopcenter).x = x;
    (*hoopcenter).y = y;
    P_SetThingPosition(hoopcenter);
    (*hoopcenter).movedir = (*mthing).pitch as angle_t;
    FM_RotateX(
        &mut pitchmatrix,
        FixedAngle(((*hoopcenter).movedir << 16 as libc::c_int) as fixed_t),
    );
    (*hoopcenter).movecount = (*mthing).angle as int32_t;
    FM_RotateZ(&mut yawmatrix, FixedAngle((*hoopcenter).movecount << 16 as libc::c_int));
    (*hoopcenter).extravalue1 = hoopsize;
    (*hoopcenter).extravalue2 = radius / 12 as libc::c_int;
    i = 0 as libc::c_int;
    while i < hoopsize {
        fa = (i * (8192 as libc::c_int / hoopsize)) as angle_t;
        v
            .x = FixedMul(
            *finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int,
            radius,
        );
        v.y = 0 as libc::c_int;
        v
            .z = FixedMul(
            finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
            radius,
        );
        v.a = (1 as libc::c_int) << 16 as libc::c_int;
        FV4_Copy(&mut v, FM_MultMatrixVec4(&mut pitchmatrix, &mut v, &mut res));
        FV4_Copy(&mut v, FM_MultMatrixVec4(&mut yawmatrix, &mut v, &mut res));
        mobj = P_SpawnMobj(x + v.x, y + v.y, z + v.z, MT_HOOP);
        (*mobj).z -= (*mobj).height / 2 as libc::c_int;
        if maptol & TOL_XMAS as libc::c_int as uint32_t != 0 {
            P_SetMobjState(
                mobj,
                ((*(*mobj).info).seestate as libc::c_uint)
                    .wrapping_add((i & 1 as libc::c_int) as libc::c_uint) as statenum_t,
            );
        }
        P_SetTarget2(&mut (*mobj).target, hoopcenter);
        (*mobj).fuse = 0 as libc::c_int;
        if !nextmobj.is_null() {
            P_SetTarget2(&mut (*mobj).hprev, nextmobj);
            P_SetTarget2(&mut (*(*mobj).hprev).hnext, mobj);
        } else {
            P_SetTarget2(
                &mut (*mobj).hprev,
                P_SetTarget2(&mut (*mobj).hnext, 0 as *mut mobj_t),
            );
        }
        nextmobj = mobj;
        i += 1;
        i;
    }
    loop {
        if hoopsize >= 32 as libc::c_int {
            hoopsize -= 16 as libc::c_int;
        } else {
            hoopsize /= 2 as libc::c_int;
        }
        radius = hoopsize * sizefactor;
        i = 0 as libc::c_int;
        while i < hoopsize {
            fa = (i * (8192 as libc::c_int / hoopsize)) as angle_t;
            v
                .x = FixedMul(
                *finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int,
                radius,
            );
            v.y = 0 as libc::c_int;
            v
                .z = FixedMul(
                finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                radius,
            );
            v.a = (1 as libc::c_int) << 16 as libc::c_int;
            FV4_Copy(&mut v, FM_MultMatrixVec4(&mut pitchmatrix, &mut v, &mut res));
            FV4_Copy(&mut v, FM_MultMatrixVec4(&mut yawmatrix, &mut v, &mut res));
            mobj = P_SpawnMobj(x + v.x, y + v.y, z + v.z, MT_HOOPCOLLIDE);
            (*mobj).z -= (*mobj).height / 2 as libc::c_int;
            P_SetTarget2(&mut (*mobj).hnext, 0 as *mut mobj_t);
            P_SetTarget2(&mut (*mobj).hprev, nextmobj);
            P_SetTarget2(&mut (*(*mobj).hprev).hnext, mobj);
            nextmobj = mobj;
            i += 1;
            i;
        }
        if !(hoopsize >= 8 as libc::c_int) {
            break;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_SetBonusTime(mut mobj: *mut mobj_t) {
    if mobj.is_null() {
        return;
    }
    if (*mobj).type_0 as libc::c_uint != MT_BLUESPHERE as libc::c_int as libc::c_uint
        && (*mobj).type_0 as libc::c_uint != MT_NIGHTSCHIP as libc::c_int as libc::c_uint
    {
        return;
    }
    P_SetMobjState(mobj, (*(*mobj).info).raisestate);
}
unsafe extern "C" fn P_SpawnItemRow(
    mut mthing: *mut mapthing_t,
    mut itemtypes: *mut mobjtype_t,
    mut numitemtypes: uint8_t,
    mut numitems: int32_t,
    mut horizontalspacing: fixed_t,
    mut verticalspacing: fixed_t,
    mut fixedangle: int16_t,
    mut bonustime: boolean,
) {
    let mut dummything: mapthing_t = mapthing_t {
        x: 0,
        y: 0,
        angle: 0,
        pitch: 0,
        roll: 0,
        type_0: 0,
        options: 0,
        z: 0,
        extrainfo: 0,
        tags: taglist_t {
            tags: 0 as *mut mtag_t,
            count: 0,
        },
        scale: 0,
        spritexscale: 0,
        spriteyscale: 0,
        args: [0; 10],
        stringargs: [0 as *mut libc::c_char; 2],
        mobj: 0 as *mut mobj_s,
    };
    let mut mobj: *mut mobj_t = 0 as *mut mobj_t;
    let mut x: fixed_t = ((*mthing).x as libc::c_int) << 16 as libc::c_int;
    let mut y: fixed_t = ((*mthing).y as libc::c_int) << 16 as libc::c_int;
    let mut z: fixed_t = ((*mthing).z as libc::c_int) << 16 as libc::c_int;
    let mut r: int32_t = 0;
    let mut angle: angle_t = FixedAngle(
        (fixedangle as libc::c_int) << 16 as libc::c_int,
    );
    let mut fineangle: angle_t = angle >> 19 as libc::c_int
        & (8192 as libc::c_int - 1 as libc::c_int) as angle_t;
    r = 0 as libc::c_int;
    while r < numitemtypes as libc::c_int {
        dummything = *mthing;
        dummything
            .type_0 = mobjinfo[*itemtypes.offset(r as isize) as usize].doomednum
            as uint16_t;
        if objectplacing == 0 {
            if P_AllowMobjSpawn(&mut dummything, *itemtypes.offset(r as isize)) == 0 {
                *itemtypes.offset(r as isize) = MT_NULL;
            } else {
                *itemtypes
                    .offset(
                        r as isize,
                    ) = P_GetMobjtypeSubstitute(
                    &mut dummything,
                    *itemtypes.offset(r as isize),
                );
            }
        }
        r += 1;
        r;
    }
    z = P_GetMobjSpawnHeight(
        *itemtypes.offset(0 as libc::c_int as isize),
        x,
        y,
        z,
        0 as libc::c_int,
        (*mthing).options as libc::c_int & 2 as libc::c_int,
        (*mthing).scale,
        (*mthing).options as libc::c_int & 16 as libc::c_int,
    );
    r = 0 as libc::c_int;
    while r < numitems {
        let mut itemtype: mobjtype_t = *itemtypes
            .offset((r % numitemtypes as libc::c_int) as isize);
        if !(itemtype as libc::c_uint == MT_NULL as libc::c_int as libc::c_uint) {
            dummything.type_0 = mobjinfo[itemtype as usize].doomednum as uint16_t;
            x
                += FixedMul(
                    horizontalspacing,
                    *finecosine.offset(fineangle as isize)
                        >> 16 as libc::c_int - 16 as libc::c_int,
                );
            y
                += FixedMul(
                    horizontalspacing,
                    finesine[fineangle as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                );
            z
                += if (*mthing).options as libc::c_int & 2 as libc::c_int != 0 {
                    -verticalspacing
                } else {
                    verticalspacing
                };
            mobj = P_SpawnMobjFromMapThing(&mut dummything, x, y, z, itemtype);
            if !mobj.is_null() {
                (*mobj).spawnpoint = 0 as *mut mapthing_t;
                if bonustime != 0 {
                    P_SetBonusTime(mobj);
                }
            }
        }
        r += 1;
        r;
    }
}
unsafe extern "C" fn P_SpawnSingularItemRow(
    mut mthing: *mut mapthing_t,
    mut itemtype: mobjtype_t,
    mut numitems: int32_t,
    mut horizontalspacing: fixed_t,
    mut verticalspacing: fixed_t,
    mut fixedangle: int16_t,
    mut bonustime: boolean,
) {
    let mut itemtypes: [mobjtype_t; 1] = [itemtype];
    P_SpawnItemRow(
        mthing,
        itemtypes.as_mut_ptr(),
        1 as libc::c_int as uint8_t,
        numitems,
        horizontalspacing,
        verticalspacing,
        fixedangle,
        bonustime,
    );
}
unsafe extern "C" fn P_SpawnItemCircle(
    mut mthing: *mut mapthing_t,
    mut itemtypes: *mut mobjtype_t,
    mut numitemtypes: uint8_t,
    mut numitems: int32_t,
    mut size: fixed_t,
    mut bonustime: boolean,
) {
    let mut dummything: mapthing_t = mapthing_t {
        x: 0,
        y: 0,
        angle: 0,
        pitch: 0,
        roll: 0,
        type_0: 0,
        options: 0,
        z: 0,
        extrainfo: 0,
        tags: taglist_t {
            tags: 0 as *mut mtag_t,
            count: 0,
        },
        scale: 0,
        spritexscale: 0,
        spriteyscale: 0,
        args: [0; 10],
        stringargs: [0 as *mut libc::c_char; 2],
        mobj: 0 as *mut mobj_s,
    };
    let mut mobj: *mut mobj_t = 0 as *mut mobj_t;
    let mut x: fixed_t = ((*mthing).x as libc::c_int) << 16 as libc::c_int;
    let mut y: fixed_t = ((*mthing).y as libc::c_int) << 16 as libc::c_int;
    let mut z: fixed_t = ((*mthing).z as libc::c_int) << 16 as libc::c_int;
    let mut angle: angle_t = FixedAngle(
        ((*mthing).angle as libc::c_int) << 16 as libc::c_int,
    );
    let mut fa: angle_t = 0;
    let mut i: int32_t = 0;
    let mut m: matrix_t = matrix_t { m: [0; 16] };
    let mut v: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    let mut res: vector4_t = vector4_t {
        x: 0,
        y: 0,
        z: 0,
        a: 0,
    };
    i = 0 as libc::c_int;
    while i < numitemtypes as libc::c_int {
        dummything = *mthing;
        dummything
            .type_0 = mobjinfo[*itemtypes.offset(i as isize) as usize].doomednum
            as uint16_t;
        if objectplacing == 0 {
            if P_AllowMobjSpawn(&mut dummything, *itemtypes.offset(i as isize)) == 0 {
                *itemtypes.offset(i as isize) = MT_NULL;
            } else {
                *itemtypes
                    .offset(
                        i as isize,
                    ) = P_GetMobjtypeSubstitute(
                    &mut dummything,
                    *itemtypes.offset(i as isize),
                );
            }
        }
        i += 1;
        i;
    }
    z = P_GetMobjSpawnHeight(
        *itemtypes.offset(0 as libc::c_int as isize),
        x,
        y,
        z,
        0 as libc::c_int,
        false_0 as libc::c_int,
        (*mthing).scale,
        (*mthing).options as libc::c_int & 16 as libc::c_int,
    );
    i = 0 as libc::c_int;
    while i < numitems {
        let mut itemtype: mobjtype_t = *itemtypes
            .offset((i % numitemtypes as libc::c_int) as isize);
        if !(itemtype as libc::c_uint == MT_NULL as libc::c_int as libc::c_uint) {
            dummything.type_0 = mobjinfo[itemtype as usize].doomednum as uint16_t;
            fa = (i * 8192 as libc::c_int / numitems) as angle_t;
            v
                .x = FixedMul(
                *finecosine.offset(fa as isize) >> 16 as libc::c_int - 16 as libc::c_int,
                size,
            );
            v.y = 0 as libc::c_int;
            v
                .z = FixedMul(
                finesine[fa as usize] >> 16 as libc::c_int - 16 as libc::c_int,
                size,
            );
            v.a = (1 as libc::c_int) << 16 as libc::c_int;
            FM_RotateZ(&mut m, angle);
            FV4_Copy(&mut v, FM_MultMatrixVec4(&mut m, &mut v, &mut res));
            mobj = P_SpawnMobjFromMapThing(
                &mut dummything,
                x + v.x,
                y + v.y,
                z + v.z,
                itemtype,
            );
            if !mobj.is_null() {
                (*mobj).z -= (*mobj).height / 2 as libc::c_int;
                (*mobj).spawnpoint = 0 as *mut mapthing_t;
                if bonustime != 0 {
                    P_SetBonusTime(mobj);
                }
            }
        }
        i += 1;
        i;
    }
}
unsafe extern "C" fn P_ParseItemTypes(
    mut itemstring: *mut libc::c_char,
    mut itemtypes: *mut mobjtype_t,
    mut numitemtypes: *mut uint8_t,
) {
    let mut tok: *mut libc::c_char = 0 as *mut libc::c_char;
    *numitemtypes = 0 as libc::c_int as uint8_t;
    if !itemstring.is_null() {
        let mut stringcopy: *mut libc::c_char = Z_MallocAlign(
            (strlen(itemstring)).wrapping_add(1 as libc::c_int as libc::c_ulong),
            PU_LEVEL as libc::c_int,
            0 as *mut libc::c_void,
            ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong as int32_t,
        ) as *mut libc::c_char;
        M_Memcpy
            .expect(
                "non-null function pointer",
            )(
            stringcopy as *mut libc::c_void,
            itemstring as *const libc::c_void,
            strlen(itemstring),
        );
        *stringcopy.offset(strlen(itemstring) as isize) = '\0' as i32 as libc::c_char;
        tok = strtok(stringcopy, b" \0" as *const u8 as *const libc::c_char);
        while !tok.is_null() && (*numitemtypes as libc::c_int) < 128 as libc::c_int {
            *itemtypes.offset(*numitemtypes as isize) = get_number(tok) as mobjtype_t;
            tok = strtok(
                0 as *mut libc::c_char,
                b" \0" as *const u8 as *const libc::c_char,
            );
            *numitemtypes = (*numitemtypes).wrapping_add(1);
            *numitemtypes;
        }
        Z_Free(stringcopy as *mut libc::c_void);
    } else {
        *itemtypes.offset(0 as libc::c_int as isize) = MT_RING;
        *numitemtypes = 1 as libc::c_int as uint8_t;
    };
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnItemPattern(
    mut mthing: *mut mapthing_t,
    mut bonustime: boolean,
) {
    let mut current_block_26: u64;
    match (*mthing).type_0 as libc::c_int {
        600 => {
            P_SpawnSingularItemRow(
                mthing,
                MT_RING,
                5 as libc::c_int,
                0 as libc::c_int,
                64 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                0 as libc::c_int as int16_t,
                bonustime,
            );
            return;
        }
        601 => {
            P_SpawnSingularItemRow(
                mthing,
                MT_RING,
                5 as libc::c_int,
                0 as libc::c_int,
                128 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                0 as libc::c_int as int16_t,
                bonustime,
            );
            return;
        }
        602 => {
            P_SpawnSingularItemRow(
                mthing,
                MT_RING,
                5 as libc::c_int,
                64 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                64 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*mthing).angle,
                bonustime,
            );
            return;
        }
        603 => {
            P_SpawnSingularItemRow(
                mthing,
                MT_RING,
                10 as libc::c_int,
                64 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                64 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                (*mthing).angle,
                bonustime,
            );
            return;
        }
        604 => {
            current_block_26 = 14590155758351933369;
        }
        605 => {
            current_block_26 = 14590155758351933369;
        }
        606 | 607 => {
            current_block_26 = 12884786718237604678;
        }
        608 | 609 => {
            let mut numitems_0: int32_t = if (*mthing).type_0 as libc::c_int
                & 1 as libc::c_int != 0
            {
                16 as libc::c_int
            } else {
                8 as libc::c_int
            };
            let mut size_0: fixed_t = if (*mthing).type_0 as libc::c_int
                & 1 as libc::c_int != 0
            {
                192 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
            } else {
                96 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
            };
            let mut itemtypes_0: [mobjtype_t; 2] = [MT_RING, MT_BLUESPHERE];
            P_SpawnItemCircle(
                mthing,
                itemtypes_0.as_mut_ptr(),
                2 as libc::c_int as uint8_t,
                numitems_0,
                size_0,
                bonustime,
            );
            return;
        }
        610 => {
            let mut itemtypes_1: [mobjtype_t; 128] = [MT_NULL; 128];
            let mut numitemtypes: uint8_t = 0;
            if udmf == 0 {
                return;
            }
            P_ParseItemTypes(
                (*mthing).stringargs[0 as libc::c_int as usize],
                itemtypes_1.as_mut_ptr(),
                &mut numitemtypes,
            );
            P_SpawnItemRow(
                mthing,
                itemtypes_1.as_mut_ptr(),
                numitemtypes,
                (*mthing).args[0 as libc::c_int as usize],
                (*mthing).args[1 as libc::c_int as usize] << 16 as libc::c_int,
                (*mthing).args[2 as libc::c_int as usize] << 16 as libc::c_int,
                (*mthing).angle,
                bonustime,
            );
            return;
        }
        611 => {
            let mut itemtypes_2: [mobjtype_t; 128] = [MT_NULL; 128];
            let mut numitemtypes_0: uint8_t = 0;
            if udmf == 0 {
                return;
            }
            P_ParseItemTypes(
                (*mthing).stringargs[0 as libc::c_int as usize],
                itemtypes_2.as_mut_ptr(),
                &mut numitemtypes_0,
            );
            P_SpawnItemCircle(
                mthing,
                itemtypes_2.as_mut_ptr(),
                numitemtypes_0,
                (*mthing).args[0 as libc::c_int as usize],
                (*mthing).args[1 as libc::c_int as usize] << 16 as libc::c_int,
                bonustime,
            );
            return;
        }
        _ => return,
    }
    match current_block_26 {
        14590155758351933369 => {}
        _ => {}
    }
    let mut numitems: int32_t = if (*mthing).type_0 as libc::c_int & 1 as libc::c_int
        != 0
    {
        16 as libc::c_int
    } else {
        8 as libc::c_int
    };
    let mut size: fixed_t = if (*mthing).type_0 as libc::c_int & 1 as libc::c_int != 0 {
        192 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
    } else {
        96 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
    };
    let mut itemtypes: [mobjtype_t; 1] = [
        (if ((*mthing).type_0 as libc::c_int) < 606 as libc::c_int {
            MT_RING as libc::c_int
        } else {
            MT_BLUESPHERE as libc::c_int
        }) as mobjtype_t,
    ];
    P_SpawnItemCircle(
        mthing,
        itemtypes.as_mut_ptr(),
        1 as libc::c_int as uint8_t,
        numitems,
        size,
        bonustime,
    );
}
#[no_mangle]
pub unsafe extern "C" fn P_CheckMissileSpawn(mut th: *mut mobj_t) -> boolean {
    if (*th).flags & MF_GRENADEBOUNCE as libc::c_int as uint32_t == 0 {
        (*th).x += (*th).momx >> 1 as libc::c_int;
        (*th).y += (*th).momy >> 1 as libc::c_int;
        (*th).z += (*th).momz >> 1 as libc::c_int;
    }
    if P_TryMove(th, (*th).x, (*th).y, true_0 as libc::c_int) == 0 {
        P_ExplodeMissile(th);
        return false_0 as libc::c_int;
    }
    return true_0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnXYZMissile(
    mut source: *mut mobj_t,
    mut dest: *mut mobj_t,
    mut type_0: mobjtype_t,
    mut x: fixed_t,
    mut y: fixed_t,
    mut z: fixed_t,
) -> *mut mobj_t {
    let mut th: *mut mobj_t = 0 as *mut mobj_t;
    let mut an: angle_t = 0;
    let mut dist: int32_t = 0;
    let mut speed: fixed_t = 0;
    if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        z -= FixedMul(mobjinfo[type_0 as usize].height, (*source).scale);
    }
    th = P_SpawnMobj(x, y, z, type_0);
    if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        (*th).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
    }
    (*th).destscale = (*source).scale;
    P_SetScale(th, (*source).scale);
    speed = FixedMul((*(*th).info).speed, (*th).scale);
    if speed == 0 as libc::c_int {
        CONS_Debug(
            0x80 as libc::c_int,
            b"P_SpawnXYZMissile - projectile has 0 speed! (mobj type %d)\n\0"
                as *const u8 as *const libc::c_char,
            type_0 as libc::c_uint,
        );
        speed = mobjinfo[MT_ROCKET as libc::c_int as usize].speed;
    }
    if (*(*th).info).seesound as u64 != 0 {
        S_StartSound(th as *const libc::c_void, (*(*th).info).seesound);
    }
    P_SetTarget2(&mut (*th).target, source);
    an = R_PointToAngle2(x, y, (*dest).x, (*dest).y);
    (*th).angle = an;
    an >>= 19 as libc::c_int;
    (*th)
        .momx = FixedMul(
        speed,
        *finecosine.offset(an as isize) >> 16 as libc::c_int - 16 as libc::c_int,
    );
    (*th)
        .momy = FixedMul(
        speed,
        finesine[an as usize] >> 16 as libc::c_int - 16 as libc::c_int,
    );
    dist = P_AproxDistance((*dest).x - x, (*dest).y - y);
    dist = dist / speed;
    if dist < 1 as libc::c_int {
        dist = 1 as libc::c_int;
    }
    (*th).momz = ((*dest).z - z) / dist;
    if (*th).flags & MF_MISSILE as libc::c_int as uint32_t != 0 {
        dist = P_CheckMissileSpawn(th);
    } else {
        dist = 1 as libc::c_int;
    }
    return if dist != 0 { th } else { 0 as *mut mobj_t };
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnAlteredDirectionMissile(
    mut source: *mut mobj_t,
    mut type_0: mobjtype_t,
    mut x: fixed_t,
    mut y: fixed_t,
    mut z: fixed_t,
    mut shiftingAngle: int32_t,
) -> *mut mobj_t {
    let mut th: *mut mobj_t = 0 as *mut mobj_t;
    let mut an: angle_t = 0;
    let mut dist: fixed_t = 0;
    let mut speed: fixed_t = 0;
    if ((*source).target).is_null()
        || (*source).flags & MF_MISSILE as libc::c_int as uint32_t == 0
    {
        return 0 as *mut mobj_t;
    }
    if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        z -= FixedMul(mobjinfo[type_0 as usize].height, (*source).scale);
    }
    th = P_SpawnMobj(x, y, z, type_0);
    if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        (*th).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
    }
    (*th).destscale = (*source).scale;
    P_SetScale(th, (*source).scale);
    speed = FixedMul((*(*th).info).speed, (*th).scale);
    if speed == 0 as libc::c_int {
        CONS_Printf(
            b"P_SpawnAlteredDirectionMissile - projectile has 0 speed! (mobj type %d)\nPlease update this SOC.\0"
                as *const u8 as *const libc::c_char,
            type_0 as libc::c_uint,
        );
        speed = mobjinfo[MT_ROCKET as libc::c_int as usize].speed;
    }
    if (*(*th).info).seesound as u64 != 0 {
        S_StartSound(th as *const libc::c_void, (*(*th).info).seesound);
    }
    P_SetTarget2(&mut (*th).target, (*source).target);
    an = (R_PointToAngle2(
        0 as libc::c_int,
        0 as libc::c_int,
        (*source).momx,
        (*source).momy,
    ))
        .wrapping_add((0xb60b61 as libc::c_int * shiftingAngle) as angle_t);
    (*th).angle = an;
    an >>= 19 as libc::c_int;
    (*th)
        .momx = FixedMul(
        speed,
        *finecosine.offset(an as isize) >> 16 as libc::c_int - 16 as libc::c_int,
    );
    (*th)
        .momy = FixedMul(
        speed,
        finesine[an as usize] >> 16 as libc::c_int - 16 as libc::c_int,
    );
    dist = P_AproxDistance(
        (*source).momx * 800 as libc::c_int,
        (*source).momy * 800 as libc::c_int,
    );
    dist = dist / speed;
    if dist < 1 as libc::c_int {
        dist = 1 as libc::c_int;
    }
    (*th).momz = (*source).momz * 800 as libc::c_int / dist;
    if (*th).flags & MF_MISSILE as libc::c_int as uint32_t != 0 {
        dist = P_CheckMissileSpawn(th);
        (*th).x -= (*th).momx >> 1 as libc::c_int;
        (*th).y -= (*th).momy >> 1 as libc::c_int;
        (*th).z -= (*th).momz >> 1 as libc::c_int;
    } else {
        dist = 1 as libc::c_int;
    }
    return if dist != 0 { th } else { 0 as *mut mobj_t };
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnPointMissile(
    mut source: *mut mobj_t,
    mut xa: fixed_t,
    mut ya: fixed_t,
    mut za: fixed_t,
    mut type_0: mobjtype_t,
    mut x: fixed_t,
    mut y: fixed_t,
    mut z: fixed_t,
) -> *mut mobj_t {
    let mut th: *mut mobj_t = 0 as *mut mobj_t;
    let mut an: angle_t = 0;
    let mut dist: fixed_t = 0;
    let mut speed: fixed_t = 0;
    if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        z -= FixedMul(mobjinfo[type_0 as usize].height, (*source).scale);
    }
    th = P_SpawnMobj(x, y, z, type_0);
    if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        (*th).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
    }
    (*th).destscale = (*source).scale;
    P_SetScale(th, (*source).scale);
    speed = FixedMul((*(*th).info).speed, (*th).scale);
    if speed == 0 as libc::c_int {
        CONS_Printf(
            b"P_SpawnPointMissile - projectile has 0 speed! (mobj type %d)\nPlease update this SOC.\0"
                as *const u8 as *const libc::c_char,
            type_0 as libc::c_uint,
        );
        speed = mobjinfo[MT_ROCKET as libc::c_int as usize].speed;
    }
    if (*(*th).info).seesound as u64 != 0 {
        S_StartSound(th as *const libc::c_void, (*(*th).info).seesound);
    }
    P_SetTarget2(&mut (*th).target, source);
    an = R_PointToAngle2(x, y, xa, ya);
    (*th).angle = an;
    an >>= 19 as libc::c_int;
    (*th)
        .momx = FixedMul(
        speed,
        *finecosine.offset(an as isize) >> 16 as libc::c_int - 16 as libc::c_int,
    );
    (*th)
        .momy = FixedMul(
        speed,
        finesine[an as usize] >> 16 as libc::c_int - 16 as libc::c_int,
    );
    dist = P_AproxDistance(xa - x, ya - y);
    dist = dist / speed;
    if dist < 1 as libc::c_int {
        dist = 1 as libc::c_int;
    }
    (*th).momz = (za - z) / dist;
    if (*th).flags & MF_MISSILE as libc::c_int as uint32_t != 0 {
        dist = P_CheckMissileSpawn(th);
    } else {
        dist = 1 as libc::c_int;
    }
    return if dist != 0 { th } else { 0 as *mut mobj_t };
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnMissile(
    mut source: *mut mobj_t,
    mut dest: *mut mobj_t,
    mut type_0: mobjtype_t,
) -> *mut mobj_t {
    let mut th: *mut mobj_t = 0 as *mut mobj_t;
    let mut an: angle_t = 0;
    let mut dist: int32_t = 0;
    let mut z: fixed_t = 0;
    let gsf: fixed_t = 6 as libc::c_int;
    let mut speed: fixed_t = 0;
    if (*source).type_0 as libc::c_uint == MT_JETTGUNNER as libc::c_int as libc::c_uint {
        if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
            z = (*source).z + (*source).height
                - FixedMul(
                    4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*source).scale,
                );
        } else {
            z = (*source).z
                + FixedMul(
                    4 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int),
                    (*source).scale,
                );
        }
    } else {
        z = (*source).z + (*source).height / 2 as libc::c_int;
    }
    if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        z -= FixedMul(mobjinfo[type_0 as usize].height, (*source).scale);
    }
    th = P_SpawnMobj((*source).x, (*source).y, z, type_0);
    if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        (*th).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
    }
    (*th).destscale = (*source).scale;
    P_SetScale(th, (*source).scale);
    if (*source).type_0 as libc::c_uint
        == MT_METALSONIC_BATTLE as libc::c_int as libc::c_uint
        && (*source).health < 4 as libc::c_int
    {
        speed = FixedMul(
            FixedMul(
                (*(*th).info).speed,
                3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                    / 2 as libc::c_int,
            ),
            (*th).scale,
        );
    } else {
        speed = FixedMul((*(*th).info).speed, (*th).scale);
    }
    if speed == 0 as libc::c_int {
        CONS_Debug(
            0x80 as libc::c_int,
            b"P_SpawnMissile - projectile has 0 speed! (mobj type %d)\n\0" as *const u8
                as *const libc::c_char,
            type_0 as libc::c_uint,
        );
        speed = FixedMul(
            mobjinfo[MT_TURRETLASER as libc::c_int as usize].speed,
            (*th).scale,
        );
    }
    if (*(*th).info).seesound as u64 != 0 {
        S_StartSound(source as *const libc::c_void, (*(*th).info).seesound);
    }
    P_SetTarget2(&mut (*th).target, source);
    if type_0 as libc::c_uint == MT_TURRETLASER as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_ENERGYBALL as libc::c_int as libc::c_uint
    {
        an = R_PointToAngle2(
            (*source).x,
            (*source).y,
            (*dest).x + (*dest).momx * gsf,
            (*dest).y + (*dest).momy * gsf,
        );
    } else {
        an = R_PointToAngle2((*source).x, (*source).y, (*dest).x, (*dest).y);
    }
    (*th).angle = an;
    an >>= 19 as libc::c_int;
    (*th)
        .momx = FixedMul(
        speed,
        *finecosine.offset(an as isize) >> 16 as libc::c_int - 16 as libc::c_int,
    );
    (*th)
        .momy = FixedMul(
        speed,
        finesine[an as usize] >> 16 as libc::c_int - 16 as libc::c_int,
    );
    if type_0 as libc::c_uint == MT_TURRETLASER as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_ENERGYBALL as libc::c_int as libc::c_uint
    {
        dist = P_AproxDistance(
            (*dest).x + (*dest).momx * gsf - (*source).x,
            (*dest).y + (*dest).momy * gsf - (*source).y,
        );
    } else {
        dist = P_AproxDistance((*dest).x - (*source).x, (*dest).y - (*source).y);
    }
    dist = dist / speed;
    if dist < 1 as libc::c_int {
        dist = 1 as libc::c_int;
    }
    if type_0 as libc::c_uint == MT_TURRETLASER as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint == MT_ENERGYBALL as libc::c_int as libc::c_uint
    {
        (*th).momz = ((*dest).z + (*dest).momz * gsf - z) / dist;
    } else {
        (*th).momz = ((*dest).z - z) / dist;
    }
    if (*th).flags & MF_MISSILE as libc::c_int as uint32_t != 0 {
        dist = P_CheckMissileSpawn(th);
    } else {
        dist = 1 as libc::c_int;
    }
    return if dist != 0 { th } else { 0 as *mut mobj_t };
}
#[no_mangle]
pub unsafe extern "C" fn P_ColorTeamMissile(
    mut missile: *mut mobj_t,
    mut source: *mut player_t,
) {
    if G_GametypeHasTeams() != 0 {
        if (*source).ctfteam == 2 as libc::c_int {
            (*missile).color = skincolor_bluering;
        } else if (*source).ctfteam == 1 as libc::c_int {
            (*missile).color = skincolor_redring;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn P_SPMAngle(
    mut source: *mut mobj_t,
    mut type_0: mobjtype_t,
    mut angle: angle_t,
    mut allowaim: uint8_t,
    mut flags2: uint32_t,
) -> *mut mobj_t {
    let mut th: *mut mobj_t = 0 as *mut mobj_t;
    let mut an: angle_t = 0;
    let mut x: fixed_t = 0;
    let mut y: fixed_t = 0;
    let mut z: fixed_t = 0;
    let mut slope: fixed_t = 0 as libc::c_int;
    let mut speed: fixed_t = 0;
    an = angle;
    if allowaim != 0 {
        slope = finesine[((*(*source).player).aiming >> 19 as libc::c_int
            & (8192 as libc::c_int - 1 as libc::c_int) as angle_t) as usize]
            >> 16 as libc::c_int - 16 as libc::c_int;
    }
    x = (*source).x;
    y = (*source).y;
    if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        z = (*source).z + 2 as libc::c_int * (*source).height / 3 as libc::c_int
            - FixedMul(mobjinfo[type_0 as usize].height, (*source).scale);
    } else {
        z = (*source).z + (*source).height / 3 as libc::c_int;
    }
    th = P_SpawnMobj(x, y, z, type_0);
    if (*source).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        (*th).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
    }
    (*th).destscale = (*source).scale;
    P_SetScale(th, (*source).scale);
    (*th).flags2 |= flags2;
    if (*(*th).info).seesound as libc::c_uint != 0
        && (*th).flags2 & MF2_RAILRING as libc::c_int as uint32_t == 0
    {
        S_StartSound(source as *const libc::c_void, (*(*th).info).seesound);
    }
    P_SetTarget2(&mut (*th).target, source);
    speed = (*(*th).info).speed;
    if !((*source).player).is_null()
        && (*(*source).player).charability as libc::c_int == CA_FLY as libc::c_int
    {
        speed = FixedMul(
            speed,
            3 as libc::c_int * ((1 as libc::c_int) << 16 as libc::c_int)
                / 2 as libc::c_int,
        );
    }
    (*th).angle = an;
    (*th)
        .momx = FixedMul(
        speed,
        *finecosine.offset((an >> 19 as libc::c_int) as isize)
            >> 16 as libc::c_int - 16 as libc::c_int,
    );
    (*th)
        .momy = FixedMul(
        speed,
        finesine[(an >> 19 as libc::c_int) as usize]
            >> 16 as libc::c_int - 16 as libc::c_int,
    );
    if allowaim != 0 {
        (*th)
            .momx = FixedMul(
            (*th).momx,
            *finecosine
                .offset(((*(*source).player).aiming >> 19 as libc::c_int) as isize)
                >> 16 as libc::c_int - 16 as libc::c_int,
        );
        (*th)
            .momy = FixedMul(
            (*th).momy,
            *finecosine
                .offset(((*(*source).player).aiming >> 19 as libc::c_int) as isize)
                >> 16 as libc::c_int - 16 as libc::c_int,
        );
    }
    (*th).momz = FixedMul(speed, slope);
    (*th).momx = FixedMul((*th).momx, (*th).scale);
    (*th).momy = FixedMul((*th).momy, (*th).scale);
    (*th).momz = FixedMul((*th).momz, (*th).scale);
    slope = P_CheckMissileSpawn(th);
    return if slope != 0 { th } else { 0 as *mut mobj_t };
}
#[no_mangle]
pub unsafe extern "C" fn P_FlashPal(
    mut pl: *mut player_t,
    mut type_0: uint16_t,
    mut duration: uint16_t,
) {
    if pl.is_null() {
        return;
    }
    (*pl).flashcount = duration;
    (*pl).flashpal = type_0;
}
#[no_mangle]
pub unsafe extern "C" fn P_SpawnMobjFromMobj(
    mut mobj: *mut mobj_t,
    mut xofs: fixed_t,
    mut yofs: fixed_t,
    mut zofs: fixed_t,
    mut type_0: mobjtype_t,
) -> *mut mobj_t {
    let mut newmobj: *mut mobj_t = 0 as *mut mobj_t;
    xofs = FixedMul(xofs, (*mobj).scale);
    yofs = FixedMul(yofs, (*mobj).scale);
    zofs = FixedMul(zofs, (*mobj).scale);
    newmobj = P_SpawnMobj((*mobj).x + xofs, (*mobj).y + yofs, (*mobj).z + zofs, type_0);
    if newmobj.is_null() {
        return 0 as *mut mobj_t;
    }
    if (*mobj).eflags as libc::c_int & MFE_VERTICALFLIP as libc::c_int != 0 {
        let mut elementheight: fixed_t = FixedMul(
            (*(*newmobj).info).height,
            (*mobj).scale,
        );
        (*newmobj)
            .eflags = ((*newmobj).eflags as libc::c_int
            | MFE_VERTICALFLIP as libc::c_int) as uint16_t;
        (*newmobj).flags2 |= MF2_OBJECTFLIP as libc::c_int as uint32_t;
        (*newmobj).z = (*mobj).z + (*mobj).height - zofs - elementheight;
        (*newmobj).old_z = (*mobj).old_z + (*mobj).height - zofs - elementheight;
        (*newmobj).old_z2 = (*mobj).old_z2 + (*mobj).height - zofs - elementheight;
    } else {
        (*newmobj).old_z = (*mobj).old_z + zofs;
        (*newmobj).old_z2 = (*mobj).old_z2 + zofs;
    }
    (*newmobj).destscale = (*mobj).destscale;
    P_SetScale(newmobj, (*mobj).scale);
    (*newmobj).old_x2 = (*mobj).old_x2 + xofs;
    (*newmobj).old_y2 = (*mobj).old_y2 + yofs;
    (*newmobj).old_x = (*mobj).old_x + xofs;
    (*newmobj).old_y = (*mobj).old_y + yofs;
    if !((*mobj).player).is_null() {
        (*newmobj).old_angle2 = (*(*mobj).player).old_drawangle2;
        (*newmobj).old_angle = (*(*mobj).player).old_drawangle;
    } else {
        (*newmobj).old_angle2 = (*mobj).old_angle2;
        (*newmobj).old_angle = (*mobj).old_angle;
    }
    (*newmobj).old_pitch2 = (*mobj).old_pitch2;
    (*newmobj).old_pitch = (*mobj).old_pitch;
    (*newmobj).old_roll2 = (*mobj).old_roll2;
    (*newmobj).old_roll = (*mobj).old_roll;
    (*newmobj).old_spriteroll2 = (*mobj).old_spriteroll2;
    (*newmobj).old_spriteroll = (*mobj).old_spriteroll;
    (*newmobj).old_scale2 = (*mobj).old_scale2;
    (*newmobj).old_scale = (*mobj).old_scale;
    (*newmobj).old_spritexscale = (*mobj).old_spritexscale;
    (*newmobj).old_spriteyscale = (*mobj).old_spriteyscale;
    (*newmobj).old_spritexoffset = (*mobj).old_spritexoffset;
    (*newmobj).old_spriteyoffset = (*mobj).old_spriteyoffset;
    return newmobj;
}
